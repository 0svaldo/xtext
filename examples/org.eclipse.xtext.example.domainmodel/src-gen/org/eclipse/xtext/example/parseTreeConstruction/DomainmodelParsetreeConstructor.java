/*
* generated by Xtext
*/
package org.eclipse.xtext.example.parseTreeConstruction;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor2;

import org.eclipse.xtext.example.services.DomainmodelGrammarAccess;

import com.google.inject.Inject;

public class DomainmodelParsetreeConstructor extends AbstractParseTreeConstructor2 {
		
	@Inject
	private DomainmodelGrammarAccess grammarAccess;
		
	public DomainmodelGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken2 getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new File_Group(this, this, 0, inst);
			case 1: return new Import_Group(this, this, 1, inst);
			case 2: return new NamedElement_Alternatives(this, this, 2, inst);
			case 3: return new Package_Group(this, this, 3, inst);
			case 4: return new Type_Alternatives(this, this, 4, inst);
			case 5: return new DataType_Group(this, this, 5, inst);
			case 6: return new Entity_Group(this, this, 6, inst);
			case 7: return new Feature_Alternatives(this, this, 7, inst);
			case 8: return new StructuralFeature_Alternatives(this, this, 8, inst);
			case 9: return new Attribute_Group(this, this, 9, inst);
			case 10: return new Reference_Group(this, this, 10, inst);
			case 11: return new Operation_Group(this, this, 11, inst);
			case 12: return new Parameter_Group(this, this, 12, inst);
			case 13: return new TypedElement_Alternatives(this, this, 13, inst);
			case 14: return new TypeRef_ReferencedAssignment(this, this, 14, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule File ****************
 *
 * File:
 *   imports+=Import* namedElements+=NamedElement*;
 *
 **/

// imports+=Import* namedElements+=NamedElement*
protected class File_Group extends GroupToken {
	
	public File_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getFileAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new File_NamedElementsAssignment_1(parent, this, 0, inst);
			case 1: return new File_ImportsAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFileRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// imports+=Import*
protected class File_ImportsAssignment_0 extends AssignmentToken  {
	
	public File_ImportsAssignment_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getFileAccess().getImportsAssignment_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("imports",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("imports");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getImportRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new File_ImportsAssignment_0(parent, next, actIndex, consumed);
			//default: return (consumed.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 1, consumed) : null;
			default: return parent.createParentFollower(next,actIndex , index - 1, consumed);
		}	
	}	
}

// namedElements+=NamedElement*
protected class File_NamedElementsAssignment_1 extends AssignmentToken  {
	
	public File_NamedElementsAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getFileAccess().getNamedElementsAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NamedElement_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("namedElements",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("namedElements");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNamedElementRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new File_NamedElementsAssignment_1(parent, next, actIndex, consumed);
			case 1: return new File_ImportsAssignment_0(parent, next, actIndex, consumed);
			//default: return (consumed.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 2, consumed) : null;
			default: return parent.createParentFollower(next,actIndex , index - 2, consumed);
		}	
	}	
}


/************ end Rule File ****************/


/************ begin Rule Import ****************
 *
 * Import:
 *   "import" importURI=STRING;
 *
 **/

// "import" importURI=STRING
protected class Import_Group extends GroupToken {
	
	public Import_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getImportAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_ImportURIAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getImportRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "import"
protected class Import_ImportKeyword_0 extends KeywordToken  {
	
	public Import_ImportKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getImportAccess().getImportKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// importURI=STRING
protected class Import_ImportURIAssignment_1 extends AssignmentToken  {
	
	public Import_ImportURIAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getImportAccess().getImportURIAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_ImportKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("importURI",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("importURI");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Import ****************/


/************ begin Rule NamedElement ****************
 *
 * NamedElement:
 *   Package|Type;
 *
 **/

// Package|Type
protected class NamedElement_Alternatives extends AlternativesToken {

	public NamedElement_Alternatives(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getNamedElementAccess().getAlternatives();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NamedElement_PackageParserRuleCall_0(parent, this, 0, inst);
			case 1: return new NamedElement_TypeParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNamedElementRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// Package
protected class NamedElement_PackageParserRuleCall_0 extends RuleCallToken {
	
	public NamedElement_PackageParserRuleCall_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getNamedElementAccess().getPackageParserRuleCall_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Package_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Package_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPackageRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// Type
protected class NamedElement_TypeParserRuleCall_1 extends RuleCallToken {
	
	public NamedElement_TypeParserRuleCall_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getNamedElementAccess().getTypeParserRuleCall_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Type_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Type_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypeRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}


/************ end Rule NamedElement ****************/


/************ begin Rule Package ****************
 *
 * Package:
 *   "package" name=QualifiedName "{" namedElements+=NamedElement* "}";
 *
 **/

// "package" name=QualifiedName "{" namedElements+=NamedElement* "}"
protected class Package_Group extends GroupToken {
	
	public Package_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getPackageAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Package_RightCurlyBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPackageRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "package"
protected class Package_PackageKeyword_0 extends KeywordToken  {
	
	public Package_PackageKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPackageAccess().getPackageKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// name=QualifiedName
protected class Package_NameAssignment_1 extends AssignmentToken  {
	
	public Package_NameAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getPackageAccess().getNameAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Package_PackageKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.PRC;
			element = grammarAccess.getPackageAccess().getNameQualifiedNameParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "{"
protected class Package_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public Package_LeftCurlyBracketKeyword_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPackageAccess().getLeftCurlyBracketKeyword_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Package_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// namedElements+=NamedElement*
protected class Package_NamedElementsAssignment_3 extends AssignmentToken  {
	
	public Package_NamedElementsAssignment_3(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getPackageAccess().getNamedElementsAssignment_3();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NamedElement_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("namedElements",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("namedElements");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNamedElementRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new Package_NamedElementsAssignment_3(parent, next, actIndex, consumed);
			case 1: return new Package_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Package_RightCurlyBracketKeyword_4 extends KeywordToken  {
	
	public Package_RightCurlyBracketKeyword_4(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPackageAccess().getRightCurlyBracketKeyword_4();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Package_NamedElementsAssignment_3(parent, this, 0, inst);
			case 1: return new Package_LeftCurlyBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Package ****************/


/************ begin Rule Type ****************
 *
 * Type:
 *   Entity|DataType;
 *
 **/

// Entity|DataType
protected class Type_Alternatives extends AlternativesToken {

	public Type_Alternatives(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeAccess().getAlternatives();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Type_EntityParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Type_DataTypeParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// Entity
protected class Type_EntityParserRuleCall_0 extends RuleCallToken {
	
	public Type_EntityParserRuleCall_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeAccess().getEntityParserRuleCall_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Entity_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Entity_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEntityRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// DataType
protected class Type_DataTypeParserRuleCall_1 extends RuleCallToken {
	
	public Type_DataTypeParserRuleCall_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeAccess().getDataTypeParserRuleCall_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DataType_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(DataType_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getDataTypeRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}


/************ end Rule Type ****************/


/************ begin Rule DataType ****************
 *
 * DataType:
 *   "datatype" name=ID;
 *
 **/

// "datatype" name=ID
protected class DataType_Group extends GroupToken {
	
	public DataType_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getDataTypeAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DataType_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDataTypeRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "datatype"
protected class DataType_DatatypeKeyword_0 extends KeywordToken  {
	
	public DataType_DatatypeKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getDataTypeAccess().getDatatypeKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// name=ID
protected class DataType_NameAssignment_1 extends AssignmentToken  {
	
	public DataType_NameAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDataTypeAccess().getNameAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DataType_DatatypeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getDataTypeAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule DataType ****************/


/************ begin Rule Entity ****************
 *
 * Entity:
 *   "entity" name=ID ("extends" superType=[Entity])? "{" features+=Feature* "}";
 *
 **/

// "entity" name=ID ("extends" superType=[Entity])? "{" features+=Feature* "}"
protected class Entity_Group extends GroupToken {
	
	public Entity_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEntityAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Entity_RightCurlyBracketKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEntityRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "entity"
protected class Entity_EntityKeyword_0 extends KeywordToken  {
	
	public Entity_EntityKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEntityAccess().getEntityKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// name=ID
protected class Entity_NameAssignment_1 extends AssignmentToken  {
	
	public Entity_NameAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEntityAccess().getNameAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Entity_EntityKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEntityAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("extends" superType=[Entity])?
protected class Entity_Group_2 extends GroupToken {
	
	public Entity_Group_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getEntityAccess().getGroup_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Entity_SuperTypeAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class Entity_ExtendsKeyword_2_0 extends KeywordToken  {
	
	public Entity_ExtendsKeyword_2_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEntityAccess().getExtendsKeyword_2_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Entity_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// superType=[Entity]
protected class Entity_SuperTypeAssignment_2_1 extends AssignmentToken  {
	
	public Entity_SuperTypeAssignment_2_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEntityAccess().getSuperTypeAssignment_2_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Entity_ExtendsKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("superType",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("superType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEntityAccess().getSuperTypeEntityCrossReference_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getEntityAccess().getSuperTypeEntityCrossReference_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}


// "{"
protected class Entity_LeftCurlyBracketKeyword_3 extends KeywordToken  {
	
	public Entity_LeftCurlyBracketKeyword_3(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEntityAccess().getLeftCurlyBracketKeyword_3();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Entity_Group_2(parent, this, 0, inst);
			case 1: return new Entity_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// features+=Feature*
protected class Entity_FeaturesAssignment_4 extends AssignmentToken  {
	
	public Entity_FeaturesAssignment_4(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getEntityAccess().getFeaturesAssignment_4();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Feature_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("features",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("features");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFeatureRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new Entity_FeaturesAssignment_4(parent, next, actIndex, consumed);
			case 1: return new Entity_LeftCurlyBracketKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Entity_RightCurlyBracketKeyword_5 extends KeywordToken  {
	
	public Entity_RightCurlyBracketKeyword_5(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEntityAccess().getRightCurlyBracketKeyword_5();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Entity_FeaturesAssignment_4(parent, this, 0, inst);
			case 1: return new Entity_LeftCurlyBracketKeyword_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Entity ****************/


/************ begin Rule Feature ****************
 *
 * Feature:
 *   StructuralFeature|Operation;
 *
 **/

// StructuralFeature|Operation
protected class Feature_Alternatives extends AlternativesToken {

	public Feature_Alternatives(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getFeatureAccess().getAlternatives();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Feature_StructuralFeatureParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Feature_OperationParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFeatureRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// StructuralFeature
protected class Feature_StructuralFeatureParserRuleCall_0 extends RuleCallToken {
	
	public Feature_StructuralFeatureParserRuleCall_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getFeatureAccess().getStructuralFeatureParserRuleCall_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructuralFeature_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StructuralFeature_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructuralFeatureRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// Operation
protected class Feature_OperationParserRuleCall_1 extends RuleCallToken {
	
	public Feature_OperationParserRuleCall_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getFeatureAccess().getOperationParserRuleCall_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Operation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}


/************ end Rule Feature ****************/


/************ begin Rule StructuralFeature ****************
 *
 * StructuralFeature:
 *   Attribute|Reference;
 *
 **/

// Attribute|Reference
protected class StructuralFeature_Alternatives extends AlternativesToken {

	public StructuralFeature_Alternatives(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getStructuralFeatureAccess().getAlternatives();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StructuralFeature_AttributeParserRuleCall_0(parent, this, 0, inst);
			case 1: return new StructuralFeature_ReferenceParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStructuralFeatureRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// Attribute
protected class StructuralFeature_AttributeParserRuleCall_0 extends RuleCallToken {
	
	public StructuralFeature_AttributeParserRuleCall_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructuralFeatureAccess().getAttributeParserRuleCall_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Attribute_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// Reference
protected class StructuralFeature_ReferenceParserRuleCall_1 extends RuleCallToken {
	
	public StructuralFeature_ReferenceParserRuleCall_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructuralFeatureAccess().getReferenceParserRuleCall_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reference_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Reference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}


/************ end Rule StructuralFeature ****************/


/************ begin Rule Attribute ****************
 *
 * Attribute:
 *   "attr" name=ID ":" type=TypeRef;
 *
 **/

// "attr" name=ID ":" type=TypeRef
protected class Attribute_Group extends GroupToken {
	
	public Attribute_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAttributeAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_TypeAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "attr"
protected class Attribute_AttrKeyword_0 extends KeywordToken  {
	
	public Attribute_AttrKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeAccess().getAttrKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// name=ID
protected class Attribute_NameAssignment_1 extends AssignmentToken  {
	
	public Attribute_NameAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getNameAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_AttrKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ":"
protected class Attribute_ColonKeyword_2 extends KeywordToken  {
	
	public Attribute_ColonKeyword_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeAccess().getColonKeyword_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=TypeRef
protected class Attribute_TypeAssignment_3 extends AssignmentToken  {
	
	public Attribute_TypeAssignment_3(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getTypeAssignment_3();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_ReferencedAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new Attribute_ColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Attribute ****************/


/************ begin Rule Reference ****************
 *
 * Reference:
 *   "ref" name=ID ":" type=TypeRef ("opposite" opposite=[Reference])?;
 *
 **/

// "ref" name=ID ":" type=TypeRef ("opposite" opposite=[Reference])?
protected class Reference_Group extends GroupToken {
	
	public Reference_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getReferenceAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reference_Group_4(parent, this, 0, inst);
			case 1: return new Reference_TypeAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getReferenceRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "ref"
protected class Reference_RefKeyword_0 extends KeywordToken  {
	
	public Reference_RefKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getReferenceAccess().getRefKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// name=ID
protected class Reference_NameAssignment_1 extends AssignmentToken  {
	
	public Reference_NameAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getReferenceAccess().getNameAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reference_RefKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getReferenceAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ":"
protected class Reference_ColonKeyword_2 extends KeywordToken  {
	
	public Reference_ColonKeyword_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getReferenceAccess().getColonKeyword_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reference_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=TypeRef
protected class Reference_TypeAssignment_3 extends AssignmentToken  {
	
	public Reference_TypeAssignment_3(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getReferenceAccess().getTypeAssignment_3();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_ReferencedAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new Reference_ColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("opposite" opposite=[Reference])?
protected class Reference_Group_4 extends GroupToken {
	
	public Reference_Group_4(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getReferenceAccess().getGroup_4();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reference_OppositeAssignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "opposite"
protected class Reference_OppositeKeyword_4_0 extends KeywordToken  {
	
	public Reference_OppositeKeyword_4_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getReferenceAccess().getOppositeKeyword_4_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reference_TypeAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// opposite=[Reference]
protected class Reference_OppositeAssignment_4_1 extends AssignmentToken  {
	
	public Reference_OppositeAssignment_4_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getReferenceAccess().getOppositeAssignment_4_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Reference_OppositeKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("opposite",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("opposite");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReferenceAccess().getOppositeReferenceCrossReference_4_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getReferenceAccess().getOppositeReferenceCrossReference_4_1_0(); 
				return obj;
			}
		}
		return null;
	}

}



/************ end Rule Reference ****************/


/************ begin Rule Operation ****************
 *
 * Operation:
 *   "op" name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" ":" type=TypeRef;
 *
 **/

// "op" name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" ":" type=TypeRef
protected class Operation_Group extends GroupToken {
	
	public Operation_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOperationAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_TypeAssignment_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOperationRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "op"
protected class Operation_OpKeyword_0 extends KeywordToken  {
	
	public Operation_OpKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationAccess().getOpKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// name=ID
protected class Operation_NameAssignment_1 extends AssignmentToken  {
	
	public Operation_NameAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationAccess().getNameAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_OpKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getOperationAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class Operation_LeftParenthesisKeyword_2 extends KeywordToken  {
	
	public Operation_LeftParenthesisKeyword_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationAccess().getLeftParenthesisKeyword_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (params+=Parameter ("," params+=Parameter)*)?
protected class Operation_Group_3 extends GroupToken {
	
	public Operation_Group_3(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOperationAccess().getGroup_3();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_Group_3_1(parent, this, 0, inst);
			case 1: return new Operation_ParamsAssignment_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Parameter
protected class Operation_ParamsAssignment_3_0 extends AssignmentToken  {
	
	public Operation_ParamsAssignment_3_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationAccess().getParamsAssignment_3_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new Operation_LeftParenthesisKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," params+=Parameter)*
protected class Operation_Group_3_1 extends GroupToken {
	
	public Operation_Group_3_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOperationAccess().getGroup_3_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_ParamsAssignment_3_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Operation_CommaKeyword_3_1_0 extends KeywordToken  {
	
	public Operation_CommaKeyword_3_1_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationAccess().getCommaKeyword_3_1_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_Group_3_1(parent, this, 0, inst);
			case 1: return new Operation_ParamsAssignment_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Parameter
protected class Operation_ParamsAssignment_3_1_1 extends AssignmentToken  {
	
	public Operation_ParamsAssignment_3_1_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationAccess().getParamsAssignment_3_1_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new Operation_CommaKeyword_3_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class Operation_RightParenthesisKeyword_4 extends KeywordToken  {
	
	public Operation_RightParenthesisKeyword_4(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationAccess().getRightParenthesisKeyword_4();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_Group_3(parent, this, 0, inst);
			case 1: return new Operation_LeftParenthesisKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class Operation_ColonKeyword_5 extends KeywordToken  {
	
	public Operation_ColonKeyword_5(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationAccess().getColonKeyword_5();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_RightParenthesisKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=TypeRef
protected class Operation_TypeAssignment_6 extends AssignmentToken  {
	
	public Operation_TypeAssignment_6(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationAccess().getTypeAssignment_6();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_ReferencedAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new Operation_ColonKeyword_5(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Operation ****************/


/************ begin Rule Parameter ****************
 *
 * Parameter:
 *   name=ID type=TypeRef;
 *
 **/

// name=ID type=TypeRef
protected class Parameter_Group extends GroupToken {
	
	public Parameter_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getParameterAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_TypeAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// name=ID
protected class Parameter_NameAssignment_0 extends AssignmentToken  {
	
	public Parameter_NameAssignment_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getNameAssignment_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// type=TypeRef
protected class Parameter_TypeAssignment_1 extends AssignmentToken  {
	
	public Parameter_TypeAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getTypeAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_ReferencedAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new Parameter_NameAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Parameter ****************/


/************ begin Rule TypedElement ****************
 *
 * TypedElement:
 *   Feature|Parameter;
 *
 **/

// Feature|Parameter
protected class TypedElement_Alternatives extends AlternativesToken {

	public TypedElement_Alternatives(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypedElementAccess().getAlternatives();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypedElement_FeatureParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TypedElement_ParameterParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypedElementRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// Feature
protected class TypedElement_FeatureParserRuleCall_0 extends RuleCallToken {
	
	public TypedElement_FeatureParserRuleCall_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypedElementAccess().getFeatureParserRuleCall_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Feature_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Feature_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFeatureRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// Parameter
protected class TypedElement_ParameterParserRuleCall_1 extends RuleCallToken {
	
	public TypedElement_ParameterParserRuleCall_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypedElementAccess().getParameterParserRuleCall_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Parameter_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}


/************ end Rule TypedElement ****************/


/************ begin Rule TypeRef ****************
 *
 * TypeRef:
 *   referenced=[Type];
 *
 **/

// referenced=[Type]
protected class TypeRef_ReferencedAssignment extends AssignmentToken  {
	
	public TypeRef_ReferencedAssignment(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getReferencedAssignment();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("referenced",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("referenced");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefAccess().getReferencedTypeCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getTypeRefAccess().getReferencedTypeCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule TypeRef ****************/


}
