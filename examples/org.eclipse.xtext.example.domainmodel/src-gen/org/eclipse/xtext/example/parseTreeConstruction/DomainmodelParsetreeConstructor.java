/*
* generated by Xtext
*/
package org.eclipse.xtext.example.parseTreeConstruction;

//import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.AbstractToken.Solution;
import org.eclipse.xtext.example.services.DomainmodelGrammarAccess;

import com.google.inject.Inject;

public class DomainmodelParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private DomainmodelGrammarAccess grammarAccess;
	
	@Override
	protected Solution internalSerialize(EObject obj) {
		IInstanceDescription inst = getDescr(obj);
		Solution s;
		if(inst.isInstanceOf(grammarAccess.getFileRule().getType().getClassifier()) && (s = new File_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getImportRule().getType().getClassifier()) && (s = new Import_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getNamedElementRule().getType().getClassifier()) && (s = new NamedElement_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getPackageRule().getType().getClassifier()) && (s = new Package_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTypeRule().getType().getClassifier()) && (s = new Type_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getDataTypeRule().getType().getClassifier()) && (s = new DataType_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getEntityRule().getType().getClassifier()) && (s = new Entity_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getFeatureRule().getType().getClassifier()) && (s = new Feature_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getStructuralFeatureRule().getType().getClassifier()) && (s = new StructuralFeature_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier()) && (s = new Attribute_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getReferenceRule().getType().getClassifier()) && (s = new Reference_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getOperationRule().getType().getClassifier()) && (s = new Operation_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier()) && (s = new Parameter_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTypedElementRule().getType().getClassifier()) && (s = new TypedElement_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier()) && (s = new TypeRef_Assignment_referenced(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		return null;
	}
	

/************ begin Rule File ****************
 *
 * File:
 *   (imports+=Import)* (namedElements+=NamedElement)*;
 *
 **/

// (imports+=Import)* (namedElements+=NamedElement)*
protected class File_Group extends GroupToken {
	
	public File_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFileAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new File_1_Assignment_namedElements(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new File_0_Assignment_imports(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// (imports+=Import)*
protected class File_0_Assignment_imports extends AssignmentToken  {
	
	public File_0_Assignment_imports(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFileAccess().getImportsAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("imports",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("imports");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getImportRule().getType().getClassifier())) {
				Solution s = new Import_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// (namedElements+=NamedElement)*
protected class File_1_Assignment_namedElements extends AssignmentToken  {
	
	public File_1_Assignment_namedElements(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFileAccess().getNamedElementsAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("namedElements",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("namedElements");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNamedElementRule().getType().getClassifier())) {
				Solution s = new NamedElement_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule File ****************/


/************ begin Rule Import ****************
 *
 * Import:
 *   "import" importURI=STRING;
 *
 **/

// "import" importURI=STRING
protected class Import_Group extends GroupToken {
	
	public Import_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getImportAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Import_1_Assignment_importURI(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Import_0_Keyword_import(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "import"
protected class Import_0_Keyword_import extends KeywordToken  {
	
	public Import_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getImportAccess().getImportKeyword_0();
	}	
}

// importURI=STRING
protected class Import_1_Assignment_importURI extends AssignmentToken  {
	
	public Import_1_Assignment_importURI(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getImportAccess().getImportURIAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("importURI",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("importURI");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule Import ****************/


/************ begin Rule NamedElement ****************
 *
 * NamedElement:
 *   Package|Type;
 *
 **/

// Package|Type
protected class NamedElement_Alternatives extends AlternativesToken {

	public NamedElement_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNamedElementAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new NamedElement_0_RuleCall_Package(current, this);
			case 1: return new NamedElement_1_RuleCall_Type(current, this);
			default: return null;
		}
	}
}

// Package
protected class NamedElement_0_RuleCall_Package extends RuleCallToken {
	
	public NamedElement_0_RuleCall_Package(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNamedElementAccess().getPackageParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Package_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPackageRule().getType().getClassifier())) return null;
		return new Package_Group(current, this).firstSolution();
	}
}

// Type
protected class NamedElement_1_RuleCall_Type extends RuleCallToken {
	
	public NamedElement_1_RuleCall_Type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNamedElementAccess().getTypeParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Type_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypeRule().getType().getClassifier())) return null;
		return new Type_Alternatives(current, this).firstSolution();
	}
}


/************ end Rule NamedElement ****************/


/************ begin Rule Package ****************
 *
 * Package:
 *   "package" name=QualifiedName "{" (namedElements+=NamedElement)* "}";
 *
 **/

// "package" name=QualifiedName "{" (namedElements+=NamedElement)* "}"
protected class Package_Group extends GroupToken {
	
	public Package_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPackageAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Package_4_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Package_3_Assignment_namedElements(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Package_2_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Package_1_Assignment_name(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new Package_0_Keyword_package(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						if(s5 != null) {
							last = s5.getPredecessor();
							return s5;
						} else {
							s4 = s4.getPredecessor().nextSolution(this,s4);
						}
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "package"
protected class Package_0_Keyword_package extends KeywordToken  {
	
	public Package_0_Keyword_package(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPackageAccess().getPackageKeyword_0();
	}	
}

// name=QualifiedName
protected class Package_1_Assignment_name extends AssignmentToken  {
	
	public Package_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPackageAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");

		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for datatype rule
			type = AssignmentType.PRC;
			element = grammarAccess.getPackageAccess().getNameQualifiedNameParserRuleCall_1_0();
			return new Solution(obj);
		}

		return null;
	}
}

// "{"
protected class Package_2_Keyword extends KeywordToken  {
	
	public Package_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPackageAccess().getLeftCurlyBracketKeyword_2();
	}	
}

// (namedElements+=NamedElement)*
protected class Package_3_Assignment_namedElements extends AssignmentToken  {
	
	public Package_3_Assignment_namedElements(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPackageAccess().getNamedElementsAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("namedElements",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("namedElements");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNamedElementRule().getType().getClassifier())) {
				Solution s = new NamedElement_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// "}"
protected class Package_4_Keyword extends KeywordToken  {
	
	public Package_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getPackageAccess().getRightCurlyBracketKeyword_4();
	}	
}


/************ end Rule Package ****************/


/************ begin Rule Type ****************
 *
 * Type:
 *   Entity|DataType;
 *
 **/

// Entity|DataType
protected class Type_Alternatives extends AlternativesToken {

	public Type_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Type_0_RuleCall_Entity(current, this);
			case 1: return new Type_1_RuleCall_DataType(current, this);
			default: return null;
		}
	}
}

// Entity
protected class Type_0_RuleCall_Entity extends RuleCallToken {
	
	public Type_0_RuleCall_Entity(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeAccess().getEntityParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Entity_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEntityRule().getType().getClassifier())) return null;
		return new Entity_Group(current, this).firstSolution();
	}
}

// DataType
protected class Type_1_RuleCall_DataType extends RuleCallToken {
	
	public Type_1_RuleCall_DataType(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeAccess().getDataTypeParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(DataType_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getDataTypeRule().getType().getClassifier())) return null;
		return new DataType_Group(current, this).firstSolution();
	}
}


/************ end Rule Type ****************/


/************ begin Rule DataType ****************
 *
 * DataType:
 *   "datatype" name=ID;
 *
 **/

// "datatype" name=ID
protected class DataType_Group extends GroupToken {
	
	public DataType_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDataTypeAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new DataType_1_Assignment_name(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new DataType_0_Keyword_datatype(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "datatype"
protected class DataType_0_Keyword_datatype extends KeywordToken  {
	
	public DataType_0_Keyword_datatype(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getDataTypeAccess().getDatatypeKeyword_0();
	}	
}

// name=ID
protected class DataType_1_Assignment_name extends AssignmentToken  {
	
	public DataType_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDataTypeAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getDataTypeAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule DataType ****************/


/************ begin Rule Entity ****************
 *
 * Entity:
 *   "entity" name=ID ("extends" superType=[Entity])? "{" (features+=Feature)* "}";
 *
 **/

// "entity" name=ID ("extends" superType=[Entity])? "{" (features+=Feature)* "}"
protected class Entity_Group extends GroupToken {
	
	public Entity_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEntityAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Entity_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Entity_4_Assignment_features(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Entity_3_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Entity_2_Group(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new Entity_1_Assignment_name(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new Entity_0_Keyword_entity(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							if(s6 != null) {
								last = s6.getPredecessor();
								return s6;
							} else {
								s5 = s5.getPredecessor().nextSolution(this,s5);
							}
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "entity"
protected class Entity_0_Keyword_entity extends KeywordToken  {
	
	public Entity_0_Keyword_entity(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEntityAccess().getEntityKeyword_0();
	}	
}

// name=ID
protected class Entity_1_Assignment_name extends AssignmentToken  {
	
	public Entity_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEntityAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEntityAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("extends" superType=[Entity])?
protected class Entity_2_Group extends GroupToken {
	
	public Entity_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEntityAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Entity_2_1_Assignment_superType(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Entity_2_0_Keyword_extends(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "extends"
protected class Entity_2_0_Keyword_extends extends KeywordToken  {
	
	public Entity_2_0_Keyword_extends(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEntityAccess().getExtendsKeyword_2_0();
	}	
}

// superType=[Entity]
protected class Entity_2_1_Assignment_superType extends AssignmentToken  {
	
	public Entity_2_1_Assignment_superType(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEntityAccess().getSuperTypeAssignment_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("superType",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("superType");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEntityAccess().getSuperTypeEntityCrossReference_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getEntityAccess().getSuperTypeEntityCrossReference_2_1_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}


// "{"
protected class Entity_3_Keyword extends KeywordToken  {
	
	public Entity_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEntityAccess().getLeftCurlyBracketKeyword_3();
	}	
}

// (features+=Feature)*
protected class Entity_4_Assignment_features extends AssignmentToken  {
	
	public Entity_4_Assignment_features(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEntityAccess().getFeaturesAssignment_4();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("features",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("features");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFeatureRule().getType().getClassifier())) {
				Solution s = new Feature_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// "}"
protected class Entity_5_Keyword extends KeywordToken  {
	
	public Entity_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEntityAccess().getRightCurlyBracketKeyword_5();
	}	
}


/************ end Rule Entity ****************/


/************ begin Rule Feature ****************
 *
 * Feature:
 *   StructuralFeature|Operation;
 *
 **/

// StructuralFeature|Operation
protected class Feature_Alternatives extends AlternativesToken {

	public Feature_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFeatureAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Feature_0_RuleCall_StructuralFeature(current, this);
			case 1: return new Feature_1_RuleCall_Operation(current, this);
			default: return null;
		}
	}
}

// StructuralFeature
protected class Feature_0_RuleCall_StructuralFeature extends RuleCallToken {
	
	public Feature_0_RuleCall_StructuralFeature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFeatureAccess().getStructuralFeatureParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(StructuralFeature_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStructuralFeatureRule().getType().getClassifier())) return null;
		return new StructuralFeature_Alternatives(current, this).firstSolution();
	}
}

// Operation
protected class Feature_1_RuleCall_Operation extends RuleCallToken {
	
	public Feature_1_RuleCall_Operation(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFeatureAccess().getOperationParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Operation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOperationRule().getType().getClassifier())) return null;
		return new Operation_Group(current, this).firstSolution();
	}
}


/************ end Rule Feature ****************/


/************ begin Rule StructuralFeature ****************
 *
 * StructuralFeature:
 *   Attribute|Reference;
 *
 **/

// Attribute|Reference
protected class StructuralFeature_Alternatives extends AlternativesToken {

	public StructuralFeature_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getStructuralFeatureAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new StructuralFeature_0_RuleCall_Attribute(current, this);
			case 1: return new StructuralFeature_1_RuleCall_Reference(current, this);
			default: return null;
		}
	}
}

// Attribute
protected class StructuralFeature_0_RuleCall_Attribute extends RuleCallToken {
	
	public StructuralFeature_0_RuleCall_Attribute(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructuralFeatureAccess().getAttributeParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Attribute_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) return null;
		return new Attribute_Group(current, this).firstSolution();
	}
}

// Reference
protected class StructuralFeature_1_RuleCall_Reference extends RuleCallToken {
	
	public StructuralFeature_1_RuleCall_Reference(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getStructuralFeatureAccess().getReferenceParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Reference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getReferenceRule().getType().getClassifier())) return null;
		return new Reference_Group(current, this).firstSolution();
	}
}


/************ end Rule StructuralFeature ****************/


/************ begin Rule Attribute ****************
 *
 * Attribute:
 *   "attr" name=ID ":" type=TypeRef;
 *
 **/

// "attr" name=ID ":" type=TypeRef
protected class Attribute_Group extends GroupToken {
	
	public Attribute_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Attribute_3_Assignment_type(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Attribute_2_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Attribute_1_Assignment_name(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Attribute_0_Keyword_attr(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "attr"
protected class Attribute_0_Keyword_attr extends KeywordToken  {
	
	public Attribute_0_Keyword_attr(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeAccess().getAttrKeyword_0();
	}	
}

// name=ID
protected class Attribute_1_Assignment_name extends AssignmentToken  {
	
	public Attribute_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ":"
protected class Attribute_2_Keyword extends KeywordToken  {
	
	public Attribute_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeAccess().getColonKeyword_2();
	}	
}

// type=TypeRef
protected class Attribute_3_Assignment_type extends AssignmentToken  {
	
	public Attribute_3_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getTypeAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				Solution s = new TypeRef_Assignment_referenced(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule Attribute ****************/


/************ begin Rule Reference ****************
 *
 * Reference:
 *   "ref" name=ID ":" type=TypeRef ("opposite" opposite=[Reference])?;
 *
 **/

// "ref" name=ID ":" type=TypeRef ("opposite" opposite=[Reference])?
protected class Reference_Group extends GroupToken {
	
	public Reference_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getReferenceAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Reference_4_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Reference_3_Assignment_type(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Reference_2_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Reference_1_Assignment_name(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new Reference_0_Keyword_ref(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						if(s5 != null) {
							last = s5.getPredecessor();
							return s5;
						} else {
							s4 = s4.getPredecessor().nextSolution(this,s4);
						}
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "ref"
protected class Reference_0_Keyword_ref extends KeywordToken  {
	
	public Reference_0_Keyword_ref(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getReferenceAccess().getRefKeyword_0();
	}	
}

// name=ID
protected class Reference_1_Assignment_name extends AssignmentToken  {
	
	public Reference_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReferenceAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getReferenceAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ":"
protected class Reference_2_Keyword extends KeywordToken  {
	
	public Reference_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getReferenceAccess().getColonKeyword_2();
	}	
}

// type=TypeRef
protected class Reference_3_Assignment_type extends AssignmentToken  {
	
	public Reference_3_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReferenceAccess().getTypeAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				Solution s = new TypeRef_Assignment_referenced(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ("opposite" opposite=[Reference])?
protected class Reference_4_Group extends GroupToken {
	
	public Reference_4_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getReferenceAccess().getGroup_4();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Reference_4_1_Assignment_opposite(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Reference_4_0_Keyword_opposite(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "opposite"
protected class Reference_4_0_Keyword_opposite extends KeywordToken  {
	
	public Reference_4_0_Keyword_opposite(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getReferenceAccess().getOppositeKeyword_4_0();
	}	
}

// opposite=[Reference]
protected class Reference_4_1_Assignment_opposite extends AssignmentToken  {
	
	public Reference_4_1_Assignment_opposite(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReferenceAccess().getOppositeAssignment_4_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("opposite",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("opposite");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReferenceAccess().getOppositeReferenceCrossReference_4_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getReferenceAccess().getOppositeReferenceCrossReference_4_1_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}



/************ end Rule Reference ****************/


/************ begin Rule Operation ****************
 *
 * Operation:
 *   "op" name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" ":" type=TypeRef;
 *
 **/

// "op" name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" ":" type=TypeRef
protected class Operation_Group extends GroupToken {
	
	public Operation_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOperationAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Operation_6_Assignment_type(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Operation_5_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Operation_4_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Operation_3_Group(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new Operation_2_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new Operation_1_Assignment_name(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							while(s6 != null) {
								Solution s7 = new Operation_0_Keyword_op(s6.getCurrent(), s6.getPredecessor()).firstSolution();
								if(s7 != null) {
									last = s7.getPredecessor();
									return s7;
								} else {
									s6 = s6.getPredecessor().nextSolution(this,s6);
								}
							}
							s5 = s5.getPredecessor().nextSolution(this,s5);
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "op"
protected class Operation_0_Keyword_op extends KeywordToken  {
	
	public Operation_0_Keyword_op(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationAccess().getOpKeyword_0();
	}	
}

// name=ID
protected class Operation_1_Assignment_name extends AssignmentToken  {
	
	public Operation_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getOperationAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "("
protected class Operation_2_Keyword extends KeywordToken  {
	
	public Operation_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationAccess().getLeftParenthesisKeyword_2();
	}	
}

// (params+=Parameter ("," params+=Parameter)*)?
protected class Operation_3_Group extends GroupToken {
	
	public Operation_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOperationAccess().getGroup_3();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Operation_3_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Operation_3_0_Assignment_params(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// params+=Parameter
protected class Operation_3_0_Assignment_params extends AssignmentToken  {
	
	public Operation_3_0_Assignment_params(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationAccess().getParamsAssignment_3_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("params",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) {
				Solution s = new Parameter_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ("," params+=Parameter)*
protected class Operation_3_1_Group extends GroupToken {
	
	public Operation_3_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOperationAccess().getGroup_3_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Operation_3_1_1_Assignment_params(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Operation_3_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// ","
protected class Operation_3_1_0_Keyword extends KeywordToken  {
	
	public Operation_3_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationAccess().getCommaKeyword_3_1_0();
	}	
}

// params+=Parameter
protected class Operation_3_1_1_Assignment_params extends AssignmentToken  {
	
	public Operation_3_1_1_Assignment_params(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationAccess().getParamsAssignment_3_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("params",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) {
				Solution s = new Parameter_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// ")"
protected class Operation_4_Keyword extends KeywordToken  {
	
	public Operation_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationAccess().getRightParenthesisKeyword_4();
	}	
}

// ":"
protected class Operation_5_Keyword extends KeywordToken  {
	
	public Operation_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationAccess().getColonKeyword_5();
	}	
}

// type=TypeRef
protected class Operation_6_Assignment_type extends AssignmentToken  {
	
	public Operation_6_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationAccess().getTypeAssignment_6();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				Solution s = new TypeRef_Assignment_referenced(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule Operation ****************/


/************ begin Rule Parameter ****************
 *
 * Parameter:
 *   name=ID type=TypeRef;
 *
 **/

// name=ID type=TypeRef
protected class Parameter_Group extends GroupToken {
	
	public Parameter_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParameterAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Parameter_1_Assignment_type(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Parameter_0_Assignment_name(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// name=ID
protected class Parameter_0_Assignment_name extends AssignmentToken  {
	
	public Parameter_0_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getNameAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0();
			return new Solution(obj);
		}
		return null;
	}
}

// type=TypeRef
protected class Parameter_1_Assignment_type extends AssignmentToken  {
	
	public Parameter_1_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParameterAccess().getTypeAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				Solution s = new TypeRef_Assignment_referenced(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule Parameter ****************/


/************ begin Rule TypedElement ****************
 *
 * TypedElement:
 *   Feature|Parameter;
 *
 **/

// Feature|Parameter
protected class TypedElement_Alternatives extends AlternativesToken {

	public TypedElement_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypedElementAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new TypedElement_0_RuleCall_Feature(current, this);
			case 1: return new TypedElement_1_RuleCall_Parameter(current, this);
			default: return null;
		}
	}
}

// Feature
protected class TypedElement_0_RuleCall_Feature extends RuleCallToken {
	
	public TypedElement_0_RuleCall_Feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypedElementAccess().getFeatureParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Feature_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFeatureRule().getType().getClassifier())) return null;
		return new Feature_Alternatives(current, this).firstSolution();
	}
}

// Parameter
protected class TypedElement_1_RuleCall_Parameter extends RuleCallToken {
	
	public TypedElement_1_RuleCall_Parameter(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypedElementAccess().getParameterParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Parameter_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParameterRule().getType().getClassifier())) return null;
		return new Parameter_Group(current, this).firstSolution();
	}
}


/************ end Rule TypedElement ****************/


/************ begin Rule TypeRef ****************
 *
 * TypeRef:
 *   referenced=[Type];
 *
 **/

// referenced=[Type]
protected class TypeRef_Assignment_referenced extends AssignmentToken  {
	
	public TypeRef_Assignment_referenced(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getReferencedAssignment();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("referenced",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("referenced");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefAccess().getReferencedTypeCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getTypeRefAccess().getReferencedTypeCrossReference_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

/************ end Rule TypeRef ****************/


}
