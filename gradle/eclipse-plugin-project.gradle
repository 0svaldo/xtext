import org.apache.ivy.osgi.core.ManifestParser

buildscript {
	repositories.jcenter()
	dependencies {
		classpath 'org.apache.ivy:ivy:2.4.0'
	}
}

apply plugin: 'java'

dependencies {
	def manifestFile = new File(projectDir, 'META-INF/MANIFEST.MF')
	def manifest = ManifestParser.parseManifest(manifestFile)
	manifest.requires
		.collect{toDependency(it)}
		.findAll {it != null}
		.each {
			add('compile', it)
		}
}

def toDependency(requirement) {
	if (requirement.resolution == 'optional') {
		return null
	}
	if (requirement.name.contains('mwe') || requirement.name.contains('.ui')) {
		return null
	}
	def projectDependency = rootProject.subprojects.findResult {it.name == requirement.name ? it : null}
	if (projectDependency) {
		return projectDependency
	}
	/*
	* TODO these belong into the dependency resolution rules of the downstream projects
	*/
	if (requirement.name == 'com.google.inject') {
		return 'com.google.inject:guice:3.0'
	}
	if (requirement.name == 'org.antlr.runtime') {
		return 'org.antlr:antlr-runtime:3.2'
	}
	if (requirement.name == 'org.eclipse.equinox.common') {
		return 'org.eclipse.equinox:org.eclipse.equinox.common:3.6.0'
	}
	if (requirement.name.startsWith('org.eclipse.emf')) {
		return "org.eclipse.emf:${requirement.name}:${requirement.version.startVersion}+"
	}
	if (requirement.name == 'org.eclipse.jdt.core') {
		return 'org.eclipse.tycho:org.eclipse.jdt.core:3.10.0+'
	}
	if (requirement.name == 'org.apache.log4j') {
		return 'log4j:log4j:1.2.16'
	}
	if (requirement.name == 'com.google.guava') {
		return 'com.google.guava:guava:[10.0.1,19.0.0)'
	}
	if (requirement.name == 'org.objectweb.asm') {
		return 'org.ow2.asm:asm:[5.0.1,6.0.0)'
	}
	logger.debug("Requirement '${requirement}' of ${project} is not mapped to a Maven dependency")
}

jar {
	from('bin')
	manifest {
		from('META-INF/MANIFEST.MF')
	}
	with {
		Properties buildProperties = new Properties()
		File propertiesFile = new File(projectDir, 'build.properties')
		propertiesFile.withInputStream {
				buildProperties.load(it)
		}
		def binIncludes = buildProperties.get("bin.includes").split(',').findAll{it != "."}
		binIncludes.each{ include ->
			if (project.file(include).isDirectory()) {
				from(include) {
					into(include)
				}
			} else {
				from(include)
			}
		}
	}
}

//skip compilation, done by Eclipse/Buckminster
sourceSets*.java*.srcDirs = []
sourceSets*.resources*.srcDirs = []