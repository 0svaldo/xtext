chapter:scripting[Scripting Language]

The scripting language allows to write code without any preludes such as package, class or method declarations.
Just open a fresh file and start coding. It's the simplest of the seven languages and is therefore a good starting point.

img[images/scripting_screenshot.png][][][]

section:scripting_solution[Overview]

As you can see the language is straight forward: All you can do is write expressions and imports.
Here's another example:

code[scripting][
// some expressions making up the application's body
val names = newArrayList('Dennis', 'Holger', 'Jan', 'Moritz', 'Sebastian', 'Sven')
for(name: names) {
  println('Hello ' + name + '!')
}
]

The expressions you see are the same available in Xtend and they are defined in its own grammar (called Xbase).
They are syntactically very close to Java, but feature a lot of modern concepts, like lambda expressions
and operator overloading. They support local type inference so you don't have to write types everyhwere
like in Java, but the expressions are still statically-typed. 
For a Java developer, the code should be self-explanatory. The Xbase expression language is more exhaustively covered in the 
link[http://www.xtext.org/documentation][Xtext documentation].

A script is compiled to a Java class with one main method. That is the script

code[scripting][
println('Hello World!')
]

gets compiled to the following Java source code

code[Java][
package my.first;

public class Application {
  public static void main(String\[\] args) {
    System.out.println("Hello World!");
  }
}
] 

Note that the core language infrastructure such as the parser, linker and compiler is not Eclipse-dependent,
but the compilation is integrated with Eclipse for convenience reasons. All 7 languages can be parsed, copiled and executed
without Eclipse. We could also make use of the interpreter which might make more sense for a sxcripting language.
How to use and integrated the interpreter is explained in the sectiondescribing the ref:tortoise language.

section:scripting_running[Running the Example]

Make sure you have the projects e[org.xtext.scripting] and e[org.xtext.scripting.ui] in your workspace.
Then start a new Eclipse by choosing e[Run > Run Configurations... > Eclipse Application > Run (org.xtext.scripting)].
Import the project e[org.xtext.scripting.examples] into your workspace using the e[Import existing projects
into workspace] wizard.

section:scripting_details[Implementation]

All we need to build such a language is a grammar and a transformation mapping our DSL to Java. This
is what we will be describing in the following section.

section2:scripting_grammar[Grammar]

To build language with Xtext, you first have to define a grammar. As opposed to other parser generators,
an Xtext grammar defines both, the lexical structure of the language and an object model (aka AST) that is build during parsing. 
For more detailed description of the Xtext grammar language, please see the link[http://www.xtext.org/documentation][Xtext documentation].

The grammar for our DSL is rather simple. We inherit from code[org.eclipse.xtext.xbase.Xbase] to get the
syntax of the expressions. As we want to refer to the type 
codeRef[org.eclipse.xtext.xbase.XBlockExpression], we have to import Xbase's Ecore model. The single type 
inferred from this grammar goes into the Ecore model code[simpleExpressions].

code[Xtext][
grammar org.xtext.scripting.Scripting with org.eclipse.xtext.xbase.Xbase

generate scripting "http://www.xtext.org/scripting/Scripting"
import "http://www.eclipse.org/xtext/xbase/Xbase"

Script returns XBlockExpression:
	{Script} // return an object of type Script which is a subtype of XBlockExpression
	((expressions+=XExpressionInsideBlock | imports+=Import) ';'?)*;

Import:
	'import' importedNamespace=QualifiedNameWithWildcard;

QualifiedNameWithWildcard:
	QualifiedName '.*'?;
]

The main rule e[Script] is defined to produce an object of type code[Script] which is a subtype of code[XBlockExpression]. 
A block expression simply consists of any number of expressions. The rule code[XExpressionInsideBlock] is defined in the
super grammar. Usually block expressions are surrounded by curly braces, but of course we don't
want to force anybody to write curly braces at the beginning and the end of a simple script.

In addition to expressions you can have any number of imports. Xtext has a very simple way to let you
define imports, all you need to do is name a feature code[importedNamespace] and it will be interpreted
as a namespace import. For JVM languages you might want to have additional functionality, like static
imports which is explained in the section about the ref:builddsl language.

section2:scripting_inferrer[Translation to Java]

To make our language executable, we have to define how its concepts relate to Java concepts. In Xtext, this
is defined in the so called codeRef[org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer]. The language
generator automatically generates an Xtend stub for it. Nevertheless, it is up to the language developer to 
implement the code[infer()] method. 

This hook is not only used to explain how to generate Java code, but also to give expressions a proper
scope and to make your DSL constructs visible by other JVM languages. The Java type system is used as
a common hub to integrate arbitrary languages.

The inferrer is written in Xtend, if you are not yet familiar with it, you should read at least the 
ref:xtend_primer[Xtend Primer] first.

The JVM model inferrer code for the scripting language looks like this: 

code[Xtend][
class ScriptingJvmModelInferrer extends AbstractModelInferrer {
	
   	@Inject extension JvmTypesBuilder

   	def dispatch void infer(Script script, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
   		val className = script.eResource.URI.trimFileExtension.lastSegment
   		acceptor.accept(script.toClass(className)).initializeLater \[
   			// the class gets one main method
   			members += script.toMethod('main', script.newTypeRef('void')) \[
   				parameters += script.toParameter("args", script.newTypeRef('java.lang.String')).addArrayTypeDimension)
   				setStatic(true)
   				// Associate the script as the body of the main method
   				body = script
   			\]
   		\]
  	}
}
]

It maps each script to one Java class with a main method. Note the use of code[script] as a receiver
for all the factory methods. When creating a Java element, you need to pass a context so Xtext knows
what the origin of a Java element is. This is used throughout the workbench for featurs like find references,
call hierarchies, rename refactoring and more.

As the whole script is an expression it is associated with the body of the main method. That association is important 
since it defines the scope of the expression, which includes what variables, fields and methods are visible and what type is expected.

In this case code[void] is expected, so you would get an error when using a return expression. Also the
parameter code[args] defined in the main method is now on the scope. So you could write the following script:

code[scripting][
for (arg : args)
	println('-- '+arg)
]   

As you can imagine, this is fairly powerful way to put things on the scope implicitly. 

section:scripting_beyond[Beyond This Example]

Well, that has only been the start, but you should now be familiar with the basic concepts of creating
a JVM language with Xtext.