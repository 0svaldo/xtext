part:general_overview[General Overview]

chapter:introduction[Introduction]

Building a domain-specific language (DSLs) for structural parts of an application has always been rather 
easy with Xtext. But structure alone is not sufficient in many cases. When it comes to the behavioral parts users 
often fall back to implementing them in Java, because expressions and statements are hard to get right and extremely complex and 
therefore costly to implement.

This document introduces and explains a new API, which allows to reuse predefined language constructs such as type references, 
annotations and full-featured expressions anywhere in your languages. You not only reuse the grammar but the full implementation 
including a compiler, interpreter, the whole type system and a tight IDE integration. And the best part is, that it is 
relatively easy to do so. It is actually just two steps:

section[Write the grammar]

Using the traditional Xtext grammar language you freely describe the syntax of your language. The specialty for JVM
languages is, that you inherit from an abstract grammar (org.eclipse.xtext.xbase.Xbase) which predefines the syntax
for the reusable parts. You do not need to use them all or actually any of them and you can of course change the syntax 
or add new concepts as it seems fit.

section[Map to Java]

Having the grammar defined, you now need to tell Xtext what your language concepts mean in terms of Java constructs. 
For that you use a special API, called the JvmModelInferrer, where you can create any number of Java classes, interfaces etc.
from your languages constructs. This hook not only defines how your language is translated to Java, but also defines 
the scope of used expressions. The expressions from your language 'live' in the context you give them in this hook.
If you for instance want an expression to have access to certain local variables, just put it into a method with appropriate 
parameters or use instance fields if that works better.

This hook also reveals your DSL constructs to other JVM languages. The Java type system is used as a common hub to 
integrate arbitrary languages with each other. You can for instance call ref:template[templates] directly from a ref:scripting[script]
and vice versa. You do not even need to generate the equivalent Java code, everything is based on the Java types you
create in the model inferrer.

To better communicate the power and flexibility of these two abstractions, we have built seven example languages using on them.
We have built:

ul[
item[ref:scripting[A simple scripting language]]
item[ref:builddsl[A Grade-like build DSL]]
item[ref:mongoDB[A DSL for statically-typed MongoDB documents]]
item[ref:guice[A Guice modules DSL]]
item[ref:httpRouting[A Playframework-like HTTP routing language]]
item[ref:template[A template language]]
item[ref:tortoise[A Logo-like programming environment for educational purposes]]
]

Each language still is very simple and focuses on the value a DSL can add to the respective 
scenario. It is meant to give you an idea of what is possible without being a full practical solution.
Yet the languages are flexible and come with powerful core abstractions.
We also covered different technical aspects of customization to the language infrastructure. Some langauges
have special import logic, others have special syntax coloring, outline views or content assist.
The new API for JVM languages does not mean that anything is hidden away and not customizable.

section:provisional_API[CAUTION: This is Provisional API]

e[Please be aware that most of new API covered in this document is not yet finalized and will
be improved in incompatible ways in future releases. The projects in these examples are configured 
to supress the corresponding API warnings (to see any interesting warnings).]

chapter:common_requirements[Common Requirements]

To run any of the examples, you will need link[http://www.eclipse.org/downloads][Eclipse 4.2 or higher]
for your platform. In addition, you have to install link[http://www.xtend-lang.org/download.html][Xtend]
and of course link[http://www.xtext.org/download.html][Xtext 2.3].

If you prefer a simple all-inclusive installation, consider downloading the latest
link[http://download.itemis.com/distros][itemis distribution].

Additional requirements are mentioned in the e[Running the Example] section of each chapter.

section:installation[Getting the Code]

You can get the source code for all languages from the github repository at
link[https://github.com/xtext-dev/seven-languages-xtext.git][https://github.com/xtext-dev/seven-languages-xtext].
The repository contains two folders e[languages] and e[examples]. Download the plug-ins from e[languages] into
the root workspace and the e[examples] into the runtime workspace spawned from the root one using
e[Run > Run Configurations... > Eclipse Application > Run (<language>)].

Each language consists of several Eclipse projects
table[
tr[td[e[org.xtext.<language>]]td[The base infrastructure]]
tr[td[e[org.xtext.<language>.ui]]td[The editor based on Eclipse]]
tr[td[e[org.xtext.<language>.tests]]td[Tests for the language]]
tr[td[e[org.xtext.<language>.lib]]td[Runtime library]]
tr[td[e[org.xtext.<language>.example]]td[Examples for using the language]]
] 
We do not provide all plug-ins for all languages. 

chapter:xtend_primer[A Short Xtend Primer]

Any general code in the examples is implemented in link[http://www.xtend-lang.org][Xtend]. Xtend is 
a more expressive and less verbose way to implement Java applications. It is 100% interoperable with Java APIs and 
compiles to readable Java code. In addition, it uses the same expressions that we use in our example languages.
In fact it is built with the same API you will learn through in this document, so this should also give you a taste of 
how powerful JVM-languages built with Xtext can actually be. 

Xtend is designed to be easy to learn for Java developers. In this section we will shortly describe
the most important language features needed in our examples. For a full description of the Xtend language, 
please consult the link[http://www.xtend-lang.org/documentation][Xtend documentation]. 

Just like a Java file, an Xtend file starts with a code[Xtend][package] declaration and an code[Xtend][import]
section followed by one or more classes. Semicolons are optional and classes are code[Xtend][public] by default.
Xtend classes can extend super classes and implement interfaces just like Java. It does not make any difference 
whether they were originally declared in Xtend or in Java.

a[xtend_property] 
JavaBean properties can be accessed directly by their name. The access will be automatically mapped to 
the appropriate accessor method. That means you can write
code[Xtend][
println(foo.bar)      // instead of println(foo.getBar())
foo.bar = baz         // instead of foo.setBar(baz)
foo.fooBars += foobar // instead of foo.getFooBars().add(foobar)
]
Empty parentheses on method calls can be skipped.

a[xtend_methods] 

Methods are introduced with the keyword code[Xtend][def] or code[Xtend][override] if they override/implement
a super type's method. They are public if not specified otherwise. The value of the last expression is returned
if no explicit return expression is used and the method's return type is not code[void].

a[xtend_variables]

Variables are declared with the keywords code[Xtend][val] (final) or code[Xtend][var] (non-final).
Field declarations can use the same syntax or the same as in Java.

a[xtend_typeinferrence]

Xtend is statically typed, but you do not have to specify the type in a declaration if it can be inferred
from the context:
code[Xtend][
val x = newArrayList('foo', 'bar', 'baz') // x is of type List<String>
def foo() {  // equivalent to  def int foo()...
  1
}
]

a[xtend_extension]
The methods of fields marked as code[Xtend][extension] are callable in extension syntax. That means,
you can put the first argument in front as if it were the receiver of the call, e.g.
code[Xtend][
// assume the class Foo defines a method foo(Baz)
extension Foo

def bar(Baz baz) {
  baz.foo  // calls _foo.foo(baz)
}
]
Static methods can be put on the extension scope with a static extension import, e.g.
code[Xtend][
import static extension java.util.Collections.*
...
val foo = singleton('foo') // calls Collections.<String>singleton('foo')
]

a[xtend_it]
In addition to Java's code[Xtend][this], you can define another implicit receiver variable named code[Xtend][it].
As with code[Xtend][this], you can skip code[Xtend][it] in feature calls, i.e.
code[Xtend][
class Foo {
  def foo(Bar it) {
    foo // will call it.foo() or if it doesn't exist this.foo()
  }
}
]

a[xtend_lambda]
Xtend provides lambda expressions. These are anonymous functions in square brackets. 
code[Xtend][
\[String foo, String bar | foo + bar\]  
  // a function (String foo, String bar) { foo + bar }
]
a[xtend_lambda_coercion]
As this is a bit bulky, there are more rules to make working with lambdas more attractive:
ol[
item[When a lambda expression is the last argument in a method call, it can be put behind the closing parenthesis.]
item[Lambdas are automatically coerced to interfaces with a single function. Parameter types will be
inferred.]
item[If you skip the declaration of the only parameter, it will be implicitly called code[Xtend][it].]
]
code[Xtend][
new Thread \[ println("Hello concurrent world") \] 
  // lambda will be coerced to a Runnable
val list = newArrayList('fooooo', 'fo', 'foo')
list.sortBy\[ length \]   
  // lambda is coerced into a function (String)=>Comparable
  // equivalent to list.sortBy\[Comparable it | it.length\]
]

a[xtend_templates]
Also noteworthy is the template expression, which allows to define interpolated multi-line string literals.
In addition, the template expressions has intelligent whitespace handling and supports a special code[Xtend][FOR] and 
code[Xtend][IF] construct, which is far better readable in this context.

We most often use this expression in the examples to generate some synthetic Java boilerplate code. Here is
an example from the ref:httpRouting[http routing language]:

code[Xtend][
'''
  String url =  request.getRequestURL().toString();
  «FOR route : routes»
    {
      java.util.regex.Matcher _matcher = _pattern«route.index».matcher(url);
      if (_matcher.find()) {
        «FOR variable : route.url.variables»
            String «variable.name» = _matcher.group(«variable.index + 1»);
        «ENDFOR»
        «IF route.condition != null»
          if («route.nameOfRouteMethod»Condition(request, response
            «FOR v : route.url.variables 
             BEFORE ", " 
             SEPARATOR ", "»«v.name»«ENDFOR»))
        «ENDIF»
        «route.nameOfRouteMethod»(request, response
          «FOR v : route.url.variables», «v.name»«ENDFOR»);
      }
    }
  «ENDFOR»
'''
] 
