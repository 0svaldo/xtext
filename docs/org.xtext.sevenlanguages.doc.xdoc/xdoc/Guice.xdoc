chapter:guice[DSL for Guice]

The Guice DSL is a little language that lets you define Guice modules 
in a readable and declarative way. 

img[images/guicemodules_screenshot.png][][][]

section:guice_solution[Overview]

Guice is a great dependency injection container, which instead uses Java types and
annotations to declare and refer to injection points. You could for instance have the following
field:

code[Java][

  @Inject
  @Named("properties") Map<String,String> properties;
]

A module is used to explain to the framework what instance to inject into such injection points.
For that Guice comes with a fluent interface API written in Java and a couple of tricks (e.g. TypeLiteral) to
make the configuration as readable and maintainable as possible.

You could for instance declare the following module:

code[Java][
public class MyModule implements Module {
	@Override
	public void configure(Binder binder) {
		Map<String,String> properties = Maps.newHashMap();
		properties.put("debugLevel", "info");
		
		binder.bind(new TypeLiteral<Map<String,String>>(){})
			.annotatedWith(Names.named("properties"))
			.toInstance(properties);
	}
}
]

The big advantage of using Java over an external text or XML file, is that you can leverage
the IDE and the type checking. We want to have that. The downside is that you have to trick (i.e. TypeLiteral) a lot in
order to have an ok syntax. Also since the configuration is 'hidden' in a method implementation and not
really declarative you cannot validate a Guice module at compile time.

The Guice DSL described in this section let's you describe aboves module like this:

code[guice][
	MyModule {
		@Named("properties") Map<String,String> to-instance newHashMap('debugLevel' -> 'info')
	}
]

This not only uses the exact same syntax one uses in any injection points, but also opens up all kinds
of possibilities for static analysis. Usually the instantiation of a Guice injector at runtime takes up qute some time
, because all the very helpful validation is done at that time. A language like the one described in this section can
potentially do all theses analysis at compile time, minimizing the start up time. 

section:guice_running[Running the Example]

In the example located in the project e[org.xtext.guicemodules.examples] two modules are declared, one
for a possible runtime scenarion and one for a test scenarion (yes, you sometimes want a module for tests).

code[guice][
import com.acme.*
import com.acme.impl.*

com.acme.RuntimeModule {
	bind DataProvider to FileDataProvider
	bind @DataFile String to-instance 'my-data.txt'
}

com.acme.TestModule mixin RuntimeModule {
	bind DataProvider to-instance \[| 'dummy-data' \]
	bind LoggingService to BufferedLoggingService
}
]

section:guice_grammar[Grammar]

The grammar is less than 30 lines long. It allows to declare any number of imports using the import mechanism
already described in ref:scripting_grammar. A module can 'mixin' any number of other modules, which allows
to reuse existing modules but override keys with different bindings. The mixin feature is described as a 
crossreference to another code[ModuleAST]. Cross references are covered in detail in the link[http://www.eclipse.org/Xtext/documentation.html#cross_reference][Xtext documentation].

The language allows to bind keys to other keys and to instances. Other concepts like binding to providers
is something you could do, but wouldn't help in getting the idea across. Everybody is encouraged to fork
this first prototype and build something really useful ;-).

Instead of extending the grammar code[org.eclipse.xtext.xbase.Xbase] the grammar code[org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations]
is extended which adds full support for annotations. You just have to refer to the rule code[XAnnotation]
as it is done in the rule code[KeyAST]. Btw. it's sometimes a good idea to suffix (or prefix) the AST
node types to avoid confusion when working with a library where concepts are named similarly.

code[Xtext][
grammar org.xtext.guicemodules.GuiceModules 
	with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations
 
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types
generate guiceModules "http://www.xtext.org/guicemodules/GuiceModules"
  
ModulesAST :
	imports+=ImportAST*
	modules+=ModuleAST*;

ModuleAST :
	name=QualifiedName ('mixin' mixins+=\[ModuleAST|QualifiedName\] (',' mixins+=\[ModuleAST|QualifiedName\])*)? 
	'{'
		bindings+=BindingAST*
	'}'
;

BindingAST:
	'bind' from=KeyAST ('to' to=KeyAST | 'to-instance' toInstance=XExpression)?;

KeyAST:
	annotation=XAnnotation? type=JvmTypeReference;

ImportAST:
	'import' importedNamespace=QualifiedNameWithWildCard;

QualifiedNameWithWildCard:
	QualifiedName '.*'?;
]

section:guice_inferrer[Translation to Java]

A module is mapped to a single java class. The 'mixin' modules are not translated to Java inheritance
but to a delegation approach. So a module like the following:

code[guice][
MyModule mixin OtherModule { 
}
]

Is translated to a Java class like :
code[Java][
public class MyModule implements Module {

  private OtherModule otherModule = new OtherModule();

  public void configure(final Binder binder) {
    configure(binder, new java.util.HashSet<com.google.inject.Key<?>>());
  }
  
  public void configure(final Binder bind, final Set<Key<? extends Object>> usedKeys) {
    try {
    	testModule.configure(bind, usedKeys);
    } catch (Exception e) {
    	throw new RuntimeException(e);
    }
    
  }
}
]

As you can see, the language simply leverages the nice equals/hashcode implementation of guice's codeRef[com.google.inject.Key]
to implement the override semantics of mixed in modules.



section:guice_additons[Additional Aspects]

Addtionally customized things: validation, scoping, code completion ...

section:guice_beyond[Beyond This Example]