chapter:simple[A Simple Language]

This example languages demonstrates the basics of a JVM language build with Xtext. It will introduce
you to the Xbase expression language and the DSL to Java transformation, a.k.a. JVM model inferrence.
It is a good starting point to read for all other languages.

section:simple_motivation[The Problem]

We are going to build a language to define an application with a method body. A file in this language
should look like this
code[simple][
// declaration of the application's name
application my.first.Application

// some expressions making up the application's body
val names = newArrayList('Holger', 'Jan', 'Moritz', 'Sebastian', 'Sven')
for(name: names) {
  println('Hello ' + name + '!')
}
]

The expressions are written in Xbase, the expression library we are going to use. For a Java developer,
the code should be self-explanatory. The Xbase language is more exhaustively covered in the 
link[http://www.xtext.org/documentation][Xtext documentation]. 

section:simple_solution[A Solution With Xtext]

The idea is to parse the language and automatically generate a Java class from it. The generated Java class 
should have the following structure

code[Java][
package my.first;

public class Application {
  public static void main(String\[\] args) {
    ... // the body transformed into Java code
  }
}
] 

section2:simple_statistics[Some Stats]

table[
tr[td[Language name]td[SimpleExpressions]]
tr[td[Author]td[Jan Koehnlein]]
tr[td[Xtext Grammar]td[8 LOC]]
tr[td[Xtext extensions]td[inferrer only]]
tr[td[Execution]td[Java code generator]]
tr[td[Runtime library]td[none]]
tr[td[Hardest part]td[Making it as simple as possible]]
]

section:simple_running[Running the Example]

Make sure you have the projects e[org.xtext.simple] and e[org.xtext.simple.ui] in your workspace.
Then start a new Eclipse by choosing e[Run > Run Configurations... > Eclipse Application > Run (org.xtext.simple)].
Create a new Java project and a new file with the file extension e[.simple] in the source folder. Try the above example. 
As soon as you save, a new folder e[src-gen] will appear in the project. It will contain the Java code for
your application. Make e[src-gen] a source folder e[(Right-click > Build path > Use as Source Folder)] and execute
it.

section:simple_details[The Solution in Detail]

All we need to build such a language is a grammar and a transformation mapping our DSL to Java. This
is what we will be describing in the folloging section.

section2:simple_grammar[Grammar]

To build language with Xtext, you first have to define a grammar. As opposed to other parser generators,
an Xtext grammar defines both, the lexical structure of the langauge and the structure of the abstract
syntax tree, the object model that is build from the text by the parser. For more detailed description
of the Xtext grammar language, please see the link[http://www.xtext.org/documentation][Xtext documentation].

The grammar for our DSL is rather simple. We inherit from code[org.eclipse.xtext.xbase.Xbase] to get the
syntax of the expressions. As we want to refer to the type 
codeRef[org.eclipse.xtext.xbase.XBlockExpression], we have to import Xbase's Ecore model. The single type 
inferred from this grammar goes into the Ecore model code[simpleExpressions].

code[Xtext][
grammar org.xtext.simple.SimpleExpressions with org.eclipse.xtext.xbase.Xbase

import "http://www.eclipse.org/xtext/xbase/Xbase"
generate simpleExpressions "http://www.xtext.org/simple/SimpleExpressions"

Application:
  'application' name=QualifiedName main=Main;
  
Main returns XBlockExpression:
  {XBlockExpression}
  (expressions+=XExpressionInsideBlock ';'?)*;
]

The grammar has two rules: An e[Application] is marked with the keyword code[simple][application] followed
by a qualified name - as defined in the supergrammar separated with dots. The code[main] of an e[Application]
is a codeRef[org.eclipse.xtext.xbase.XBlockExpression] from Xbase. Note that we reuse the semantic type 
codeRef[org.eclipse.xtext.xbase.XBlockExpression] but use a different syntax - without the curly braces
as defined in the original rule code[XBlockExpression] - to set its code[expressions].

Even though this is a small grammar, the actual language is already pretty powerful because we include
to Xbase's codeRef[org.eclipse.xtext.xbase.XBlockExpression] which allows any sequence of expressions,
including variable declarations, control structures, closures, etc. Our little languague is already 
Turing-complete!

section2:simple_inferrer[Translation to Java]

To make our language executable, we have to define how its concepts relate to Java concepts. In Xtext, this
is defined in the so called codeRef[org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer]. The language
generator automatically generates an Xtend stub for it. Nevertheless, it is up to the language developer to 
implement the code[infer()] method. 

What you actually do in the code[infer()] method is build a model of the Java class to be created. The
model contains all information needed to generate the Java code from it. So instead of writing a traditional
model-to-text code generator, you rather provide a transformation. The advantage of this approach is
that you can use your inferred classes immediately and interchangeably with Java. In addition, Xtext
can provide a lot better tooling, like debugging, find references, rename refactoring etc. based on that
rich information.   

It is very convenient to write the inferrer in the programming language Xtend, as it offers a far less 
verbose syntax. If you are not yet familiar with Xtend, it would be a good idea to read at least the 
ref:xtend_primer[Xtend Primer] first.

An codeRef[org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer] usually looks like this:

code[Xtend][
class SampleJvmModelInferrer extends AbstractModelInferrer {
     def dispatch void infer(ElementType element, IJvmDeclaredTypeAcceptor acceptor, 
         boolean isPreIndexingPhase) {
       acceptor.accept('<create some class>').initializeLater \[
           '<initialize the contents of the class>' 
         \]  
       \]
    }
}
]

As you see, the JVM model inferrence works in two phases: In the first phase, you create the empty types only. 
This is necessary to be able to refer to these types the same as to other Java types form within the later 
initialized members of the class. The created types are returned via the method code[acceptor.accept()]. 
In the second phase, you create the superclass references, fields, methods etc. You do that by handling a 
ref:xtend_lambda[lambda expression] to the method code[initializeLater]  of the result from the call to 
code[acceptor.accept()]. As we do not provide a parameter declaration for the lambda, the parameter is called 
code[Xtend][it] and the type is inferred as codeRef[org.eclipse.xtext.common.types.JvmGenericType] (see 
section on ref:xtend_lambda_coercion[lambda coercion]).

The JVM model inferrer code for our DSL looks like this: 

code[Xtend][
class SimpleExpressionsJvmModelInferrer extends AbstractModelInferrer {

  @Inject extension JvmTypesBuilder

  def dispatch void infer(Application application, IJvmDeclaredTypeAcceptor acceptor, 
      boolean isPreIndexingPhase) {
    acceptor.accept(application.toClass(application.name)).initializeLater \[
      members += application.toMethod('main', application.newTypeRef(Void::TYPE)) \[
        // add parameter
        parameters += application.toParameter("args", 
            application.newTypeRef(typeof(String)).addArrayTypeDimension)
        setStatic(true)
        body = application.main
      \]  
    \]
  }
}
]

We use an instance of the Java helper class codeRef[org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder] 
to create a Java model from our DSL model.The method is injected - Xtext uses Google Guice as the DI container
- as an ref:xtend_extension[extension], allowing to the shorthand syntax 
code[Xtend][
  application.toClass(application.name)
  // same as: _jvmTypesBuilder.toClass(application, application.getName())
]
The class we create in the first phase has the same name as the e[Application]. 

In the second phase, i.e. inside the lambda expression, we add a method to the new class. Note that 
code[Xtend][members += ...] is a shorthand notation for code[Xtend][it.getMembers().add(...)], where 
code[Xtend][it] is the lambda's implicit parameter, thus the created class.
 
We use the codeRef[org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder] again to create the code[main] method with 
return type code[Java][void]. 

To create references to Java types, you have to use one of the  
codeRef[org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder][JvmTypeBuilder's] code[newTypeRef()] methods. In to 
find it on the classpath, they need a context object which is our application. 

In the following closure the ref:xtend_it[implicit parameter] code[Xtend][it] is bound to the new method. 
First we create a parameter code[Java][String\[\] args] and add it to the method's parameters. Same as above 
code[Xtend][parameters += ...] is short for code[Xtend][it.getParameters().add(...)]. 

Then we set the static flag on the code[main] method.

Finally, we associate the body of the e[Application] with the body of the code[main] method. The compiler
shipped with Xbase knows how to translate that to Java code, so there is nothing more you have to care
about.  

section:mongo_beyond[Beyond This Example]

Well, that has only been the start, but you should now be familiar with the basic concepts of creating
a JVM language with Xtext. No go for the real applications in the other languages!