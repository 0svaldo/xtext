chapter:simple[A Simple Language]

This example languages demonstrates the basics of an Xtext language using the language library Xbase.

section:simple_motivation[The Problem]

When building DSLs with Xtext


section:simple_solution[A Solution With Xtext]

Why a DSL
How about expressions
DSL example, Java example, Client code example (if appropriate)

Approx 2 pages upto here

section2:simple_statistics[Some Stats]

table[
tr[td[Language name]td[SimpleExpressions]]
tr[td[Author]td[Jan Koehnlein]]
tr[td[Xtext Grammar]td[8 LOC]]
tr[td[Xtext extensions]td[inferrer only]]
tr[td[Execution]td[Java code generator]]
tr[td[Runtime library]td[none]]
tr[td[Hardest part]td[Making it as simple as possible]]
]

section:simple_running[Running the Example]

Details on how to run it: Prerequisites, additional plugins... 

section:simple_details[The Solution in Detail]

section2:simple_grammar[Grammar]

The grammar is as simple as possible. We inherit from code[org.eclipse.xtext.xbase.Xbase] to get the
syntactic part of the expressions. As we want to refer to the type 
codeRef[org.eclipse.xtext.xbase.XBlockExpression], we have to import Xbase's Ecore model. The single type 
inferred from this grammar goes into the Ecore model code[simpleExpressions].

code[Xtext][
grammar org.xtext.simple.SimpleExpressions with org.eclipse.xtext.xbase.Xbase

import "http://www.eclipse.org/xtext/xbase/Xbase"
generate simpleExpressions "http://www.xtext.org/simple/SimpleExpressions"

Application:
  'application' name=QualifiedName main=Main;
  
Main returns XBlockExpression:
  {XBlockExpression}
  (expressions+=XExpressionInsideBlock ';'?)*;
]

The grammar has two rules: An e[Application] is marked with the keyword code[simple][application] followed
by a qualified name - as defined in the supergrammar separated with dots. The code[main] of an e[Application]
is a codeRef[org.eclipse.xtext.xbase.XBlockExpression] from Xbase. Note that we reuse the semantic type 
codeRef[org.eclipse.xtext.xbase.XBlockExpression] but use a different syntax - without curly braces - to
set its children.

Even though this is a small grammar, the actual language is already pretty powerful because we include
to Xbase's codeRef[org.eclipse.xtext.xbase.XBlockExpression] which allows any sequence of expressions,
including variable declarations, control structures, closures, etc.  

section2:simple_inferrer[Translation to Java]

To make our language executable, we have to define how its concepts map to Java concepts. In Xtext, this
is defined in the so called codeRef[org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer]. The language
generator has already generated an Xtend stub for it. Nevertheless, it is up to the language developer to 
implement the code[infer()] method. 

It is very convenient to write the inferrer in the programming language Xtend, as it offers a far less 
verbose syntax. If you are not yet familiar with Xtend, it would be a good idea to read the 
ref:xtend_primer[Xtend Primer] now.

An codeRef[org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer] usually looks like this:

code[Xtend][
class SampleJvmModelInferrer extends AbstractModelInferrer {

     def dispatch void infer(ElementType element, IJvmDeclaredTypeAcceptor acceptor, 
         boolean isPreIndexingPhase) {
       acceptor.accept('<create some class>').initializeLater \[
           '<initialize the contents of the class>' 
         \]  
       \]
    }
}
]

As you see, the JVM model inferrence works in two phases: In the first phase, you create the empty types only. 
This is necessary to be able to refer to these types the same as to other Java types form within the later 
initialized members of the class. The created types are returned via the method code[acceptor.accept()]. 
In the second phase, you create the superclass references, fields, methods etc. You specify what happens
to the type in the second phase by handling a ref:xtend_lambda[lambda expression] to the method 
code[initializeLater]  of the result from the call to code[acceptor.accept()]. As we do not provide a
parameter declaration for the lambda, the parameter is called code[Xtend][it] and the type is inferred
as codeRef[org.eclipse.xtext.common.types.JvmGenericType] (see section on ref:xtend_lambda_coercion[lambda
coercion]).

The JVM model inferrer code for our DSL looks like this: 

code[Xtend][
class SimpleExpressionsJvmModelInferrer extends AbstractModelInferrer {

  @Inject extension JvmTypesBuilder

     def dispatch void infer(Application application, IJvmDeclaredTypeAcceptor acceptor, 
         boolean isPreIndexingPhase) {
       acceptor.accept(application.toClass(application.name)).initializeLater \[
         members += application.toMethod('main', application.newTypeRef(Void::TYPE)) \[
           // add parameter
           parameters += application.toParameter("args", 
             application.newTypeRef(typeof(String)).addArrayTypeDimension)
           setStatic(true)
           body = application.main
         \]  
       \]
    }
}
]

We use an instance of the Java helper class codeRef[org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder] 
to create a Java model from our DSL model.The method is injected - Xtext uses Google Guice as the DI container
- as an ref:xtend_extension[extension], allowing to the shorthand syntax 
code[Xtend][
  application.toClass(application.name)
  //   _jvmTypesBuilder.toClass(application, application.getName())
]
The class we create in the first phase has the same name as the e[Application]. 

In the second phase, i.e. inside the lambda, we add a method to the new class. Note that 
code[Xtend][members += ...] is a shorthand notation for code[Xtend][it.getMembers().add(...)], where 
code[Xtend][it] is the lambda's implicit parameter, thus the created class.
 
We use the codeRef[org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder] again to create the code[main] method with 
return type code[Java][void]. 

To create references to Java types, you have to use one of the  
codeRef[org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder]s code[newTypeRef()] methods. In order to get
the classpath right, they need a context object, which is our application. 

In the following closure the implicit parameter ref:xtend_it[it] is bound to the new method. First we create 
a parameter code[Java][String\[\] args] and add it to the method's parameters. Same as above 
code[Xtend][parameters += ...] is short for code[Xtend][it.getParameters().add(...)]. 

Then we set the static flag on the code[main] method.

Finally, we associate the body of the e[Application] with the body of the code[main] method. The compiler
shipped with Xbase knows how to translate that to Java code, so there is nothing more you have to care
about.  
 
