/******************************************************************************* * Copyright (c) 2008 Michael Clay and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * *******************************************************************************/package org.eclipse.xtext.reference.ui.services;import java.util.ArrayList;import java.util.EnumSet;import java.util.HashMap;import java.util.List;import java.util.Map;import org.eclipse.emf.ecore.EObject;import org.eclipse.xtext.AbstractElement;import org.eclipse.xtext.Alternatives;import org.eclipse.xtext.Assignment;import org.eclipse.xtext.Grammar;import org.eclipse.xtext.Group;import org.eclipse.xtext.ParserRule;import org.eclipse.xtext.RuleCall;import org.eclipse.xtext.parsetree.AbstractNode;import org.eclipse.xtext.parsetree.CompositeNode;import org.eclipse.xtext.parsetree.LeafNode;/** *  * Represents a class wich provides various static helper functions used to * support the work with object models containing {@link * org.eclipse.xtext.AbstractElement} and {@link * org.eclipse.xtext.parsetree.AbstractNode} composite structure models. *  *  * @author Michael Clay - Initial contribution and API *  * @see org.eclipse.xtext.AbstractElement * @see org.eclipse.xtext.parsetree.AbstractNode */public final class ParseTreeUtil {    /**     * Dump the composite structure (parsetree) of the given node.     *      * @param abstractNode     *      the node to dump     */    public static final void dumpNode(AbstractNode abstractNode) {        doDumpNode(abstractNode, "\t");    }    /**     * @param abstractNode     * @param indentString     */    private static final void doDumpNode(AbstractNode abstractNode, String indentString) {        if (abstractNode instanceof CompositeNode) {            // CompositeNode compositeNode = (CompositeNode) abstractNode;            System.out.println(indentString + "line '" + abstractNode.line() + "' offset '" + abstractNode.offset()                    + ", length '" + abstractNode.length() + "'");        }        else if (abstractNode instanceof LeafNode) {            LeafNode leafNode = (LeafNode) abstractNode;            // ommit hidden channel            if (!leafNode.isHidden()) {                System.out.println(indentString + "'" + "line '" + leafNode.line() + "' offset '" + leafNode.offset()                        + " length '" + leafNode.length() + "' "                        + (leafNode.getFeature() != null ? leafNode.getFeature() + " = " : "") + " text '"                        + leafNode.getText() + "'");            }        }        for (AbstractNode childNode : abstractNode.getLeafNodes()) {            doDumpNode(childNode, indentString + indentString);        }    }    /**     * @param contextNode     *      the node representing the 'scope' of the current lookup     * @param offsetPosition     *      the text position within the the current sentence     * @param tab     * @return the last grammar element contained within the given contextNode     *  at the provided position     */    public static final AbstractElement getLastElementByOffset(AbstractNode contextNode, int offsetPosition) {        assertParameterNotNull(contextNode, "contextNode");        AbstractElement abstractElement = null;        if (contextNode.getGrammarElement() instanceof AbstractElement) {            abstractElement = (AbstractElement) contextNode.getGrammarElement();        }        for (AbstractNode childNode : contextNode.getLeafNodes()) {            if (childNode.offset() <= offsetPosition) {                AbstractElement lastGrammarElementFromOffset = getLastElementByOffset(childNode, offsetPosition);                if (null != lastGrammarElementFromOffset) {                    abstractElement = lastGrammarElementFromOffset;                }            }        }        return abstractElement;    }    /**     *      * This method returns the parent grammar of the given eObject by recursive     * 'upwards' invocations, passing the eContainer property as parameter until     * some Grammar level object is reached.     *      * @param eObject     *      an object contained or referenced within some 'root' grammar     * @return the {@link org.eclipse.xtext.Grammar} of the given object.     */    public static final Grammar getGrammar(EObject eObject) {        assertParameterNotNull(eObject, "eObject");        if (eObject instanceof Grammar) {            return (Grammar) eObject;        }        else {            return getGrammar(eObject.eContainer());        }    }    /**     * Returns the the {@link org.eclipse.xtext.ParserRule} matching the given     * rule call.     *      * @param ruleCall     *      represents the name of the rule to return     * @return the {@link org.eclipse.xtext.ParserRule} matching the given rule     *  call.     */    public static final ParserRule getParserRule(RuleCall ruleCall) {        assertParameterNotNull(ruleCall, "ruleCall");        Grammar grammar = getGrammar(ruleCall);        return getParserRule(ruleCall, grammar);    }    /**     * This method returns the {@link org.eclipse.xtext.ParserRule} within the     * given gramar matching the provided {@link org.eclipse.xtext.RuleCall}.     *      * @param ruleCall     *      the name of the rule to match     * @param grammar     *      the grammar in which to search for the matching rule name     * @return the {@link org.eclipse.xtext.ParserRule} within the given grammar     *  matching the given name or null if not found.     */    public static final ParserRule getParserRule(RuleCall ruleCall, Grammar grammar) {        assertParameterNotNull(ruleCall, "ruleCall");        assertParameterNotNull(grammar, "grammar");        return getParserRule(ruleCall.getName(), grammar);    }    /**     * @see #getParserRule(RuleCall, Grammar)     */    public static final ParserRule getParserRule(String ruleName, Grammar grammar) {        assertParameterNotNull(ruleName, "ruleName");        assertParameterNotNull(grammar, "grammar");        for (ParserRule parserRule : grammar.getParserRules()) {            if (ruleName.equals(parserRule.getName())) {                return parserRule;            }        }        return null;    }    /**     * Tests if the given element is declared as optional element. (BNF ? or *)     *      * @param element     *      to test     * @return true if the element is optional     */    public static final boolean isOptional(AbstractElement element) {        assertParameterNotNull(element, "element");        boolean isOptional = false;        if (element.getCardinality() != null) {            isOptional = getCardinalityType(element) == CardinalityType.ANY_LITERAL                    || getCardinalityType(element) == CardinalityType.OPTIONAL_LITERAL;        }        return isOptional;    }    /**     *      * @param abstractElement     *      containing the cardinality info to look for     * @return the cardinality of the given grammar element     */    public static final CardinalityType getCardinalityType(AbstractElement abstractElement) {        assertParameterNotNull(abstractElement, "abstractElement");        return CardinalityType.get(abstractElement.getCardinality());    }    /**     *      * Returns a list of all assignment to the given rule.     *      * @param parserRule     *      the rule of the assignments (ruleCall) to match     * @return a list containing all {@see org.eclipse.xtext.Assignment} to the     *  given rule.     */    public static final List<AbstractElement> getParserRuleAssignments(ParserRule parserRule) {        assertParameterNotNull(parserRule, "refParserRule");        List<AbstractElement> list = new ArrayList<AbstractElement>();        Grammar grammar = (Grammar) parserRule.eContainer();        // filter and search        for (ParserRule rule : grammar.getParserRules()) {            // excluded?            if (!parserRule.equals(rule)) {                Assignment ruleAssignment = getParserRuleAssignment(rule.getAlternatives(), parserRule);                if (ruleAssignment != null) {                    list.add(ruleAssignment);                }            }        }        return list;    }    /**     *      * @param contextElement     *      element searched for assignments to the given rule     * @param parserRule     *      the rule of the assignments to search for     * @return an assignment object containing a rulecall to the given     *  parserRule or null if not found.     */    private static final Assignment getParserRuleAssignment(AbstractElement contextElement, ParserRule parserRule) {        assertParameterNotNull(contextElement, "contextElement");        assertParameterNotNull(parserRule, "parserRule");        Assignment assignment = null;        if (contextElement instanceof Group) {            Group group = (Group) contextElement;            for (AbstractElement groupElement : group.getAbstractTokens()) {                assignment = getParserRuleAssignment(groupElement, parserRule);                if (null != assignment) {                    break;                }            }        }        else if (contextElement instanceof Alternatives) {            Alternatives alternatives = (Alternatives) contextElement;            for (AbstractElement groupElement : alternatives.getGroups()) {                assignment = getParserRuleAssignment(groupElement, parserRule);                if (null != assignment) {                    break;                }            }        }        else if (contextElement instanceof Assignment) {            Assignment assignmentToMatch = (Assignment) contextElement;            if (assignmentToMatch.getTerminal() instanceof RuleCall                    && ((RuleCall) assignmentToMatch.getTerminal()).getName().equalsIgnoreCase(parserRule.getName())) {                assignment = assignmentToMatch;            }        }        return assignment;    }    /**     * Represent a Jdk5+ enumeration used to map the set of supported     * cardinality types as enumeration.     */    static enum CardinalityType {        NULL_LITERAL(null), OPTIONAL_LITERAL("?"), ANY_LITERAL("*"), ONEORMORE_LITERAL("+");        private static final Map<String, CardinalityType> lookup = new HashMap<String, CardinalityType>();        static {            for (CardinalityType s : EnumSet.allOf(CardinalityType.class)) {                lookup.put(s.code, s);            }        }        private String code;        private CardinalityType(String code) {            this.code = code;        }        public static CardinalityType get(String code) {            return lookup.get(code);        }    }    private static final void assertParameterNotNull(Object parameter, String parameterName) {        if (null == parameter) {            throw new IllegalArgumentException("parameter '" + parameterName + "' must not be null.");        }    }}