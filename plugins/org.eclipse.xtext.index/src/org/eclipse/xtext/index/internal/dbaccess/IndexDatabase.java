/*******************************************************************************
 * All rights reserved. This program and the accompanying materials
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
package org.eclipse.xtext.index.internal.dbaccess;

import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

import org.apache.log4j.Logger;
import org.eclipse.xtext.util.Files;

/**
 * @author Jan Köhnlein - Initial contribution and API
 * 
 */
public class IndexDatabase {

	private static final Logger log = Logger.getLogger(IndexDatabase.class);

	private static final String USER_NAME = "user";
	private static final String DRIVER = "org.apache.derby.jdbc.EmbeddedDriver";
	private static final String PROTOCOL = "jdbc:derby:";
	private static final String DB_NAME = "xtextIndexer";
	private static final String DERBY_HOME = "/tmp/derby";

	private Connection conn;
	private List<Statement> statements;
	private Statement insertStatement;

	private CrossReferenceDAO crossReferenceDAO;

	private EClassDAO eClassDAO;

	private EObjectDAO eObjectDAO;

	private EPackageDAO ePackageDAO;

	private ResourceContainerDAO resourceContainerDAO;

	private ResourceContainerReferenceDAO resourceContainerReferenceDAO;

	private ResourceDAO resourceDAO;


	public IndexDatabase() {
		try {
			setupConnection();
			createTables();
			statements = new ArrayList<Statement>();
			insertStatement = conn.createStatement();
			statements.add(insertStatement);
			createDAOs();
		}
		catch (Exception exc) {
			throw new RuntimeException(exc);
		}
	}

	private void createDAOs() {
		crossReferenceDAO = new CrossReferenceDAO(this);
		eClassDAO = new EClassDAO(this);
		eObjectDAO = new EObjectDAO(this);
		ePackageDAO = new EPackageDAO(this);
		resourceContainerDAO = new ResourceContainerDAO(this);
		resourceContainerReferenceDAO = new ResourceContainerReferenceDAO(this);
		resourceDAO = new ResourceDAO(this);
	}

	private void setupConnection() throws Exception {
		File derbyHome = new File(DERBY_HOME);
		if (derbyHome.exists()) {
			//Files.cleanFolder(derbyHome);
		}
		System.setProperty("derby.system.home", DERBY_HOME);
		Class.forName(DRIVER).newInstance();
		Properties props = new Properties();
		props.put("user", USER_NAME);
		props.put("password", USER_NAME);
		try{
			conn = DriverManager.getConnection(PROTOCOL + DB_NAME + ";create=true", props);
		} catch (SQLException e) {
			Files.cleanFolder(derbyHome);
			conn = DriverManager.getConnection(PROTOCOL + DB_NAME + ";create=true", props);
		}
		conn.setAutoCommit(false);
	}

	private void createTables() throws Exception {
		executeCommand(
				"CREATE TABLE EPackage (id INTEGER GENERATED BY DEFAULT AS IDENTITY, nsURI VARCHAR(512), PRIMARY KEY (id))",
				true);
		executeCommand(
				"CREATE TABLE EClass (id INTEGER GENERATED BY DEFAULT AS IDENTITY, ePackage INTEGER, name VARCHAR(256), PRIMARY KEY (id), FOREIGN KEY (ePackage) REFERENCES EPackage(id) ON DELETE CASCADE)",
				true);
		executeCommand(
				"CREATE TABLE Container (id INTEGER GENERATED BY DEFAULT AS IDENTITY, uri VARCHAR(512) NOT NULL, type INTEGER, PRIMARY KEY (id))",
				true);
		executeCommand("CREATE TABLE ContainerReference (source INTEGER, target VARCHAR(512), FOREIGN KEY (source) REFERENCES Container(id) ON DELETE CASCADE)", true);
		executeCommand(
				"CREATE TABLE Resource (id INTEGER GENERATED BY DEFAULT AS IDENTITY, container INTEGER, path VARCHAR(512), PRIMARY KEY (id), FOREIGN KEY (container) REFERENCES Container(id) ON DELETE CASCADE)",
				true);
		executeCommand(
				"CREATE TABLE EObject (id INTEGER GENERATED BY DEFAULT AS IDENTITY, resource INTEGER, fragment VARCHAR(256), eClass INTEGER, PRIMARY KEY (id), FOREIGN KEY (resource) REFERENCES Resource(id) ON DELETE CASCADE, FOREIGN KEY (eClass) REFERENCES EClass(id) ON DELETE CASCADE)",
				true);
		executeCommand("CREATE TABLE CrossReference (source INTEGER, target VARCHAR(768), FOREIGN KEY (source) REFERENCES EObject(id) ON DELETE CASCADE)", true);
		commitOrRollback();
	}

	private void executeCommand(String sqlCommand, boolean ignoreExceptions) throws SQLException {
		try {
			Statement createStatement = conn.createStatement();
			createStatement.execute(sqlCommand);
			createStatement.close();
		}
		catch (SQLException exc) {
			if (!ignoreExceptions) {
				throw exc;
			}
		}
	}

	public PreparedStatement prepareStatements(String sql) throws SQLException {
		PreparedStatement preparedStatement = conn.prepareStatement(sql);
		statements.add(preparedStatement);
		return preparedStatement;
	}

	public void commitOrRollback() throws SQLException {
		try {
			conn.commit();
		}
		catch (SQLException exc) {
			conn.rollback();
			throw exc;
		}
	}

	public void shutdown() throws Exception {
		Exception exception = null;
		try {
			commitOrRollback();
		}
		catch (Exception exc) {
			exception = exc;
			log.error(exc);
		}

		for (Statement statement : statements) {
			try {
				statement.close();
			}
			catch (Exception exc) {
				exception = exc;
				log.error(exc);
			}
		}
		try {
			conn.close();
		}
		catch (Exception exc) {
			exception = exc;
			log.error(exc);
		}
		conn = null;
		if (exception != null) {
			throw exception;
		}
	}

	public void clearAll() throws SQLException {
		Statement deleteStatement = null;
		try {
			commitOrRollback();
			deleteStatement = conn.createStatement();
			deleteStatement.execute("DELETE FROM EPackage");
			deleteStatement.execute("DELETE FROM EClass");
			deleteStatement.execute("DELETE FROM CrossReference");
			deleteStatement.execute("DELETE FROM EObject");
			deleteStatement.execute("DELETE FROM Resource");
			deleteStatement.execute("DELETE FROM ContainerReference");
			deleteStatement.execute("DELETE FROM Container");
			commitOrRollback();
		}
		finally {
			if (deleteStatement != null) {
				deleteStatement.close();
			}
		}
	}

	public int queryID(PreparedStatement idQuery) throws SQLException, NotFoundInIndexException {
		int id;
		ResultSet result = null;
		try {
			result = idQuery.executeQuery();
			if (!result.next()) {
				throw new NotFoundInIndexException();
			}
			id = result.getInt(1);
			if (result.next()) {
				throw new SQLException("ID is not unique");
			}
		}
		finally {
			if (result != null) {
				result.close();
			}
		}
		return id;
	}

	/**
	 * Unfortunately, the JDBC API does not provide an autoGeneratedKeys flag on
	 * PreparedStatement, so we use String SQL here...
	 * 
	 * @param insertSQL
	 * @return
	 * @throws SQLException
	 */
	public int insertWithAutoID(String insertSQL) throws SQLException {
		insertStatement.executeUpdate(insertSQL, Statement.RETURN_GENERATED_KEYS);
		ResultSet generatedKeys = null;
		try {
			generatedKeys = insertStatement.getGeneratedKeys();
			if (!generatedKeys.next()) {
				throw new IllegalStateException("Error auto-generating id");
			}
			return generatedKeys.getInt(1);
		}
		finally {
			if (generatedKeys != null) {
				generatedKeys.close();
			}
		}
	}


	public CrossReferenceDAO getCrossReferenceDAO() {
		return crossReferenceDAO;
	}

	public EClassDAO getEClassDAO() {
		return eClassDAO;
	}

	public EObjectDAO getEObjectDAO() {
		return eObjectDAO;
	}

	public EPackageDAO getEPackageDAO() {
		return ePackageDAO;
	}

	public ResourceContainerDAO getResourceContainerDAO() {
		return resourceContainerDAO;
	}
	public ResourceContainerReferenceDAO getResourceContainerReferenceDAO() {
		return resourceContainerReferenceDAO;
	}

	public ResourceDAO getResourceDAO() {
		return resourceDAO;
	}

	
}