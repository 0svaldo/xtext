/*******************************************************************************
 * All rights reserved. This program and the accompanying materials
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
package org.eclipse.xtext.index.internal.dbaccess;

import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

import org.apache.log4j.Logger;
import org.eclipse.xtext.util.Files;

/**
 * @author Jan Köhnlein - Initial contribution and API
 * 
 */
public class IndexDatabase {

	private static final Logger log = Logger.getLogger(IndexDatabase.class);

	private static final String USER_NAME = "user";
	private static final String DRIVER = "org.apache.derby.jdbc.EmbeddedDriver";
	private static final String PROTOCOL = "jdbc:derby:";
	private static final String DB_NAME = "xtextIndexer";
	private static final String DERBY_HOME = "/tmp/derby";

	private Connection conn;
	private List<Statement> statements;
	private Statement insertStatement;

	private static IndexDatabase INSTANCE;

	public static IndexDatabase getInstance() {
		if (INSTANCE == null) {
			INSTANCE = new IndexDatabase();
		}
		return INSTANCE;
	}

	private IndexDatabase() {
		try {
			setupConnection();
			createTables();
			statements = new ArrayList<Statement>();
			insertStatement = conn.createStatement();
			statements.add(insertStatement);
		}
		catch (Exception exc) {
			throw new RuntimeException(exc);
		}
	}

	private void setupConnection() throws Exception {
		File derbyHome = new File(DERBY_HOME);
		if (derbyHome.exists()) {
			Files.cleanFolder(derbyHome);
		}
		System.setProperty("derby.system.home", DERBY_HOME);
		Class.forName(DRIVER).newInstance();
		Properties props = new Properties();
		props.put("user", USER_NAME);
		props.put("password", USER_NAME);
		conn = DriverManager.getConnection(PROTOCOL + DB_NAME + ";create=true", props);
		conn.setAutoCommit(false);
	}

	private void createTables() throws Exception {
		executeCommand("CREATE TABLE EPackage (id INTEGER GENERATED BY DEFAULT AS IDENTITY, nsURI VARCHAR(512), PRIMARY KEY (id))");
		executeCommand("CREATE TABLE EClass (id INTEGER GENERATED BY DEFAULT AS IDENTITY, ePackage INTEGER, name VARCHAR(256), PRIMARY KEY (id), FOREIGN KEY (ePackage) REFERENCES EPackage(id))");
		executeCommand("CREATE TABLE Container (id INTEGER GENERATED BY DEFAULT AS IDENTITY, uri VARCHAR(512) NOT NULL, type INTEGER, PRIMARY KEY (id))");
		executeCommand("CREATE TABLE ContainerReference (source INTEGER, target INTEGER, FOREIGN KEY (source) REFERENCES Container(id), FOREIGN KEY (target) REFERENCES Container(id))");
		executeCommand("CREATE TABLE Resource (id INTEGER GENERATED BY DEFAULT AS IDENTITY, container INTEGER, path VARCHAR(512), PRIMARY KEY (id), FOREIGN KEY (container) REFERENCES Container(id))");
		executeCommand("CREATE TABLE EObject (id INTEGER GENERATED BY DEFAULT AS IDENTITY, resource INTEGER, fragment VARCHAR(256), eClass INTEGER, PRIMARY KEY (id), FOREIGN KEY (resource) REFERENCES Resource(id), FOREIGN KEY (eClass) REFERENCES EClass(id))");
		executeCommand("CREATE TABLE CrossReference (source INTEGER, target INTEGER, FOREIGN KEY (source) REFERENCES EObject(id), FOREIGN KEY (target) REFERENCES EObject(id))");
		commitOrRollback();
	}

	private void executeCommand(String sqlCommand) throws SQLException {
		Statement createStatement = conn.createStatement();
		createStatement.execute(sqlCommand);
		createStatement.close();
	}

	public PreparedStatement prepareStatements(String sql) throws SQLException {
		PreparedStatement preparedStatement = conn.prepareStatement(sql);
		statements.add(preparedStatement);
		return preparedStatement;
	}

	private void commitOrRollback() throws SQLException {
		try {
			conn.commit();
		}
		catch (SQLException exc) {
			conn.rollback();
			throw exc;
		}
	}

	public void shutdown() throws Exception {
		Exception exception = null;
		try {
			commitOrRollback();
		}
		catch (Exception exc) {
			exception = exc;
			log.error(exc);
		}

		for (Statement statement : statements) {
			try {
				statement.close();
			}
			catch (Exception exc) {
				exception = exc;
				log.error(exc);
			}
		}
		try {
			conn.close();
		}
		catch (Exception exc) {
			exception = exc;
			log.error(exc);
		}
		INSTANCE = null;
		if (exception != null) {
			throw exception;
		}
	}

	public int queryID(PreparedStatement idQuery) throws SQLException, NotFoundInIndexException {
		int id;
		ResultSet result = null;
		try {
			result = idQuery.executeQuery();
			if (!result.next()) {
				throw new NotFoundInIndexException();
			}
			id = result.getInt(1);
			if (result.next()) {
				throw new SQLException("ID is not unique");
			}
		}
		finally {
			if (result != null) {
				result.close();
			}
		}
		return id;
	}

	/**
	 * Unfortunately, the JDBC API does not provide an autoGeneratedKeys flag on
	 * PreparedStatement, so we use String SQL here...
	 * 
	 * @param insertSQL
	 * @return
	 * @throws SQLException
	 */
	public int insertWithAutoID(String insertSQL) throws SQLException {
		insertStatement.executeUpdate(insertSQL, Statement.RETURN_GENERATED_KEYS);
		ResultSet generatedKeys = null;
		try {
			generatedKeys = insertStatement.getGeneratedKeys();
			if (!generatedKeys.next()) {
				throw new IllegalStateException("Error auto-generating id");
			}
			return generatedKeys.getInt(1);
		}
		finally {
			if (generatedKeys != null) {
				generatedKeys.close();
			}
		}
	}
}