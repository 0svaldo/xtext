/*******************************************************************************
 * All rights reserved. This program and the accompanying materials
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
package org.eclipse.xtext.index.internal.dbaccess;

import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

import org.apache.log4j.Logger;
import org.eclipse.xtext.index.internal.IndexPlugin;
import org.eclipse.xtext.util.Files;

/**
 * @author Jan Köhnlein - Initial contribution and API
 * 
 */
public class IndexDatabase {

	private static final Logger log = Logger.getLogger(IndexDatabase.class);

	private static enum DB_IMPL_TYPE {
		DERBY, HSQL_MEM, HSQL_FILE
	};

	private static DB_IMPL_TYPE DB_IMPL = DB_IMPL_TYPE.DERBY;

	private static final String USER_NAME = "sa";
	private static final String PASSWORD = "";
	private static final String DERBY_DRIVER = "org.apache.derby.jdbc.EmbeddedDriver";
	private static final String PROTOCOL = "jdbc:derby:";
	private static final String DB_NAME = "xtextIndexer";
	private static final String DB_HOME;

	static {
		IndexPlugin indexPlugin = IndexPlugin.getDefault();
		if (indexPlugin != null) {
			DB_HOME = indexPlugin.getStateLocation().toString();
		}
		else {
			String tmpDir = System.getProperty("java.io.tmpdir");
			DB_HOME = new File(tmpDir).toString();
		}
	}

	private Connection conn;
	private List<Statement> statements;
	private Statement insertStatement;

	private CrossReferenceDAO crossReferenceDAO;

	private EClassDAO eClassDAO;

	private EObjectDAO eObjectDAO;

	private EPackageDAO ePackageDAO;

	private ResourceContainerDAO resourceContainerDAO;

	private ResourceContainerReferenceDAO resourceContainerReferenceDAO;

	private ResourceDAO resourceDAO;

	int uniqueID;

	public IndexDatabase() {
		try {
			setupConnection();
			createTables();
			statements = new ArrayList<Statement>();
			insertStatement = conn.createStatement();
			statements.add(insertStatement);
			uniqueID = queryMaxID();
			createDAOs();
		}
		catch (Exception exc) {
			throw new RuntimeException(exc);
		}
	}

	private void createDAOs() {
		crossReferenceDAO = new CrossReferenceDAO(this);
		eClassDAO = new EClassDAO(this);
		eObjectDAO = new EObjectDAO(this);
		ePackageDAO = new EPackageDAO(this);
		resourceContainerDAO = new ResourceContainerDAO(this);
		resourceContainerReferenceDAO = new ResourceContainerReferenceDAO(this);
		resourceDAO = new ResourceDAO(this);
	}

	private void setupConnection() throws Exception {
		File dbHome = new File(DB_HOME);
		if (dbHome.exists()) {
			// Files.cleanFolder(derbyHome);
		}
		switch (DB_IMPL) {
			case DERBY:
				System.setProperty("derby.system.home", DB_HOME);
				Class.forName(DERBY_DRIVER).newInstance();
				Properties props = new Properties();
				props.put("user", USER_NAME);
				props.put("password", PASSWORD);
				String connectionURL = PROTOCOL + DB_NAME + ";create=true";
				try {
					conn = DriverManager.getConnection(connectionURL, props);
				}
				catch (SQLException e) {
					Files.sweepFolder(dbHome);
					conn = DriverManager.getConnection(connectionURL, props);
				}
				break;
			case HSQL_FILE:
			case HSQL_MEM:
				Class.forName("org.hsqldb.jdbcDriver");
				String connectionBaseURL;
				if (DB_IMPL == DB_IMPL_TYPE.HSQL_FILE) {
					connectionBaseURL = "jdbc:hsqldb:file:" + DB_HOME + "/" + DB_NAME;
				}
				else {
					connectionBaseURL = "jdbc:hsqldb:mem:" + DB_NAME;
				}
				try {
					conn = DriverManager.getConnection(connectionBaseURL, USER_NAME, PASSWORD);
				}
				catch (SQLException e) {
					Files.sweepFolder(dbHome);
					conn = DriverManager.getConnection(connectionBaseURL, USER_NAME, PASSWORD);
				}
				break;
		}
		conn.setAutoCommit(false);
	}

	private void createTables() throws Exception {
		executeCommand(
				"CREATE TABLE EPackage (id INTEGER GENERATED BY DEFAULT AS IDENTITY, nsURI VARCHAR(512), PRIMARY KEY (id))",
				true);
		executeCommand(
				"CREATE TABLE EClass (id INTEGER GENERATED BY DEFAULT AS IDENTITY, ePackage INTEGER, name VARCHAR(256), PRIMARY KEY (id), FOREIGN KEY (ePackage) REFERENCES EPackage(id) ON DELETE CASCADE)",
				true);
		executeCommand(
				"CREATE TABLE Container (id INTEGER GENERATED BY DEFAULT AS IDENTITY, uri VARCHAR(512) NOT NULL, type INTEGER, PRIMARY KEY (id))",
				true);
		executeCommand(
				"CREATE TABLE ContainerReference (source INTEGER, target VARCHAR(512), FOREIGN KEY (source) REFERENCES Container(id) ON DELETE CASCADE)",
				true);
		executeCommand(
				"CREATE TABLE Resource (id INTEGER GENERATED BY DEFAULT AS IDENTITY, container INTEGER, path VARCHAR(512), PRIMARY KEY (id), FOREIGN KEY (container) REFERENCES Container(id) ON DELETE CASCADE)",
				true);
		executeCommand(
				"CREATE TABLE EObject (id INTEGER GENERATED BY DEFAULT AS IDENTITY, resource INTEGER, fragment VARCHAR(256), eClass INTEGER, PRIMARY KEY (id), FOREIGN KEY (resource) REFERENCES Resource(id) ON DELETE CASCADE, FOREIGN KEY (eClass) REFERENCES EClass(id) ON DELETE CASCADE)",
				true);
		executeCommand(
				"CREATE TABLE CrossReference (source INTEGER, target VARCHAR(768), FOREIGN KEY (source) REFERENCES EObject(id) ON DELETE CASCADE)",
				true);
		commitOrRollback();
	}

	private int queryMaxID() throws SQLException {
		return Math.max(Math.max(Math.max(queryMaxID("EPackage"), queryMaxID("EClass")), Math.max(
				queryMaxID("Container"), queryMaxID("Resource"))), queryMaxID("EObject"));
	}

	private int queryMaxID(String table) throws SQLException {
		Statement queryMaxID = null;
		ResultSet result = null;
		try {
			queryMaxID = conn.createStatement();
			result = queryMaxID.executeQuery("SELECT max(id) FROM " + table);
		}
		finally {
			if (queryMaxID != null) {
				queryMaxID.close();
			}
			if (result != null) {
				result.close();
			}
		}
		return 0;
	}

	private void executeCommand(String sqlCommand, boolean ignoreExceptions) throws SQLException {
		try {
			Statement createStatement = conn.createStatement();
			createStatement.execute(sqlCommand);
			createStatement.close();
		}
		catch (SQLException exc) {
			if (!ignoreExceptions) {
				throw exc;
			}
		}
	}

	public PreparedStatement prepareStatements(String sql) throws SQLException {
		PreparedStatement preparedStatement = conn.prepareStatement(sql);
		statements.add(preparedStatement);
		return preparedStatement;
	}

	public void commitOrRollback() throws SQLException {
		try {
			conn.commit();
		}
		catch (SQLException exc) {
			conn.rollback();
			throw exc;
		}
	}

	public void shutdown() throws Exception {
		Exception exception = null;
		try {
			commitOrRollback();
		}
		catch (Exception exc) {
			exception = exc;
			log.error(exc);
		}

		for (Statement statement : statements) {
			try {
				statement.close();
			}
			catch (Exception exc) {
				exception = exc;
				log.error(exc);
			}
		}
		try {
			conn.close();
		}
		catch (Exception exc) {
			exception = exc;
			log.error(exc);
		}
		conn = null;
		if (exception != null) {
			throw exception;
		}
	}

	public synchronized int nextUniqueID() {
		return ++uniqueID;
	}

	public void clearAll() throws SQLException {
		Statement deleteStatement = null;
		try {
			commitOrRollback();
			deleteStatement = conn.createStatement();
			deleteStatement.execute("DELETE FROM EPackage");
			deleteStatement.execute("DELETE FROM EClass");
			deleteStatement.execute("DELETE FROM CrossReference");
			deleteStatement.execute("DELETE FROM EObject");
			deleteStatement.execute("DELETE FROM Resource");
			deleteStatement.execute("DELETE FROM ContainerReference");
			deleteStatement.execute("DELETE FROM Container");
			commitOrRollback();
		}
		finally {
			if (deleteStatement != null) {
				deleteStatement.close();
			}
		}
	}

	public int queryID(PreparedStatement idQuery) throws SQLException, NotFoundInIndexException {
		int id;
		ResultSet result = null;
		try {
			result = idQuery.executeQuery();
			if (!result.next()) {
				throw new NotFoundInIndexException();
			}
			id = result.getInt(1);
			if (result.next()) {
				throw new SQLException("ID is not unique");
			}
		}
		finally {
			if (result != null) {
				result.close();
			}
		}
		return id;
	}

	/**
	 * Unfortunately, the JDBC API does not provide an autoGeneratedKeys flag on
	 * PreparedStatement, so we use String SQL here...
	 * 
	 * @param insertSQL
	 * @return
	 * @throws SQLException
	 */
	public int insertWithAutoID(String insertSQL) throws SQLException {
		insertStatement.executeUpdate(insertSQL, Statement.RETURN_GENERATED_KEYS);
		ResultSet generatedKeys = null;
		try {
			generatedKeys = insertStatement.getGeneratedKeys();
			if (!generatedKeys.next()) {
				throw new IllegalStateException("Error auto-generating id");
			}
			return generatedKeys.getInt(1);
		}
		finally {
			if (generatedKeys != null) {
				generatedKeys.close();
			}
		}
	}

	public CrossReferenceDAO getCrossReferenceDAO() {
		return crossReferenceDAO;
	}

	public EClassDAO getEClassDAO() {
		return eClassDAO;
	}

	public EObjectDAO getEObjectDAO() {
		return eObjectDAO;
	}

	public EPackageDAO getEPackageDAO() {
		return ePackageDAO;
	}

	public ResourceContainerDAO getResourceContainerDAO() {
		return resourceContainerDAO;
	}

	public ResourceContainerReferenceDAO getResourceContainerReferenceDAO() {
		return resourceContainerReferenceDAO;
	}

	public ResourceDAO getResourceDAO() {
		return resourceDAO;
	}

}