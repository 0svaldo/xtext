/**
 * Copyright (c) 2015 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package org.eclipse.xtext.xtext.generator;

import com.google.common.base.Objects;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import org.eclipse.emf.common.EMFPlugin;
import org.eclipse.emf.common.util.ResourceLocator;
import org.eclipse.emf.mwe.core.WorkflowContext;
import org.eclipse.emf.mwe.core.issues.Issues;
import org.eclipse.emf.mwe.core.lib.AbstractWorkflowComponent2;
import org.eclipse.emf.mwe.core.monitor.ProgressMonitor;
import org.eclipse.xtend.lib.annotations.Accessors;
import org.eclipse.xtext.XtextStandaloneSetup;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Pure;
import org.eclipse.xtext.xtext.generator.IClassAnnotation;

/**
 * The Xtext language infrastructure generator. Can be configured with {@link IGeneratorFragment2}
 * instances as well as with some properties declared via setter or adder methods.
 * 
 * <p><b>NOTE: This is a reimplementation of org.eclipse.xtext.generator.Generator</b></p>
 */
@SuppressWarnings("all")
public class XtextGenerator extends AbstractWorkflowComponent2 {
  /**
   * Only needed to determine the Manifest file and its version of this plugin in standalone mode.
   */
  private static class Plugin extends EMFPlugin {
    public final static XtextGenerator.Plugin INSTANCE = new XtextGenerator.Plugin();
    
    private Plugin() {
      super(new ResourceLocator[] {});
    }
    
    @Override
    public ResourceLocator getPluginResourceLocator() {
      return null;
    }
  }
  
  private final static String FILE_HEADER_VAR_TIME = "${time}";
  
  private final static String FILE_HEADER_VAR_DATE = "${date}";
  
  private final static String FILE_HEADER_VAR_YEAR = "${year}";
  
  private final static String FILE_HEADER_VAR_USER = "${user}";
  
  private final static String FILE_HEADER_VAR_VERSION = "${version}";
  
  @Accessors
  private String encoding = System.getProperty("file.encoding");
  
  @Accessors
  private String fileHeader = "/*\n * generated by Xtext\n */";
  
  private final List<IClassAnnotation> classAnnotations = CollectionLiterals.<IClassAnnotation>newArrayList();
  
  public XtextGenerator() {
    XtextStandaloneSetup _xtextStandaloneSetup = new XtextStandaloneSetup();
    _xtextStandaloneSetup.createInjectorAndDoEMFRegistration();
  }
  
  @Override
  protected void invokeInternal(final WorkflowContext ctx, final ProgressMonitor monitor, final Issues issues) {
  }
  
  /**
   * Class annotations are used configure specific Java annotations to be added to each generated class.
   */
  public void addClassAnnotation(final IClassAnnotation annotation) {
    this.classAnnotations.add(annotation);
  }
  
  protected String getTransformedFileHeader() {
    String result = this.fileHeader;
    boolean _notEquals = (!Objects.equal(result, null));
    if (_notEquals) {
      boolean _contains = result.contains(XtextGenerator.FILE_HEADER_VAR_TIME);
      if (_contains) {
        final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
        Date _date = new Date();
        final String time = dateFormat.format(_date);
        String _replace = result.replace(XtextGenerator.FILE_HEADER_VAR_TIME, time);
        result = _replace;
      }
      boolean _contains_1 = result.contains(XtextGenerator.FILE_HEADER_VAR_DATE);
      if (_contains_1) {
        final SimpleDateFormat dateFormat_1 = new SimpleDateFormat("MMM d, yyyy");
        Date _date_1 = new Date();
        final String date = dateFormat_1.format(_date_1);
        String _replace_1 = result.replace(XtextGenerator.FILE_HEADER_VAR_DATE, date);
        result = _replace_1;
      }
      boolean _contains_2 = result.contains(XtextGenerator.FILE_HEADER_VAR_YEAR);
      if (_contains_2) {
        final SimpleDateFormat dateFormat_2 = new SimpleDateFormat("yyyy");
        Date _date_2 = new Date();
        final String year = dateFormat_2.format(_date_2);
        String _replace_2 = result.replace(XtextGenerator.FILE_HEADER_VAR_YEAR, year);
        result = _replace_2;
      }
      boolean _contains_3 = result.contains(XtextGenerator.FILE_HEADER_VAR_USER);
      if (_contains_3) {
        final String user = System.getProperty("user.name");
        boolean _notEquals_1 = (!Objects.equal(user, null));
        if (_notEquals_1) {
          String _replace_3 = result.replace(XtextGenerator.FILE_HEADER_VAR_USER, user);
          result = _replace_3;
        }
      }
      boolean _contains_4 = result.contains(XtextGenerator.FILE_HEADER_VAR_VERSION);
      if (_contains_4) {
        final String version = this.getVersion();
        boolean _notEquals_2 = (!Objects.equal(version, null));
        if (_notEquals_2) {
          String _replace_4 = result.replace(XtextGenerator.FILE_HEADER_VAR_VERSION, version);
          result = _replace_4;
        }
      }
    }
    return result;
  }
  
  /**
   * Read the exact version from the Manifest of the plugin.
   */
  private String getVersion() {
    InputStream is = null;
    try {
      URL _baseURL = XtextGenerator.Plugin.INSTANCE.getBaseURL();
      String _plus = (_baseURL + "META-INF/MANIFEST.MF");
      final URL url = new URL(_plus);
      InputStream _openStream = url.openStream();
      is = _openStream;
      final Manifest manifest = new Manifest(is);
      Attributes _mainAttributes = manifest.getMainAttributes();
      return _mainAttributes.getValue("Bundle-Version");
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        return null;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    } finally {
      boolean _notEquals = (!Objects.equal(is, null));
      if (_notEquals) {
        try {
          is.close();
        } catch (final Throwable _t_1) {
          if (_t_1 instanceof IOException) {
            final IOException e_1 = (IOException)_t_1;
          } else {
            throw Exceptions.sneakyThrow(_t_1);
          }
        }
      }
    }
  }
  
  @Pure
  public String getEncoding() {
    return this.encoding;
  }
  
  public void setEncoding(final String encoding) {
    this.encoding = encoding;
  }
  
  @Pure
  public String getFileHeader() {
    return this.fileHeader;
  }
  
  public void setFileHeader(final String fileHeader) {
    this.fileHeader = fileHeader;
  }
}
