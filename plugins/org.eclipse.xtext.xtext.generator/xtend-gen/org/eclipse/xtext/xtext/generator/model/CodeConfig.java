/**
 * Copyright (c) 2015 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package org.eclipse.xtext.xtext.generator.model;

import com.google.common.base.Objects;
import com.google.inject.Injector;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.jar.Attributes;
import java.util.jar.Manifest;
import org.eclipse.emf.common.EMFPlugin;
import org.eclipse.emf.common.util.ResourceLocator;
import org.eclipse.xtend.lib.annotations.AccessorType;
import org.eclipse.xtend.lib.annotations.Accessors;
import org.eclipse.xtext.util.Strings;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Pure;
import org.eclipse.xtext.xtext.generator.IGuiceAwareGeneratorComponent;
import org.eclipse.xtext.xtext.generator.model.IClassAnnotation;
import org.eclipse.xtext.xtext.generator.model.TypeReference;

/**
 * Configuration object for generated code.
 */
@SuppressWarnings("all")
public class CodeConfig implements IGuiceAwareGeneratorComponent {
  /**
   * Only needed to determine the Manifest file and its version of this plugin in standalone mode.
   */
  private static class Plugin extends EMFPlugin {
    public final static CodeConfig.Plugin INSTANCE = new CodeConfig.Plugin();
    
    private Plugin() {
      super(new ResourceLocator[] {});
    }
    
    @Override
    public ResourceLocator getPluginResourceLocator() {
      return null;
    }
  }
  
  private final static String FILE_HEADER_VAR_TIME = "${time}";
  
  private final static String FILE_HEADER_VAR_DATE = "${date}";
  
  private final static String FILE_HEADER_VAR_YEAR = "${year}";
  
  private final static String FILE_HEADER_VAR_USER = "${user}";
  
  private final static String FILE_HEADER_VAR_VERSION = "${version}";
  
  @Accessors
  private String encoding;
  
  @Accessors
  private String lineDelimiter;
  
  @Accessors(AccessorType.PUBLIC_GETTER)
  private String fileHeader;
  
  private String fileHeaderTemplate = "/*\n * generated by Xtext\n */";
  
  @Accessors(AccessorType.PUBLIC_GETTER)
  private final List<IClassAnnotation> classAnnotations = CollectionLiterals.<IClassAnnotation>newArrayList();
  
  /**
   * Configure a template for file headers. The template can contain variables:
   * <ul>
   *   <li><code>${time}</code> - the current time of the day (hour:minute:second)</li>
   *   <li><code>${date}</code> - the current date (month day, year)</li>
   *   <li><code>${year}</code> - the current year</li>
   *   <li><code>${user}</code> - the content of the 'user.name' system property</li>
   *   <li><code>${version}</code> - the generator plug-in version</li>
   * </ul>
   */
  public void setFileHeader(final String fileHeaderTemplate) {
    this.fileHeaderTemplate = fileHeaderTemplate;
  }
  
  /**
   * Class annotations are used to configure specific Java annotations to be added to each generated class.
   */
  public void addClassAnnotation(final IClassAnnotation annotation) {
    this.classAnnotations.add(annotation);
  }
  
  @Override
  public void initialize(final Injector injector) {
    injector.injectMembers(this);
    if ((this.lineDelimiter == null)) {
      this.lineDelimiter = "\n";
    }
    String fileHeader = this.fileHeaderTemplate;
    boolean _notEquals = (!Objects.equal(fileHeader, null));
    if (_notEquals) {
      boolean _contains = fileHeader.contains(CodeConfig.FILE_HEADER_VAR_TIME);
      if (_contains) {
        final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
        Date _date = new Date();
        final String time = dateFormat.format(_date);
        String _replace = fileHeader.replace(CodeConfig.FILE_HEADER_VAR_TIME, time);
        fileHeader = _replace;
      }
      boolean _contains_1 = fileHeader.contains(CodeConfig.FILE_HEADER_VAR_DATE);
      if (_contains_1) {
        final SimpleDateFormat dateFormat_1 = new SimpleDateFormat("MMM d, yyyy");
        Date _date_1 = new Date();
        final String date = dateFormat_1.format(_date_1);
        String _replace_1 = fileHeader.replace(CodeConfig.FILE_HEADER_VAR_DATE, date);
        fileHeader = _replace_1;
      }
      boolean _contains_2 = fileHeader.contains(CodeConfig.FILE_HEADER_VAR_YEAR);
      if (_contains_2) {
        final SimpleDateFormat dateFormat_2 = new SimpleDateFormat("yyyy");
        Date _date_2 = new Date();
        final String year = dateFormat_2.format(_date_2);
        String _replace_2 = fileHeader.replace(CodeConfig.FILE_HEADER_VAR_YEAR, year);
        fileHeader = _replace_2;
      }
      boolean _contains_3 = fileHeader.contains(CodeConfig.FILE_HEADER_VAR_USER);
      if (_contains_3) {
        final String user = System.getProperty("user.name");
        boolean _notEquals_1 = (!Objects.equal(user, null));
        if (_notEquals_1) {
          String _replace_3 = fileHeader.replace(CodeConfig.FILE_HEADER_VAR_USER, user);
          fileHeader = _replace_3;
        }
      }
      boolean _contains_4 = fileHeader.contains(CodeConfig.FILE_HEADER_VAR_VERSION);
      if (_contains_4) {
        final String version = this.getVersion();
        boolean _notEquals_2 = (!Objects.equal(version, null));
        if (_notEquals_2) {
          String _replace_4 = fileHeader.replace(CodeConfig.FILE_HEADER_VAR_VERSION, version);
          fileHeader = _replace_4;
        }
      }
    }
    this.fileHeader = fileHeader;
  }
  
  /**
   * Read the exact version from the Manifest of the plugin.
   */
  private String getVersion() {
    InputStream is = null;
    try {
      URL _baseURL = CodeConfig.Plugin.INSTANCE.getBaseURL();
      String _plus = (_baseURL + "META-INF/MANIFEST.MF");
      final URL url = new URL(_plus);
      InputStream _openStream = url.openStream();
      is = _openStream;
      final Manifest manifest = new Manifest(is);
      Attributes _mainAttributes = manifest.getMainAttributes();
      return _mainAttributes.getValue("Bundle-Version");
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        return null;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    } finally {
      boolean _notEquals = (!Objects.equal(is, null));
      if (_notEquals) {
        try {
          is.close();
        } catch (final Throwable _t_1) {
          if (_t_1 instanceof IOException) {
            final IOException e_1 = (IOException)_t_1;
          } else {
            throw Exceptions.sneakyThrow(_t_1);
          }
        }
      }
    }
  }
  
  public String getClassAnnotationsAsString() {
    boolean _isEmpty = this.classAnnotations.isEmpty();
    if (_isEmpty) {
      return null;
    }
    final StringBuilder stringBuilder = new StringBuilder();
    for (final IClassAnnotation annotation : this.classAnnotations) {
      String _string = annotation.toString();
      StringBuilder _append = stringBuilder.append(_string);
      String _newLine = Strings.newLine();
      _append.append(_newLine);
    }
    return stringBuilder.toString();
  }
  
  public String getAnnotationImportsAsString() {
    boolean _isEmpty = this.classAnnotations.isEmpty();
    if (_isEmpty) {
      return null;
    }
    final StringBuilder stringBuilder = new StringBuilder();
    for (final IClassAnnotation annotation : this.classAnnotations) {
      {
        final TypeReference importString = annotation.getAnnotationImport();
        if ((importString != null)) {
          StringBuilder _append = stringBuilder.append("import ");
          StringBuilder _append_1 = _append.append(importString);
          StringBuilder _append_2 = _append_1.append(";");
          String _newLine = Strings.newLine();
          _append_2.append(_newLine);
        }
      }
    }
    return stringBuilder.toString();
  }
  
  @Pure
  public String getEncoding() {
    return this.encoding;
  }
  
  public void setEncoding(final String encoding) {
    this.encoding = encoding;
  }
  
  @Pure
  public String getLineDelimiter() {
    return this.lineDelimiter;
  }
  
  public void setLineDelimiter(final String lineDelimiter) {
    this.lineDelimiter = lineDelimiter;
  }
  
  @Pure
  public String getFileHeader() {
    return this.fileHeader;
  }
  
  @Pure
  public List<IClassAnnotation> getClassAnnotations() {
    return this.classAnnotations;
  }
}
