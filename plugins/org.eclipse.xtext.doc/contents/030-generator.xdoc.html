<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Configuration</title>
<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="index.html" title="">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<a name="configuration"></a>
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Configuration</h1>


<a name="generator"></a>

<a name="generator"></a>
<div class="section" title="The Generator">
<div class="titlepage">
<div>
<div>
<h2 class="title">
The Generator
</h2>
</div>
</div>
</div>



<p>
Xtext provides lots of generic implementations for your language&apos;s
infrastructure but also uses code generation to generate some of the 
components. Those generated components are for instance the parser, the 
serializer, the inferred Ecore model (if any) and a couple of convenient base classes for 
content assist, etc.
</p>

<p>
The generator also contributes to shared project resources such as the 
<em>plugin.xml</em>, <em>MANIFEST.MF</em> and the 
<a href="040-dependency-injection.xdoc.html#guicemodules">Guice modules</a>.
</p>

<p>
Xtext&apos;s generator leverages 
<a href="118-mwe-in-depth.xdoc.html#MWE2">MWE2 - the modeling workflow engine</a> 
from EMFT to configure the generator.
</p>


<a name="short_intro_to_mwe"></a>

<a name="short_intro_to_mwe"></a>
<div class="section" title="A Short Introduction to MWE2">
<div class="titlepage">
<div>
<div>
<h3 class="title">
A Short Introduction to MWE2
</h3>
</div>
</div>
</div>



<p>
MWE2 allows to compose object graphs declaratively in a very compact manner. The nice thing about it is that it just 
instantiates Java classes and the configuration is done through public setter and adder methods as one is used to 
from Java Beans encapsulation principles. An in-depth documentation can be found in the chapter 
<a href="118-mwe-in-depth.xdoc.html#MWE2">MWE2</a>.
</p>

<p>
Given the following simple Java class (POJO):
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">package</span>&nbsp;com.mycompany;<br />&nbsp;&nbsp;<br /><span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;Person&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;String&nbsp;name;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;setName(String&nbsp;name)&nbsp;{&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.name&nbsp;=&nbsp;name;<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;<span class="keyword">final</span>&nbsp;List&lt;Person&gt;&nbsp;children&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;ArrayList&lt;Person&gt;();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;addChild(Person&nbsp;child)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.children.add(child);<br />&nbsp;&nbsp;}<br />}<br />&nbsp;&nbsp;
</p>
</div>
</div>


</p>

<p>
One can create a family tree with MWE2 easily by describing it in a declarative manner 
without writing a single line of Java code and without the need to compile classes:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">module</span>&nbsp;com.mycompany.CreatePersons<br /><br />Person&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;&quot;Grandpa&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;child&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;&quot;Father&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;&quot;Son&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>

<p>
These couple of lines will, when interpreted by MWE2, result in an 
object tree consisting of three instances of <em>com.mycompany.Person</em>.
The interpreter will basically do the same as the following <em>main</em> method: 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">package</span>&nbsp;com.mycompany;<br /><br /><span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;CreatePersons&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;grandpa&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;Person();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grandpa.setName(&quot;Grandpa&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;father&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;Person();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;father.setName(&quot;Father&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grandpa.addChild(father);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person&nbsp;son&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;Person();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;son.setName(&quot;Son&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;father.addChild(son);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>

<p>
!{width:50%}images/family_tree.png! 
</p>

<p>
The root element is a class-name following the Java classpath visibility rules. As the module is a sibling to the class
<em>com.mycompany.Person</em> it is not necessary to use use fully qualified name. There are other packages implicitly imported
into this workflow as well to make it convenient to instantiate actual workflows and components, but these ones are covered 
in depth in the appropriate 
<a href="118-mwe-in-depth.xdoc.html#MWE2">chapter</a>. The constructed objects are furthermore configured according to the declaration 
in the module, e.g. a second instance of Person will be created and added to the list of children of &quot;Grandpa&quot; while the third 
person - the class is inferred from the assigned feature - becomes a child of &quot;Father&quot;. All three instances will have 
their respective <em>name</em> assigned via a reflective invocation <em>setName</em>. If one wants to add another child to &quot;Father&quot;, she
can simply repeat the child assignment:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
child&nbsp;=&nbsp;com.mycompany.Person&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;&quot;Father&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;child&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;&quot;Son&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;child&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;&quot;Daughter&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>

<p>
As you can see in the example above MWE2 can be used to instantiate arbitrary Java object models without any dependency or
limitation to MWE2 specific implementations. This is conceptually very close to the dependency injection mechanism and 
the XML language in the <a href="http://www.springframework.org.">Spring Framework</a> 
</p>

<p>
<em>Tip</em>
<em>Whenever you are in an *.mwe2 file and wonder what kind of configuration the underlying component may accept:</em>
<em>Just use the Content Assist in the MWE2 Editor or navigate directly to the declaration of the underlying Java</em> 
<em>implementation by means of F3 (Go To Declaration).</em>
</p>

<p>
This is the basic idea of the MWE2 language. There are of course a couple of additional concepts and features in the 
language and we also have not yet talked about the runtime workflow model. Please refer to the dedicated MWE2 

<a href="118-mwe-in-depth.xdoc.html#MWE2">reference documentation</a> for additional information.
</p>


</div>



<a name="generator-5"></a>
<div class="section" title="General Architecture">
<div class="titlepage">
<div>
<div>
<h3 class="title">
General Architecture
</h3>
</div>
</div>
</div>



<p>
Of course a generator in Xtext is not composed of fathers and sons, but of so called language configurations. 
For each language configuration a URI pointing to 
its grammar file and the file extensions for the DSL must be provided. 
In addition, a language is configured with a list of 

<em>org.eclipse.xtext.generator.IGeneratorFragment</em>
s.
The whole generator is composed of theses fragments. We have fragments for generating parsers, the serializer, the EMF code, 
the outline view, etc. 
</p>

<p>
<div class="image" >
<img src="images/generator-structure.png" class=" width:50%" />
 
</div>
</p>


<a name="generator_fragment"></a>

<a name="generator_fragment"></a>
<div class="section" title="Generator Fragments">
<div class="titlepage">
<div>
<div>
<h4 class="title">
Generator Fragments
</h4>
</div>
</div>
</div>



<p>
Each fragment gets the grammar of the language as an EMF model passed in. A fragment is able to generate code in one 
of the configured locations and contribute to several shared artifacts. The main interface 

<em>org.eclipse.xtext.generator.IGeneratorFragment</em>
 is supported by a convenient 
abstract base class 
<em>org.eclipse.xtext.generator.AbstractGeneratorFragment</em>
, which 
by default delegates to an Xpand template with the same qualified name as the class and delegates some of the 
calls to Xpand template definitions.
</p>

<p>
We suggest to have a look at the fragment we have written for label providers (
<em>org.eclipse.xtext.ui.generator.labeling.LabelProviderFragment</em>
). It is pretty trivial and at the same time uses the most important call backs. In addition, the structure is not cluttered with too much extra noise so that the whole package can serve as a template to write your own fragment.
</p>


</div>



<a name="generator-5-4"></a>
<div class="section" title="Configuration">
<div class="titlepage">
<div>
<div>
<h4 class="title">
Configuration
</h4>
</div>
</div>
</div>



<p>
As already explained we use MWE2 from EMFT in order to instantiate, configure and execute this structure of components. 
In the following we see an exemplary Xtext generator configuration written in MWE2 configuration code:  
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">module</span>&nbsp;org.xtext.example.MyDsl<br /><br /><span class="keyword">import</span>&nbsp;org.eclipse.emf.mwe.utils.*<br /><span class="keyword">import</span>&nbsp;org.eclipse.xtext.generator.*<br /><span class="keyword">import</span>&nbsp;org.eclipse.xtext.ui.generator.*<br /><br /><span class="keyword">var</span>&nbsp;grammarURI&nbsp;=&nbsp;&quot;classpath:/org/xtext/example/MyDsl.xtext&quot;<br /><span class="keyword">var</span>&nbsp;file.extensions&nbsp;=&nbsp;&quot;mydsl&quot;<br /><span class="keyword">var</span>&nbsp;projectName&nbsp;=&nbsp;&quot;org.xtext.example.mydsl&quot;<br /><span class="keyword">var</span>&nbsp;runtimeProject&nbsp;=&nbsp;&quot;../${projectName}&quot;<br /><br />Workflow&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;bean&nbsp;=&nbsp;StandaloneSetup&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;platformUri&nbsp;=&nbsp;&quot;${runtimeProject}/..&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;component&nbsp;=&nbsp;DirectoryCleaner&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;directory&nbsp;=&nbsp;&quot;${runtimeProject}/src-gen&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;component&nbsp;=&nbsp;DirectoryCleaner&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;directory&nbsp;=&nbsp;&quot;${runtimeProject}.ui/src-gen&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;component&nbsp;=&nbsp;Generator&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathRtProject&nbsp;=&nbsp;runtimeProject<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pathUiProject&nbsp;=&nbsp;&quot;${runtimeProject}.ui&quot;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;projectNameRt&nbsp;=&nbsp;projectName<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;projectNameUi&nbsp;=&nbsp;&quot;${projectName}.ui&quot;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;language&nbsp;=&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uri&nbsp;=&nbsp;grammarURI<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileExtensions&nbsp;=&nbsp;file.extensions<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Java&nbsp;API&nbsp;to&nbsp;access&nbsp;grammar&nbsp;elements<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fragment&nbsp;=&nbsp;grammarAccess.GrammarAccessFragment&nbsp;{}<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;more&nbsp;fragments&nbsp;to&nbsp;configure&nbsp;the&nbsp;language&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>

<p>
Here the root element is <em>Workflow</em> and is part of the very slim runtime model shipped with MWE2. It accepts 
<em>bean</em> s and <em>component</em> s. The <em>var</em> declaration is a first class concept of MWE2&apos;s configuration language 
and defines the interface of the module. They allow to externalize some common configuration parameters. This 
comes especially handy in String variables where one can easily use <em>${variable}</em> to concatenate values. 
</p>

<p>
The method <em>Workflow.addBean(Object)</em> does nothing but provides a means to apply global side-effects, which 
unfortunately is required sometimes. In this example we do a so called <em>EMF stand-alone setup</em>. This class 
initializes a bunch of things for a non-OSGi environment that are otherwise configured by means of extension points, 
e.g. it allows to populate EMF&apos;s singletons like the <em>EPackage.Registry</em>.
</p>

<p>
Following the <em>bean</em> assignment there are three <em>component</em> elements. The <em>Workflow.addComponent()</em> method 
accepts instances of <em>IWorkflowComponent</em>, which is the primary concept of MWE2&apos;s workflow model. Xtext&apos;s generator 
itself is an instance of <em>IWorkflowComponent</em> and can therefore be used within MWE2 workflows. 
</p>

<p>
There are two fragments 
<em>org.eclipse.xtext.generator.ImplicitRuntimeFragment</em>
 and 

<em>org.eclipse.xtext.ui.generator.ImplicitUiFragment</em>
 will be called implicitly if 
the required paths and project names are set. They take care of common defaults.  
</p>


</div>

</div>



<a name="generator-6"></a>
<div class="section" title="Standard Generator Fragments">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Standard Generator Fragments
</h3>
</div>
</div>
</div>



<p>
In the following table the most important standard generator fragments are listed. Please refer to the Javadocs for more detailed documentation.
</p>

<p>


</p>


</div>

</div>



<a name="configuration-2"></a>
<div class="section" title="Dependency Injection in Xtext with Google Guice">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Dependency Injection in Xtext with Google Guice
</h2>
</div>
</div>
</div>



<p>
All Xtext components are assembled by means of Dependency Injection (DI). This means basically that whenever some code is in need for functionality (or state) 
from another component, one just declares the dependency rather then stating how to resolve it, i.e. obtaining that component.
</p>

<p>
For instance when some code wants to use a scope provider, it just declares a field (or method or constructor) and 
adds the @Inject annotation: 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;MyLanguageLinker&nbsp;<span class="keyword">extends</span>&nbsp;Linker&nbsp;{<br /><br />&nbsp;&nbsp;@Inject<br />&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;IScopeProvider&nbsp;scopeProvider;<br /><br />}<br />&nbsp;
</p>
</div>
</div>


</p>

<p>
It is not the duty of the code to care about where the <em>IScopeProvider</em> comes from or how it is created. When above&apos;s
class is instantiated, Guice sees that it requires an instance of IScopeProvider and assigns it to the specified field or method parameter.
This of course only works, if the object itself is created by Guice. In Xtext almost every instance is created that way 
and therefore the whole dependency net is controlled and configured by the means of Google Guice.
</p>

<p>
Guice of course needs to know how to instantiate real objects for declared dependencies. This is done in so called <em>Modules</em>.
A <em>Module</em> defines a set of mappings from types to either existing instances, instance providers or concrete
classes. Modules are implemented in Java. Here&apos;s an example:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;MyDslRuntimeModule&nbsp;<span class="keyword">extends</span>&nbsp;AbstractMyDslRuntimeModule&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;@Override<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;configure(Binder&nbsp;binder)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">super</span>.configure(binder);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binder.bind(IScopeProvider.<span class="keyword">class</span>).to(MyConcreteScopeProvider.<span class="keyword">class</span>);<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>

<p>
With plain Guice modules one implements a method called configure and gets a so called <em>Binder</em> passed in.
That binder provides a fluent API to define the mentioned mappings. This was just a very brief and simplified description.
We highly recommend to have a look at <a href="http://code.google.com/p/google-guice/">the website Google Guice</a> to learn more.  
</p>


<a name="guicemodules"></a>

<a name="guicemodules"></a>
<div class="section" title="The Module API">
<div class="titlepage">
<div>
<div>
<h3 class="title">
The Module API
</h3>
</div>
</div>
</div>



<p>
Xtext comes with a slightly enhanced module API. For your language you get two different modules: One for the runtime bundle
which is used when executing your language infrastructure outside of Eclipse such as on the build server. The other is
located in the UI bundle and adds or overrides bindings when Xtext is used within an Eclipse environment. 
</p>

<p>
The enhancement we added to Guice&apos;s Module API is that we provide an abstract base class, which reflectively looks for certain 
methods in order to find declared bindings. The most common kind of method is :
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;Class&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;IScopeProvider&gt;&nbsp;bindIScopeProvider()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;MyConcreteScopeProvider.<span class="keyword">class</span>;<br />}<br />
</p>
</div>
</div>


</p>

<p>
which would do the same as the code snippet above. It simply declares a binding from <em>IScopeProvider</em> to <em>MyConcreteScopeProvider</em>.
That binding will make Guice instantiate and inject a new instance of <em>MyConcreteScopeProvider</em> whenever a dependency 
to <em>IScopeProvider</em> is declared.
</p>

<p>
Having a method per binding allows to deactivate individual bindings by overriding the corresponding methods and either change 
the binding by returning a different target type or removing that binding completely by returning null.
</p>

<p>
There are two additional kinds of binding-methods supported. The first one allows to configure a provider. A <em>Provider</em> is
an interface with just one method : 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">interface</span>&nbsp;Provider&lt;T&gt;&nbsp;{<br /><br />&nbsp;&nbsp;/**<br />&nbsp;&nbsp;&nbsp;*&nbsp;Provides&nbsp;an&nbsp;instance&nbsp;of&nbsp;{@code&nbsp;T}.&nbsp;Must&nbsp;never&nbsp;<span class="keyword">return</span>&nbsp;{@code&nbsp;null}.<br />&nbsp;&nbsp;&nbsp;*/<br />&nbsp;&nbsp;T&nbsp;get();<br />}<br />
</p>
</div>
</div>


</p>

<p>
This one can be used if you need a hook whenever an instance of a certain type is created. For instance if you want to 
provide lazy access to a singleton or you need to do some computation each time an instance is created (i.e. factory). If you want 
to point to a provider rather than to a concrete class you can use the following binding method.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;Class&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;Provider&lt;IScopeProvider&gt;&gt;&nbsp;provideIScopeProvider()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;MyConcreteScopeProviderFactory.<span class="keyword">class</span>;<br />}<br />
</p>
</div>
</div>


</p>

<p>
<em>(Please forgive us the overuse of the term</em> provider. <em>The IScopeProvider is not a Guice</em> provider <em>.)</em>
</p>

<p>
That binding tells Guice to instantiate <em>MyConcreteScopeProviderFactory</em> and invoke get() in order to obtain an instance of 
<em>IScopeProvider</em> 
for clients having declared a dependency to that type. Both mentioned methods are allowed to return an instance instead of a type. This
may be useful if some global state should be shared in the application:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;Provider&lt;IScopeProvider&gt;&nbsp;provideIScopeProvider()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;MyConcreteScopeProviderFactory();<br />}<br />
</p>
</div>
</div>


</p>

<p>
or
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;IScopeProvider&nbsp;bindIScopeProvider()&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;MyConcreteScopeProvider();<br />}<br />
</p>
</div>
</div>


</p>

<p>
respectively.
</p>

<p>
The last binding method provided by Xtext allows to do anything you can do with Guice&apos;s binding API, since it allows you to 
use it directly. If your method&apos;s name starts with the name &apos;configure&apos;, has a return type <em>void</em> and accepts one argument of 
type <em>Binder</em>
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">void</span>&nbsp;configureIScopeProvider(Binder&nbsp;binder)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;binder.bind(IScopeProvider.<span class="keyword">class</span>).to(MyConcreteScopeProvider.<span class="keyword">class</span>);<br />}&nbsp;<br />
</p>
</div>
</div>


</p>


</div>



<a name="dependencyInjection-9"></a>
<div class="section" title="Obtaining an Injector">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Obtaining an <em>Injector</em>
</h3>
</div>
</div>
</div>



<p>
In every application wired up with Guice there is usually one point where you initialize a so called <em>Injector</em> using the 
modules declared and after that using that injector to create the root instance of the whole application. In plain Java environments
this is something that&apos;s done in the main method. It could look like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;Injector&nbsp;injector&nbsp;=&nbsp;Guice.createInjector(<span class="keyword">new</span>&nbsp;MyDslRuntimeModule());<br />&nbsp;&nbsp;&nbsp;&nbsp;MyApplication&nbsp;application&nbsp;=&nbsp;injector.getInstance(MyApplication.<span class="keyword">class</span>);<br />&nbsp;&nbsp;&nbsp;&nbsp;application.run();<br />}<br />
</p>
</div>
</div>


</p>

<p>
Xtext uses EMF which makes use of a couple of global registries, which have to be configured on startup. Because we
of course want to leverage Guice also for all factories, etc. that we put into those registries, we have introduced a so called
<em>ISetup</em> which provides a method called <em>Injector createInjectorAndDoEMFRegistration()</em>. So instead of using the plain Guice
code shown above you rather use the <em>ISetup</em> class generated for your language, which, as the method name suggests, creates
an <em>Injector</em> and uses it to initialize a couple of EMF objects and register them in the corresponding registries.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Injector&nbsp;injector&nbsp;=&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">new</span>&nbsp;MyStandaloneSetup().createInjectorAndDoEMFRegistration();&nbsp;<br />
</p>
</div>
</div>


</p>

<p>
These are the basic ideas around Guice and the small extension Xtext provides on top. For more information we 
strongly encourage you to read through the documentation on <a href="http://code.google.com/p/google-guice/.">the website of Google Guice</a>
</p>


</div>

</div>

</body>
</html>
