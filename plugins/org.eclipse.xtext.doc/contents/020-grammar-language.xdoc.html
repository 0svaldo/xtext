<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>The Grammar Language</title>
<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="index.html" title="">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<a name="grammarLanguage"></a>
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">The Grammar Language</h1>

<p>
The <a href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/Xtext.xtext?root=Modeling_Project&view=markup">grammar language</a> 
is the corner stone of Xtext. It is a domain-specific language, carefully designed for the description of textual languages.
The main idea is to describe the concrete syntax and how it is mapped to an in-memory model created during parsing. 
</p>




<a name="grammarLanguage-2"></a>
<div class="section" title="A First Example">
<div class="titlepage">
<div>
<div>
<h2 class="title">
A First Example
</h2>
</div>
</div>
</div>



<p>
To get an idea of how it works we&apos;ll start by implementing a <a href="http://martinfowler.com/dslwip/Intro.html">simple example</a> 
introduced by Martin Fowler. It&apos;s mainly about describing state machines used as the (un)lock mechanism of secret compartments.
People who have secret compartments control their access in a very old-school way, e.g. by opening the door first and 
turning on the light afterwards. Then the secret compartment, for instance a panel, opens up. One of those state machines 
could look like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">events</span><br />&nbsp;&nbsp;doorClosed&nbsp;&nbsp;D1CL<br />&nbsp;&nbsp;drawOpened&nbsp;&nbsp;D2OP<br />&nbsp;&nbsp;lightOn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L1ON<br />&nbsp;&nbsp;doorOpened&nbsp;&nbsp;D1OP<br />&nbsp;&nbsp;panelClosed&nbsp;PNCL<br />&nbsp;&nbsp;<span class="keyword">resetting</span>&nbsp;doorOpened&nbsp;D1OP<br /><span class="keyword">end</span><br />&nbsp;<br /><span class="keyword">commands</span><br />&nbsp;&nbsp;unlockPanel&nbsp;PNUL<br />&nbsp;&nbsp;lockPanel&nbsp;&nbsp;&nbsp;PNLK<br />&nbsp;&nbsp;lockDoor&nbsp;&nbsp;&nbsp;&nbsp;D1LK<br />&nbsp;&nbsp;unlockDoor&nbsp;&nbsp;D1UL<br /><span class="keyword">end</span><br />&nbsp;<br /><span class="keyword">state</span>&nbsp;idle<br />&nbsp;&nbsp;<span class="keyword">actions</span>&nbsp;{unlockDoor&nbsp;lockPanel}<br />&nbsp;&nbsp;doorClosed&nbsp;=&gt;&nbsp;active<br /><span class="keyword">end</span><br />&nbsp;<br /><span class="keyword">state</span>&nbsp;active<br />&nbsp;&nbsp;drawOpened&nbsp;=&gt;&nbsp;waitingForLight<br />&nbsp;&nbsp;lightOn&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;waitingForDraw<br /><span class="keyword">end</span><br />&nbsp;<br /><span class="keyword">state</span>&nbsp;waitingForLight<br />&nbsp;&nbsp;lightOn&nbsp;=&gt;&nbsp;unlockedPanel<br /><span class="keyword">end</span><br />&nbsp;<br /><span class="keyword">state</span>&nbsp;waitingForDraw<br />&nbsp;&nbsp;drawOpened&nbsp;=&gt;&nbsp;unlockedPanel<br /><span class="keyword">end</span><br />&nbsp;<br /><span class="keyword">state</span>&nbsp;unlockedPanel<br />&nbsp;&nbsp;<span class="keyword">actions</span>&nbsp;{unlockPanel&nbsp;lockDoor}<br />&nbsp;&nbsp;panelClosed&nbsp;=&gt;&nbsp;idle<br /><span class="keyword">end</span><br />
</p>
</div>
</div>


</p>

<p>
So, we have a bunch of declared events, commands, and states. Within states there are references to declared actions,
which should be executed when entering such a state. Also there are transitions consisting of a reference to an event and 
a state. Please read <a href="http://martinfowler.com/dslwip/Intro.html">Martin&apos;s description</a> if you want to read the whole story.
</p>

<p>
In order to implment this little language with Xtext, you need to write the following grammar:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
&nbsp;<span class="keyword">grammar</span>&nbsp;my.pack.SecretCompartments&nbsp;<br />&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;org.eclipse.xtext.common.Terminals<br /><span class="keyword">generate</span>&nbsp;secretcompartment&nbsp;&quot;http://www.eclipse.org/secretcompartment&quot;<br /><br />Statemachine&nbsp;:<br />&nbsp;&apos;events&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;(events+=Event)+<br />&nbsp;&apos;end&apos;<br />&nbsp;(&apos;resetEvents&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;(resetEvents+=[Event])+<br />&nbsp;&apos;end&apos;)?<br />&nbsp;&apos;commands&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;(commands+=Command)+<br />&nbsp;&apos;end&apos;<br />&nbsp;(states+=State)+;<br /><br />Event&nbsp;:<br />&nbsp;name=ID&nbsp;code=ID;<br /><br />Command&nbsp;:<br />&nbsp;name=ID&nbsp;code=ID;<br /><br />State&nbsp;:<br />&nbsp;&apos;state&apos;&nbsp;name=ID<br />&nbsp;&nbsp;&nbsp;&nbsp;(&apos;actions&apos;&nbsp;&apos;{&apos;&nbsp;(actions+=[Command])+&nbsp;&apos;}&apos;)?<br />&nbsp;&nbsp;&nbsp;&nbsp;(transitions+=Transition)*<br />&nbsp;&apos;end&apos;;<br /><br />Transition&nbsp;:<br />&nbsp;event=[Event]&nbsp;&apos;=&gt;&apos;&nbsp;state=[State];<br />&nbsp;
</p>
</div>
</div>


</p>

<p>
Martin uses this example throughout his book &quot;Domain-Specific Languages&quot; to implement external and internal DSLs using
different technologies. Note, that none of his implmentations is nearly as readable and concise as the description in
Xtext&apos;s grammar language above. That is of course because the grammar language is designed to do just that, i.e. it is 
specific to the domain of language descriptions.
</p>


</div>

<a name="syntax"></a>

<a name="syntax"></a>
<div class="section" title="The Syntax">
<div class="titlepage">
<div>
<div>
<h2 class="title">
The Syntax
</h2>
</div>
</div>
</div>



<p>
In the following the different concepts and syntactical constructs of the grammar language are explained. 
</p>




<a name="syntax-2"></a>
<div class="section" title="Language Declaration">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Language Declaration
</h3>
</div>
</div>
</div>



<p>
The first line in every grammar ... 
</p>

<p>
<span class="inlinecode"><span class="keyword">grammar</span>&nbsp;my.pack.SecretCompartments&nbsp;<span class="keyword">with</span>&nbsp;org.eclipse.xtext.common.Terminals</span>

</p>

<p>
declares the name of the grammar. Xtext leverages Java&apos;s classpath mechanism. This means that the name 
can be any valid Java qualifier. The file name needs to correspond to the grammar name and have the file 
extension &apos;_.xtext_&apos;. This means that the name has to be <em>SecretCompartments.xtext</em> and must be placed 
in a package <em>my.pack</em> somewhere on your project&apos;s classpath.
</p>

<p>
The first line is also used to declare any used language (for mechanism details see 
<a href="020-grammar-language.xdoc.html#grammarMixins">Grammar Mixins</a>).
</p>


</div>

<a name="package_declarations"></a>

<a name="package_declarations"></a>
<div class="section" title="EPackage Declarations">
<div class="titlepage">
<div>
<div>
<h3 class="title">
EPackage Declarations
</h3>
</div>
</div>
</div>



<p>
Xtext parsers create in-memory object graphs while parsing text. Such object-graphs are 
instances of EMF Ecore models. An Ecore model basically consists of an <em>EPackage</em> containing <em>EClasses</em>, 
<em>EDataTypes</em> and <em>EEnums</em> (See the 
<a href="210-emf-integration.xdoc.html#model_metamodel">section on EMF</a> for more details).
Xtext can infer Ecore models from a grammar (see 
<a href="020-grammar-language.xdoc.html#metamodelInference">Ecore model inference</a>) but it is also 
possible to reuse existing Ecore models. You can even mix this and use multiple existing Ecore models and 
infer some others from one grammar. 
</p>




<a name="package_declarations-2"></a>
<div class="section" title="EPackage Generation">
<div class="titlepage">
<div>
<div>
<h4 class="title">
EPackage Generation
</h4>
</div>
</div>
</div>



<p>
The easiest way to get started is to let Xtext infer the Ecore model from your grammar. This is what is done in the 
secret compartment example. To do so just state:
</p>

<p>
<span class="inlinecode"><span class="keyword">generate</span>&nbsp;secretcompartment&nbsp;&apos;http://www.eclipse.org/secretcompartment&apos;</span>

</p>

<p>
That statement means: generate an <em>EPackage</em> with the <em>name</em> &quot;secretcompartment&quot; and the <em>nsURI</em> &quot;http://www.eclipse.org/secretcompartment&quot;. 
Actually these are the properties that are required to create an <em>EPackage</em>.
Xtext will then add <em>EClasses</em> with properties (_EAttributes_ and <em>EReferences</em>) for the different rules, as described in

<a href="020-grammar-language.xdoc.html#metamodelInference">Ecore model inference</a>. 
</p>


</div>



<a name="package_declarations-3"></a>
<div class="section" title="EPackage Import">
<div class="titlepage">
<div>
<div>
<h4 class="title">
EPackage Import
</h4>
</div>
</div>
</div>



<p>
If you already have an existing <em>EPackage</em>, you can import it using either a namespace URI or a resource URI. 
An <a href="http://www.ietf.org/rfc/rfc2396.txt">URI</a> (Uniform Resource Identifier) provides a simple and extensible 
means for identifying an abstract or physical resource. For all the niftx details about EMF URIs 
please see its <a href="http://help.eclipse.org/help32/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/common/util/URI.html.">documentation</a>
</p>




<a name="package_declarations-3-2"></a>
<div class="section" title="Using Resource URIs to Import Existing EPackages">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Using Resource URIs to Import Existing EPackages
</h5>
</div>
</div>
</div>



<p>
In order to import an existing Ecore model, you&apos;ll have to have the *.ecore file describing the <em>EPackage</em> you want to 
use somewhere in your workspace. In order to refer to that file you make use of the platform:/resource scheme.
Platform URIs are a special EMF concept, which allow to reference elements in the workspace 
independent of the location of the workspace. 
</p>

<p>
An import statement referring to an Ecore file by a <em>platform:/resource/</em>-URI looks like this: 
</p>

<p>
<span class="inlinecode"><span class="keyword">import</span>&nbsp;&apos;platform:/resource/my.project/src/my/pack/SecretCompartments.ecore&apos;</span>

</p>

<p>
If you want to mix generated and imported Ecore models you&apos;ll have to configure the generator fragment 
in your MWE file responsible for generating the Ecore classes 
(
<em>org.eclipse.xtext.generator.ecore.EcoreGeneratorFragment</em>
) 
with resource URIs that point to the 
<a href="210-emf-integration.xdoc.html#emf_codegen">generator models</a> of the referenced Ecore models.
</p>

<p>
The *.genmodel provides all kind of generator configuration used by EMF&apos;s code generator. Xtext will automatically create
a *.genmodel for generated ecore models, but if such a model references an existing imported Ecore model, the code generator 
needs to know how that code was generated in order to generate valid references in Java for the new Ecore model. 
</p>

<p>
Example:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
fragment&nbsp;=&nbsp;org.eclipse.xtext.generator.ecore.EcoreGeneratorFragment&nbsp;{<br />&nbsp;&nbsp;genModels&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;platform:/resource/my.project/src/my/pack/SecretCompartments.genmodel&quot;<br />}<br />
</p>
</div>
</div>


</p>




<a name="package_declarations-3-3"></a>
<div class="section" title="Using Classpath URIs to Import Existing EPackages">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Using Classpath URIs to Import Existing EPackages
</h5>
</div>
</div>
</div>



<p>
We like to leverage Java&apos;s classpath mechanism, because besides that it is well understood and designed it allows us to
package libraries as jars. If you want to reference an *.ecore file which is contained in a jar, you can make use of the 
classpath scheme we&apos;ve introduced. For instance if you want to reference Java elements, you can use the JvmType Ecore model 
which is shipped as part of Xtext. 
</p>

<p>
Example:
</p>

<p>
<span class="inlinecode"><span class="keyword">import</span>&nbsp;&apos;classpath:/model/JvmTypes.ecore&apos;&nbsp;<span class="keyword">as</span>&nbsp;types</span>

</p>

<p>
As with platform resource URIs you&apos;ll also have to tell the generator where the corresponding *.genmodel can be found:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
fragment&nbsp;=&nbsp;org.eclipse.xtext.generator.ecore.EcoreGeneratorFragment&nbsp;{<br />&nbsp;&nbsp;genModels&nbsp;=<br />&nbsp;&nbsp;&nbsp;&nbsp;&quot;classpath:/model/JvmTypes.genmodel&quot;<br />}<br />
</p>
</div>
</div>


</p>

<p>
See the section on 
<a href="199-jvmtypes.xdoc.html#jvmtypes">Referring Java Types</a> for a full explanation of this useful feature.
</p>




<a name="package_declarations-3-4"></a>
<div class="section" title="Using Namespace URIs to Import Existing EPackages">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Using Namespace URIs to Import Existing EPackages
</h5>
</div>
</div>
</div>



<p>
You can also use nsURI in order to import existing <em>EPackage</em>. Note that this is generally not
preferrable, because you&apos;ll have to have the corresponding EPackage installed in the workbench.
There&apos;s mainly just one exception, that is Ecore itself. So if you refer to Ecore it is best
to use its nsURI :
</p>

<p>
<span class="inlinecode"><span class="keyword">import</span>&nbsp;&quot;http://www.eclipse.org/emf/2002/Ecore&quot;&nbsp;<span class="keyword">as</span>&nbsp;ecore</span>

</p>


</div>



<a name="package_declarations-4"></a>
<div class="section" title="Ecore Model Aliases for EPackages">
<div class="titlepage">
<div>
<div>
<h4 class="title">
Ecore Model Aliases for EPackages
</h4>
</div>
</div>
</div>



<p>
If you want to use multiple <em>EPackages</em> you need to specify aliases in the following way:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">generate</span>&nbsp;secretcompartment&nbsp;&apos;http://www.eclipse.org/secretcompartment&apos;<br /><span class="keyword">import</span>&nbsp;&apos;http://www.eclipse.org/anotherPackage&apos;&nbsp;<span class="keyword">as</span>&nbsp;another<br />
</p>
</div>
</div>


</p>

<p>
When referring to a type somewhere in the grammar you need to qualify the reference using that 
alias (example <em>another::CoolType</em>). We&apos;ll see later where such type references occur.
</p>

<p>
It is also supported to put multiple <em>EPackage</em> imports into one alias. This is no problem as 
long as there are not any two <em>EClassifiers</em> with the same name. In such cases none of them can be referenced. 
It is even possible to <em>import</em> multiple and <em>generate</em> one Ecore model and all of them are declared for 
the same alias. If you do so, for a reference to an <em>EClassifier</em> first the imported <em>EPackages</em> are 
scanned before it is assumed that a type needs to by generated into the to-be-generated package. 
</p>

<p>
Note, that using this feature is not recommended, because it might cause problems, which are hard to track down.
For instance, a reference to <em>classA</em> would as well be linked to a newly created <em>EClass</em>, because the 
corresponding type in <em>http://www.eclipse.org/packContainingClassA</em> is spelled with a capital letter.
</p>


</div>

</div>



<a name="syntax-4"></a>
<div class="section" title="Rules">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Rules
</h3>
</div>
</div>
</div>



<p>
Basically parsing can be separated in the following phases. 


<ol>

<li>

<p>
lexing
</p>

</li>

<li>

<p>
parsing
</p>

</li>

<li>

<p>
linking
</p>

</li>

<li>

<p>
validation
</p>

</li>

</ol>

</p>




<a name="syntax-4-2"></a>
<div class="section" title="Terminal Rules">
<div class="titlepage">
<div>
<div>
<h4 class="title">
Terminal Rules
</h4>
</div>
</div>
</div>



<p>
In the first stage called <em>lexing</em>, a sequence of characters (the text input) is transformed into a sequence of so 
called tokens. In this context, a token is sort of a strongly typed part of the input sequence. It consists of one 
or more characters and was matched by a particular terminal rule or keyword and therefore represents an atomic symbol.
Terminal rules are also referred to as <em>token rules</em> or <em>lexer rules</em>. There is an informal naming convention that 
names of terminal rules are all upper-case.
</p>

<p>
In the secret compartments example there are no explicitly defined terminal rules, since it only uses the <em>ID</em> rule 
which is inherited from the grammar <em>org.eclipse.xtext.common.Terminals</em> (cf. 
<a href="020-grammar-language.xdoc.html#grammarMixins">Grammar Mixins</a>).
Therein the <em>ID</em> rule is defined as follows:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">terminal</span>&nbsp;ID&nbsp;:&nbsp;<br />&nbsp;&nbsp;(&apos;^&apos;)?(&apos;a&apos;..&apos;z&apos;|&apos;A&apos;..&apos;Z&apos;|&apos;_&apos;)&nbsp;(&apos;a&apos;..&apos;z&apos;|&apos;A&apos;..&apos;Z&apos;|&apos;_&apos;|&apos;0&apos;..&apos;9&apos;)*;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;
</p>
</div>
</div>


</p>

<p>
It says that a token <em>ID</em> starts with an optional <em>&apos;^&apos;</em> character (caret), followed by a letter <em>(&apos;a&apos;..&apos;z&apos;|&apos;A&apos;..&apos;Z&apos;)</em> 
or underscore (&apos;_&apos;) followed by any number of letters, underscores and numbers <em>(&apos;0&apos;..&apos;9&apos;)</em>. 
</p>

<p>
The caret is used to escape an identifier for cases where there are conflicts with keywords. It is removed 
by the <em>ID</em> rule&apos;s 
<a href="090-valueconverter.xdoc.html#valueconverter">ValueConverter</a>. 
</p>

<p>
This is the formal definition of terminal rules:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
TerminalRule&nbsp;:<br />&nbsp;&nbsp;&apos;<span class="keyword">terminal</span>&apos;&nbsp;name=ID&nbsp;(&apos;<span class="keyword">returns</span>&apos;&nbsp;type=TypeRef)?&nbsp;&apos;:&apos;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;alternatives=TerminalAlternatives&nbsp;&apos;;&apos;<br />;<br />
</p>
</div>
</div>


</p>

<p>
Note, that <em>the order of terminal rules is crucial for your grammar</em>, as they may hide each other. 
This is especially important for newly introduced rules in connection with mixed rules from used grammars. 
</p>

<p>
If you for instance want to add a rule to allow fully qualified names in addition to simple IDs, you should 
implement it as a 
<a href="020-grammar-language.xdoc.html#datatypeRules">data type rule</a>, instead of adding another terminal rule.
</p>




<a name="syntax-4-2-10"></a>
<div class="section" title="Return Types">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Return Types
</h5>
</div>
</div>
</div>



<p>
A terminal rule returns a value, which is a string (type <em>ecore::EString</em>) by default.
However, if you want to have a different type you can specify it. For instance, the rule <em>INT</em> is defined as:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">terminal</span>&nbsp;INT&nbsp;<span class="keyword">returns</span>&nbsp;ecore::EInt&nbsp;:&nbsp;<br />&nbsp;&nbsp;(&apos;0&apos;..&apos;9&apos;)+;<br />
</p>
</div>
</div>


</p>

<p>
This means that the terminal rule <em>INT</em> returns instances of <em>ecore::EInt</em>. It is possible to define any 
kind of data type here, which just needs to be an instance of <em>ecore::EDataType</em>. In order to tell the parser 
how to convert the parsed string to a value of the declared data type, you need to provide your own 
implementation of 
<em>org.eclipse.xtext.conversion.IValueConverterService</em>
 (cf. 

<a href="090-valueconverter.xdoc.html#valueconverter">value converters</a>). The value converter is also the point where you can remove things 
like quotes from string literals or the caret (&apos;^&apos;) from identifiers. Its implementation needs to be registered 
as a service (cf. 
<a href="040-dependency-injection.xdoc.html#dependencyInjection">Service Framework</a>).
</p>


</div>



<a name="syntax-4-3"></a>
<div class="section" title="Extended Backus-Naur Form Expressions">
<div class="titlepage">
<div>
<div>
<h4 class="title">
Extended Backus-Naur Form Expressions
</h4>
</div>
</div>
</div>



<p>
Token rules are described using &quot;Extended Backus-Naur Form&quot;-like (EBNF) expressions. The different expressions 
are described in the following. The one thing all of these expressions have in common is the cardinality operator.
There are four different possible cardinalities


<ol>

<li>

<p>
exactly one (the default, no operator)
</p>

</li>

<li>

<p>
one or none (operator <em>?</em>)
</p>

</li>

<li>

<p>
any (zero or more, operator <em>*</em>)
</p>

</li>

<li>

<p>
one or more (operator <em>+</em>)
</p>

</li>

</ol>

</p>


<a name="Keywords"></a>

<a name="Keywords"></a>
<div class="section" title="Keywords / Characters">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Keywords / Characters
</h5>
</div>
</div>
</div>



<p>
Keywords are a kind of token rule literals. 
The <em>ID</em> rule in <em>org.eclipse.xtext.common.Terminals</em> for instance starts with a keyword:
</p>

<p>
<span class="inlinecode"><span class="keyword">terminal</span>&nbsp;ID&nbsp;:&nbsp;&apos;^&apos;?&nbsp;....&nbsp;;</span>

</p>

<p>
The question mark sets the cardinality to &quot;none or one&quot; (i.e. optional) like explained above.
</p>

<p>
Note that a keyword can have any length and contain arbitrary characters. 
</p>

<p>
The following standard Java notations for special characters are allowed: <em>\n</em>, <em>\r</em>,
<em>\t</em>, <em>\b</em>, and <em>\f</em>. We currently don&apos;t support quoted unicode character notation, as <em>\u123</em>.
</p>




<a name="syntax-4-3-3"></a>
<div class="section" title="Character Ranges">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Character Ranges
</h5>
</div>
</div>
</div>



<p>
A character range can be declared using the &apos;..&apos; operator.
</p>

<p>
Example:
</p>

<p>
<span class="inlinecode"><span class="keyword">terminal</span>&nbsp;INT&nbsp;<span class="keyword">returns</span>&nbsp;ecore::EInt:&nbsp;(&apos;0&apos;..&apos;9&apos;)+;</span>

</p>

<p>
In this case an <em>INT</em> is comprised of one or more (note the <em>+</em> operator) characters 
between (and including) <em>&apos;0&apos;</em> and <em>&apos;9&apos;</em>.
</p>




<a name="syntax-4-3-4"></a>
<div class="section" title="Wildcard">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Wildcard
</h5>
</div>
</div>
</div>



<p>
If you want to allow any character you can simple write the wildcard operator &apos;_._&apos; (dot):
Example:
</p>

<p>
<span class="inlinecode">FOO&nbsp;:&nbsp;&apos;f&apos;&nbsp;.&nbsp;&apos;o&apos;;</span>

</p>

<p>
The rule above would allow expressions like &apos;foo&apos;, &apos;f0o&apos; or even &apos;f\no&apos;.
</p>




<a name="syntax-4-3-5"></a>
<div class="section" title="Until Token">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Until Token
</h5>
</div>
</div>
</div>



<p>
With the until token it is possible to state that everything should be consumed until a certain token occurs.
The multi-line comment is implemented this way:
</p>

<p>
<span class="inlinecode"><span class="keyword">terminal</span>&nbsp;ML_COMMENT&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&apos;/*&apos;&nbsp;-&gt;&nbsp;&apos;*/&apos;;</span>

</p>

<p>
This is the rule for Java-style comments that begin with &apos;_/*_&apos; and end with &apos;_*/_&apos;.
</p>




<a name="syntax-4-3-6"></a>
<div class="section" title="Negated Token">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Negated Token
</h5>
</div>
</div>
</div>



<p>
All the tokens explained above can be inverted using a preceding exclamation mark:
</p>

<p>
<span class="inlinecode"><span class="keyword">terminal</span>&nbsp;BETWEEN_HASHES&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&apos;#&apos;&nbsp;(!&apos;#&apos;)*&nbsp;&apos;#&apos;;</span>

</p>




<a name="syntax-4-3-7"></a>
<div class="section" title="Rule Calls">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Rule Calls
</h5>
</div>
</div>
</div>



<p>
Rules can refer to other rules. This is done by writing the name of the rule to be called.
We refer to this as rule calls. Rule calls in terminal rules can only point to terminal rules.
</p>

<p>
Example:
</p>

<p>
<span class="inlinecode"><span class="keyword">terminal</span>&nbsp;DOUBLE&nbsp;:&nbsp;INT&nbsp;&apos;.&apos;&nbsp;INT;</span>

</p>


<a name="Alternatives"></a>

<a name="Alternatives"></a>
<div class="section" title="Alternatives">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Alternatives
</h5>
</div>
</div>
</div>



<p>
Using alternatives one can state multiple different alternatives.
For instance, the whitespace rule uses alternatives like this:
</p>

<p>
<span class="inlinecode"><span class="keyword">terminal</span>&nbsp;WS&nbsp;:&nbsp;(&apos;&nbsp;&apos;|&apos;\t&apos;|&apos;\r&apos;|&apos;\n&apos;)+;</span>

</p>

<p>
That is a WS can be made of one or more whitespace characters (including &apos; &apos;, &apos;_\t_&apos;, &apos;_\r_&apos;, &apos;_\n_&apos;).
</p>




<a name="syntax-4-3-9"></a>
<div class="section" title="Groups">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Groups
</h5>
</div>
</div>
</div>



<p>
Finally, if you put tokens one after another, the whole sequence is referred to as a group.
Example:
</p>

<p>
<span class="inlinecode"><span class="keyword">terminal</span>&nbsp;ASCII&nbsp;:&nbsp;&apos;0x&apos;&nbsp;(&apos;0&apos;..&apos;7&apos;)&nbsp;(&apos;0&apos;..&apos;9&apos;|&apos;A&apos;..&apos;F&apos;);</span>

</p>

<p>
That is the 2-digit hexadecimal code of ASCII characters.
</p>


</div>

</div>

<a name="parser_rules"></a>

<a name="parser_rules"></a>
<div class="section" title="Parser Rules">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Parser Rules
</h3>
</div>
</div>
</div>



<p>
The parser reads a sequence of terminals and walks through the parser rules. Hence a parser rule - 
contrary to a terminal rule - does not produce a single terminal token but a tree of non-terminal 
and terminal tokens. They lead to a so called 
<a href="016-working-with-Xtext-models.xdoc.html#node_model">parse tree</a> (in Xtext it is also referred 
as node model). Furthermore, parser rules are handled as kind of a building plan for the creation of 
the <em>EObjects</em> that form the semantic model (the linked abstract syntax graph or AST). Due to this 
fact, parser rules are even called production rules. The different constructs like actions and 
assignments are used to derive types and initialize the semantic objects accordingly. 
</p>




<a name="parser_rules-2"></a>
<div class="section" title="Extended Backus-Naur Form Expressions">
<div class="titlepage">
<div>
<div>
<h4 class="title">
Extended Backus-Naur Form Expressions
</h4>
</div>
</div>
</div>



<p>
Not all the expressions that are available in terminal rules can be used in parser rules. Character 
ranges, wildcards, the until token and the negation are only available for terminal rules. 
</p>

<p>
The elements that are available in parser rules as well as in terminal rules are


<ol>

<li>

<p>
groups, 
</p>

</li>

<li>

<p>

<a href="020-grammar-language.xdoc.html#Alternatives">alternatives</a>, 
</p>

</li>

<li>

<p>

<a href="020-grammar-language.xdoc.html#Keywords">keywords</a> and 
</p>

</li>

<li>

<p>
rule calls.
</p>

</li>

</ol>

</p>

<p>
In addition to these elements, there are some expressions used to direct how the AST 
is constructed, which are listed and explained in the following.
</p>


<a name="assignments"></a>

<a name="assignments"></a>
<div class="section" title="Assignments">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Assignments
</h5>
</div>
</div>
</div>



<p>
Assignments are used to assign the parsed information to a feature of the current object. 
The type of the current object, its <em>EClass</em>, is specified by the return type of the parser 
rule. If it is not explicitly stated it is implied that the type&apos;s name equals the rule&apos;s name. 
The type of the feature is inferred from the right hand side of the assignment.
</p>

<p>
Example:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
State&nbsp;:<br />&nbsp;&nbsp;&apos;state&apos;&nbsp;name=ID<br />&nbsp;&nbsp;&nbsp;&nbsp;(&apos;actions&apos;&nbsp;&apos;{&apos;&nbsp;(actions+=[Command])+&nbsp;&apos;}&apos;)?<br />&nbsp;&nbsp;&nbsp;&nbsp;(transitions+=Transition)*<br />&nbsp;&nbsp;&apos;end&apos;<br />;<br />
</p>
</div>
</div>


</p>

<p>
The syntactic declaration for states in the state machine example starts with a keyword <em>state</em> followed by an assignment:
</p>

<p>
<span class="inlinecode">name=ID</span>

</p>

<p>
The left hand side refers to a feature &apos;_name_&apos; of the current object (which has the <em>EClass</em> &apos;_State_&apos; in this case). 
The right hand side can be a rule call, a keyword, a cross-reference (explained later) or even an 
alternative comprised by the former. The type of the feature needs to be compatible with the type of the
 expression on the right. As <em>ID</em> returns an <em>EString</em> in this case, the feature &apos;_name_&apos; needs to be 
 of type <em>EString</em> as well.
</p>

<p>
<em>Assignment Operators</em>
</p>

<p>
There are three different assignment operators, each with different semantics.
</p>

<p>


<ol>

<li>

<p>
The simple equal sign &apos;_=_&apos; is the straight forward assignment, and used for features which take only one element.
</p>

</li>

<li>

<p>
The &apos;_+=_&apos; sign (the add operator) expects a multi-valued feature and adds the value on the right hand to that feature, which is a list feature.
</p>

</li>

<li>

<p>
The &apos;_?=_&apos; sign (boolean assignment operator) expects a feature of type <em>EBoolean</em> and sets it to true if the right hand side was consumed independently from the concrete value of the right hand side.
</p>

</li>

</ol>

</p>

<p>
The used assignment operator does not effect the cardinality of the expected symbols on the right hand side. 
</p>




<a name="parser_rules-2-5"></a>
<div class="section" title="Cross-References">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Cross-References
</h5>
</div>
</div>
</div>



<p>
A unique feature of Xtext is the ability to declare crosslinks in the grammar. In traditional compiler 
construction the crosslinks are not established during parsing but in a later linking phase. This is the 
same in Xtext, but we allow to specify crosslink information in the grammar. This information is used by the linker.
The syntax for crosslinks is:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
CrossReference&nbsp;:<br />&nbsp;&nbsp;&apos;[&apos;&nbsp;type=TypeRef&nbsp;(&apos;|&apos;&nbsp;^<span class="keyword">terminal</span>=CrossReferenceableTerminal&nbsp;)?&nbsp;&apos;]&apos;<br />;<br />
</p>
</div>
</div>


</p>

<p>
For example, the transition is made up of two cross-references, pointing to an event and a state:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Transition&nbsp;:<br />&nbsp;&nbsp;event=[Event]&nbsp;&apos;=&gt;&apos;&nbsp;state=[State]<br />;<br />
</p>
</div>
</div>


</p>

<p>
It is important to understand that the text between the square brackets does not refer to another rule, but to a type!
This is sometimes confusing, because one usually uses the same name for the rules and the returned types.
That is if we had named the type for events differently like in the following the cross-reference needs 
to be adapted as well:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Transition&nbsp;:<br />&nbsp;&nbsp;event=[MyEvent]&nbsp;&apos;=&gt;&apos;&nbsp;state=[State]<br />;<br />&nbsp;<br />Event&nbsp;<span class="keyword">returns</span>&nbsp;MyEvent&nbsp;:&nbsp;....;<br />
</p>
</div>
</div>


</p>

<p>
Looking at the syntax definition of cross-references, there is an optional part starting with a vertical 
bar (pipe) followed by <em>CrossReferenceableTerminal</em>. This is the part describing the concrete text, from 
which the crosslink later should be established. If the terminal is omitted, it is expected to be <em>ID</em>.
</p>

<p>
You may even use alternatives as the referencable terminal. This way, either an <em>ID</em> or a <em>STRING</em> may be 
used as the referencable terminal, as it is possible in many SQL dialects.
</p>

<p>
<span class="inlinecode">TableRef:&nbsp;table=[Table|(ID|STRING)];</span>

</p>

<p>
Have a look at the 
<a href="070-linking.xdoc.html#linking">linking section</a> in order to understand how linking is done.
</p>


<a name="unordered_groups"></a>

<a name="unordered_groups"></a>
<div class="section" title="Unordered Groups">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Unordered Groups
</h5>
</div>
</div>
</div>



<p>
The elements of an unordered group can occur in any order but each element must appear once. Unordered 
groups are separated with &apos;_&amp;_&apos;, e.g.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Modifier:&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;static?=&apos;static&apos;?&nbsp;&amp;&nbsp;final?=&apos;final&apos;?&nbsp;&amp;&nbsp;visibility=Visibility;<br /><br /><span class="keyword">enum</span>&nbsp;Visibility:<br />&nbsp;&nbsp;&nbsp;&nbsp;PUBLIC=&apos;public&apos;&nbsp;|&nbsp;PRIVATE=&apos;private&apos;&nbsp;|&nbsp;PROTECTED=&apos;protected&apos;;<br />&nbsp;&nbsp;&nbsp;&nbsp;
</p>
</div>
</div>


</p>

<p>
allows
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">final</span><br /><span class="keyword">static</span>&nbsp;<span class="keyword">protected</span>&nbsp;<br /><span class="keyword">final</span>&nbsp;<span class="keyword">private</span>&nbsp;<span class="keyword">static</span><br /><span class="keyword">public</span><br />
</p>
</div>
</div>


</p>

<p>
but not
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">static</span>&nbsp;<span class="keyword">final</span>&nbsp;<span class="keyword">static</span>&nbsp;//&nbsp;ERROR:&nbsp;<span class="keyword">static</span>&nbsp;appears&nbsp;twice<br /><span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">final</span>&nbsp;<span class="keyword">private</span>&nbsp;//&nbsp;ERROR:&nbsp;visibility&nbsp;appears&nbsp;twice<br /><span class="keyword">final</span>&nbsp;//&nbsp;ERROR:&nbsp;visibility&nbsp;is&nbsp;missing<br />
</p>
</div>
</div>


</p>

<p>
Note that if you want an element of an unordered group to appear once or not at all, 
you have to choose a cardinality of &apos;_?_&apos;. In the example, the visibility is mandatory, 
while &apos;_static_&apos; or &apos;_final_&apos; are optional. Elements with a cardinality of &apos;_*_&apos; or &apos;_+_&apos;
have to appear continuously without interruption, i.e.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Rule:<br />&nbsp;&nbsp;&nbsp;&nbsp;values+=INT*&nbsp;&amp;&nbsp;name=ID;<br />
</p>
</div>
</div>


</p>

<p>
will parse
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
0&nbsp;8&nbsp;15&nbsp;x<br />x&nbsp;0&nbsp;8&nbsp;15&nbsp;<br />
</p>
</div>
</div>


</p>

<p>
but not 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
0&nbsp;x&nbsp;8&nbsp;15&nbsp;//&nbsp;wrong,&nbsp;as&nbsp;values&nbsp;cannot&nbsp;be&nbsp;interrupted.<br />
</p>
</div>
</div>


</p>




<a name="parser_rules-2-7"></a>
<div class="section" title="Simple Actions">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Simple Actions
</h5>
</div>
</div>
</div>



<p>
By default the object to be returned by a parser rule is created lazily on the first assignment. Then the type of the <em>EObject</em> to be created is determined from the specified return type or the rule name if no explicit return type is specified.
With Actions however, the creation of returned <em>EObject</em> can be made explicit. Xtext supports two kinds of Actions:


<ol>

<li>

<p>
simple actions, and
</p>

</li>

<li>

<p>
assigned actions.
</p>

</li>

</ol>

</p>

<p>
If at some point you want to enforce the creation of a specific type you can use alternatives or simple actions.
In the following example <em>TypeB</em> must be a subtype of <em>TypeA</em>. An expression <em>A ident</em> should create an instance of 
<em>TypeA</em>, whereas <em>B ident</em> should instantiate <em>TypeB</em>.
</p>

<p>
Example with alternatives:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
MyRule&nbsp;<span class="keyword">returns</span>&nbsp;TypeA&nbsp;:<br />&nbsp;&nbsp;&quot;A&quot;&nbsp;name=ID&nbsp;|<br />&nbsp;&nbsp;MyOtherRule<br />;&nbsp;<br />&nbsp;<br />MyOtherRule&nbsp;<span class="keyword">returns</span>&nbsp;TypeB&nbsp;:<br />&nbsp;&nbsp;&quot;B&quot;&nbsp;name&nbsp;=&nbsp;ID<br />;<br />
</p>
</div>
</div>


</p>

<p>
Example with simple actions:  
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
MyRule&nbsp;<span class="keyword">returns</span>&nbsp;TypeA&nbsp;:<br />&nbsp;&nbsp;&quot;A&quot;&nbsp;name=ID&nbsp;|<br />&nbsp;&nbsp;&quot;B&quot;&nbsp;{TypeB}&nbsp;name=ID<br />;&nbsp;<br />
</p>
</div>
</div>


</p>

<p>
Generally speaking, the instance is created as soon as the parser hits the first assignment. However, actions 
allow to explicitly instantiate any <em>EObject</em>. The notation <em>{TypeB}</em> will create an instance of TypeB and assign 
it to the result of the parser rule. This allows parser rules without any assignment and object creation without 
the need to introduce unnecessary rules.
</p>




<a name="parser_rules-2-8"></a>
<div class="section" title="Unassigned Rule Calls">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Unassigned Rule Calls
</h5>
</div>
</div>
</div>



<p>
We previously explained, that the <em>EObject</em> to be returned is created lazily when the first assignment occurs or 
when a simple action is evaluated. There is another way one can set the <em>EObject</em> to be returned, which we call 
an &quot;unassigned rule call&quot;.
</p>

<p>
Unassigned rule calls (the name suggests it) are rule calls to other parser rules, which are not used within an 
assignment. If there is no feature the returned value shall be assigned to, the value is assigned to the 
&quot;to-be-returned&quot; result of the calling rule.
</p>

<p>
With unassigned rule calls one can, for instance, create rules which just dispatch between several other rules:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
AbstractToken&nbsp;:<br />&nbsp;&nbsp;TokenA&nbsp;|<br />&nbsp;&nbsp;TokenB&nbsp;|<br />&nbsp;&nbsp;TokenC<br />;<br />
</p>
</div>
</div>


</p>

<p>
As <em>AbstractToken</em> could possibly return an instance of <em>TokenA</em>, <em>TokenB</em> or <em>TokenC</em> its type must by a 
super type of these types. It is now for instance as well possible to further change the state of the AST 
element by assigning additional things.
</p>

<p>
Example:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
AbstractToken&nbsp;:<br />&nbsp;&nbsp;(&nbsp;TokenA&nbsp;|<br />&nbsp;&nbsp;&nbsp;&nbsp;TokenB&nbsp;|<br />&nbsp;&nbsp;&nbsp;&nbsp;TokenC&nbsp;)&nbsp;(cardinality=(&apos;?&apos;|&apos;+&apos;|&apos;*&apos;))?<br />;<br />
</p>
</div>
</div>


</p>

<p>
This way the <em>cardinality</em> is optional (last question mark) and can be represented 
by a question mark, a plus, or an asterisk. It will be assigned to either an 
<em>EObject</em> of type <em>TokenA</em>,  <em>TokenB</em>, or <em>TokenC</em> which are all subtypes of 
<em>AbstractToken</em>. The rule in this example will never create an instance of <em>AbstractToken</em> directly 
as long as the preceeding <em>TokenX</em> rule call returns an element. 
</p>


<a name="grammarActions"></a>

<a name="grammarActions"></a>
<div class="section" title="Assigned Actions">
<div class="titlepage">
<div>
<div>
<h5 class="title">
Assigned Actions
</h5>
</div>
</div>
</div>



<p>
LL-parsing has some significant advantages over LR algorithms. The most important ones for Xtext are, that the generated code is much simpler to understand and debug and that it is easier to recover from errors. Especially ANTLR has a very nice generic error recovery mechanism. This allows to construct an AST even if there are syntactic errors in the text. You wouldn&apos;t get any of the nice IDE features as soon as there is one little error, if we hadn&apos;t error recovery.
</p>

<p>
However, LL also has some drawbacks. The most important one is that it does not allow left recursive grammars.
For instance, the following is not allowed in LL-based grammars, because <em>Expression &apos;+&apos; Expression</em> is left recursive:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Expression&nbsp;:<br />&nbsp;&nbsp;Expression&nbsp;&apos;+&apos;&nbsp;Expression&nbsp;|<br />&nbsp;&nbsp;&apos;(&apos;&nbsp;Expression&nbsp;&apos;)&apos;&nbsp;|<br />&nbsp;&nbsp;INT<br />;<br />
</p>
</div>
</div>


</p>

<p>
Instead one has to rewrite such things by &quot;left-factoring&quot; it:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Expression&nbsp;:<br />&nbsp;&nbsp;TerminalExpression&nbsp;(&apos;+&apos;&nbsp;TerminalExpression)?<br />;<br />&nbsp;<br />TerminalExpression&nbsp;:<br />&nbsp;&nbsp;&apos;(&apos;&nbsp;Expression&nbsp;&apos;)&apos;&nbsp;|<br />&nbsp;&nbsp;INT<br />;<br />
</p>
</div>
</div>


</p>

<p>
In practice this is always the same pattern and therefore not that problematic. 
However, by simply applying the Xtext AST construction features we&apos;ve covered so far, a grammar ...
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Expression&nbsp;:<br />&nbsp;&nbsp;{Operation}&nbsp;left=TerminalExpression&nbsp;(op=&apos;+&apos;&nbsp;right=TerminalExpression)?<br />;<br />&nbsp;<br />TerminalExpression&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br />&nbsp;&nbsp;&apos;(&apos;&nbsp;Expression&nbsp;&apos;)&apos;&nbsp;|<br />&nbsp;&nbsp;{IntLiteral}&nbsp;value=INT<br />;<br />
</p>
</div>
</div>


</p>

<p>
... would result in unwanted elements in the AST.
For instance the expression <em>(42)</em> would result in a tree like this:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Operation&nbsp;{<br />&nbsp;&nbsp;left=Operation&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;left=IntLiteral&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value=42<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;}<br />}<br />
</p>
</div>
</div>


</p>

<p>
Typically one would only want to have one instance of <em>IntLiteral</em> instead.
</p>

<p>
One can solve this problem using a combination of unassigned rule calls and assigned actions:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Expression&nbsp;:<br />&nbsp;&nbsp;TerminalExpression&nbsp;({Operation.left=current}&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;op=&apos;+&apos;&nbsp;right=Expression)?<br />;<br />&nbsp;<br />TerminalExpression&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br />&nbsp;&nbsp;&apos;(&apos;&nbsp;Expression&nbsp;&apos;)&apos;&nbsp;|<br />&nbsp;&nbsp;{IntLiteral}&nbsp;value=INT<br />;<br />
</p>
</div>
</div>


</p>

<p>
In the example above <em>{Operation.left=current}</em> is a so called tree rewrite action, which creates a new instance of the stated <em>EClass</em> (_Operation_ in this case) and assigns the element currently to-be-returned (_current_ variable) to a feature of the newly created object (in this case feature <em>left</em> of the <em>Operation</em> instance).
In Java these semantics could be expressed as:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Operation&nbsp;temp&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;Operation();<br />temp.setLeft(current);<br />current&nbsp;=&nbsp;temp;<br />
</p>
</div>
</div>


</p>


</div>

</div>

<a name="hidden_terminals"></a>

<a name="hidden_terminals"></a>
<div class="section" title="Hidden Terminal Symbols">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Hidden Terminal Symbols
</h3>
</div>
</div>
</div>



<p>
Because parser rules describe not a single token, but a sequence of patterns in the input, it is necessary to define the interesting parts of the input. Xtext introduces the concept of hidden tokens to handle semantically unimportant things like whitespaces, comments, etc. in the input sequence gracefully. It is possible to define a set of terminal symbols, that are hidden from the parser rules and automatically skipped when they are recognized. Nevertheless, they are transparently woven into the node model, but not relevant for the semantic model. 
</p>

<p>
Hidden terminals may (or may not) appear between any other terminals in any cardinality. They can be described per rule or for the whole grammar. When 
<a href="020-grammar-language.xdoc.html#grammarMixins">reusing a single grammar</a> its definition of hidden tokens is reused as well. The grammar <em>org.eclipse.xtext.common.Terminals</em> comes with a reasonable default and hides all comments and whitespace from the parser rules.
</p>

<p>
If a rule defines hidden symbols, you can think of a kind of scope that is automatically introduced. Any rule that is called from the declaring rule uses the same hidden terminals as the calling rule, unless it defines other hidden tokens itself.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
Person&nbsp;<span class="keyword">hidden</span>(WS,&nbsp;ML_COMMENT,&nbsp;SL_COMMENT):&nbsp;<br />&nbsp;&nbsp;name=Fullname&nbsp;age=INT&nbsp;&apos;;&apos;<br />;<br /><br />Fullname:&nbsp;<br />&nbsp;&nbsp;(firstname=ID)?&nbsp;lastname=ID<br />;<br />
</p>
</div>
</div>


</p>

<p>
The sample rule &quot;Person&quot; defines multiline comments (_ML_COMMENT_), single-line comments (_SL_COMMENT_), and whitespace (_WS_) to be allowed between the <em>Fullname</em> and the <em>age</em>. Because the rule <em>Fullname</em> does not introduce another set of hidden terminals, it allows the same symbols to appear between <em>firstname</em> and <em>lastname</em> as the calling rule <em>Person</em>. Thus, the following input is perfectly valid for the given grammar snippet:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
John&nbsp;/*&nbsp;comment&nbsp;*/&nbsp;Smith&nbsp;//&nbsp;line&nbsp;comment<br />/*&nbsp;comment&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;&nbsp;//&nbsp;line&nbsp;comment<br />
</p>
</div>
</div>


</p>

<p>
A list of all default terminals like <em>WS</em> can be found in section 
<a href="020-grammar-language.xdoc.html#grammarMixins">Grammar Mixins</a>.
</p>


</div>

<a name="datatypeRules"></a>

<a name="datatypeRules"></a>
<div class="section" title="Data Type Rules">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Data Type Rules
</h3>
</div>
</div>
</div>



<p>
Data type rules are parsing-phase rules, which create instances of <em>EDataType</em> instead of <em>EClass</em>. Thinking about it, one may discover that they are quite similar to terminal rules.
However, the nice thing about data type rules is that they are actually parser rules and are therefore 
</p>

<p>


<ol>

<li>

<p>
context sensitive and 
</p>

</li>

<li>

<p>
allow for use of hidden tokens.
</p>

</li>

</ol>

</p>

<p>
If you, for instance, want to define a rule to consume Java-like qualified names (e.g. &quot;foo.bar.Baz&quot;)
you could write:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
QualifiedName&nbsp;:<br />&nbsp;&nbsp;ID&nbsp;(&apos;.&apos;&nbsp;ID)*<br />;<br />
</p>
</div>
</div>


</p>

<p>
In contrast to a terminal rule this is only valid in certain contexts, i.e. it won&apos;t conflict with the rule <em>ID</em>.
If you had defined it as a terminal rule, it would possibly hide the <em>ID</em> rule.
</p>

<p>
In addition when this has been defined as a data type rule, it is allowed to use hidden tokens (e.g. &quot;/* comment <em></em>/&quot;) between the IDs and dots (e.g. <em>foo/* comment */. bar . Baz</em>).
</p>

<p>
Return types can be specified in the same way as in terminal rules:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
QualifiedName&nbsp;<span class="keyword">returns</span>&nbsp;ecore::EString&nbsp;:&nbsp;<br />&nbsp;&nbsp;ID&nbsp;(&apos;.&apos;&nbsp;ID)*<br />;<br />
</p>
</div>
</div>


</p>

<p>
Note that if a rule does not call another parser rule and does neither contain any actions nor 
<a href="020-grammar-language.xdoc.html#assignments">assignments</a>, it is considered to be a data type rule and the data type <em>EString</em> is implied if none has been explicitly declared. You have to import Ecore with the alias <em>ecore</em> in this case.
</p>

<p>
For conversion again value converters are responsible (cf. 
<a href="090-valueconverter.xdoc.html#valueconverter">value converters</a>).
</p>


</div>



<a name="syntax-8"></a>
<div class="section" title="Enum Rules">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Enum Rules
</h3>
</div>
</div>
</div>



<p>
Enum rules return enumeration literals from strings. They can be seen as a shortcut for data type rules with specific value converters.
The main advantage of enum rules is their simplicity, type safety and therefore nice validation. Furthermore it is possible to infer enums and their respective literals during the Ecore model transformation.
</p>

<p>
If you want to define a <em>ChangeKind</em> <a href="http://help.eclipse.org/stable/index.jsp?topic=/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/change/impl/package-summary.html">org.eclipse.emf.ecore.change/model/Change.ecore</a> with <em>ADD</em>, <em>MOVE</em> and <em>REMOVE</em> you could write:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">enum</span>&nbsp;ChangeKind&nbsp;:<br />&nbsp;&nbsp;ADD&nbsp;|&nbsp;MOVE&nbsp;|&nbsp;REMOVE<br />;<br />
</p>
</div>
</div>


</p>

<p>
It is even possible to use alternative literals for your enums or reference an enum value twice:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">enum</span>&nbsp;ChangeKind&nbsp;:<br />&nbsp;&nbsp;ADD&nbsp;=&nbsp;&apos;add&apos;&nbsp;|&nbsp;ADD&nbsp;=&nbsp;&apos;+&apos;&nbsp;|&nbsp;<br />&nbsp;&nbsp;MOVE&nbsp;=&nbsp;&apos;move&apos;&nbsp;|&nbsp;MOVE&nbsp;=&nbsp;&apos;-&gt;&apos;&nbsp;|&nbsp;<br />&nbsp;&nbsp;REMOVE&nbsp;=&nbsp;&apos;remove&apos;&nbsp;|&nbsp;REMOVE&nbsp;=&nbsp;&apos;-&apos;<br />;<br />
</p>
</div>
</div>


</p>

<p>
Please note, that Ecore does not support unset values for enums. If you formulate a grammar like
</p>

<p>
<span class="inlinecode">Element:&nbsp;&quot;element&quot;&nbsp;name=ID&nbsp;(value=SomeEnum)?;</span>

</p>

<p>
with the input of
</p>

<p>
<span class="inlinecode">element&nbsp;Foo</span>

</p>

<p>
the resulting value of the element <em>Foo</em> will hold the enum value with the internal representation of &apos;0&apos; (zero). When generating the <em>EPackage</em> from your grammar this will be the first literal you define. As a workaround you could introduce a dedicated none-value or order the enums accordingly. Note that it is not possible to define an enum literal with an empty textual representation.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">enum</span>&nbsp;Visibility:&nbsp;<br />&nbsp;&nbsp;package&nbsp;|&nbsp;private&nbsp;|&nbsp;protected&nbsp;|&nbsp;public<br />;<br />&nbsp;
</p>
</div>
</div>


</p>

<p>
You can overcome this by modifying the infered Ecore model through a 
<a href="020-grammar-language.xdoc.html#customPostProcessing">model to model transformation</a>.
</p>


</div>

</div>

<a name="metamodelInference"></a>

<a name="metamodelInference"></a>
<div class="section" title="Ecore Model Inference">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Ecore Model Inference
</h2>
</div>
</div>
</div>



<p>
The Ecore model (or meta model) of a textual language describes the structure of its abstract syntax trees (AST). 
</p>

<p>
Xtext uses Ecore&apos;s <em>EPackages</em> to define Ecore models. Ecore models are declared to be either inferred (generated) from the grammar or imported. 
By using the <em>generate</em> directive, one tells Xtext to derive an <em>EPackage</em> from the grammar. 
</p>




<a name="metamodelInference-3"></a>
<div class="section" title="Type and Package Generation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Type and Package Generation
</h3>
</div>
</div>
</div>



<p>
Xtext creates
</p>

<p>


<ul>

<li>

<p>
an <em>EPackage</em>
</p>

</li>

<li>

<p>
for each generate-package declaration. After the directive <em>generate</em> a list of parameters follows. The <em>name</em> of the <em>EPackage</em> will be set to the first parameter, its <em>nsURI</em> to the second parameter. An optional alias as the third parameter allows to distinguish generated <em>EPackages</em> later. Only one generated package declaration per alias is allowed.
</p>

</li>

<li>

<p>
an <em>EClass</em>
</p>

</li>

<li>

<p>
for each return type of a parser rule. If a parser rule does not define a return type, an implicit one with the same name as the rule itself is assumed. You can specify more than one rule that return the same type but only one <em>EClass</em> will be generated.
</p>

</li>

<li>

<p>
for each type defined in an action or a cross-reference.
</p>

</li>

<li>

<p>
an <em>EEnum</em>
</p>

</li>

<li>

<p>
for each return type of an enum rule.
</p>

</li>

<li>

<p>
an <em>EDataType</em>
</p>

</li>

<li>

<p>
for each return type of a terminal rule or a data type rule.
</p>

</li>

</ul>

</p>

<p>
All <em>EClasses</em>, <em>EEnums</em>, and <em>EDataTypes</em> are added to the <em>EPackage</em> referred to by the alias provided in the type reference they were created from.
</p>


</div>



<a name="metamodelInference-4"></a>
<div class="section" title="Feature and Type Hierarchy Generation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Feature and Type Hierarchy Generation
</h3>
</div>
</div>
</div>



<p>
While walking through the grammar, the algorithm keeps track of a set of the currently possible return types to add features to. 


<ul>

<li>

<p>
Entering a parser rule the set contains only the return type of the rule. 
</p>

</li>

<li>

<p>
Entering a group in an alternative the set is reset to the same state it was in when entering the first group of this alternative. 
</p>

</li>

<li>

<p>
Leaving an alternative the set contains the union of all types at the end of each of its groups.
</p>

</li>

<li>

<p>
After an optional element, the set is reset to the same state it was before entering it. 
</p>

</li>

<li>

<p>
After a mandatory (non-optional) rule call or mandatory action the set contains only the return type of the called rule or action. 
</p>

</li>

<li>

<p>
An optional rule call does not modify the set.
</p>

</li>

<li>

<p>
A rule call is optional, if its cardinality is &apos;_?_&apos; or &apos;_*_&apos;.
</p>

</li>

</ul>

</p>

<p>
While iterating the parser rules Xtext creates


<ul>

<li>

<p>
an <em>EAttribute</em> in each current return type
</p>

</li>

<li>

<p>
of type <em>EBoolean</em> for each feature assignment using the &apos;_?=_&apos; operator. No further <em>EReferences</em> or <em>EAttributes</em> will be generated from this assignment.
</p>

</li>

<li>

<p>
for each assignment with the &apos;_=_&apos; or &apos;_+=_&apos; operator calling a terminal rule. Its type will be the return type of the called rule.
</p>

</li>

<li>

<p>
an <em>EReference</em> in each current return type
</p>

</li>

<li>

<p>
for each assignment with the &apos;_=_&apos; or &apos;_+=_&apos; operator in a parser rule calling a parser rule. The <em>EReference</em>&apos;s type will be the return type of the called parser rule.
</p>

</li>

<li>

<p>
for each assigned action. The reference&apos;s type will be set to the return type of the current calling rule. 
</p>

</li>

</ul>

</p>

<p>
Each <em>EAttribute</em> or <em>EReference</em> takes its name from the assignment or action that caused it. Multiplicities will be 0...1 for assignments with the &apos;_=_&apos; operator and 0...* for assignments with the &apos;_+=_&apos; operator. 
</p>

<p>
Furthermore, each type that is added to the currently possible return types automatically extends the current return type of the parser rule. You can specify additional common super types by means of &quot;artificial&quot; parser rules, that are never called, e.g.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
CommonSuperType:<br />&nbsp;&nbsp;SubTypeA&nbsp;|&nbsp;SubTypeB&nbsp;|&nbsp;SubTypeC;<br />
</p>
</div>
</div>


</p>


</div>



<a name="metamodelInference-5"></a>
<div class="section" title="Enum Literal Generation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Enum Literal Generation
</h3>
</div>
</div>
</div>



<p>
For each alternative defined in an enum rule, the transformer creates an enum literal, when another literal with the same name cannot be found. The <em>literal</em> property of the generated enum literal is set to the right hand side of the declaration. If it is omitted, you will get an enum literal with equal <em>name</em> and <em>literal</em> attributes.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">enum</span>&nbsp;MyGeneratedEnum:<br />&nbsp;&nbsp;NAME&nbsp;=&nbsp;&apos;literal&apos;&nbsp;|&nbsp;EQUAL_NAME_AND_LITERAL;<br />
</p>
</div>
</div>


</p>


</div>



<a name="metamodelInference-6"></a>
<div class="section" title="Feature Normalization">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Feature Normalization
</h3>
</div>
</div>
</div>



<p>
In the next step the generator examines all generated <em>EClasses</em> and lifts up similar features to super types if there is more than one subtype and the feature is defined in every subtypes. This does even work for multiple super types.
</p>


</div>

<a name="customPostProcessing"></a>

<a name="customPostProcessing"></a>
<div class="section" title="Customized Post Processing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Customized Post Processing
</h3>
</div>
</div>
</div>



<p>
As a last step, the generator invokes the post processor for every generated Ecore model. The post processor expects an Xtend file with name <em>MyDslPostProcessor.ext</em> (if the name of the grammar file is <em>MyDsl.xtext</em>) in the same folder as the grammar file. Further, for a successful invocation, the Xtend file must declare an extension with signature <em>process(xtext::GeneratedMetamodel)</em>. E.g.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
process(xtext::GeneratedMetamodel&nbsp;<span class="keyword">this</span>)&nbsp;:<br />&nbsp;&nbsp;process(ePackage)<br />;<br />&nbsp;<br />process(ecore::EPackage&nbsp;<span class="keyword">this</span>)&nbsp;:<br />&nbsp;&nbsp;...&nbsp;do&nbsp;something<br />;<br />
</p>
</div>
</div>


</p>

<p>
The invoked extension can then augment the generated Ecore model in place. Some typical use cases are to:


<ul>

<li>

<p>
set default values for attributes,
</p>

</li>

<li>

<p>
add container references as opposites of existing containment references, or
</p>

</li>

<li>

<p>
add operations with implementation using a body annotation.
</p>

</li>

</ul>

</p>

<p>
Great care must be taken to not modify the Ecore model in a way preventing the Xtext parser from working correctly (e.g. removing or renaming model elements).
</p>


</div>



<a name="metamodelInference-8"></a>
<div class="section" title="Error Conditions">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Error Conditions
</h3>
</div>
</div>
</div>



<p>
The following conditions cause an error


<ul>

<li>

<p>
An <em>EAttribute</em> or <em>EReference</em> has two different types or different cardinality.
</p>

</li>

<li>

<p>
There is an <em>EAttribute</em> and an <em>EReference</em> with the same name in the same <em>EClass</em>.
</p>

</li>

<li>

<p>
There is a cycle in the type hierarchy.
</p>

</li>

<li>

<p>
An new <em>EAttribute</em>, <em>EReference</em> or super type is added to an imported type.
</p>

</li>

<li>

<p>
An <em>EClass</em> is added to an imported <em>EPackage</em>.
</p>

</li>

<li>

<p>
An undeclared alias is used. 
</p>

</li>

<li>

<p>
An imported Ecore model cannot be loaded.
</p>

</li>

</ul>

</p>


</div>

</div>

<a name="grammarMixins"></a>

<a name="grammarMixins"></a>
<div class="section" title="Grammar Mixins">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Grammar Mixins
</h2>
</div>
</div>
</div>



<p>
Xtext supports the reuse of existing grammars. Grammars that are created via the Xtext wizard use <em>org.eclipse.xtext.common.Terminals</em> by default which introduces a common set of terminal rules and defines reasonable defaults for hidden terminals.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;org.xtext.example.MyDsl&nbsp;<span class="keyword">with</span>&nbsp;org.eclipse.xtext.common.Terminals<br />&nbsp;<br /><span class="keyword">generate</span>&nbsp;myDsl&nbsp;&apos;http://www.xtext.org/example/MyDsl&apos;<br />&nbsp;<br />...&nbsp;some&nbsp;rules<br />
</p>
</div>
</div>


</p>

<p>
Mixing in another grammar makes the rules defined in that grammar referable. It is also possible to overwrite rules from the used grammar. 
</p>

<p>
Example :
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;my.SuperGrammar<br />...<br />RuleA&nbsp;:&nbsp;&quot;a&quot;&nbsp;stuff=RuleB;<br />RuleB&nbsp;:&nbsp;&quot;{&quot;&nbsp;name=ID&nbsp;&quot;}&quot;;<br /><br /><span class="keyword">grammar</span>&nbsp;my.SubGrammar&nbsp;<span class="keyword">with</span>&nbsp;my.SuperGrammar<br /><br />Model&nbsp;:&nbsp;(ruleAs+=RuleA)*;<br /><br />//&nbsp;overrides&nbsp;my.SuperGrammar.RuleB<br />RuleB&nbsp;:&nbsp;&apos;[&apos;&nbsp;name=ID&nbsp;&apos;]&apos;;<br />
</p>
</div>
</div>


</p>

<p>
Note that declared terminal rules always get a higher priority then imported terminal rules.
</p>


</div>



<a name="grammarLanguage-6"></a>
<div class="section" title="Common Terminals">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Common Terminals
</h2>
</div>
</div>
</div>



<p>
Xtext ships with a default set of predefined, reasonable and often required terminal rules. This grammar is defined as follows:
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
&nbsp;<span class="keyword">grammar</span>&nbsp;org.eclipse.xtext.common.Terminals&nbsp;<br />&nbsp;<span class="keyword">hidden</span>(WS,&nbsp;ML_COMMENT,&nbsp;SL_COMMENT)<br /><span class="keyword">import</span>&nbsp;&quot;http://www.eclipse.org/emf/2002/Ecore&quot;&nbsp;<span class="keyword">as</span>&nbsp;ecore<br /><span class="keyword">terminal</span>&nbsp;ID&nbsp;:&nbsp;<br />&nbsp;&apos;^&apos;?(&apos;a&apos;..&apos;z&apos;|&apos;A&apos;..&apos;Z&apos;|&apos;_&apos;)&nbsp;(&apos;a&apos;..&apos;z&apos;|&apos;A&apos;..&apos;Z&apos;|&apos;_&apos;|&apos;0&apos;..&apos;9&apos;)*&nbsp;;<br /><span class="keyword">terminal</span>&nbsp;INT&nbsp;<span class="keyword">returns</span>&nbsp;ecore::EInt:&nbsp;(&apos;0&apos;..&apos;9&apos;)+&nbsp;;<br /><span class="keyword">terminal</span>&nbsp;STRING&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;<br />&nbsp;&apos;&quot;&apos;&nbsp;(&nbsp;&apos;\\&apos;&nbsp;(&apos;b&apos;|&apos;t&apos;|&apos;n&apos;|&apos;f&apos;|&apos;r&apos;|&apos;&quot;&apos;|&quot;&apos;&quot;|&apos;\\&apos;)&nbsp;|&nbsp;!(&apos;\\&apos;|&apos;&quot;&apos;)&nbsp;)*&nbsp;&apos;&quot;&apos;&nbsp;|<br />&nbsp;&quot;&apos;&quot;&nbsp;(&nbsp;&apos;\\&apos;&nbsp;(&apos;b&apos;|&apos;t&apos;|&apos;n&apos;|&apos;f&apos;|&apos;r&apos;|&apos;&quot;&apos;|&quot;&apos;&quot;|&apos;\\&apos;)&nbsp;|&nbsp;!(&apos;\\&apos;|&quot;&apos;&quot;)&nbsp;)*&nbsp;&quot;&apos;&quot;;&nbsp;<br /><span class="keyword">terminal</span>&nbsp;ML_COMMENT&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&apos;/*&apos;&nbsp;-&gt;&nbsp;&apos;*/&apos;&nbsp;;<br /><span class="keyword">terminal</span>&nbsp;SL_COMMENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;&apos;//&apos;&nbsp;!(&apos;\n&apos;|&apos;\r&apos;)*&nbsp;(&apos;\r&apos;?&nbsp;&apos;\n&apos;)?&nbsp;;<br /><span class="keyword">terminal</span>&nbsp;WS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;(&apos;&nbsp;&apos;|&apos;\t&apos;|&apos;\r&apos;|&apos;\n&apos;)+&nbsp;;<br /><span class="keyword">terminal</span>&nbsp;ANY_OTHER:&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;;
</p>
</div>
</div>


</p>


</div>

</body>
</html>
