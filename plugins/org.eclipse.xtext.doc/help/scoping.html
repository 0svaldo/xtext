<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Scoping</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="RuntimeConcepts.html" title="Runtime Concepts">
<link rel="prev" href="linking.html" title="Linking">
<link rel="next" href="valueconverter.html" title="Value Converter">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Scoping</h1>
<p>An 
				<code class="code">IScopeProvider</code> is responsible for providing an 
				<code class="code">IScope</code> for a given 
				<code class="code">EObject</code> and 
				<code class="code">EReference</code> (declared or inherited by the object&rsquo;s 
				<code class="code">EClass</code>). The returned 
				<code class="code">IScope</code> should contain all target candidates for the given object and cross reference.
			</p>
<div class="literallayout">
<p>
<code class="code">
<br>
public&nbsp;interface&nbsp;IScopeProvider&nbsp;{<br>

<br>
&nbsp;&nbsp;/**<br>
&nbsp;&nbsp;&nbsp;*&nbsp;Returns&nbsp;a&nbsp;scope&nbsp;for&nbsp;the&nbsp;given&nbsp;context.&nbsp;The&nbsp;scope&nbsp;provides&nbsp;access&nbsp;to&nbsp;<br>
&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;compatible&nbsp;visible&nbsp;EObjects&nbsp;for&nbsp;a&nbsp;given&nbsp;reference.<br>
&nbsp;&nbsp;&nbsp;*<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;context&nbsp;the&nbsp;element&nbsp;from&nbsp;which&nbsp;an&nbsp;element&nbsp;shall&nbsp;be&nbsp;referenced<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;reference&nbsp;the&nbsp;reference&nbsp;to&nbsp;be&nbsp;used&nbsp;to&nbsp;filter&nbsp;the&nbsp;elements.<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;{@link&nbsp;IScope}&nbsp;representing&nbsp;the&nbsp;inner&nbsp;most&nbsp;{@link&nbsp;IScope}&nbsp;for&nbsp;<br>
&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;passed&nbsp;context&nbsp;and&nbsp;reference.<br>
&nbsp;&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;public&nbsp;IScope&nbsp;getScope(EObject&nbsp;context,&nbsp;EReference&nbsp;reference);<br>

<br>
&nbsp;&nbsp;/**<br>
&nbsp;&nbsp;&nbsp;*&nbsp;Returns&nbsp;a&nbsp;scope&nbsp;for&nbsp;a&nbsp;given&nbsp;context.&nbsp;The&nbsp;scope&nbsp;contains&nbsp;any&nbsp;visible,&nbsp;<br>
&nbsp;&nbsp;&nbsp;*&nbsp;type-compatible&nbsp;element.<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;context&nbsp;the&nbsp;element&nbsp;from&nbsp;which&nbsp;an&nbsp;element&nbsp;shall&nbsp;be&nbsp;referenced<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;type&nbsp;the&nbsp;(super)type&nbsp;of&nbsp;the&nbsp;elements.<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;{@link&nbsp;IScope}&nbsp;representing&nbsp;the&nbsp;inner&nbsp;most&nbsp;{@link&nbsp;IScope}&nbsp;for<br>
&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;passed&nbsp;context&nbsp;and&nbsp;type.<br>
&nbsp;&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;public&nbsp;IScope&nbsp;getScope(EObject&nbsp;context,&nbsp;EClass&nbsp;type);<br>
}<br>

<br>

</code>
</p>
</div>
<p>An 
				<code class="code">IScope</code> represents an element of a linked list of scopes. That means that a scope can be nested within an outer scope.
				For instance Java has multiple kinds of scopes (object scope, type scope, etc.).
			</p>
<p>For Java one would create the scope hierarchy as commented in the following example:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
//&nbsp;file&nbsp;contents&nbsp;scope<br>
import&nbsp;static&nbsp;my.Constants.STATIC;<br>

<br>
public&nbsp;class&nbsp;ScopeExample&nbsp;{&nbsp;//&nbsp;class&nbsp;body&nbsp;scope<br>
&nbsp;&nbsp;private&nbsp;Object&nbsp;field&nbsp;=&nbsp;STATIC;<br>

<br>
&nbsp;&nbsp;private&nbsp;void&nbsp;method(String&nbsp;param)&nbsp;{&nbsp;//&nbsp;method&nbsp;body&nbsp;scope<br>
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;localVar&nbsp;=&nbsp;"bar";<br>
&nbsp;&nbsp;&nbsp;&nbsp;innerBlock:&nbsp;{&nbsp;//&nbsp;block&nbsp;scope<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;innerScopeVar&nbsp;=&nbsp;"foo";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;field&nbsp;=&nbsp;innerScopeVar;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;scope&nbsp;hierarchy&nbsp;at&nbsp;this&nbsp;point&nbsp;would&nbsp;look&nbsp;like&nbsp;this:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//blockScope{field,innerScopeVar}-&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//methodScope{localVar,param}-&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//classScope{field}-&gt;&nbsp;('field'&nbsp;is&nbsp;overlayed)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//fileScope{STATIC}-&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//classpathScope{'all&nbsp;qualified&nbsp;names&nbsp;of&nbsp;accessible&nbsp;static&nbsp;fields'}&nbsp;-&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//NULLSCOPE{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;field.add(localVar);<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>In fact the class path scope should also reflect the order of class path entries.
				For instance:</p>
<div class="literallayout">
<p>
<code class="code">classpathScope{stuff&nbsp;from&nbsp;bin/}<br>
-&gt;&nbsp;classpathScope{stuff&nbsp;from&nbsp;foo.jar/}<br>
-&gt;&nbsp;...<br>
-&gt;&nbsp;classpathScope{stuff&nbsp;from&nbsp;JRE&nbsp;System&nbsp;Library}<br>
-&gt;&nbsp;NULLSCOPE{}<br>

</code>
</p>
</div>
<p>Please find the motivation behind this and some additional details in 
				<a class="ulink" href="http://blog.efftinge.de/2009/01/xtext-scopes-and-emf-index.html" target="_new">this blog post</a> .
			</p>
<p>The default implementation would produce this hierarchy of scopes for the model from the last example in the 
				<a class="link" href="linking.html#defaultImports" title="Default Imports">previous chapter</a>:
			</p>
<div class="literallayout">
<p>
<code class="code">//file&nbsp;model.dsl<br>
import&nbsp;"model1.dsl";<br>
import&nbsp;"model2.dsl";<br>
&nbsp;<br>
ref&nbsp;Foo;<br>
entity&nbsp;Bar;<br>

<br>

</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">//file&nbsp;model1.dsl&nbsp;<br>
entity&nbsp;Stuff;<br>

<br>

</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">//file&nbsp;model2.dsl<br>
entity&nbsp;Foo;<br>

<br>

</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">Scope&nbsp;(model.dsl)&nbsp;{<br>
&nbsp;&nbsp;parent&nbsp;:&nbsp;Scope&nbsp;(model1.dsl)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;parent&nbsp;:&nbsp;Scope&nbsp;(model2.dsl)&nbsp;{}<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>When enumerating the scope&rsquo;s content, the first, most specialized scope would return 
				<code class="code">Bar</code>, it&rsquo;s parent would provide 
				<code class="code">Stuff</code> and the outermost scope adds 
				<code class="code">Foo</code>. The linker will iterate the scope in that order and abort when it finds a matching 
				<code class="code">ScopedElement</code>. 
			</p>
<div class="section" title="Declarative Scope Provider">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="DeclarativeScopeProvider"></a>Declarative Scope Provider</h3>
</div>
</div>
</div>
<p>As always there is an implementation allowing to specify scoping in a declarative way (extend 
					<code class="code">org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider</code> for this purpose). It looks up methods which have either of the following two signatures:
				</p>
<div class="literallayout">
<p>
<code class="code">IScope&nbsp;scope_&lt;ContextReference&gt;(&lt;ContextType&gt;&nbsp;ctx,&nbsp;EReference&nbsp;ref)<br>

</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">IScope&nbsp;scope_&lt;TypeToReturn&gt;(&lt;ContextType&gt;&nbsp;ctx,&nbsp;EClass&nbsp;type)<br>

</code>
</p>
</div>
<p>The former is used when evaluating the scope for a specific cross reference and here 
					<code class="code">&lt;ContextReference&gt;</code> corresponds to the name of this reference (prefixed with the name of the reference&rsquo;s declaring type and separated by an underscore). The 
					<code class="code">ref</code> parameter represents this cross reference.
				</p>
<p>The latter method signature is used when computing the scope for a given element type and is applicable to all cross references of that type. Here 
					<code class="code">&lt;TypeToReturn&gt;</code> is the name of that type which also corresponds to the 
					<code class="code">type</code> parameter. 
				</p>
<p>So if you for example have a state machine with a  
					<span class="emphasis"><em>Transition</em></span> object owned by its source 
					<span class="emphasis"><em>State</em></span> and you want to compute all reachable states (i.e. potential target states), the corresponding method could be declared as follows (assuming the cross reference is declared by the 
					<span class="emphasis"><em>Transition</em></span> type and is called 
					<span class="emphasis"><em>target</em></span>):
				</p>
<div class="literallayout">
<p>
<code class="code">IScope&nbsp;scope_Transition_target(Transition&nbsp;this,&nbsp;EReference&nbsp;ref)<br>

</code>
</p>
</div>
<p>If such a method does not exist, the implementation will try to find one for the context object&rsquo;s container. Thus in the example this would match a method with the same name but 
					<span class="emphasis"><em>State</em></span> as the type of the first parameter. It will keep on walking the containment hierarchy until a matching method is found. This container delegation allows to reuse the same scope definition for elements in different places of the containment hierarchy. Also it may make the method easier to implement as the elements comprising the scope are quite often owned or referenced by a container of the context object. In the example the 
					<span class="emphasis"><em>State</em></span> objects could for instance be owned by a containing 
					<span class="emphasis"><em>StateMachine</em></span> object.
				</p>
<p>If no method specific to the cross reference in question was found for any of the objects in the containment hierarchy, the implementation will start looking for methods matching the other signature (with the 
					<span class="emphasis"><em>EClass</em></span> parameter). Again it will first attempt matching the context object. Thus in the example the signature first matched would be:
				</p>
<div class="literallayout">
<p>
<code class="code">IScope&nbsp;scope_State(Transition&nbsp;this,&nbsp;EClass&nbsp;type)<br>

</code>
</p>
</div>
<p>If no such method exists, the implementation will again try to find a method matching the context object&rsquo;s container objects. In the case of the state machine example you might want to declare the scope with available states at the state machine level:</p>
<div class="literallayout">
<p>
<code class="code">IScope&nbsp;scope_State(StateMachine&nbsp;this,&nbsp;EClass&nbsp;type)<br>

</code>
</p>
</div>
<p>This scope can now be used for any cross references of type 
					<span class="emphasis"><em>State</em></span> for context objects owned by the state machine.
				</p>
</div>
</body>
</html>
