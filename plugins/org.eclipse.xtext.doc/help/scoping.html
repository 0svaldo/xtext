<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Scoping</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="RuntimeConcepts.html" title="Runtime Concepts">
<link rel="prev" href="linking.html" title="Linking">
<link rel="next" href="valueconverter.html" title="Value Converter">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Scoping</h1>
<p>An 
				<code class="code">IScopeProvider</code> is responsible for providing an 
				<code class="code">IScope</code> for a given context 
				<code class="code">EObject</code> and 
				<code class="code">EReference</code>. The returned 
				<code class="code">IScope</code> should contain all target candidates for the given object and cross reference.
			</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;interface&nbsp;IScopeProvider&nbsp;{<br>

<br>
&nbsp;&nbsp;/**<br>
&nbsp;&nbsp;&nbsp;*&nbsp;Returns&nbsp;a&nbsp;scope&nbsp;for&nbsp;the&nbsp;given&nbsp;context.&nbsp;The&nbsp;scope&nbsp;provides&nbsp;access&nbsp;to&nbsp;<br>
&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;compatible&nbsp;visible&nbsp;EObjects&nbsp;for&nbsp;a&nbsp;given&nbsp;reference.<br>
&nbsp;&nbsp;&nbsp;*<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;context&nbsp;the&nbsp;element&nbsp;from&nbsp;which&nbsp;a&nbsp;scope&nbsp;shall&nbsp;be&nbsp;computed<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;reference&nbsp;the&nbsp;reference&nbsp;to&nbsp;be&nbsp;used&nbsp;to&nbsp;filter&nbsp;the&nbsp;elements.<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;{@link&nbsp;IScope}&nbsp;representing&nbsp;the&nbsp;inner&nbsp;most&nbsp;{@link&nbsp;IScope}&nbsp;for&nbsp;<br>
&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;passed&nbsp;context&nbsp;and&nbsp;reference.<br>
&nbsp;&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;public&nbsp;IScope&nbsp;getScope(EObject&nbsp;context,&nbsp;EReference&nbsp;reference);<br>
&nbsp;&nbsp;<br>
}<br>

<br>

</code>
</p>
</div>
<p>A single 
				<code class="code">IScope</code> represents an element of a linked list of scopes. That means that a scope can be nested within an outer scope.
				For instance Java has multiple kinds of scopes (object scope, type scope, etc.).
			</p>
<p>For Java one would create the scope hierarchy as commented in the following example:</p>
<div class="literallayout">
<p>
<code class="code">//&nbsp;file&nbsp;contents&nbsp;scope<br>
import&nbsp;static&nbsp;my.Constants.STATIC;<br>

<br>
public&nbsp;class&nbsp;ScopeExample&nbsp;{&nbsp;//&nbsp;class&nbsp;body&nbsp;scope<br>
&nbsp;&nbsp;private&nbsp;Object&nbsp;field&nbsp;=&nbsp;STATIC;<br>

<br>
&nbsp;&nbsp;private&nbsp;void&nbsp;method(String&nbsp;param)&nbsp;{&nbsp;//&nbsp;method&nbsp;body&nbsp;scope<br>
&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;localVar&nbsp;=&nbsp;"bar";<br>
&nbsp;&nbsp;&nbsp;&nbsp;innerBlock:&nbsp;{&nbsp;//&nbsp;block&nbsp;scope<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;innerScopeVar&nbsp;=&nbsp;"foo";<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;field&nbsp;=&nbsp;innerScopeVar;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;the&nbsp;scope&nbsp;hierarchy&nbsp;at&nbsp;this&nbsp;point&nbsp;would&nbsp;look&nbsp;like&nbsp;this:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;blockScope{field,innerScopeVar}-&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;methodScope{localVar,&nbsp;param}-&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;classScope{field}-&gt;&nbsp;('field'&nbsp;is&nbsp;overlayed)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;fileScope{STATIC}-&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;classpathScope{'all&nbsp;qualified&nbsp;names&nbsp;of&nbsp;accessible&nbsp;static&nbsp;fields'}&nbsp;-&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;NULLSCOPE{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;field.add(localVar);<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>In fact the class path scope should also reflect the order of class path entries.
				For instance:</p>
<div class="literallayout">
<p>
<code class="code">classpathScope{stuff&nbsp;from&nbsp;bin/}<br>
-&gt;&nbsp;classpathScope{stuff&nbsp;from&nbsp;foo.jar/}<br>
-&gt;&nbsp;...<br>
-&gt;&nbsp;classpathScope{stuff&nbsp;from&nbsp;JRE&nbsp;System&nbsp;Library}<br>
-&gt;&nbsp;NULLSCOPE{}<br>

<br>

</code>
</p>
</div>
<p>Please find the motivation behind this and some additional details in 
				<a class="ulink" href="http://blog.efftinge.de/2009/01/xtext-scopes-and-emf-index.html" target="_new">this blog post</a> .
			</p>
<p>The default implementation would produce this hierarchy of scopes for the model from the last example in the 
				<a class="link" href="linking.html#defaultImports" title="Default Imports">previous chapter</a>:
			</p>
<div class="literallayout">
<p>
<code class="code">//file&nbsp;model.dsl<br>
import&nbsp;"model1.dsl";<br>
import&nbsp;"model2.dsl";<br>
&nbsp;<br>
ref&nbsp;Foo;<br>
entity&nbsp;Bar;<br>

<br>

</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">//file&nbsp;model1.dsl&nbsp;<br>
entity&nbsp;Stuff;<br>

<br>

</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">//file&nbsp;model2.dsl<br>
entity&nbsp;Foo;<br>

<br>

</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">Scope&nbsp;(model.dsl)&nbsp;{<br>
&nbsp;&nbsp;parent&nbsp;:&nbsp;Scope&nbsp;(model1.dsl)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;parent&nbsp;:&nbsp;Scope&nbsp;(model2.dsl)&nbsp;{}<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>When enumerating the scope&rsquo;s content, the first, most specialized scope would return 
				<code class="code">Bar</code>, its parent would provide 
				<code class="code">Stuff</code> and the outermost scope adds 
				<code class="code">Foo</code>. The linker will iterate the scope in that order and abort when it finds a matching 
				<code class="code">ScopedElement</code>. 
			</p>
<div class="section" title="DeclarativeScopeProvider">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="org.eclipse.xtextsrcorg.eclipse.xtext.scoping.impl.DeclarativeScopeProvider"></a>
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/DeclarativeScopeProvider.java?root=Modeling_Project&view=co" target="_new">DeclarativeScopeProvider</a>
				
</h3>
</div>
</div>
</div>
<p>As always there is an implementation that allows to specify scoping in a declarative way. It looks up methods which have either of the following two signatures:</p>
<div class="literallayout">
<p>
<code class="code">IScope&nbsp;scope_&lt;RefDeclaringEClass&gt;_&lt;Reference&gt;(&lt;ContextType&gt;&nbsp;ctx,&nbsp;EReference&nbsp;ref)<br>

</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">IScope&nbsp;scope_&lt;TypeToReturn&gt;(&lt;ContextType&gt;&nbsp;ctx,&nbsp;EReference&nbsp;ref)<br>

</code>
</p>
</div>
<p>The former is used when evaluating the scope for a specific cross reference and here 
					<code class="code">&lt;ContextReference&gt;</code> corresponds to the name of this reference (prefixed with the name of the reference&rsquo;s declaring type and separated by an underscore). The 
					<code class="code">ref</code> parameter represents this cross reference.
				</p>
<p>The latter method signature is used when computing the scope for a given element type and is applicable to all cross references of that type. Here 
					<code class="code">&lt;TypeToReturn&gt;</code> is the name of that type which also corresponds to the 
					<code class="code">type</code> parameter. 
				</p>
<p>So if you for example have a state machine with a  
					<span class="emphasis"><em>Transition</em></span> object owned by its source 
					<span class="emphasis"><em>State</em></span> and you want to compute all reachable states (i.e. potential target states), the corresponding method could be declared as follows (assuming the cross reference is declared by the 
					<span class="emphasis"><em>Transition</em></span> type and is called 
					<span class="emphasis"><em>target</em></span>):
				</p>
<div class="literallayout">
<p>
<code class="code">IScope&nbsp;scope_Transition_target(Transition&nbsp;this,&nbsp;EReference&nbsp;ref)<br>

</code>
</p>
</div>
<p>If such a method does not exist, the implementation will try to find one for the context object&rsquo;s container. Thus in the example this would match a method with the same name but 
					<span class="emphasis"><em>State</em></span> as the type of the first parameter. It will keep on walking the containment hierarchy until a matching method is found. This container delegation allows to reuse the same scope definition for elements in different places of the containment hierarchy. Also it may make the method easier to implement as the elements comprising the scope are quite often owned or referenced by a container of the context object. In the example the 
					<span class="emphasis"><em>State</em></span> objects could for instance be owned by a containing 
					<span class="emphasis"><em>StateMachine</em></span> object.
				</p>
<p>If no method specific to the cross reference in question was found for any of the objects in the containment hierarchy, the implementation will start looking for methods matching the other signature (with the 
					<span class="emphasis"><em>EClass</em></span> parameter). Again it will first attempt to match the context object. Thus in the example the signature first matched would be:
				</p>
<div class="literallayout">
<p>
<code class="code">IScope&nbsp;scope_State(Transition&nbsp;this,&nbsp;EReference&nbsp;ref)<br>

</code>
</p>
</div>
<p>If no such method exists, the implementation will again try to find a method matching the context object&rsquo;s container objects. In the case of the state machine example you might want to declare the scope with available states at the state machine level:</p>
<div class="literallayout">
<p>
<code class="code">IScope&nbsp;scope_State(StateMachine&nbsp;this,&nbsp;EReference&nbsp;ref)<br>

</code>
</p>
</div>
<p>This scope can now be used for any cross references of type 
					<span class="emphasis"><em>State</em></span> for context objects owned by the state machine.
				</p>
<p>There are currently two different scope provider implmentations available which support these semantics:</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p> 
							
<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/AbstractDeclarativeScopeProvider.java?root=Modeling_Project&view=co" target="_new">AbstractDeclarativeScopeProvider</a> 
						
</p>
</li>
<li class="listitem">
<p> 
							
<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/AbstractDeclarativeQualifiedNameScopeProvider.java?root=Modeling_Project&view=co" target="_new">AbstractDeclarativeQualifiedNameScopeProvider</a>
						
</p>
</li>
</ol>
</div>
</div>
<div class="section" title="QualifiedNameScopeProvider">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="org.eclipse.xtextsrcorg.eclipse.xtext.scoping.impl.QualifiedNameScopeProvider"></a>
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/QualifiedNameScopeProvider.java?root=Modeling_Project&view=co" target="_new">QualifiedNameScopeProvider</a>
				
</h3>
</div>
</div>
</div>
<p>The qualified name scoping is based on qualified names and name spaces. It adds name space support to your language, which is comparable and similar to the one in Scala and C#. Scala and C# both allow to have multiple nested packages within one file and you can put imports per namespace, so that imported names are only visible within that namespace. See the domain model example its scope provider extends  
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/AbstractDeclarativeQualifiedNameScopeProvider.java?root=Modeling_Project&view=co" target="_new">AbstractDeclarativeQualifiedNameScopeProvider</a>.
				</p>
<div class="section" title="IQualifiedNameProvider">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="org.eclipse.xtextsrcorg.eclipse.xtext.scoping.IQualifiedNameProvider"></a>
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IQualifiedNameProvider.java?root=Modeling_Project&view=co" target="_new">IQualifiedNameProvider</a>
					
</h4>
</div>
</div>
</div>
<p>The 
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/QualifiedNameScopeProvider.java?root=Modeling_Project&view=co" target="_new">QualifiedNameScopeProvider</a> makes use of the so called 
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IQualifiedNameProvider.java?root=Modeling_Project&view=co" target="_new">IQualifiedNameProvider</a> service. It computes qualified names for EObjects. The default implementation (
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/DefaultDeclarativeQualifiedNameProvider.java?root=Modeling_Project&view=co" target="_new">DefaultDeclarativeQualifiedNameProvider</a>) uses a simple name look up and concats the result to the qualified name of its parent object. See its JavaDoc and the code for more details.
					</p>
</div>
<div class="section" title="Importing name spaces">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="Importingnamespaces"></a>Importing name spaces</h4>
</div>
</div>
</div>
<p>The QualifiedNameScopeProvider looks up EAttributes with name &sbquo;importNamespace&rsquo; and interprets such as import statements.
						By default qualified names with or without a wildcard at the end are supported. For an import of a qualified name the simple name is made available as we know from e.g. Java, where</p>
<div class="literallayout">
<p>
<code class="code">import&nbsp;java.util.Set;<br>

</code>
</p>
</div>
<p>makes it possible to refer to &sbquo;java.util.Set&rsquo; by its simple name &sbquo;Set&rsquo;.
						Contrary to Java the import is not active for the whole file but only for the namespace it is declared in and its child namespaces. That is why you can write the following in the example DSL:</p>
<div class="literallayout">
<p>
<code class="code">package&nbsp;foo&nbsp;{<br>
&nbsp;&nbsp;import&nbsp;bar.Foo<br>
&nbsp;&nbsp;entity&nbsp;Bar&nbsp;extends&nbsp;Foo&nbsp;{<br>
&nbsp;&nbsp;}<br>
}<br>

<br>
package&nbsp;bar&nbsp;{<br>
&nbsp;&nbsp;entity&nbsp;Foo&nbsp;{}<br>
}<br>

<br>

</code>
</p>
</div>
<p>Of course the declared elements within a package are as well referable by their simple name:</p>
<div class="literallayout">
<p>
<code class="code">package&nbsp;bar&nbsp;{<br>
&nbsp;&nbsp;entity&nbsp;Bar&nbsp;extends&nbsp;Foo&nbsp;{}<br>
&nbsp;&nbsp;entity&nbsp;Foo&nbsp;{}<br>
}<br>

<br>

</code>
</p>
</div>
<p>Of course the following would as well be ok:</p>
<div class="literallayout">
<p>
<code class="code">package&nbsp;bar&nbsp;{<br>
&nbsp;&nbsp;entity&nbsp;Bar&nbsp;extends&nbsp;bar.Foo&nbsp;{}<br>
&nbsp;&nbsp;entity&nbsp;Foo&nbsp;{}<br>
}<br>

<br>

</code>
</p>
</div>
<p>As the name suggests it uses the EMF index to find any EObjects which are not located in the current resource. 
						The 
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/index/IndexBasedScopeProvider.java?root=Modeling_Project&view=co" target="_new">IndexBasedScopeProvider</a> supports nested namespaces (similar to C# and Scala) and is used in the Domainmodel example (project org.eclipse.xtext.example.domainmodel). There is support for declarative overwriting of the default semantics if you subclass 
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/index/AbstractDeclarativeIndexBasedScopeProvider.java?root=Modeling_Project&view=co" target="_new">AbstractDeclarativeIndexBasedScopeProvider</a>.
					</p>
<p>See the JavaDocs and 
						<a class="ulink" href="http://blog.efftinge.de/2009/07/xtext-scopes-and-emf-index-in-action.html" target="_new">this blog post</a> for details.
					</p>
</div>
</div>
</body>
</html>
