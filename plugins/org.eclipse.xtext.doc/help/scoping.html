<html>
<head>
<title>Scoping</title>
<link href="book.css" rel="stylesheet" type="text/css"/>
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator"/>
<link rel="home" href="index.html" title="Xtext User Guide"/>
<link rel="up" href="RuntimeConcepts.html" title="Runtime Concepts"/>
<link rel="prev" href="linking.html" title="Linking"/>
<link rel="next" href="valueconverter.html" title="Value Converter"/>
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Scoping</h1>
<p>An 
				<code class="code">IScopeProvider</code> is responsible for providing an 
				<code class="code">IScope</code> for a given 
				<code class="code">EObject</code> and its 
				<code class="code">EReference</code>, for which all candidates shall be returned. 
			</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
@Stable(since = "0.7.0", subClass = AbstractScopeProvider.class)<br/>
public interface IScopeProvider {<br/>
<br/>
  /**<br/>
   * Returns a scope for the given context. The scope provides access to <br/>
   * the compatible visible EObjects for a given reference.<br/>
   *<br/>
   * @param context the element from which an element shall be referenced<br/>
   * @param reference the reference to be used to filter the elements.<br/>
   * @return {@link IScope} representing the inner most {@link IScope} for <br/>
   *         the passed context and reference.<br/>
   */<br/>
  public IScope getScope(EObject context, EReference reference);<br/>
<br/>
  /**<br/>
   * Returns a scope for a given context. The scope contains any visible, <br/>
   * type-compatible element.<br/>
   * @param context the element from which an element shall be referenced<br/>
   * @param type the (super)type of the elements.<br/>
   * @return {@link IScope} representing the inner most {@link IScope} for<br/>
   *         the passed context and type.<br/>
   */<br/>
  public IScope getScope(EObject context, EClass type);<br/>
}<br/>
<br/>
</code>
</p>
</div>
<p>An 
				<code class="code">IScope</code> represents an element of a linked list of scopes. That means that a scope can be nested within an outer scope.
				For instance Java has multiple kinds of scopes (object scope, type scope, etc.).
			</p>
<p>For Java one would create the scope hierarchy as commented in the following example:</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
// file contents scope<br/>
import static my.Constants.STATIC;<br/>
<br/>
public class ScopeExample { // class body scope<br/>
  private Object field = STATIC;<br/>
<br/>
  private void method(String param) { // method body scope<br/>
    String localVar = "bar";<br/>
    innerBlock: { // block scope<br/>
      String innerScopeVar = "foo";<br/>
      Object field = innerScopeVar;<br/>
      // the scope hierarchy at this point would look like so:<br/>
      //blockScope{field,innerScopeVar}-&gt;<br/>
      //methodScope{localVar,param}-&gt;<br/>
      //classScope{field}-&gt; ('field' is overlayed)<br/>
      //fileScope{STATIC}-&gt;<br/>
      //classpathScope{'all qualified names of accessible static fields'} -&gt;<br/>
      //NULLSCOPE{}<br/>
      //<br/>
    }<br/>
    field.add(localVar);<br/>
  }<br/>
}<br/>
<br/>
</code>
</p>
</div>
<p>In fact the class path scope should also reflect the order of class path entries.
				For instance:</p>
<div class="literallayout">
<p>
<code class="code">classpathScope{stuff from bin/}<br/>
-&gt; classpathScope{stuff from foo.jar/}<br/>
-&gt; ...<br/>
-&gt; classpathScope{stuff from JRE System Library}<br/>
-&gt; NULLSCOPE{}<br/>
</code>
</p>
</div>
<p>Please find the motivation behind this and some additional details in 
				<a class="ulink" href="http://blog.efftinge.de/2009/01/xtext-scopes-and-emf-index.html" target="_new">this blog post</a> .
			</p>
<div class="section" title="Declarative Scope Provider">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="DeclarativeScopeProvider"/>Declarative Scope Provider</h3>
</div>
</div>
</div>
<p>As always there is an implementation allowing to specify scoping in a declarative way (extend 
					<code class="code">org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider</code> for this purpose). It looks up methods which have either of the following two signatures:
				</p>
<div class="literallayout">
<p>
<code class="code">IScope scope_&lt;ContextReference&gt;(&lt;ContextType&gt; ctx, EReference ref)<br/>
</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">IScope scope_&lt;TypeToReturn&gt;(&lt;ContextType&gt; ctx, EClass type)<br/>
</code>
</p>
</div>
<p>The former is used when evaluating the scope for a specific cross reference and here 
					<code class="code">&lt;ContextReference&gt;</code> corresponds to the name of this reference (prefixed with the name of the reference&#8217;s declaring type and separated by an underscore). Tthe 
					<code class="code">ref</code> parameter represents this cross reference.
				</p>
<p>The latter method signature is used when evaluating the scope of a given element type and is applicable to all cross references of that type. Here 
					<code class="code">&lt;TypeToReturn&gt;</code> is the name of that type which also corresponds to the 
					<code class="code">type</code> parameter. 
				</p>
<p>So if you for example have a state machine with a  
					<span class="emphasis">
<em>Transition</em>
</span> object owned by its source 
					<span class="emphasis">
<em>State</em>
</span> and you want to compute all reachable states (i.e. potential target states), the corresponding method could be declared as follows (assuming the cross reference is declared by the 
					<span class="emphasis">
<em>Transition</em>
</span> type and is called 
					<span class="emphasis">
<em>target</em>
</span>):
				</p>
<div class="literallayout">
<p>
<code class="code">IScope scope_Transition_target(Transition this, EReference ref)<br/>
</code>
</p>
</div>
<p>If such a method does not exist, the implementation will try to find one for the context object&#8217;s container. Thus in the example this would match a method with the same name but 
					<span class="emphasis">
<em>State</em>
</span> as the type of the first parameter. It will keep on walking the containment hierarchy until a matching method is found. This container delegation allows to reuse the same scope definition for elements in different places of the containment hierarchy. Also it may make the method easier to implement as the elements comprising the scope are quite often owned or referenced by a container of the context object. In the example the 
					<span class="emphasis">
<em>State</em>
</span> objects could for instance be owned by a containing 
					<span class="emphasis">
<em>StateMachine</em>
</span> object.
				</p>
<p>If no method specific to the cross reference in question was found for any of the objects in the containment hierarchy, the implementation will start looking for methods matching the other signature (with the 
					<span class="emphasis">
<em>EClass</em>
</span> parameter). Again it will first attempt matching the context object. Thus in the example the signature first matched would be:
				</p>
<div class="literallayout">
<p>
<code class="code">IScope scope_State(Transition this, EClass type)<br/>
</code>
</p>
</div>
<p>If no such method exists, the implementation will again try to find a method matching the context object&#8217;s container objects. In the case of the state machine example you might want to declare the scope with available states at the state machine level:</p>
<div class="literallayout">
<p>
<code class="code">IScope scope_State(StateMachine this, EClass type)<br/>
</code>
</p>
</div>
<p>This scope can now be used for any cross references of type 
					<span class="emphasis">
<em>Scope</em>
</span> for context objects owned by the state machine.
				</p>
</div>
</body>
</html>
