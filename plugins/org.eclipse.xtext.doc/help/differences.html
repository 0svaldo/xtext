<html>
<head>
<title>Differences</title>
<link href="book.css" rel="stylesheet" type="text/css"/>
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator"/>
<link rel="home" href="index.html" title="Xtext User Guide"/>
<link rel="up" href="from_oaw_to_tmf.html" title="From oAW to TMF"/>
<link rel="prev" href="Xtend_based_apis.html" title="Where are the Xtend-based APIs?"/>
<link rel="next" href="NewFeatures.html" title="New Features"/>
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Differences</h1>
<p>In this section differences between oAW Xtext and TMF Xtext are outlined and explained. We&#8217;ll start from the primary APIs such as the grammar language and the validation hook and finish with the different secondary hooks for customizing linking and several UI aspects, such as outline view and content assist. We&#8217;ll also try to translate/map some of the oAW Xtext concepts to their counterparts from TMF Xtext.</p>
<div class="section" title="Differences in the grammar language">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="differenced_grammar_language"/>Differences in the grammar language</h3>
</div>
</div>
</div>
<p>When looking at a TMF Xtext grammar the first time it looks like one has to provide additional information which was not necessary in oAW Xtext. In oAW Xtext *.xtxt files started with the first production rule where in TMF Xtext one has to declare the name of the language followed by declaration of one or more used/generated meta models:</p>
<p>TMF Xtext heading information</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  grammar my.namespace.Language with org.eclipse.xtext.common.Terminals<br/>
  generate myDsl "http://www.namespace.my/2009/MyDSL"<br/>
 <br/>
  FirstRule : ...<br/>
<br/>
</code>
</p>
</div>
<p>In oAW Xtext this information was provided through the generator (actually it is contained in the *.properties file) but we found that these things are very important for a complete description of a grammar and had therefore be part of the grammar in order to have self-describing grammars and allow for sophisticated static analysis, etc.. </p>
<p>Apart from the first two lines the grammar languages of both versions are more or less compatible. The syntax for all the different EBNF concepts (alternatives, groups, cardinalities) is similar.
					Also assignments are syntactically and semantically identical in both versions. 
					However in TMF Xtext some concepts have been generalized and improved:</p>
<div class="section" title="String rules become Datatype rules">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_datatype_rules"/>String rules become Datatype rules</h4>
</div>
</div>
</div>
<p>The very handy String rules are still present in TMF Xtext but we generalized them so that you don&#8217;t need to write the &#8216;String&#8217; keyword in front of them and at the same time these rules can not only produce EStrings but (as the name suggests) any kind of EDatatype. Every parser rule that does include assignments or calls any that does returns an EDataType containing the consumed data. Per default this is an EString but you can now simply create a parser rule returning other EDatatype as well (see TODO-REF).</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  Float returns ecore::EDouble : INT ('.' INT)?;<br/>
</code>
</p>
</div>
</div>
<div class="section" title="Enum rules">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_enum_rules"/>Enum rules</h4>
</div>
</div>
</div>
<p>Enum rules have not changed significantly. The keyword has changed to be all lower case (&#8216;enum&#8217; instead of &#8216;Enum&#8217;).
						Also the right handside of the assignment is now optional. That is in oAW Xtext:</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  Enum MyEnum : foo='foo' | bar='bar';<br/>
  <br/>
</code>
</p>
</div>
<p>becomes</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  enum MyEnum : foo='foo' | bar='bar';<br/>
   <br/>
</code>
</p>
</div>
<p>and because the name of the literal equals the literal value one can ommit the right handside in this case and write:</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  enum MyEnum : foo | bar;<br/>
<br/>
</code>
</p>
</div>
</div>
<div class="section" title="Native rules">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_native_rules"/>Native rules</h4>
</div>
</div>
</div>
<p>The most significant improvement to oAW Xtext is that we could replace the blackbox native rules with full-blown EBNF syntax. 
						That is native rules become terminal rules and or no longer written as a string literal containing ANTLR syntax but are a part of the language.</p>
<p>Example :</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  Native FOO : "'f' 'o' 'o'";<br/>
</code>
</p>
</div>
<p>becomes</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  terminal FOO : 'f' 'o' 'o';<br/>
</code>
</p>
</div>
<p>See the reference documentation for all the different expressions possible in terminal rules (TODO-REF).</p>
</div>
<div class="section" title="No URI terminal rule anymore">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_no_URI_token"/>No URI terminal rule anymore</h4>
</div>
</div>
</div>
<p>Although with grammar-mixins we would have been able to implement the URI terminal rule again, we decided to remove it. The only reason for the URI token was to mark the model some how so that the framework knows what information to use in order to load referenced models. Instead we decided to solve this similar to how we imply other defaults: by convention.</p>
<p>So instead of using a special token which is syntactically a STRING token, the default import mechanism now looks for EAttributes of type EString with the name &#8216;importedURI&#8217;.
						That is if you&#8217;ve used the URI token like so:</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  Import : 'import' myReference=URI;<br/>
</code>
</p>
</div>
<p>you&#8217;ll have to rewrite it like so</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  Import : 'import' importedURI=STRING;<br/>
</code>
</p>
</div>
<p>Although this changes your meta model, one usually never used this reference explicititely as it was only there to be used by the default import mechanism. So we assume and hope that changing the reference is not a big deal for you. </p>
</div>
<div class="section" title="Return types">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_return_types"/>Return types</h4>
</div>
</div>
</div>
<p>The syntax to explicitly declare the return type of a rule has changed. In oAW Xtext (where this was marked as &#8216;experimental&#8217;) the syntax was like so:</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  MyRule [MyType] : foo=ID;  <br/>
</code>
</p>
</div>
<p>in TMF Xtext we have a keyword for this :</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  MyRule returns MyType : foo=ID;<br/>
</code>
</p>
</div>
<p>This is a bit more verbose, but at the same time more readable. And as you don&#8217;t have to write the return type in most situations, it&#8217;s good to have a more explicit, readable syntax.</p>
</div>
</div>
<div class="section" title="Differences in Validation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="differences_validation"/>Differences in Validation</h3>
</div>
</div>
</div>
<p>TMF Xtext still supports implementing validation using Xpand&#8217;s check. However it is no longer using the EMF meta model (typesystem) but now uses the JavaBeansMetamodel.
					This requires minor changes (namely the namespaces to be imported are now the qualified name of the generated Java classes). 
					Example: If your check file looked like this in oAW Xtext :</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  import myMetamodel;<br/>
  context Type ERROR "foo" : name!=null;   <br/>
</code>
</p>
</div>
<p>it becomes something like the following in TMF Xtext :</p>
<div class="literallayout">
<p>
<code class="code">
<br/>
  import my::pack::to::myMetaModel;<br/>
  context Type ERROR "foo" : name!=null;<br/>
</code>
</p>
</div>
<p>Where 
					<code class="code">my::pack::to::myMetaModel</code> refers to the package the generated EClasses are in. In other words there&#8217;s a Java class 
					<code class="code">my.pack.to.myMetaModel.Type</code>.
					We changed this in order to allow use of any Java API , such as 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java?root=Modeling_Project&amp;view=co" target="_new">IScopeProvider</a>, from within Check and Xtend.
				</p>
</div>
<div class="section" title="Differences in Linking">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="differences_linking"/>Differences in Linking</h3>
</div>
</div>
</div>
<p>The linking has been completely redesigned. In oAW Xtext linking was done in a very naive way: To find an element one queries a list of all &#8216;visible&#8217; EObjects, then filters out what is not needed and tries to find a match by comparing the text written for the crosslink with the value returned by the id() extension. As a side-effect of link_feature() the reference is then set.</p>
<p>The code about selecting and filtering allElements() usually has been duplicated in the corresponding content assist function, so that linking an content assist are semantically in sync. If you&#8217;re good (we usually were not) you externalized that piece of code and reused the same extension in content assist and linking. </p>
<p>To put it blunty this approach could be summarized in two steps:</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>Give me the whole universe including every unregarded object in the uncharted backwaters of the unfashionable end of the western spiral arm of the galaxy </p>
</li>
<li class="listitem">
<p>From this, select the one I need</p>
</li>
</ol>
</div>
<p>This was not only very expensive but also lacks an important abstraction: the notion of scopes.</p>
<div class="section" title="The idea of scopes">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_linking_sopes"/>The idea of scopes</h4>
</div>
</div>
</div>
<p>In TMF Xtext we&#8217;ve introduced scopes and scope providers that are responsible for creating scopes. A scope is basically a set of name-&gt;value pairs. Scopes are implemented upon Iterables and are nested to build a hierarchy. With scopes we declare &#8220;visible&#8221; objects in a lazy and cost-saving way where the linker only navigates as far as necessary to find the needed objects. The content assist reuses this set of visible objects to offer only objects that can be linked. </p>
<p>When implementing custom linking scoping is where most of the semantics typically goes into. By implementing an 
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java?root=Modeling_Project&amp;view=co" target="_new">IScopeProvider</a> for your language linking and content assist will automatically be kept in sync since both rely on and use the scope provider.
					</p>
<p>The provided default implementation is semantically mostly identical to how the default linking worked in oAW Xtext: </p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>Elements which have an attribute &#8216;name&#8217; will be made visible by their name,</p>
</li>
<li class="listitem">
<p>Referenced resources will be put on the (outer) scope by using the &#8216;importedURI&#8217;- naming convention (TODO-REF) and will only be navigated to if necessary</p>
</li>
<li class="listitem">
<p>The available elements are filtered by the expected type (i.e. the type of the reference to be linked)</p>
</li>
</ol>
</div>
</div>
<div class="section" title="Migration">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_linking_migration"/>Migration</h4>
</div>
</div>
</div>
<p>We expect the migration of linking to be very simple if you&#8217;ve not changed the default semantics that much. We&#8217;ve already migrated a couple of projects and it wasn&#8217;t too hard to do so.
						If you have changed linking (and also content assist) a lot, you&#8217;ll have to translate the semantics to the IScopeProvider concept. This might a bit of work, but it is worth the effort as this will clean up your code base and better separate concerns.</p>
</div>
</div>
<div class="section" title="Differences in UI customizing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="differences_ui"/>Differences in UI customizing</h3>
</div>
</div>
</div>
<p>In oAW Xtext several UI services such as content assist, outline view or the label provider have been customized using Xtend. In TMF Xtext there is no Xtend API for these aspects. Extensive model computations for the content assist is most probably not necessary anymore- it reuses scopes. And since we provide a declarative Java API that mimics the polymorphic dispatch and relies on static ecore classes you will gain nearly the same expressiveness as before while increasing maintainability and performance.</p>
<p>Beside the API change in favor of Java we have to mention that in TMF Xtext the outline view does not support multiple view points so far. This is just because we didn&#8217;t manage to get this included (due to low priorization). We don&#8217;t think that view points are a bad idea in general, but we decided that other things were more important.</p>
</div>
</body>
</html>
