<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Differences</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="from_oaw_to_tmf.html" title="From oAW to TMF">
<link rel="prev" href="Xtend_based_apis.html" title="Where are the Xtend-based APIs?">
<link rel="next" href="NewFeatures.html" title="New Features">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Differences</h1>
<div class="section" title="Differences">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both">
<a name="differences"></a>Differences</h2>
</div>
</div>
</div>
<p>In this section differences between oAW Xtext and TMF Xtext are outlined and explained. We&rsquo;ll start from the APIs such as the grammar language and the validation and finish with the different hooks for customizing linking and several UI aspects, such as outline view and content assist. We&rsquo;ll also try to map some of the oAW Xtext concepts to their counterparts in TMF Xtext.</p>
<div class="section" title="Differences in the grammar language">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="differenced_grammar_language"></a>Differences in the grammar language</h3>
</div>
</div>
</div>
<p>When looking at a TMF Xtext grammar the first time it looks like one has to provide additional information which was not necessary in oAW Xtext. In oAW Xtext *.xtxt files started with the first production rule where in TMF Xtext one has to declare the name of the language followed by declaration of one or more used/generated Ecore models:</p>
<p>TMF Xtext heading information</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;grammar&nbsp;my.namespace.Language&nbsp;with&nbsp;org.eclipse.xtext.common.Terminals<br>
&nbsp;&nbsp;generate&nbsp;myDsl&nbsp;"http://www.namespace.my/2009/MyDSL"<br>
&nbsp;<br>
&nbsp;&nbsp;FirstRule&nbsp;:&nbsp;...<br>

<br>

</code>
</p>
</div>
<p>In oAW Xtext this information was provided through the generator (actually it is contained in the *.properties file) but we found that these things are very important for a complete description of a grammar. Therefore we made that information becoming a part of the grammar language in order to have self-describing grammars and allow for sophisticated static analysis, etc.. </p>
<p>Apart from the first two lines the grammar languages of both versions are more or less compatible. The syntax for all the different EBNF concepts (alternatives, groups, cardinalities) is similar.
					Also assignments are syntactically and semantically identical in both versions. 
					However in TMF Xtext some concepts have been generalized and improved:</p>
<div class="section" title="String rules become Datatype rules">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_datatype_rules"></a>String rules become Datatype rules</h4>
</div>
</div>
</div>
<p>The very handy String rules are still present in TMF Xtext but we generalized them so that you don&rsquo;t need to write the &lsquo;String&rsquo; keyword in front of them and at the same time these rules can not only produce EStrings but (as the name suggests) any kind of EDataType. Every parser rule that neither includes assignments nor calls any other that does, returns an EDataType containing the consumed data. Per default this is an EString but you can now simply create a parser rule returning other EDataTypes as well (see 
						<a class="link" href="syntax.html#datatypeRules" title="Data type rules">Datatype rules</a>).
					</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;Float&nbsp;returns&nbsp;ecore::EDouble&nbsp;:&nbsp;INT&nbsp;('.'&nbsp;INT)?;<br>

</code>
</p>
</div>
</div>
<div class="section" title="Enum rules">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_enum_rules"></a>Enum rules</h4>
</div>
</div>
</div>
<p>Enum rules have not changed significantly. The keyword has changed to be all lower case (&lsquo;enum&rsquo; instead of &lsquo;Enum&rsquo;).
						Also the right-hand side of the assignment is now optional. That is in oAW Xtext:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;Enum&nbsp;MyEnum&nbsp;:&nbsp;foo='foo'&nbsp;|&nbsp;bar='bar';<br>
&nbsp;&nbsp;<br>

</code>
</p>
</div>
<p>becomes</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;enum&nbsp;MyEnum&nbsp;:&nbsp;foo='foo'&nbsp;|&nbsp;bar='bar';<br>
&nbsp;&nbsp;&nbsp;<br>

</code>
</p>
</div>
<p>and because the name of the literal equals the literal value one can omit the right-hand side in this case and write:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;enum&nbsp;MyEnum&nbsp;:&nbsp;foo&nbsp;|&nbsp;bar;<br>

<br>

</code>
</p>
</div>
</div>
<div class="section" title="Native rules">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_native_rules"></a>Native rules</h4>
</div>
</div>
</div>
<p>Another improvement is that we could replace the blackbox native rules with full-blown EBNF syntax. 
						That is native rules become terminal rules and are no longer written as a string literal containing ANTLR syntax.</p>
<p>Example :</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;Native&nbsp;FOO&nbsp;:&nbsp;"'f'&nbsp;'o'&nbsp;'o'";<br>

</code>
</p>
</div>
<p>becomes</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;terminal&nbsp;FOO&nbsp;:&nbsp;'f'&nbsp;'o'&nbsp;'o';<br>

</code>
</p>
</div>
<p>See the 
						<a class="link" href="syntax.html#TerminalRules" title="Terminal Rules">reference documentation</a> for all the different expressions possible in terminal rules.
					</p>
</div>
<div class="section" title="No URI terminal rule anymore">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_no_URI_token"></a>No URI terminal rule anymore</h4>
</div>
</div>
</div>
<p>We decided to remove the URI terminal. The only reason for the existence was to mark the model somehow so that the framework knows what information to use in order to load referenced models. Instead we decided to solve this similar to how we imply other defaults: by convention.</p>
<p>So instead of using a special token which is syntactically a STRING token, the default import mechanism now looks for EAttributes of type EString with the name &lsquo;importURI&rsquo;.
						That is if you&rsquo;ve used the URI token like this:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;Import&nbsp;:&nbsp;'import'&nbsp;myReference=URI;<br>

</code>
</p>
</div>
<p>you&rsquo;ll have to rewrite it that way</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;Import&nbsp;:&nbsp;'import'&nbsp;importURI=STRING;<br>

</code>
</p>
</div>
<p>Although this changes your Ecore model, one usually never used this reference explicitly as it was only there to be used by the default import mechanism. So we assume and hope that changing the reference is not a big deal for you. </p>
</div>
<div class="section" title="Return types">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_return_types"></a>Return types</h4>
</div>
</div>
</div>
<p>The syntax to explicitly declare the return type of a rule has changed. In oAW Xtext (where this was marked as &lsquo;experimental&rsquo;) the syntax was:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;MyRule&nbsp;[MyType]&nbsp;:&nbsp;foo=ID;&nbsp;&nbsp;<br>

</code>
</p>
</div>
<p>in TMF Xtext we have a keyword for this :</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;MyRule&nbsp;returns&nbsp;MyType&nbsp;:&nbsp;foo=ID;<br>

</code>
</p>
</div>
<p>This is a bit more verbose, but at the same time more readable. And as you don&rsquo;t have to write the return type in most situations, it&rsquo;s good to have a more explicit, readable syntax.</p>
</div>
</div>
<div class="section" title="Differences in Linking">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="differences_linking"></a>Differences in Linking</h3>
</div>
</div>
</div>
<p>The linking has been completely redesigned. In oAW Xtext linking was done in a very naive way: To find an element one queries a list of all &lsquo;visible&rsquo; EObjects, then filters out what is not needed and tries to find a match by comparing the text written for the crosslink with the value returned by the 
					<code class="code">id()</code> extension. As a side-effect of 
					<code class="code">link_feature()</code> the reference is set.
				</p>
<p>The code about selecting and filtering 
					<code class="code">allElements()</code> usually has been duplicated in the corresponding content assist function, so that linking and content assist are semantically in sync. If you&rsquo;re good (we usually were not) you externalized that piece of code and reused the same extension in content assist and linking. 
				</p>
<p>To put it bluntly this approach could be summarized in two steps:</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>Give me the whole universe including every unregarded object in the uncharted backwaters of the unfashionable end of the western spiral arm of the galaxy and squeeze it into an Arraylist </p>
</li>
<li class="listitem">
<p>From this, select the one I need</p>
</li>
</ol>
</div>
<p>This was not only very expensive but also lacks an important abstraction: the notion of scopes.</p>
<div class="section" title="The idea of scopes">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_linking_sopes"></a>The idea of scopes</h4>
</div>
</div>
</div>
<p>In TMF Xtext we&rsquo;ve introduced scopes and scope providers that are responsible for creating scopes. A scope is basically a set of name-&gt;value pairs. Scopes are implemented upon Iterables and are nested to build a hierarchy. With scopes we declare &ldquo;visible&rdquo; objects in a lazy and cost-saving way where the linker only navigates as far as necessary to find matching objects. The content assist reuses this set of visible objects to offer only reachable objects. </p>
<p>When the linking has to be customized scoping is where most of the semantics typically goes into. By implementing an 
						<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java?root=Modeling_Project&amp;view=co" target="_new">IScopeProvider</a> for your language linking and content assist will automatically be kept in sync since both use the scope provider.
					</p>
<p>The provided default implementation is semantically mostly identical to how the default linking worked in oAW Xtext: </p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>Elements which have an attribute &lsquo;name&rsquo; will be made visible by their name</p>
</li>
<li class="listitem">
<p>Referenced resources will be put on the (outer) scope by using the &lsquo;importURI&rsquo;- naming convention and will only be loaded if necessary</p>
</li>
<li class="listitem">
<p>The available elements are filtered by the expected type (i.e. the type of the reference to be linked)</p>
</li>
</ol>
</div>
</div>
<div class="section" title="Migration">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="differences_linking_migration"></a>Migration</h4>
</div>
</div>
</div>
<p>We expect the migration of linking to be very simple if you&rsquo;ve not changed the default semantics that much. We&rsquo;ve already migrated a couple of projects and it wasn&rsquo;t too hard to do so.
						If you have changed linking (and also content assist) a lot, you&rsquo;ll have to translate the semantics to the IScopeProvider concept. This might be a bit of work, but it is worth the effort as this will clean up your code base and better separate concerns.</p>
</div>
</div>
<div class="section" title="Differences in UI customizing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="differences_ui"></a>Differences in UI customizing</h3>
</div>
</div>
</div>
<p>In oAW Xtext several UI services such as content assist, outline view or the label provider have been customized using Xtend. In TMF Xtext there is no Xtend API for these aspects. Extensive model computations for the content assist is most probably not necessary anymore- it reuses scopes. And since we provide a declarative Java API that mimics the polymorphic dispatch and relies on static Ecore classes you will gain nearly the same expressiveness as before while increasing maintainability and performance.</p>
<p>Beside the API change in favor of Java we have to mention that in TMF Xtext the outline view does not support multiple view points so far. This is just because we didn&rsquo;t manage to get this included. We don&rsquo;t think that view points are a bad idea in general, but we decided that other things were more important.</p>
</div>
</div>
</body>
</html>
