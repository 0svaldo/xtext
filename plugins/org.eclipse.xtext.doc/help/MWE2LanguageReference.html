<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Language Reference</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="MWE2.html" title="MWE2">
<link rel="prev" href="MWE2.html" title="MWE2">
<link rel="next" href="MWE2SyntaxReference.html" title="Syntax Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Language Reference</h1>
<p>MWE2 has a few well defined concepts which can be combined to 
				assemble arbitrary object graphs in a compact and declarative 
				manner.</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>A MWE2 file defines a 
						<span class="emphasis"><em>module</em></span> which exposes its root 
						<span class="emphasis"><em>component</em></span> as reusable artifact.
					</p>
</li>
<li class="listitem">
<p>
						
<span class="emphasis"><em>Properties</em></span> can be used to extract reusable, configurable parts of the workflow.
					</p>
</li>
<li class="listitem">
<p>Components are mapped to plain vanilla 
						<span class="emphasis"><em>Java objects</em></span>. Arbitrary 
						<span class="emphasis"><em>set- and add-methods</em></span> are used to configure them.
					</p>
</li>
</ul>
</div>
<p>Let&rsquo;s consider the follow short example module and 
				<code class="code">SampleClass</code> to 
				explain these concepts.
			</p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;com.mycompany.Example<br>

<br>
import&nbsp;java.util.*<br>

<br>
SampleClass&nbsp;{<br>
&nbsp;&nbsp;singleValue&nbsp;=&nbsp;'a&nbsp;string'<br>
&nbsp;&nbsp;multiValue&nbsp;=&nbsp;ArrayList&nbsp;{}<br>
&nbsp;&nbsp;child&nbsp;=&nbsp;{}<br>
}&nbsp;<br>

</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">package&nbsp;com.mycompany;<br>

<br>
import&nbsp;java.util.List;<br>

<br>
public&nbsp;class&nbsp;SampleClass&nbsp;{<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;setSingleValue(String&nbsp;value)&nbsp;{..}<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;addMultiValue(List&lt;?&gt;&nbsp;value)&nbsp;{..}<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;addChild(SampleClass&nbsp;value)&nbsp;{..}<br>
}<br>

</code>
</p>
</div>
<div class="section" title="Mapping to Java Classes">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MWE2JavaReferences"></a>Mapping to Java Classes</h3>
</div>
</div>
</div>
<p>The module 
					<code class="code">com.mycompany.Example</code> defines a root component of 
					type 
					<code class="code">com.mycompany.SampleClass</code>. It is possible to use the simple 
					class-name because MWE2 uses the very same visibility rules as the 
					Java compiler. Classes that are in the same package as the module 
					can be referenced by their simple name. The same rule applies for 
					classes from the 
					<code class="code">java.lang</code> package. For convenience reasons is the 
					package 
					<code class="code">org.eclipse.emf.mwe2.runtime.workflow</code> implicitly imported 
					as well as it exposes some library workflow components. However, the
					imports are more flexible since MWE2-imports can be relative, e.g. 
					the 
					<code class="code">import java.*</code> resolves the reference 
					<code class="code">util.ArrayList</code> to 

					<code class="code">java.util.ArrayList</code>.  
				</p>
<p>The root instance of type 
					<code class="code">SampleClass</code> has to be configured 
					after it has been created. Therefore the method 
					<code class="code">setSingleValue</code> 
					will be called at first. The parameter given parameter is 

					<code class="code">'a string'</code>. The method is identified by its name which starts with 

					<code class="code">set</code>. To allow to assign multi-value properties, MWE provides 
					access to methods call 
					<code class="code">add*</code> as well. 
				</p>
<p>If the right side of the assignment in the workflow file does not 
					define an explicit class, its type is inferred from the method 
					parameter. The line 
					<code class="code">child = {}</code> is equivalent to 

					<code class="code">child = SampleClass {}</code> and creates a new instance of 
					<code class="code">SampleClass</code>.
				</p>
<p>MWE2 ships with a nice tool support. The editor will provide 
					content assist for the allowed types and highlight incompatible 
					assignments. The available properties for Java classes will be 
					proposed as well.</p>
</div>
<div class="section" title="Module">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MWE2Module"></a>Module </h3>
</div>
</div>
</div>
<p>As MWE2 modules have a fully qualified name, it is possible to refer
					to them from other modules. The type of the module is derived from
					the type of its root component. The 
					<code class="code">com.mycompany.Example</code> can be
					assigned at any place where a 
					<code class="code">com.mycompany.SampleClass</code> is expected.
				</p>
<p>Let&rsquo;s create a second module 
					<code class="code">com.mycompany.Second</code> like this:
				</p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;com.mycompany.sub.Second<br>

<br>
import&nbsp;com.mycompany.*<br>

<br>
SampleClass&nbsp;{<br>
&nbsp;&nbsp;child&nbsp;=&nbsp;@Example&nbsp;{}<br>
}&nbsp;<br>

</code>
</p>
</div>
<p>The 
					<code class="code">child</code> value will be assigned to an instance of 
					<code class="code">SampleClass</code> 
					that is configured as in the first example workflow. This enables
					nice composition and a very focused, reusable component design. 
				</p>
<p>As the same rules apply in MWE2 like in Java, the module 

					<code class="code">com.mycompany.sub.Second</code> has to be defined in a file called 

					<code class="code">Second.mwe2</code> in the package 
					<code class="code">com.mycompany.sub</code>. The import semantic
					for other modules is the same as for classes. The import statement
					allows to refer to 
					<code class="code">com.mycompany.Example</code> with a shortened name.
				</p>
</div>
<div class="section" title="Properties">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MWE2Properties"></a>Properties</h3>
</div>
</div>
</div>
<p>MWE2 allows to extract arbitrary information into properties to 
					ensure that these pieces are not cluttered around the workflow and 
					to allow for easier external customization. The exemplary component 
					definition was only changed slightly by introducing a property 

					<code class="code">value</code>.
				</p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;com.mycompany.Example<br>

<br>
var&nbsp;value&nbsp;=&nbsp;'a&nbsp;string'<br>

<br>
SampleClass&nbsp;{<br>
&nbsp;&nbsp;singleValue&nbsp;=&nbsp;value<br>
}<br>

</code>
</p>
</div>
<p>The type of the property will be derived from the default value 
					similar to the mechanism that is already known from 
					<code class="code">set</code>- and 

					<code class="code">add</code>-methods. If no default value is given, 
					<code class="code">java.lang.String</code> will
					be assumed. However, properties are not limited to strings. The 
					second built in type is boolean via the familiar literals 
					<code class="code">true</code> and

					<code class="code">false</code>. More flexibility is available via actual component literals.
				</p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;com.mycompany.Example<br>

<br>
var&nbsp;childInstance&nbsp;=&nbsp;SampleClass&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;singleValue&nbsp;=&nbsp;"child"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>

<br>
SampleClass&nbsp;{<br>
&nbsp;&nbsp;child&nbsp;=&nbsp;childInstance<br>
}<br>

</code>
</p>
</div>
<p>If one wants to define string properties that are actual reusable
					parts for other properties, she may use defined variables inside other
					literals like this: </p>
<div class="literallayout">
<p>
<code class="code">var&nbsp;aString&nbsp;=&nbsp;"part"<br>
var&nbsp;anotherString&nbsp;=&nbsp;"reuse&nbsp;the&nbsp;${part}&nbsp;here"<br>

</code>
</p>
</div>
<p>This is especially useful for file paths in workflows as one would
					usually want to define some common root directories only ones in the
					workflow and reuse this fragment across certain other file locations.</p>
</div>
<div class="section" title="Mandatory Properties">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MWE2Mandatory"></a>Mandatory Properties</h3>
</div>
</div>
</div>
<p>It is not always feasible to define default values for properties. 
					That is where mandatory properties come into play. Modules define their
					interface not only via their fully qualified name and the type of the
					root component but also by means of the defined properties.    </p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;com.mycompany.Example<br>

<br>
var&nbsp;optional&nbsp;=&nbsp;'a&nbsp;string'<br>
var&nbsp;mandatory<br>

<br>
SampleClass&nbsp;{<br>
&nbsp;&nbsp;singleValue&nbsp;=&nbsp;optional<br>
&nbsp;&nbsp;child&nbsp;=&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;singleValue&nbsp;=&nbsp;mandatory<br>
&nbsp;&nbsp;}<br>
}<br>

</code>
</p>
</div>
<p>This version of the example module exposes two externally assignable
					properties. The second one has no default value assigned and is 
					thereby considered to be mandatory. The mandatory value must be assigned
					if we reuse 
					<code class="code">org.mycompany.Example</code> in another module like this:
				</p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;com.mycompany.Second<br>

<br>
var&nbsp;newMandatory<br>

<br>
@Example&nbsp;{<br>
&nbsp;&nbsp;mandatory&nbsp;=&nbsp;"mandatoryValue"<br>
&nbsp;&nbsp;optional&nbsp;=&nbsp;newMandatory<br>
}&nbsp;<br>

</code>
</p>
</div>
<p>Note that it is even possible to reuse another module as the root
					component of a new module. In this case we set the mandatory 
					property of 
					<code class="code">Example</code> to a specific constant value while the previously
					optional value is now redefined as mandatory by means of a new property
					without a default value.
				</p>
<p>It is not only possible to define mandatory properties for MWE2 
					modules but for classes as well. Therefore MWE2 ships with the 

					<code class="code">Mandatory</code> annotation. If a 
					<code class="code">set</code>- or 
					<code class="code">add</code>-method is marked as

					<code class="code">mandatory</code>, the module validation will fail if no value was assigned
					to that feature.
				</p>
</div>
<div class="section" title="Named Components">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MWE2NamedComponents"></a>Named Components</h3>
</div>
</div>
</div>
<p>Properties are not the only way to define something that can be reused.
					It is possible to assign a name to any instantiated component being
					it created from a class literal or from another component. This allows
					to refer to previously created and configured instances. Named instances
					can come handy for notification and call-back mechanisms or more general
					in terms of defined life-cylce events. </p>
<p>If we wanted to assign the created instance to a property of itself,
					we could use the following syntax:</p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;com.mycompany.Example<br>

<br>
SampleClass&nbsp;:&nbsp;self&nbsp;{<br>
&nbsp;&nbsp;child&nbsp;=&nbsp;self<br>
}<br>

</code>
</p>
</div>
<p>A named component can be referenced immediately after its creation but
					it is not possible to define forward references in a MWE2 file.</p>
</div>
<div class="section" title="Auto Injection">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MWE2AutoInject"></a>Auto Injection</h3>
</div>
</div>
</div>
<p>Existing modules or classes often expose a set of properties that 
					will be assigned to features of its root component or set- and add- 
					methods respectively. In many cases its quite hard to come up with 
					yet another name for the very same concept which leads to the situation
					where the properties itself have the very same name as the component&rsquo;s
					feature. To avoid the overall repetition of assignments, MWE2 offers
					the possibility to use the 
					<code class="code">auto-inject</code> modifier on the component 
					literal:
				</p>
<div class="literallayout">
<p>
<code class="code">module&nbsp;com.mycompany.Example<br>

<br>
var&nbsp;child&nbsp;=&nbsp;SampleClass&nbsp;{}<br>

<br>
SampleClass&nbsp;auto-inject&nbsp;{<br>
}<br>

</code>
</p>
</div>
<p>This example will implicitly assign the value of the property

					<code class="code">child</code> to the feature 
					<code class="code">child</code> of the root component. This is especially
					useful for highly configurable workflows that expose dozens of optional
					parameters each of which can be assigned to one or more components.
				</p>
<p>The 
					<code class="code">auto-inject</code> modifier can be used for a subset of the available
					features as well. It will suppressed for the explicitly set values
					of a component.        
				</p>
</div>
<div class="section" title="Factory Support">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="MWE2Factories"></a>Factory Support</h3>
</div>
</div>
</div>
</div>
</body>
</html>
