<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Serialization</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="RuntimeConcepts.html" title="Runtime Concepts">
<link rel="prev" href="valueconverter.html" title="Value Converter">
<link rel="next" href="fragmentProvider.html" title="Fragment Provider (referencing Xtext models from other EMF artifacts)">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Serialization</h1>
<p>Serialization is the process of transforming an EMF model to its textual representation. Thereby, serialization complements parsing and lexing.</p>
<p>In Xtext, the process of serialization is split into three steps:</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>Matching the model elements with the grammar rules and creating a stream of tokens. This is done by the 
						<a class="link" href="serialization.html#parsetreeconstructor" title="Parse Tree Constructor">Parse Tree Constructor</a>.
					</p>
</li>
<li class="listitem">
<p>Mixing existing hidden tokens (whitespaces, comments, etc.) into the token stream. This is done by the 
						<a class="link" href="serialization.html#hiddentokenmerger" title="Hidden Token Merger">Hidden TOken Merger</a>.
					</p>
</li>
<li class="listitem">
<p>Adding needed whitespaces or replacing all whitespaces using a 
						<a class="link" href="formatting.html" title="Formatting (Pretty Printing)">Formatter</a>.  
					</p>
</li>
</ol>
</div>
<p>Serialization is invoked when calling 
				<code class="code">XtextResource.save(...)</code>. Furthermore, 
				<code class="code">SerializerUtil</code> provides resource-independent support for serialization.
			</p>
<div class="section" title="The Contract">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="serializationcontract"></a>The Contract</h3>
</div>
</div>
</div>
<p>The contract of serialization is that when a model is serialized to its textual representation and then loaded (parsed) again, the loaded model equals the original model. Please be aware that this does 
					<span class="emphasis"><em>not</em></span> imply, that when loading a textual representation and serializing it again that both textual representations equal each other. For example, this is the case when a default value is used in a textual representation and the assignment is optional. Another example is:
				</p>
<div class="literallayout">
<p>
<code class="code">MyRule:<br>
&nbsp;&nbsp;(xval+=ID&nbsp;|&nbsp;yval+=INT)*;<br>
&nbsp;&nbsp;<br>

</code>
</p>
</div>
<p>
					
<code class="code">MyRule</code> in this example reads 
					<code class="code">ID</code>- and 
					<code class="code">INT</code>-elements which may occur in an arbitrary in the textual representation. However, when serializing the model all 
					<code class="code">ID</code>-elements will be written first and then all 
					<code class="code">INT</code>-elements. If the order is important it can be preserved by storing all elements in the same list &ndash; which may require wrapping the 
					<code class="code">ID</code>- and 
					<code class="code">INT</code>-elements into objects.   
				</p>
</div>
<div class="section" title="Parse Tree Constructor">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="parsetreeconstructor"></a>Parse Tree Constructor</h3>
</div>
</div>
</div>
<p>The Parse Tree Constructor usually doesn&rsquo;t need to be customized since it is automatically derived from the 
					<a class="link" href="grammarLanguage.html" title="The Grammar Language">Xtext Grammar</a>. However, it can be a good idea to look into it to understand its error messages and its runtime performance.
				</p>
<p>For serialization to succeed, the Parse Tree Constructor must be able to 
					<span class="emphasis"><em>consume</em></span> every element of the to-be-serialized EMF model. To 
					<span class="emphasis"><em>consume</em></span> means, in this context, to write it to the textual representation of the model. This can turn out to be a not-so-easy to fulfill requirement, since a Grammar usually introduces implicit constraints to the Ecore model. Example:
				</p>
<div class="literallayout">
<p>
<code class="code">MyRule:<br>
&nbsp;&nbsp;(sval+=ID&nbsp;ival+=INT)*;<br>
	
<br>

</code>
</p>
</div>
<p>This example introduces the constraint  
					<code class="code">sval.size() == ival.size()</code>. Models which violate this constraint are valid EMF models, but they can not be serialized. To check whether a model complies with all constraints introduced by the grammar, there is currently only the way to invoke the Parse Tree Constructor. If this changes at some day, there will be news in 
					<a class="ulink" href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=239565" target="_new">bugzilla 239565</a>.
				</p>
<p>For the Parse Tree Constructor, this can lead to the scenarios, that</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>a model element can not be consumed. This can have the following reasons/solutions:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>The model element should not be stored in the model.</p>
</li>
<li class="listitem">
<p>The grammar needs an assignment which would consume the model element.</p>
</li>
<li class="listitem">
<p>The 
									<a class="link" href="serialization.html#transientvalues" title="Transient Values">Transient Value</a> service could be used to indicate that this models element should not be consumed. 
								</p>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>an assignment in the grammar has no corresponding model element. The Parse Tree Constructor considers a model element not to be present if it is 
							<span class="emphasis"><em>unset</em></span> or equals its default value. However, the parse tree constructor may serialize default values if this is required by a grammar constraint to be able to serialize another model element. The following solution may help to solve such a scenario:
						</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="circle">
<li class="listitem">
<p>A model element is missing in the model.</p>
</li>
<li class="listitem">
<p>The assignment in the grammar should be made optional.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>To understand error messages and performance issues of the Parse Tree Constructor it is important to know that it implements a backtracking approach. This basically means that the grammar is used to specify the structure of a tree in which one path (from the root node to a leaf node) is a valid serialization of a specific model. The Parse Tree Constructor&rsquo;s task is to find this path &ndash; with the condition, that all model elements are consumed while walking this path. The Parse Tree Constructor&rsquo;s strategy is to take the most promising branch first (the one that would consume the most model elements). If the branch leads to a dead end (for example, if a model element needs to be consumed that is not present in the model), the Parse Tree Constructor goes back the path until a different branch can be taken. This behavior has two consequences:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>In case of an error, the Parse Tree Constructor has found only dead ends but no leaf. It can not tell which dead end is actually erroneous. Therefore, the error message lists dead ends of the longs paths, a fragment of their serialization and the reason why the path could not be continued at this point. The developer has to judge on his own which reason is the actual error.</p>
</li>
<li class="listitem">
<p> For reasons of performance, it is critical that the Parse Tree Constructor takes the right branch first and detects wrong branches early. One way to archive this is to avoid having many rules which return the same type and which are called from within the same grammar-alternative.   </p>
</li>
</ul>
</div>
</div>
<div class="section" title="Transient Values">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="transientvalues"></a>Transient Values</h3>
</div>
</div>
</div>
<p>Transient Values are values or model elements which are not persisted (written to the textual representation in the serialization phase). If a model contains model elements which can not be serialized with the current grammar, it is critical to mark them transient using the 
					<code class="code">ITransientValueService</code>, or serialization will fail. The default implementation marks all model elements transient, that are 
					<span class="emphasis"><em>unset</em></span> or equal their default value.  
				</p>
</div>
<div class="section" title="Unassigned Text">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="unassignedtext"></a>Unassigned Text</h3>
</div>
</div>
</div>
<p>Unassigned Text are data rule calls or terminal rule calls which do not reside within an association. Example:</p>
<div class="literallayout">
<p>
<code class="code">PluralRule:<br>
&nbsp;&nbsp;'contents:'&nbsp;count=INT&nbsp;Plural;<br>
&nbsp;&nbsp;<br>
terminal&nbsp;Plural:&nbsp;<br>
&nbsp;&nbsp;'item'&nbsp;|&nbsp;'items';<br>
&nbsp;&nbsp;<br>

</code>
</p>
</div>
<p>Valid DSL-Scripts for this example are 
					<code class="code">contents 1 item</code> or 
					<code class="code">contents 5 items</code>. However, it is not stored in the semantic model whether the keyword 
					<code class="code">item</code> or 
					<code class="code">items</code> has been parsed. This is due to the fact that the rule call 
					<code class="code">Plural</code> is unassigned. However, the 
					<a class="link" href="serialization.html#parsetreeconstructor" title="Parse Tree Constructor">Parse Tree Constructor</a> needs a decision which value to write during serialization. This decision can be be made by implementing the 
					<code class="code">IUnassignedTextSerializer</code>.  
				</p>
</div>
<div class="section" title="Cross Reference Serializer">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="crossreferenceserializer"></a>Cross Reference Serializer</h3>
</div>
</div>
</div>
<p>The Cross Reference Serializer specifies which values are to be writting to the textual representation for cross references. This behavior can be customized by implementing 
					<code class="code">ICrossReferenceSerializer</code>. The default implementation delegates to 
					<code class="code">ILinkingService</code>, which may be the better place for customization.
				</p>
</div>
<div class="section" title="Hidden Token Merger">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="hiddentokenmerger"></a>Hidden Token Merger</h3>
</div>
</div>
</div>
<p>After the 
					<a class="link" href="serialization.html#parsetreeconstructor" title="Parse Tree Constructor">Parse Tree Constructor</a> has done its job to create a stream of tokens which are to be written to the textual representation, the Hidden Token Merger (
					<code class="code">IHiddenTokenMerger</code>) mixes existing hidden tokens into this token stream. The default implementation uses the hidden tokens (whitespaces, linebreaks, comments) from the node model. The 
					<code class="code">IHiddenTokenMerger</code> is the factory for a &ldquo;Token Stream&rdquo;#tokenstream which is fed by the 
					<a class="link" href="serialization.html#parsetreeconstructor" title="Parse Tree Constructor">Parse Tree Constructor</a> and which writes to another Token Stream.  
				</p>
</div>
<div class="section" title="Token Stream">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="tokenstream"></a>Token Stream</h3>
</div>
</div>
</div>
<p>The 
					<a class="link" href="serialization.html#parsetreeconstructor" title="Parse Tree Constructor">Parse Tree Constructor</a>, the 
					<a class="link" href="serialization.html#hiddentokenmerger" title="Hidden Token Merger">Hidden Token Merger</a> and the 
					<a class="link" href="formatting.html" title="Formatting (Pretty Printing)">Formatter</a> use Token Streams for their output, and the latter two for their input as well. This makes them chainable. Token Streams can be converted to 
					<code class="code">String</code> using the 
					<code class="code">TokenStringBuffer</code> and to 
					<code class="code">java.io.OutputStream</code> using the 
					<code class="code">TokenOutputStream</code>. Maybe there will be an implementation to reconstruct a node model as well at some point in the future. While providing fast output due to the stream pattern, Token Streams allow easy manipulation of the stream, such as mixing in whitespaces or manipulating them.    
				</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;interface&nbsp;ITokenStream&nbsp;{<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;close()&nbsp;throws&nbsp;IOException;<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;writeHidden(EObject&nbsp;grammarElement,&nbsp;String&nbsp;value)&nbsp;throws&nbsp;IOException;<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;writeSemantic(EObject&nbsp;grammarElement,&nbsp;String&nbsp;value)&nbsp;throws&nbsp;IOException;<br>
}<br>

<br>
&nbsp;<br>

<br>

</code>
</p>
</div>
</div>
</body>
</html>
