<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Linking</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="RuntimeConcepts.html" title="Runtime Concepts">
<link rel="prev" href="validation.html" title="Validation">
<link rel="next" href="scoping.html" title="Scoping">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Linking</h1>
<div class="section" title="Linking">
<div class="titlepage">
<div>
<div>
<h2 class="title" style="clear: both">
<a name="linking"></a>Linking</h2>
</div>
</div>
</div>
<p>The linking feature allows for specification of cross references within an Xtext grammar.
				The following things are needed for the linking:</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>declaration of a cross link in the grammar (at least in the meta model)</p>
</li>
<li class="listitem">
<p>specification of linking semantics</p>
</li>
</ol>
</div>
<div class="section" title="Declaration of cross links">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Declarationofcrosslinks"></a>Declaration of cross links</h3>
</div>
</div>
</div>
<p>In the grammar a cross reference is specified using square brackets.</p>
<div class="literallayout">
<p>
<code class="code">CrossReference&nbsp;:<br>
&nbsp;&nbsp;&nbsp;'['&nbsp;ReferencedEClass&nbsp;('|'&nbsp;terminal=AbstractTerminal)?&nbsp;']'<br>

</code>
</p>
</div>
<p>Example:</p>
<div class="literallayout">
<p>
<code class="code">ReferringType&nbsp;:<br>
&nbsp;&nbsp;&nbsp;'ref'&nbsp;referencedObject=[Entity|(ID|STRING)];<br>

</code>
</p>
</div>
<p>The meta model derivation would create an 
					<code class="code">EClass</code> &lsquo;ReferringType&rsquo; with an 
					<code class="code">EReference</code> &lsquo;referencedObject&rsquo; of type &lsquo;Entity&rsquo; (containment=false). The referenced object would be identified either by an ID or a STRING and the surrounding information (see scoping).
				</p>
<p>Example: While parsing a given input string, say</p>
<div class="literallayout">
<p>
<code class="code">ref&nbsp;Entity01<br>

</code>
</p>
</div>
<p>Xtext produces an instance of &lsquo;ReferringType&rsquo;. After this parsing step it enters the linking phase and tries to find an instance of '&lsquo;Entity&rsquo;' using the parsed text &lsquo;Entity01&rsquo;. The input </p>
<div class="literallayout">
<p>
<code class="code">ref&nbsp;"EntityWith&Auml;&Ouml;&Uuml;"<br>

</code>
</p>
</div>
<p>would work analogously. This is not an ID (umlauts are not allowed), but a STRING (as it is apparent from the quotation marks).</p>
</div>
<div class="section" title="Specification of linking semantics">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Specificationoflinkingsemantics"></a>Specification of linking semantics</h3>
</div>
</div>
</div>
<p>The default 
					<code class="code">ILinker</code> implementation installs 
					<code class="code">EObject</code> proxies for all crosslinks, which are then resolved on demand.
					The actual cross ref resolution is done in 
					<code class="code">LazyLinkingResource.getEObject(String)</code> and delegates to 
					<code class="code">ILinkingService</code>.
					Although the default linking behavior is appropriate in many cases there might be scenarios where this is not sufficient. For each grammar a linking service can be implemented/configured, which implements the following interface:
				</p>
<div class="literallayout">
<p>
<code class="code">@Stable(since&nbsp;=&nbsp;"0.7.0",&nbsp;subClass&nbsp;=&nbsp;AbstractLinkingService.class)<br>
public&nbsp;interface&nbsp;ILinkingService&nbsp;{<br>

<br>
&nbsp;&nbsp;/**<br>
&nbsp;&nbsp;&nbsp;*&nbsp;Returns&nbsp;all&nbsp;{@link&nbsp;EObject}s&nbsp;referenced&nbsp;by&nbsp;the&nbsp;given&nbsp;link&nbsp;text&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;*&nbsp;given&nbsp;context.&nbsp;But&nbsp;does&nbsp;not&nbsp;set&nbsp;the&nbsp;references&nbsp;or&nbsp;modifies&nbsp;the&nbsp;passed<br>
&nbsp;&nbsp;&nbsp;*&nbsp;information&nbsp;somehow<br>
&nbsp;&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;List&lt;EObject&gt;&nbsp;getLinkedObjects(<br>
&nbsp;&nbsp;&nbsp;&nbsp;EObject&nbsp;context,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;EReference&nbsp;reference,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;AbstractNode&nbsp;node)<br>
		throws&nbsp;IllegalNodeException;<br>

<br>
&nbsp;&nbsp;/**<br>
&nbsp;&nbsp;&nbsp;*&nbsp;Returns&nbsp;the&nbsp;textual&nbsp;representation&nbsp;of&nbsp;a&nbsp;given&nbsp;object&nbsp;as&nbsp;it&nbsp;would&nbsp;be<br>
&nbsp;&nbsp;&nbsp;*&nbsp;serialized&nbsp;in&nbsp;the&nbsp;given&nbsp;context.<br>
&nbsp;&nbsp;&nbsp;*&nbsp;<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;object<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;reference<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;context<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;the&nbsp;text&nbsp;representation.<br>
&nbsp;&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;String&nbsp;getLinkText(<br>
&nbsp;&nbsp;&nbsp;&nbsp;EObject&nbsp;object,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;EReference&nbsp;reference,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;EObject&nbsp;context);<br>
}<br>

<br>

</code>
</p>
</div>
<p>The method 
					<code class="code">getLinkedObjects</code> is directly related to this topic whereas 
					<code class="code">getLinkText</code> adresses complementary functionality: it is used for Serialization.
				</p>
<p>A simple implementation of the linking service (
					<code class="code">DefaultLinkingService</code>) is shipped with Xtext and is used for any grammar per default. It uses the default implementation of 
					<code class="code">IScopeProvider</code>. 
				</p>
</div>
<div class="section" title="Default linking semantics">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Defaultlinkingsemantics"></a>Default linking semantics</h3>
</div>
</div>
</div>
<p>The default implementation for all languages, looks within the current file for an EObject of the respective type (&lsquo;Entity&rsquo;) which has a name attribute set to &lsquo;Entity01&rsquo;. </p>
<p>Given the grammar :</p>
<div class="literallayout">
<p>
<code class="code">Model&nbsp;:&nbsp;(stuff+=(Ref|Entity))*;<br>
&nbsp;Ref&nbsp;:&nbsp;'ref'&nbsp;referencedObject=[Entity|ID]&nbsp;';';<br>
&nbsp;Entity&nbsp;:&nbsp;'entity'&nbsp;name=ID&nbsp;';';<br>

<br>

</code>
</p>
</div>
<p>In the following model :</p>
<div class="literallayout">
<p>
<code class="code">ref&nbsp;Entity01;<br>
&nbsp;entity&nbsp;Entity01;<br>

</code>
</p>
</div>
<p>the 
					<code class="code">ref</code> would be linked to the declared entity (
					<code class="code">entity Entity01;</code>).
				</p>
<div class="section" title="Default Imports">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="DefaultImports"></a>Default Imports</h4>
</div>
</div>
</div>
<p>There is a default implementation for inter-resource referencing, which as well uses convention.
						Each string in a model which is assigned to an EAttribute with the name &lsquo;importURI&rsquo;, will be interpreted as a URI and used to be loaded using the ResourceSet of the current Resource.</p>
<p>For example, given the following grammar :</p>
<div class="literallayout">
<p>
<code class="code">Model&nbsp;:&nbsp;(imports+=Import)*&nbsp;(stuff+=(Ref|Entity))*;<br>
&nbsp;Import&nbsp;:&nbsp;'import'&nbsp;importURI=STRING&nbsp;';';<br>
&nbsp;Ref&nbsp;:&nbsp;'ref'&nbsp;referencedObject=[Entity|ID]&nbsp;';';<br>
&nbsp;Entity&nbsp;:&nbsp;'entity'&nbsp;name=ID&nbsp;';';<br>

<br>

</code>
</p>
</div>
<p>It would be possible to write three files using in that language where the first references the other two, like this:</p>
<div class="literallayout">
<p>
<code class="code">//file&nbsp;model.dsl<br>
&nbsp;import&nbsp;"model1.dsl";<br>
&nbsp;import&nbsp;"model2.dsl";<br>
&nbsp;<br>
&nbsp;ref&nbsp;Foo;<br>
&nbsp;entity&nbsp;Bar;<br>

<br>

</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">//file&nbsp;model1.dsl&nbsp;<br>
&nbsp;entity&nbsp;Stuff;<br>

<br>

</code>
</p>
</div>
<div class="literallayout">
<p>
<code class="code">//file&nbsp;model2.dsl<br>
&nbsp;entity&nbsp;Foo;<br>

<br>

</code>
</p>
</div>
<p>The resulting default scope list is as follows:</p>
<div class="literallayout">
<p>
<code class="code">Scope&nbsp;(model.dsl)&nbsp;{<br>
&nbsp;&nbsp;parent&nbsp;:&nbsp;Scope&nbsp;(model1.dsl)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;parent&nbsp;:&nbsp;Scope&nbsp;(model2.dsl)&nbsp;{}<br>
&nbsp;&nbsp;}<br>
&nbsp;}<br>

<br>

</code>
</p>
</div>
<p>So, the outer scope is asked for an Entity named 
						<code class="code">Foo</code>, as it does not contain such a declaration itself its parent is asked and so on.
						The default implementation of 
						<code class="code">IScopeProvider</code> creates this kind of scope chain.
					</p>
</div>
</div>
</div>
</body>
</html>
