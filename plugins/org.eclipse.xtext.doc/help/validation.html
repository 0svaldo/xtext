<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Validation</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="RuntimeConcepts.html" title="Runtime Concepts">
<link rel="prev" href="Logging.html" title="Logging">
<link rel="next" href="linking.html" title="Linking">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Validation</h1>
<p>Static analysis or validation is one of the most interesting aspects when developing a programming language. The users of your languages will be grateful
				if they get informative feedback as they type. 
				In Xtext there are basically three different kinds of validation.</p>
<div class="section" title="Syntactical Validation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="syntactical_validation"></a>Syntactical Validation</h3>
</div>
</div>
</div>
<p>The syntactical correctness of any textual input is validated automatically by the parser. The error messages are generated by the underlying parser technology and cannot be customized using a general hook.
					Any syntax errors can be retrieved from the Resource using the common EMF API:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">org.eclipse.emf.ecore.resource.Resource.getErrors()</code>
						
</p>
</li>
<li class="listitem">
<p>
							
<code class="code">org.eclipse.emf.ecore.resource.Resource.getWarnings()</code>
						
</p>
</li>
</ul>
</div>
</div>
<div class="section" title="Crosslink Validation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="linking_validation"></a>Crosslink Validation</h3>
</div>
</div>
</div>
<p>Any broken crosslinks can be checked generically. As crosslink resolution is done lazily (see 
					<a class="link" href="linking.html" title="Linking">linking</a>), any broken links are resolved lazily as well.
					If you want to validate whether all links are valid, you will have to navigate through the model so that all installed EMF proxies get resolved. This is done automatically in the editor.
				</p>
<p>Any unresolvable crosslinks will be reported and can be obtained through:</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">org.eclipse.emf.ecore.resource.Resource.getErrors()</code>
						
</p>
</li>
<li class="listitem">
<p>
							
<code class="code">org.eclipse.emf.ecore.resource.Resource.getWarnings()</code>
						
</p>
</li>
</ul>
</div>
</div>
<div class="section" title="Custom Validation">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="custom_validation"></a>Custom Validation</h3>
</div>
</div>
</div>
<p>In addition to the afore mentioned kinds of validation, which are more or less done automatically, you can specify additional constraints specific for your Ecore model.
					We leverage existing EMF API (mainly 
					<code class="code">EValidator</code>) and have put some convenience stuff on top. 
					Basically all you need to do is to make sure that an 
					<code class="code">EValidator</code> is registered for your 
					<code class="code">EPackage</code>. The registry for 
					<code class="code">EValidators</code> (
					<code class="code">EValidator.Registry.INSTANCE</code>) can only be filled programmatically.
					That means contrary to the EPackage and 
					<code class="code">Resource.Factory</code> registries there is no Equinox extension point to populate the validator registry.
				</p>
<p>For Xtext we provide a 
					<a class="link" href="configuration.html#generator_fragment" title="Generator Fragments">generator fragment</a> for the convenient Java-based 
					<code class="code">EValidator</code> API. Just add the following fragment to your generator configuration and you are good to go:
				</p>
<div class="literallayout">
<p>
<code class="code">&lt;fragment&nbsp;class=<br>
&nbsp;&nbsp;"org.eclipse.xtext.generator.validation.JavaValidatorFragment"/&gt;<br>

<br>

</code>
</p>
</div>
<p>The generator will provide you with two Java classes. An abstract class generated to 
					<code class="code">src-gen/</code> which extends the library class 
					<code class="code">AbstractDeclarativeValidator</code>. This one just registers the EPackages for which this validator introduces constraints.
					The other class is a subclass of that abstract class and is generated to the 
					<code class="code">src/</code> folder in order to be edited by you. That&rsquo;s where you put the constraints in.
				</p>
<p>The purpose of the 
					<code class="code">AbstractDeclarativeValidator</code> is to allow you to write constraints in a declarative way &ndash; as the class name already suggests. That is instead of writing exhaustive if-else constructs or extending the generated EMF switch you just have to add the <code class="code">@Check</code> annotation to any method and it will be invoked automatically when validation takes place.
					Moreover you can state for what type the respective constraint method is, just by declaring a typed parameter. This also lets you avoid any type casts.  
					In addition to the reflective invocation of validation methods the 
					<code class="code">AbstractDeclarativeValidator</code> provides a couple of convenient assertions.
				</p>
<p>All in all this is very similar to how JUnit works. Here is an example:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
public&nbsp;class&nbsp;DomainmodelJavaValidator&nbsp;<br>
&nbsp;&nbsp;extends&nbsp;AbstractDomainmodelJavaValidator&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;@Check<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;checkTypeNameStartsWithCapital(Type&nbsp;type)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!Character.isUpperCase(type.getName().charAt(0)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warning("Name&nbsp;should&nbsp;start&nbsp;with&nbsp;a&nbsp;capital",&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DomainmodelPackage.TYPE__NAME);<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
</div>
<div class="section" title="Quickfixes">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="quickfixes"></a>Quickfixes</h3>
</div>
</div>
</div>
<p>For validations written using the 
					<code class="code">AbstractDeclarativeValidator</code> it is possible to provide corresponding quickfixes in the editor. To be able to implement a quickfix for a given diagnostic (a warning or error) the underlying 
					<span class="emphasis"><em>cause</em></span> of the diagnostic must be known (i.e. what actual problem does the diagnostic represent?), otherwise the fix doesn&rsquo;t know what needs to be done. As we don&rsquo;t want to deduce this from the diagnostic&rsquo;s error message we associate a problem specific 
					<span class="emphasis"><em>code</em></span> with the diagnostic.
				</p>
<p>In the following example (from 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.example.domainmodel/src/org/eclipse/xtext/example/validation/DomainmodelJavaValidator.java?root=Modeling_Project&view=co" target="_new">DomainmodelJavaValidator</a>) the diagnostic&rsquo;s 
					<span class="emphasis"><em>code</em></span> is given by the last argument to the 
					<code class="code">warning()</code> method and it is a reference to the static 
					<code class="code">int</code> field 
					<code class="code">INVALID_TYPE_NAME</code> in the validator class.
				</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warning("Name&nbsp;should&nbsp;start&nbsp;with&nbsp;a&nbsp;capital",&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DomainmodelPackage.TYPE__NAME,&nbsp;INVALID_TYPE_NAME);<br>

<br>

</code>
</p>
</div>
<p>Now that the validation has a unique code identifying the problem we can register quickfixes against it. We start by adding the 
					<code class="code">org.eclipse.xtext.ui.generator.quickfix.QuickfixProviderFragment</code> to our workflow and after regenerating the code we should find an empty class 
					<code class="code">MyDslQuickfixProvider</code> in our DSL&rsquo;s UI project.
				</p>
<p>Continuing with the 
					<code class="code">INVALID_TYPE_NAME</code> problem from the Domainmodel example we add a method with which the problem can be fixed (see also 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.example.domainmodel.ui/src/org/eclipse/xtext/example/quickfix/DomainmodelQuickfixProvider.java?root=Modeling_Project&view=co" target="_new">DomainmodelQuickfixProvider</a>):
				</p>
<div class="literallayout">
<p>
<code class="code">
<br>
public&nbsp;class&nbsp;DomainmodelQuickfixProvider&nbsp;extends&nbsp;AbstractDeclarativeQuickfixProvider&nbsp;{<br>

<br>
&nbsp;&nbsp;@Fix(code&nbsp;=&nbsp;DomainmodelJavaValidator.INVALID_TYPE_NAME,&nbsp;label&nbsp;=&nbsp;"Capitalize&nbsp;name",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description&nbsp;=&nbsp;"Capitalize&nbsp;name&nbsp;of&nbsp;type")<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;fixName(Type&nbsp;type,&nbsp;IMarker&nbsp;marker)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;type.setName(type.getName().toUpperCase());<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>By using the correct signature (see below) and annotating the method with the 
					<code class="code">Fix</code> annotation referencing the code we specified in the validator, Xtext knows that this method implements a fix for the problem. This also allows us to annotate multiple methods as fixes for the same problem.
				</p>
<p>The 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui.core/src/org/eclipse/xtext/ui/core/editor/quickfix/Fix.java?root=Modeling_Project&view=co" target="_new">Fix</a> annotation accepts the following arguments:
				</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<span class="bold"><strong>code</strong></span> - the code of the validation this fix is applicable to
						</p>
</li>
<li class="listitem">
<p>
							
<span class="bold"><strong>label</strong></span> - the label text to display for this fix in the editor
						</p>
</li>
<li class="listitem">
<p>
							
<span class="bold"><strong>description</strong></span> - the description to display for this fix
						</p>
</li>
<li class="listitem">
<p>
							
<span class="bold"><strong>icon</strong></span> - the name of the icon file (in the UI plug-in&rsquo;s 
							<code class="code">icons</code> directory) to display for this fix
						</p>
</li>
</ul>
</div>
<p>In addition to the 
					<code class="code">Fix</code> annotation our fix method also needs to have the correct signature: Its first argument needs to be of a type which is compatible with the type of the object the validation was created for (the validation&rsquo;s 
					<span class="emphasis"><em>source</em></span>) and its second argument is of type 
					<span class="emphasis"><em>IMarker</em></span>.
				</p>
<p>The fix method will be invoked inside a modification transaction and the first argument will be passed as the actual object the validation was created for and the second argument will be passed as the Eclipse marker that corresponds to the validation. This makes it very easy for the fix method to modify the model as necessary. After the method returns the model as well as the Xtext editor&rsquo;s content will be updated accordingly. If the method fails (throws an exception) the change will not be committed.</p>
</div>
<div class="section" title="Validation with the Check language">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="check_based_validation"></a>Validation with the Check language</h3>
</div>
</div>
</div>
<p>In addition to the Java-based validation code you can use the language Check (from M2T/Xpand) to implement constraint checks against your model. To do so, you have to configure the 
					<a class="link" href="configuration.html#generator" title="The Generator">generator</a> with the

					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/validation/CheckFragment.java?root=Modeling_Project&view=co" target="_new">CheckFragment</a>.
					Please note, that you can combine both types of validation in your project. 
				</p>
<div class="literallayout">
<p>
<code class="code">&lt;fragment&nbsp;class=<br>
&nbsp;&nbsp;"org.eclipse.xtext.generator.validation.CheckFragment"/&gt;<br>
&nbsp;&nbsp;<br>

</code>
</p>
</div>
<p>After regenerating your language artifacts you will find three new files &ldquo;YourLanguageChecks.chk&rdquo;, &ldquo;YourLanguageFastChecks.chk&rdquo; and &ldquo;YourLanguageExpensiveChecks.chk&rdquo; in the 
					<code class="code">src/</code> folder in the sub-package 
					<code class="code">validation</code>.  The checks in these files will be executed when saving a file, while typing (FastChecks) or when triggering the validation explicitly (ExpensiveChecks). When using Check the example of the previous chapter could be written like this.
				</p>
<div class="literallayout">
<p>
<code class="code">context&nbsp;Type#name&nbsp;WARNING&nbsp;"Name&nbsp;should&nbsp;start&nbsp;with&nbsp;a&nbsp;capital":<br>
&nbsp;&nbsp;name.toFirstUpper()&nbsp;==&nbsp;name;&nbsp;&nbsp;<br>

<br>

</code>
</p>
</div>
<p>Each check works in a specific context (here: 
					<code class="code">Type</code>) and can further denote a feature to which a warning or error should be attached to (here: 
					<code class="code">name</code>). Each check could either be a 
					<code class="code">WARNING</code> or an 
					<code class="code">ERROR</code> with a given string to explain the situation. The essential part of each check is an invariant that must hold true for the given context. If it fails the check will produce an issue with the provided explanation.
				</p>Please read more about the Check language as well as the underlying expression language in Xpand&rsquo;s reference documentation which is shipped as Eclipse help. 
			</div>
<div class="section" title="Test Validators">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="test_validators"></a>Test Validators</h3>
</div>
</div>
</div>
<p>If you have implemented your validators by extending 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/AbstractDeclarativeValidator.java?root=Modeling_Project&view=co" target="_new">AbstractDeclarativeValidator</a>, there are helper classes which may assist you when testing your validators.
				</p>
<p>Testing validators typicallally works as follows: </p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>The test creates some models which intentionally violate some constraints.</p>
</li>
<li class="listitem">
<p>The test runs some choosen @Check-methods from the validator.</p>
</li>
<li class="listitem">
<p>The test asserts whether the @Check-methods have raised the expected warnings and errors.</p>
</li>
</ol>
</div>
<p>To create models, you can either use EMF&rsquo;s 
					<code class="code">ResourceSet</code> to load models from your hard disk or you can utilize the 
					<code class="code">&lt;MyLanguage&gt;Factory</code> (which EMF generates for each 
					<code class="code">EPackage</code>) to construct the needed model elements manually. While the fist option has the advantages that you can edit your models in your textual concrete syntax, the second option has the advantage that you can create partial models.
				</p>
<p>To run the @Check-methods and ensure they raise the intended errors and warnings, you can utilize 
					<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/ValidatorTester.java?root=Modeling_Project&view=co" target="_new">ValidatorTester</a> as shown by the following example:
				</p>
<p>Validator:</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;MyLanguageValidator&nbsp;extends&nbsp;AbstractDeclarativeValidator&nbsp;{<br>
&nbsp;&nbsp;@Check<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;checkFooElement(FooElement&nbsp;element)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;if(element.getBarAttribute().contains("foo"))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error("Only&nbsp;Foos&nbsp;allowed",&nbsp;element,&nbsp;MyLanguagePackage.FOO_ELEMENT__BAR_ATTRIBUTE,&nbsp;101);<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>JUnit-Test:</p>
<div class="literallayout">
<p>
<code class="code">public&nbsp;class&nbsp;MyLanguageValidatorTest&nbsp;extends&nbsp;TestCase&nbsp;{<br>

<br>
&nbsp;&nbsp;private&nbsp;ValidatorTester&lt;MyLanguageValidator&gt;&nbsp;tester;<br>

<br>
&nbsp;&nbsp;@Override<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;setUp()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;MyLanguageValidator&nbsp;val&nbsp;=&nbsp;new&nbsp;MyLanguageValidator();<br>
&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;MyLanguageStandaloneSetup().createInjectorAndDoEMFRegistration().injectMembers(val);<br>
&nbsp;&nbsp;&nbsp;&nbsp;tester&nbsp;=&nbsp;new&nbsp;ValidatorTester&lt;TestingValidator&gt;(val);<br>
&nbsp;&nbsp;}<br>

<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;testError()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;FooElement&nbsp;model&nbsp;=&nbsp;MyLanguageFactory.eINSTANCE.createFooElement()<br>
&nbsp;&nbsp;&nbsp;&nbsp;model.setBarAttribute("barbarbarbarfoo");<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;tester.validator().checkFooElement(model);<br>
&nbsp;&nbsp;&nbsp;&nbsp;tester.diagnose().assertError(101);<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;testError2()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;FooElement&nbsp;model&nbsp;=&nbsp;MyLanguageFactory.eINSTANCE.createFooElement()<br>
&nbsp;&nbsp;&nbsp;&nbsp;model.setBarAttribute("barbarbarbarfoo");<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;tester.validate(model).assertError(101);<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>This example uses JUnit 3, but since the involved classes from Xtext have no dependency on JUnit whatsoever, JUnit 4 and other testing frameworks will work as well.  JUnit runs the 
					<code class="code">setUp()</code>-method before each testcase and thereby helps to create some common state. In this example, the validator (
					<code class="code">MyLanguageValidator</code>) is instantiated manually and initialized via Google Guice&rsquo;s dependency injection. Then the 
					<code class="code">ValidatorTester</code> is created. It acts as a wrapper for the validator, ensures that the validator has a valid state and provides convenient access to the validator itself (
					<code class="code">tester.validator()</code>) as well as to the utility classes which assert diagnostics created by the validator (
					<code class="code">tester.diagnose()</code>). Please be aware that you have to call 
					<code class="code">validator()</code> before you can call 
					<code class="code">diagnose()</code>. However, you can call 
					<code class="code">validator()</code> multiple times in a row.
				</p>
<p>While 
					<code class="code">validator()</code> allows to call the validator&rsquo;s @Check-methods directly, 
					<code class="code">validate(model)</code> leaves it to the framework to call the applicable @Check-methods. However, to avoid side-effects between tests, it is recommended to call the @Check-methods directly.
				</p>
<p>
					
<code class="code">diagnose()</code> and 
					<code class="code">validate(model)</code> return an object of type @{org.eclipse.xtext/src/org/eclipse/xtext/validation/AssertableDiagnostics} which provides several 
					<code class="code">assert</code>-methods to verify whether the expected diagnostics are present:
				</p>
<div class="itemizedlist">
<ul class="itemizedlist" type="disc">
<li class="listitem">
<p>
							
<code class="code">assertError(int code)</code>: There must be one diagnostic with severity ERROR and the supplied error code.
						</p>
</li>
<li class="listitem">
<p>
							
<code class="code">assertErrorContains(String messageFragment)</code>:  There must be one diagnostic with severity ERROR and its message must contain 
							<code class="code">messageFragment</code>.
						</p>
</li>
<li class="listitem">
<p>
							
<code class="code">assertError(int code, String messageFragment)</code>: Verifies severity, error code and messageFragment.
						</p>
</li>
<li class="listitem">
<p>
							
<code class="code">assertWarning(...)</code>: This method is available for the same combination of parameters as 
							<code class="code">assertError()</code>.
						</p>
</li>
<li class="listitem">
<p>
							
<code class="code">assertOK()</code>: Expects that no diagnostics (errors, warnings etc.) have been raised.   
						</p>
</li>
<li class="listitem">
<p>
							
<code class="code">assertDiagnostics(int severity, int code, String messageFragment)</code>: Verifies severity, error code and messageFragment.
						</p>
</li>
<li class="listitem">
<p>
							
<code class="code">assertAll(DiagnosticPredicate... predicates)</code>: Allows to describe multiple diagnostics at the same time and verifies that all of them are present. Class @{org.eclipse.xtext/src/org/eclipse/xtext/validation/AssertableDiagnostics} contains static 
							<code class="code">error()</code> and 
							<code class="code">warning()</code>-methods which help to create the needed 
							<code class="code">DiagnosticPredicate</code>. Example: 
							<code class="code">assertAll(error(123), warning("some part of the message"))</code>. 
						</p>
</li>
<li class="listitem">
<p>
							
<code class="code">assertAny(DiagnosticPredicate predicate)</code>: Asserts that a diagnostic exists which matches the predicate. 
						</p>
</li>
</ul>
</div>
</div>
</body>
</html>
