<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>The Syntax</title>
<link href="book.css" rel="stylesheet" type="text/css">
<meta content="DocBook XSL Stylesheets V1.75.1" name="generator">
<link rel="home" href="index.html" title="Xtext User Guide">
<link rel="up" href="grammarLanguage.html" title="The Grammar Language">
<link rel="prev" href="grammarLanguage.html" title="The Grammar Language">
<link rel="next" href="metamodelInference.html" title="Meta-Model inference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">The Syntax</h1>
<p>In the following the different concepts of the grammar language are explained. </p>
<div class="section" title="Language Declaration">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="LanguageDeclaration"></a>Language Declaration</h3>
</div>
</div>
</div>
<p>The first line  </p>
<div class="literallayout">
<p>
<code class="code">grammar&nbsp;my.pack.SecretCompartments&nbsp;with&nbsp;org.eclipse.xtext.common.Terminals<br>

</code>
</p>
</div>
<p>declares the name of the grammar. Xtext leverages Java&rsquo;s classpath mechanism. This means that the name can be any valid Java qualifier. The file name needs to correspond and have the file extension '&lsquo;xtext&rsquo;'. This means that the name needs to be 
					<code class="code">SecretCompartments.xtext</code> and must be placed in package 
					<code class="code">my.pack</code> somewhere on your project&rsquo;s class path.
				</p>
<p>The first line is also used to declare any used language (for mechanism details cf. 
					<a class="link" href="grammarMixins.html" title="Grammar Mixins">Grammar Mixins</a>).
				</p>
</div>
<div class="section" title="EPackage declarations">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="EPackagedeclarations"></a>EPackage declarations</h3>
</div>
</div>
</div>
<p>Xtext parsers instantiate Ecore models (aka meta model). An Ecore model basically consists of an EPackage containing EClasses, EDatatypes and EEnums.
					Xtext can infer Ecore models from a grammar (see 
					<a class="link" href="metamodelInference.html" title="Meta-Model inference">Meta-Model Inference</a>) but it is also possible to instantiate existing Ecore models. You can even mix this, use multiple existing Ecore models and infer some others from one grammar. 
				</p>
<div class="section" title="EPackage generation">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EPackagegeneration"></a>EPackage generation</h4>
</div>
</div>
</div>
<p>The easiest way to get started is to let Xtext infer the meta model from your grammar. This is what is done in the secret compartment example. To do so just state:</p>
<div class="literallayout">
<p>
<code class="code">generate&nbsp;secretcompartment&nbsp;http://www.eclipse.org/secretcompartment<br>

</code>
</p>
</div>
<p>Which means: generate an EPackage with name 
						<code class="code">secretcompartment</code> and nsURI 
						<code class="code">http://www.eclipse.org/secretcompartment</code> (these are the properties needed to create an EPackage). 
						The whole algorithm used to derive complete Ecore models from Xtext grammars is described in section 
						<a class="link" href="metamodelInference.html" title="Meta-Model inference">Meta-Model Inference</a>.
					</p>
</div>
<div class="section" title="EPackage import">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="EPackageimport"></a>EPackage import</h4>
</div>
</div>
</div>
<p>If you already have an existing EPackage, you can import it using either a namespace URI or a resource URI (URIs are an EMF concept).</p>
<div class="section" title="Using namespace URIs to import existing EPackages">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="UsingnamespaceURIstoimportexistingEPackages"></a>Using namespace URIs to import existing EPackages</h5>
</div>
</div>
</div>
<p>You can import existing EPackages using the following syntax:</p>
<div class="literallayout">
<p>
<code class="code">import&nbsp;"http://www.eclipse.org/secretcompartment"<br>

</code>
</p>
</div>
<p>Note that if you use a namespace URI, the corresponding EPackage needs to be installed into the workbench, so that the editor can find it.
							At runtime (i.e. when starting the generator) you need to make sure that the corresponding EPackage is registered in 
							<code class="code">EPackage.Registry.INSTANCE</code>. If you use MWE to drive your code generator, you need to add the following lines to your workflow file:
						</p>
<div class="literallayout">
<p>
<code class="code">&lt;bean&nbsp;class="org.eclipse.emf.mwe.utils.StandaloneSetup"&nbsp;<br>
&nbsp;&nbsp;platformUri="${runtimeProject}/.."&gt;<br>
&nbsp;&nbsp;&lt;registerGeneratedEPackage&nbsp;value="foo.bar.MyPackage"/&gt;<br>
&lt;/bean&gt;<br>

<br>

</code>
</p>
</div>
<p>using namespace URIs is typically only interesting when using common Ecore models, such as Ecore itself or the UML metamodel. If you&rsquo;re developing the EPackage together with the DSL but don&rsquo;t want to have it derived from the grammar for some reason, we suggest to use a resource URI.</p>
</div>
<div class="section" title="Using resource URIs to import existing EPackages">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="UsingresourceURIstoimportexistingEPackages"></a>Using resource URIs to import existing EPackages</h5>
</div>
</div>
</div>
<p>If the EPackage you want to use is somewhere in your workspace you should refer to it using a platform:/resource/ URI.
							Platform URIs are a special EMF construct, which allow for some kind of transparency between workspace projects and installed bundles. Consult the EMF documentation (we recomend the book) for details.</p>
<p>An import statement referring to an Ecore file by a platform:/resource/ URI looks like this: </p>
<div class="literallayout">
<p>
<code class="code">import&nbsp;"platform:/resource/my.project/modelFolder/MyEcore.ecore"<br>

</code>
</p>
</div>
<p>If you want to mix generated and imported Ecore models you&rsquo;ll have to configure the generator fragment in your MWE file responsible for generating the Ecore classes (
							<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/ecore/EcoreGeneratorFragment.java?root=Modeling_Project&view=co" target="_new">EcoreGeneratorFragment</a>) with resource URIs to the genmodels for the referenced Ecore models.
							Example:
						</p>
<div class="literallayout">
<p>
<code class="code">&lt;fragment&nbsp;class="org.eclipse.xtext.generator.ecore.EcoreGeneratorFragment"<br>
&nbsp;&nbsp;genModels="platform:/resource/my.project/model/myEcore.genmodel"/&gt;<br>

</code>
</p>
</div>
</div>
</div>
<div class="section" title="Using multiple packages / meta model aliases">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="Usingmultiplepackagesmetamodelaliases"></a>Using multiple packages / meta model aliases</h4>
</div>
</div>
</div>
<p>If you want to use multiple EPackages you need to specify aliases in the following way:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;generate&nbsp;secretcompartment&nbsp;http://www.eclipse.org/secretcompartment<br>
&nbsp;&nbsp;import&nbsp;http://www.eclipse.org/anotherPackage&nbsp;as&nbsp;another<br>

<br>

</code>
</p>
</div>
<p>When referring to a type somewhere in the grammar you need to qualify the reference using that alias (example '&lsquo;another::CoolType&rsquo;'). We&rsquo;ll see later where such type references occur.</p>
<p>It is also supported to put multiple EPackage imports into one alias. This is no problem as long as there are no two EClassifiers with the same name. In such cases none of them are referable. It is even possible to have multiple '&lsquo;import&rsquo;&lsquo;s and one &rsquo;&lsquo;generate&rsquo;' declared for the same alias. If you do so, for a reference to an EClassifier first the imported EPackages are scanned before it is assumed that a type needs to by generated into the to-be-generated package.</p>
<p>Example:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;&nbsp;generate&nbsp;toBeGenerated&nbsp;http://www.eclipse.org/toBeGenerated<br>
&nbsp;&nbsp;import&nbsp;http://www.eclipse.org/packContainingClassA<br>
&nbsp;&nbsp;import&nbsp;http://www.eclipse.org/packContainingClassB<br>

<br>

</code>
</p>
</div>
<p>With the declaration from above </p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>a reference to type 
								<code class="code">ClassA</code> would be linked to the EClass contained in 
								<code class="code">http://www.eclipse.org/packContainingClassA</code>, 
							</p>
</li>
<li class="listitem">
<p>a reference to type 
								<code class="code">ClassB</code> would be linked to the EClass contained in 
								<code class="code">http://www.eclipse.org/packContainingClassB</code>, 
							</p>
</li>
<li class="listitem">
<p>a reference to type 
								<code class="code">NotYetDefined</code> would be linked to a newly created EClass in 
								<code class="code">http://www.eclipse.org/toBeGenerated</code>
							
</p>
</li>
</ol>
</div>
<p>Note, that using this feature is not recommended, because it might cause problems, which are hard to track down.
						For instance, a reference to ''
						<code class="code">classA</code>'' would as well be linked to a newly created EClass, because the corresponding type in 
						<code class="code">http://www.eclipse.org/packContainingClassA</code> is spelled with a capital letter.
					</p>
</div>
</div>
<div class="section" title="Rules">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Rules"></a>Rules</h3>
</div>
</div>
</div>
<p>The default parsing is based on a homegrown packrat parser. It can be substituted by an Anltr parser through the Xtext service mechanism. Antlr is a sophisticated parser generator framework based on an LL(*) 
					<a class="ulink" href="http://bit.ly/ANTLR_LL_star_algorithm" target="_new">parsing algorithm</a>, that works quite well for Xtext. At the moment it is advised to download the plugin de.itemis.xtext.antlr (from update site 
					<code class="code">http://www.itemis.com/xtext/updatesite/milestones</code>) and use the Antlr Parser instead of the packrat parser (cf. 
					<a class="ulink" href="Xtext_Workspace_Setup" target="_new">Xtext Workspace Setup</a>).
				</p>
<p>Basically parsing can be separated in the following phases. </p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>lexing</p>
</li>
<li class="listitem">
<p>parsing</p>
</li>
<li class="listitem">
<p>linking</p>
</li>
<li class="listitem">
<p>validation</p>
</li>
</ol>
</div>
<div class="section" title="Terminal Rules">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="TerminalRules"></a>Terminal Rules</h4>
</div>
</div>
</div>
<p>In the first phase, i.e. lexing, a sequence of characters (the text input) is transformed into a sequence of so called tokens. 
						Each token consists of one or more characters and was matched by a particular terminal rule and represents an atomic symbol.
						In the secret compartments example there are no explicitly defined terminal rules, since it only uses the ID rule which is inherited from the grammar org.eclipse.xtext.common.Terminals (cf. 
						<a class="link" href="grammarMixins.html" title="Grammar Mixins">Grammar Mixins</a>).
						Terminal rules are also referred to as token rules or lexer rules. There is an informal naming convention that terminal-rule names are all uppercase.
					</p>
<p>Therein the ID rule is defined as follows:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;terminal&nbsp;ID&nbsp;:&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;('^')?('a'..'z'|'A'..'Z'|'_')&nbsp;('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>

</code>
</p>
</div>
<p>It says that a Token ID starts with an optional &lsquo;^&rsquo; character, which is called caret, followed by a letter (&lsquo;a&rsquo;..&lsquo;z&rsquo;|&lsquo;A&rsquo;..&lsquo;Z&rsquo;) or underscore (&lsquo;_&rsquo;) followed by any number of letters, underscores and numbers (&lsquo;0&rsquo;..&lsquo;9&rsquo;). </p>
<p>The caret is used to escape an identifier for cases where there are conflicts with keywords. It is removed by the ID rule&rsquo;s 
						<a class="link" href="valueconverter.html" title="Value Converter">ValueConverter</a>. 
					</p>
<p>This is the formal definition of terminal rules:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;TerminalRule&nbsp;:<br>
&nbsp;&nbsp;&nbsp;'terminal'&nbsp;name=ID&nbsp;('returns'&nbsp;type=TypeRef)?&nbsp;':'&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alternatives=TerminalAlternatives&nbsp;';'<br>
&nbsp;;<br>

<br>

</code>
</p>
</div>
<p>Note, that the order of terminal rules is crucial for your grammar, as they may hide each other. This is especially important for newly introduced rules in connection with mixed rules from used grammars. </p>
<p>If you for instance want to add a rule to allow fully qualified names in addition to simple IDs, you should implement it as a 
						<a class="link" href="syntax.html#datatypeRules" title="Datatype rules">datatype rule</a>, instead of adding another terminal rule.
					</p>
<div class="section" title="Return types">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="Returntypes"></a>Return types</h5>
</div>
</div>
</div>
<p>A terminal rule returns a value, which is a string (type ecore::EString) by default.
							However, if you want to have a different type you can specify it. For instance, the rule &lsquo;INT&rsquo; is defined as:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;terminal&nbsp;INT&nbsp;returns&nbsp;ecore::EInt&nbsp;:&nbsp;<br>
&nbsp;&nbsp;&nbsp;('0'..'9')+;<br>

<br>

</code>
</p>
</div>
<p>This means that the terminal rule INT returns instances of ecore::EInt. It is possible to define any kind of data type here, which just needs to be an instance of ecore::EDataType.
							In order to tell the parser how to convert the parsed string to a value of the declared data type, you need to provide your own implementation of &lsquo;IValueConverterService&rsquo; (cf. 
							<a class="link" href="valueconverter.html" title="Value Converter">value converters</a>).
						</p>
<p>The implementation needs to be registered as a service (cf. 
							<a class="link" href="">Service Framework</a>).
						</p>
<p>This is also the point where you can remove things like quotes from string literals or the caret (&lsquo;^&rsquo;) from identifiers.</p>
</div>
</div>
<div class="section" title="Extended Backus-Naur form expressions">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="ExtendedBackusNaurformexpressions"></a>Extended Backus-Naur form expressions</h4>
</div>
</div>
</div>
<p>Token rules are described using &ldquo;Extended Backus-Naur Form&rdquo;-like (EBNF) expressions. The different expressions are described in the following.
						The one thing all of these expressions have in common is the quantifier operator.
						There are four different quantities</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>exactly one (the default no operator)</p>
</li>
<li class="listitem">
<p>one or none (operator &ldquo;?&rdquo;)</p>
</li>
<li class="listitem">
<p>any (operator &ldquo;*&rdquo;)</p>
</li>
<li class="listitem">
<p>one or more (operator &ldquo;+&rdquo;)</p>
</li>
</ol>
</div>
<div class="section" title="Keywords / Characters">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="Keywords"></a>Keywords / Characters</h5>
</div>
</div>
</div>
<p>Keywords are a kind of token rule literals. 
							The ID rule in org.eclipse.xtext.common.Terminals for instance starts with a keyword :</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;terminal&nbsp;ID&nbsp;:&nbsp;'^'?&nbsp;....&nbsp;;<br>

</code>
</p>
</div>
<p>The question mark sets the cardinality to &ldquo;none or one&rdquo; (i.e. optional) like explained above.</p>
<p>Note that a keyword can have any length and contain arbitrary characters.</p>
</div>
<div class="section" title="Character Ranges">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="CharacterRanges"></a>Character Ranges</h5>
</div>
</div>
</div>
<p>A character range can be declared using the &lsquo;..&rsquo; operator.</p>
<p>Example:</p>
<div class="literallayout">
<p>
<code class="code">terminal&nbsp;INT&nbsp;returns&nbsp;ecore::EInt:&nbsp;('0'..'9')+&nbsp;;<br>

</code>
</p>
</div>
<p>In this case an INT is comprised of one or more (note the &lsquo;+&rsquo; operator) characters between (and including) &lsquo;0&rsquo; and &lsquo;9&rsquo;.</p>
</div>
<div class="section" title="Wildcard">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="Wildcard"></a>Wildcard</h5>
</div>
</div>
</div>
<p>If you want to allow any character you can simple write a dot:
							Example:</p>
<div class="literallayout">
<p>
<code class="code">FOO&nbsp;:&nbsp;'f'&nbsp;.&nbsp;'o';<br>

</code>
</p>
</div>
<p>The rule above would allow expressions like &lsquo;foo&rsquo;, &lsquo;f0o&rsquo; or even &lsquo;f\no&rsquo;.</p>
</div>
<div class="section" title="Until Token">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="UntilToken"></a>Until Token</h5>
</div>
</div>
</div>
<p>With the until token it is possible to state that everything should be consumed until a certain token occurs.
							The multi line comment is implemented using it:</p>
<div class="literallayout">
<p>
<code class="code">terminal&nbsp;ML_COMMENT	:&nbsp;'/*'&nbsp;-&gt;&nbsp;'*/'&nbsp;;<br>

</code>
</p>
</div>
<p>This is the rule for Java-style comments that begin with &lsquo;/*&rsquo; and end with &lsquo;*/&rsquo;.</p>
</div>
<div class="section" title="Negated Token">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="NegatedToken"></a>Negated Token</h5>
</div>
</div>
</div>
<p>All the tokens explained above can be inverted using a preceding explanation mark:</p>
<div class="literallayout">
<p>
<code class="code">terminal&nbsp;ML_COMMENT	:&nbsp;'/*'&nbsp;(!'*/')+&nbsp;;<br>

</code>
</p>
</div>
</div>
<div class="section" title="Rule Calls">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="RuleCalls"></a>Rule Calls</h5>
</div>
</div>
</div>
<p>Rules can refer to other rules. This is done by writing the name of the rule to be called.
							We refer to this as rule calls. Rule calls in terminal rules can only point to terminal rules.</p>
<p>Example:</p>
<div class="literallayout">
<p>
<code class="code">terminal&nbsp;QUALIFIED_NAME&nbsp;:&nbsp;ID&nbsp;('.'&nbsp;ID)*;<br>

</code>
</p>
</div>
</div>
<div class="section" title="Alternatives">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="Alternatives"></a>Alternatives </h5>
</div>
</div>
</div>
<p>Using alternatives one can state multiple different alternatives.
							For instance, the whitespace rule uses alternatives like this:</p>
<div class="literallayout">
<p>
<code class="code">terminal&nbsp;WS&nbsp;:&nbsp;('&nbsp;'|'\t'|'\r'|'\n')+&nbsp;;<br>

</code>
</p>
</div>
<p>That is a WS can be made of one or more whitespace characters (including &lsquo; &rsquo;,&lsquo;\t&rsquo;,&lsquo;\r&rsquo;,&lsquo;\n&rsquo;)</p>
</div>
<div class="section" title="Groups">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="Groups"></a>Groups</h5>
</div>
</div>
</div>
<p>Finally, if you put tokens one after another, the whole sequence is referred to as a group.
							Example:</p>
<div class="literallayout">
<p>
<code class="code">terminal&nbsp;FOO&nbsp;:&nbsp;'0x'&nbsp;('0'..'7')&nbsp;('0'..'9'|'A'..'F')&nbsp;;<br>

</code>
</p>
</div>
<p>That is the 4-digit hexadecimal code of ascii characters.</p>
</div>
</div>
</div>
<div class="section" title="Parser Rules">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="ParserRules"></a>Parser Rules</h3>
</div>
</div>
</div>
<p>The parser reads in a sequence of terminals and walks through the parser rules. That&rsquo;s why a parser rule &ndash; contrary to a terminal rule &ndash; does not produce a single terminal token but a tree of non-terminal and terminal tokens that lead to a so called parse tree (in Xtext it is a.k.a node model). Furthermore, parser rules are handled a as kind of a building plan for how to create EObjects that form the semantic model (the linked! AST). The different constructs like actions and assignments are used to derive types and initialize the semantic objects accordingly. </p>
<div class="section" title="Extended Backus-Naur Form expressions">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="ExtendedBackusNaurFormexpressions"></a>Extended Backus-Naur Form expressions</h4>
</div>
</div>
</div>
<p>In parser rules (as well as in datatype rules) not all the expressions available for terminal rules can be used. Character ranges, wildcards, the until token and the negation are currently only available for terminal rules. 
						Available in parser rules as well as in terminal rules are</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>
								
<a class="link" href="syntax.html#Groups" title="Groups">groups</a>, 
							</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="syntax.html#Alternatives" title="Alternatives">alternatives</a>, 
							</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="syntax.html#Keywords" title="Keywords / Characters">keywords</a> and 
							</p>
</li>
<li class="listitem">
<p>
								
<a class="link" href="syntax.html#RuleCalls" title="Rule Calls">rule calls</a>.
							</p>
</li>
</ol>
</div>
<p>In addition to these elements, there are some expressions used to direct how the AST is constructed, which are listed and explained in the following.</p>
<div class="section" title="Assignments">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="Assignments"></a>Assignments </h5>
</div>
</div>
</div>
<p>Assignments are used to assign parsed information to a feature of the current EClass. The current EClass is specified by the return type resp. if not explicitly stated it is implied that the type&rsquo;s name equals the rule&rsquo;s name.</p>
<p>Example:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;State&nbsp;:<br>
&nbsp;&nbsp;'state'&nbsp;name=ID<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('actions'&nbsp;'{'&nbsp;(actions+=[Command])+&nbsp;'}')?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(transitions+=Transition)*<br>
&nbsp;&nbsp;'end';<br>

<br>

</code>
</p>
</div>
<p>The syntactic declaration for states in the state machine example starts with a keyword &lsquo;state&rsquo; followed by an assignment :</p>
<div class="literallayout">
<p>
<code class="code">name=ID<br>

</code>
</p>
</div>
<p>Where the left hand side refers to a feature of the current EClass (in this case EClass &lsquo;State&rsquo;). 
							The right hand side can be a rule call, a keyword, a cross reference (explained later) or even an alternative comprised by the former.
							The type of the feature needs to be compatible with the type of the expression on the right. As ID returns an EString the feature name needs to be of type EString as well.</p>
</div>
</div>
<div class="section" title="Assignment Operators">
<div class="titlepage">
<div>
<div>
<h4 class="title">
<a name="AssignmentOperators"></a>Assignment Operators</h4>
</div>
</div>
</div>
<p>There are three different assignment operators, each with different semantics</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>the simple equal sign &ldquo;=&rdquo; is the straight forward assignment, and used for features which take only one element</p>
</li>
<li class="listitem">
<p>the &ldquo;+=&rdquo; sign (the add operator) expects a multi valued feature and adds the value on the right hand to that feature, which is, of course, a list feature</p>
</li>
<li class="listitem">
<p>the &ldquo;?=&rdquo; sign (boolean add operator) expects a feature of type EBoolean and sets it to true if the right hand side was consumed (no matter with what values)</p>
</li>
</ol>
</div>
<div class="section" title="Cross References">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="CrossReferences"></a>Cross References </h5>
</div>
</div>
</div>
<p>A unique feature of Xtext is the ability to declare cross links in the grammar. In traditional compiler construction the cross links are not established during parsing but in a later linking phase. This is the same in Xtext, but we allow to specify cross link information in the grammar, which is used during the linking phase.
							The syntax for cross links is:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;CrossReference&nbsp;:<br>
&nbsp;&nbsp;&nbsp;'['&nbsp;type=TypeRef&nbsp;('|'&nbsp;^terminal=CrossReferenceableTerminal&nbsp;)?&nbsp;']'<br>
&nbsp;;<br>

<br>

</code>
</p>
</div>
<p>For example, the transition is made up of two cross references, pointing to an event and a state:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;Transition&nbsp;:<br>
&nbsp;&nbsp;event=[Event]&nbsp;'=&gt;'&nbsp;state=[State];<br>

<br>

</code>
</p>
</div>
<p>It is important to understand that the text between the square brackets does not refer to another rule, but to the type!
							This is sometimes confusing, because one usually uses the same name for the rules and the types.
							That is if we had named the type for events differently like in the following the cross references needs to be adapted as well:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;Transition&nbsp;:<br>
&nbsp;&nbsp;event=[MyEvent]&nbsp;'=&gt;'&nbsp;state=[State];<br>
&nbsp;<br>
&nbsp;Event&nbsp;returns&nbsp;MyEvent&nbsp;:&nbsp;....;<br>

<br>

</code>
</p>
</div>
<p>Looking at the syntax definition of cross references, there is an optional part starting with a vertical bar followed by &lsquo;CrossReferenceableTerminal&rsquo;. This is the part describing the concrete text, from which the crosslink later should be established.
							By default (that&rsquo;s why it&rsquo;s optional) it is &ldquo;|ID&rdquo;.</p>
<p>You may even use alternatives as the referencable terminal. This way, either an ID or a STRING may be used as the referencable terminal, as it is possible in many SQL dialects.</p>
<div class="literallayout">
<p>
<code class="code">TableRef:&nbsp;table=[Table|(ID|STRING)];<br>

</code>
</p>
</div>
<p>Have a look at the 
							<a class="link" href="linking.html" title="Linking">linking section</a> in order to understand how linking is done.
						</p>
</div>
<div class="section" title="Simple Actions">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="SimpleActions"></a>Simple Actions </h5>
</div>
</div>
</div>
<p>By default the object to be returned by a parser rule is created lazily on the first assignment. Then the type of the EObject to be created is determined from the specified return type (or the rule name if not explicit return type is specified).
							With Actions however, creation of EObject can be made explicit. Xtext supports two kinds of Actions:</p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>simple actions</p>
</li>
<li class="listitem">
<p>assigned actions.</p>
</li>
</ol>
</div>
<p>If at some point you want to enforce creation of a specific type you can use alternatives or simple actions.
							In the following example TypeB must be a subtype of TypeA. An expression 
							<code class="code">A ident</code> should create an instance of TypeA, whereas 
							<code class="code">B ident</code> should instantiate TypeB.
						</p>
<p>Example with alternatives:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;MyRule&nbsp;returns&nbsp;TypeA&nbsp;:<br>
&nbsp;&nbsp;&nbsp;"A"&nbsp;name=ID&nbsp;|<br>
&nbsp;&nbsp;&nbsp;MyOtherRule;&nbsp;<br>
&nbsp;<br>
&nbsp;MyOtherRule&nbsp;returns&nbsp;TypeB&nbsp;:<br>
&nbsp;&nbsp;&nbsp;"B"&nbsp;name&nbsp;=&nbsp;ID;<br>

<br>

</code>
</p>
</div>
<p>Example with simple actions:  </p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;MyRule&nbsp;returns&nbsp;TypeA&nbsp;:<br>
&nbsp;&nbsp;&nbsp;"A"&nbsp;name=ID&nbsp;|<br>
&nbsp;&nbsp;&nbsp;"B"&nbsp;{TypeB}&nbsp;name=ID;&nbsp;<br>

<br>

</code>
</p>
</div>
<p>Generally speaking, the instance is created as soon as the parser hits the first assignment. However, Actions allow to explicitly instantiate any EClass. The notation 
							<code class="code">{TypeB}</code> will create an instance of TypeB and assign it to the result of the parser rule. This allows parser rules without any assignment and object creation without the need to introduce stub-rules.
						</p>
</div>
<div class="section" title="Unassigned rule calls">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="Unassignedrulecalls"></a>Unassigned rule calls </h5>
</div>
</div>
</div>
<p>We previously explained, that the EObject to be returned is created lazily when the first assignment occurs or when a simple action is evaluated. There is another way one can set the EObject to be returned, which we call an &ldquo;unassigned rule call&rdquo;.</p>
<p>Unassigned rule calls (the name suggests it) are rule calls to other parser rules, which are not used within an assignment. If there is no feature the returned value shall be assigned to, the value is assigned to the &ldquo;to-be-returned&rdquo; reference.</p>
<p>With unassigned rule calls one can, for instance, create rules which just dispatch between several other rules:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;AbstractToken&nbsp;:<br>
&nbsp;&nbsp;&nbsp;&nbsp;TokenA&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;TokenB&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;TokenC;<br>

<br>

</code>
</p>
</div>
<p>As 
							<code class="code">AbstractToken</code> could possibly return an instance of 
							<code class="code">TokenA</code>, 
							<code class="code">TokenB</code> or 
							<code class="code">TokenC</code> its type must by a super type to these types.
						</p>
<p>It is now for instance as well possible to further change the state of the AST element by assigning additional things.</p>
<p>Example:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;AbstractToken&nbsp;:<br>
&nbsp;&nbsp;&nbsp;(TokenA&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;TokenB&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;TokenC&nbsp;)&nbsp;(cardinality=('?'|'+'|'*'))?;<br>

<br>

</code>
</p>
</div>
<p>Thus, to state the cardinality is optional (last question mark) and can be represented by a question mark, a plus, or an asterisk.</p>
</div>
<div class="section" title="Tree Rewrite Actions">
<div class="titlepage">
<div>
<div>
<h5 class="title">
<a name="grammarActions"></a>Tree Rewrite Actions </h5>
</div>
</div>
</div>
<p>LL parsing has some significant advantages over LR algorithms. The most important ones for Xtext are, that the generated code is much simpler to understand and debug and that it is easier to recover from errors and especially Antlr has a very nice generic error recovery mechanism. This allows to have AST constructed even if there are syntactic errors in the text. You wouldn&rsquo;t get any of the nice IDE features as soon as there is one little error, if we hadn&rsquo;t error recovery.</p>
<p>However, LL also has some drawbacks. The most important is, that it does not allow left recursive grammars.
							For instance, the following is not allowed in LL based grammars, because &ldquo;Expression '+' Expression&rdquo; is left recursive:</p>
<div class="literallayout">
<p>
<code class="code">Expression&nbsp;:<br>
&nbsp;&nbsp;Expression&nbsp;'+'&nbsp;Expression&nbsp;|<br>
&nbsp;&nbsp;'('&nbsp;Expression&nbsp;')'<br>
&nbsp;&nbsp;INT;<br>

<br>

</code>
</p>
</div>
<p>Instead one has to rewrite such things by &ldquo;left-factoring&rdquo; it:</p>
<div class="literallayout">
<p>
<code class="code">Expression&nbsp;:<br>
&nbsp;&nbsp;TerminalExpression&nbsp;('+'&nbsp;TerminalExpression)?;<br>
&nbsp;<br>
TerminalExpression&nbsp;:<br>
&nbsp;&nbsp;'('&nbsp;Expression&nbsp;')'&nbsp;|<br>
&nbsp;&nbsp;&nbsp;INT&nbsp;<br>

<br>

</code>
</p>
</div>
<p>In practice this is always the same pattern and therefore not that problematic. 
							However, by simply applying the Xtext AST construction features we&rsquo;ve covered so far, a grammar ...</p>
<div class="literallayout">
<p>
<code class="code">Expression&nbsp;:<br>
&nbsp;&nbsp;{Operation}&nbsp;left=TerminalExpression&nbsp;(op='+'&nbsp;right=TerminalExpression)?;<br>
&nbsp;<br>
TerminalExpression&nbsp;returns&nbsp;Expression:<br>
&nbsp;&nbsp;'('&nbsp;Expression&nbsp;')'&nbsp;|<br>
&nbsp;&nbsp;{IntLiteral}&nbsp;value=INT;<br>

<br>

</code>
</p>
</div>
<p>... would result in unwanted elements in the AST.
							For instance the expression &ldquo; ( 42 ) &rdquo; would result in a tree like this:</p>
<div class="literallayout">
<p>
<code class="code">Operation&nbsp;{<br>
&nbsp;&nbsp;left=Operation&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;left=IntLiteral&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value=42<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
}<br>

<br>

</code>
</p>
</div>
<p>Typically one would only want to have one instance of IntLiteral instead.</p>
<p>One can solve this problem using a combination of unassigned rule calls and actions:</p>
<div class="literallayout">
<p>
<code class="code">Expression&nbsp;:<br>
&nbsp;&nbsp;TerminalExpression&nbsp;({Operation.left=current}&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;op='+'&nbsp;right=TerminalExpression)?;<br>
&nbsp;<br>
TerminalExpression&nbsp;returns&nbsp;Expression:<br>
&nbsp;&nbsp;'('&nbsp;Expression&nbsp;')'&nbsp;|<br>
&nbsp;&nbsp;{IntLiteral}&nbsp;value=INT;<br>

<br>

</code>
</p>
</div>
<p>In the example above 
							<code class="code">{Operation.left=current}</code> is a so called tree rewrite action, which creates a new instance of the stated EClass (Operation in this case) and assigns the element currently to-be-returned (
							<code class="code">current</code> variable) to a feature of the newly created Object (in this case &lsquo;left&rsquo;).
							In Java these semantics could be expressed as:
						</p>
<div class="literallayout">
<p>
<code class="code">Operation&nbsp;temp&nbsp;=&nbsp;new&nbsp;Operation();<br>
temp.setLeft(current);<br>
current&nbsp;=&nbsp;temp;<br>

<br>

</code>
</p>
</div>
</div>
</div>
</div>
<div class="section" title="Hidden terminal symbols">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="Hiddenterminalsymbols"></a>Hidden terminal symbols</h3>
</div>
</div>
</div>
<p>Because parser rules describe not a single token, but a sequence of patterns in the input, it is necessary to define the interesting parts of the input. Xtext introduces the concept of hidden tokens to handle semantically unimportant things like whitespaces, comments, etc. in the input sequence gracefully. It is possible to define a set of terminal symbols, that are hidden from the parser rules and automatically skipped when they are recognized. Nevertheless, they are transparently woven into the node model, but not relevant for the semantic model. </p>
<p>Hidden terminals may (or may not) appear between any other terminals in any cardinality. They can be described per rule or for the whole grammar. When 
					<a class="link" href="grammarMixins.html" title="Grammar Mixins">reusing a single grammar</a> its definition of hidden tokens is reused as well. The grammar org.eclipse.xtext.common.Terminals comes with a reasonable default and hides all comments and whitespace from the parser rules.
				</p>
<p>If a rule defines hidden symbols, you can think of a kind of scope that is automatically introduced. Any rule that is called from the declaring rule uses the same hidden terminals as the calling rule, unless it defines other hidden tokens itself.</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;Person&nbsp;hidden(WS,&nbsp;ML_COMMENT,&nbsp;SL_COMMENT):&nbsp;<br>
&nbsp;&nbsp;&nbsp;name=fullname&nbsp;age=INT&nbsp;';';<br>

<br>
&nbsp;Fullname:&nbsp;<br>
&nbsp;&nbsp;&nbsp;(firstname=ID)?&nbsp;lastname=ID;<br>

<br>

</code>
</p>
</div>
<p>The sample rule &ldquo;Person&rdquo; defines multiple-line comments (ML_COMMENT), single-line comments (SL_COMMENT), and whitespaces (WS) to be allowed between the &lsquo;Fullname&rsquo; and the &lsquo;age&rsquo;. Because &lsquo;Fullname&rsquo; does not introduce another set of hidden terminals, it allows the same symbols to appear between &lsquo;firstname&rsquo; and &lsquo;lastname&rsquo; as the calling rule &lsquo;Person&rsquo;. Thus, the following input is perfectly valid for the given grammar snippet:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;John&nbsp;/*&nbsp;comment&nbsp;*/&nbsp;Smith&nbsp;//&nbsp;line&nbsp;comment<br>
&nbsp;&nbsp;&nbsp;/*&nbsp;comment&nbsp;*/<br>
&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br>

<br>

</code>
</p>
</div>
<p>A list of all default terminals like WS can be found in section 
					<a class="link" href="grammarMixins.html" title="Grammar Mixins">Grammar Mixins</a>.
				</p>
</div>
<div class="section" title="Datatype rules">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="datatypeRules"></a>Datatype rules</h3>
</div>
</div>
</div>
<p>Datatype rules are parsing-phase rules, which create instances of EDataType as terminal rules do.
					The nice thing about datatype rules is that they are actually parser rules and are therefore </p>
<div class="orderedlist">
<ol class="orderedlist" type="1">
<li class="listitem">
<p>context sensitive and </p>
</li>
<li class="listitem">
<p>allow for use of hidden tokens</p>
</li>
</ol>
</div>
<p>If you, for instance, want to define a rule to consume Java-like qualified names (e.g. &ldquo;foo.bar.Baz&rdquo;)
					you could write:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;QualifiedName&nbsp;:<br>
&nbsp;&nbsp;&nbsp;ID&nbsp;('.'&nbsp;ID)*;<br>

<br>

</code>
</p>
</div>
<p>Which looks similar to the terminal rule we&rsquo;ve defined above in order to explain rule calls.
					However, the difference is that because it is a parser rule and therefore only valid in certain contexts, it won&rsquo;t conflict with the rule ID.
					If you had defined it as a terminal rule, it would hide the ID rule.</p>
<p>In addition having this defined as a datatype rule, it is allowed to use hidden tokens (e.g. "/* comment 
					<span class="bold"><strong>/") between the IDs and dots (e.g. @foo/</strong></span> comment */. bar . Baz"@)
				</p>
<p>Return types can be specified like in terminal rules:</p>
<div class="literallayout">
<p>
<code class="code">QualifiedName&nbsp;returns&nbsp;ecore::EString&nbsp;:&nbsp;ID&nbsp;('.'&nbsp;ID)*;<br>

</code>
</p>
</div>
<p>Note that if a rule does not call another parser rule and does not contain any actions nor assignments (see parser rules), it is considered a datatype rule and the datatype EString is implied if not explicitly declared differently.</p>
<p>For conversion again value converters are responsible (cf. 
					<a class="link" href="valueconverter.html" title="Value Converter">value converters</a>).
				</p>
</div>
<div class="section" title="Enum Rules">
<div class="titlepage">
<div>
<div>
<h3 class="title">
<a name="EnumRules"></a>Enum Rules</h3>
</div>
</div>
</div>
<p>Enum rules return enumeration literals from strings. They can be seen as a shortcut for datatype rules with specific value converters.
					The main advantage of enum rules is their simplicity, typesafety and therefore nice validation. Furthermore it is possible to infer enums and their respective literals during the metamodel transformation.</p>
<p>If you want to define a ChangeKind 
					<a class="ulink" href="http://help.eclipse.org/stable/index.jsp?topic=/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/change/impl/package-summary.html" target="_new">org.eclipse.emf.ecore.change/model/Change.ecore</a> with &lsquo;ADD&rsquo;, &lsquo;MOVE&rsquo; and &lsquo;REMOVE&rsquo; you could write:
				</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;enum&nbsp;ChangeKind&nbsp;:<br>
&nbsp;&nbsp;&nbsp;ADD&nbsp;|&nbsp;MOVE&nbsp;|&nbsp;REMOVE;<br>

<br>

</code>
</p>
</div>
<p>It is even possible to use alternative literals for your enums or reference an enum value twice:</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;enum&nbsp;ChangeKind&nbsp;:<br>
&nbsp;&nbsp;&nbsp;ADD&nbsp;=&nbsp;'add'&nbsp;|&nbsp;ADD&nbsp;=&nbsp;'+'&nbsp;|&nbsp;<br>
&nbsp;&nbsp;&nbsp;MOVE&nbsp;=&nbsp;'move'&nbsp;|&nbsp;MOVE&nbsp;=&nbsp;'-&gt;'&nbsp;|&nbsp;<br>
&nbsp;&nbsp;&nbsp;REMOVE&nbsp;=&nbsp;'remove'&nbsp;|&nbsp;REMOVE&nbsp;=&nbsp;'-';<br>

<br>

</code>
</p>
</div>
<p>Please note, that Ecore does not support unset values for enums. If you formulate a grammar like</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;Element:&nbsp;"element"&nbsp;name=ID&nbsp;(value=SomeEnum)?;<br>

</code>
</p>
</div>
<p>with the input of</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;element&nbsp;Foo<br>

</code>
</p>
</div>
<p>the resulting value of the element 
					<code class="code">Foo</code> will hold the enum value with the internal representation of 0. When generating the EPackage from your grammar this will be the first literal you define. As a workaround you could introduce a dedicated none-value or order the enums accordingly. Note that it is not possible to define an enum literal with an empty textual representation.
				</p>
<div class="literallayout">
<p>
<code class="code">
<br>
&nbsp;enum&nbsp;Visibility:&nbsp;package&nbsp;|&nbsp;private&nbsp;|&nbsp;protected&nbsp;|&nbsp;public;<br>

</code>
</p>
</div>
</div>
</body>
</html>
