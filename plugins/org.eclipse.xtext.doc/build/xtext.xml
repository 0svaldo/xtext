<?xml version='1.0' ?><!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
	<title>Xtext User Guide</title>
	<chapter id="Overview">
		<title>Overview</title>
		<section id="WhatisXtext">
			<title>What is Xtext?</title>
			<para>No matter if you want to create a small textual domain-specific language (DSL) or you want to implement 
				a full-blown general purpose programming language. 
				With Xtext you can create your very own languages in a snap. Also if you already have an existing 
				language but it lacks decent tool support, you can use Xtext to create 
				a sophisticated Eclipse-based development environment providing editing experience known from modern 
				Java IDEs in a surprisingly short amount of time. We call Xtext a language development framework.  </para>
		</section>
		<section id="HowDoesItWork">
			<title>How Does It Work?</title>
			<para>Xtext provides you with a set of domain-specific languages and modern APIs to describe the different 
				aspects of your programming language. 
				Based on that information it gives you a full implementation of that language running on the JVM. 
				The compiler components of your language are independent of Eclipse or OSGi and can be used in any Java environment.
				They include such things as the parser, the type-safe abstract syntax tree (AST), the serializer and 
				code formatter, the scoping framework and the linking, compiler checks and static analysis aka validation 
				and last but not least a code generator or interpreter. These runtime components integrate with and 
				are based on the Eclipse Modeling Framework (EMF), which effectively allows you to 
				use Xtext together with other EMF frameworks like for instance the Graphical Modeling Project GMF.</para>
			<para>In addition to this nice runtime architecture, you will get a full blown Eclipse-IDE specifically tailored 
				for your language. It already provides great default functionality for 
				all aspects and again comes with DSLs and APIs that allow to configure or change the most common things 
				very easily. And if that’s not flexible enough there is Guice to replace the default behaviour with
				your own implementations.</para>
		</section>
		<section id="XtextisHighlyConfigurable">
			<title>Xtext is Highly Configurable</title>
			<para>Xtext uses the lightweight dependency injection (DI) framework Google Guice to wire up the whole language 
				as well as the IDE infrastructure. A central, external module is used to configure the DI container. 
				As already mentioned, Xtext comes with decent default implementations and DSLs and APIs for the aspect that 
				are common sweet spots for customization. But if you need something completely different, 
				Google Guice gives you the power to exchange every little class in a non-invasive way.</para>
		</section>
		<section id="WhoUsesXtext">
			<title>Who Uses Xtext?</title>
			<para>Xtext is used in many different industries. It is used in the field of mobile devices, automotive development, 
				embedded systems or Java enterprise software projects and game development. 
				People use Xtext-based languages to drive code generators that target Java, C, C++, C#, Objective C, Python, or Ruby code. 
				Although the language infrastructure itself runs on the JVM, you can compile Xtext languages to any 
				existing platform.
				Xtext-based languages are developed for well known Open-Source projects such as Maven, Eclipse B3, 
				the Eclipse Webtools platform or Google’s Protocol Buffers and the framework is also widely used in research projects.  </para>
		</section>
		<section id="WhoisBehindXtext">
			<title>Who is Behind Xtext?</title>
			<para>Xtext is a professional Open-Source project. We, the main developers and the project lead, work for 
				itemis, 
				which is a well known consulting company specialized on model-based development.
				Therefore we are able to work almost full-time on the project. Xtext is an Eclipse.org project. 
				Besides many other advantages this means that you don’t have to fear any IP issues, because the Eclipse Foundation 
				has their own lawyers who take care that no intellectual property is violated. </para>
			<para>You may ask: Where does the money for Open-Source development come from? Well, we provide professional 
				services around Xtext. Be it training or on-site consulting, be it development of prototypes or 
				implementation of full-blown IDEs for programming languages. We do not only know the framework very well 
				but we are also experts in programming and domain-specific language design. Don’t hesitate to get in 
				contact with us (
				<ulink url="http://xtext.itemis.com">www.itemis.com</ulink>).
			</para>
		</section>
		<section id="DSL">
			<title>What is a Domain-Specific Language</title>
			<para>A 
				<emphasis>Domain-Specific Language (DSL)</emphasis> is a small programming language, which focuses on a particular domain.
				Such a domain can be more or less anything. The idea is that its concepts and notation is as close as possible to
				what you have in mind when you think about a solution in that domain. Of course we are talking about problems which can
				be solved or processed by computers somehow.
			</para>
			<para>The opposite of a DSL is a so called 
				<emphasis>GPL</emphasis>, a 
				<emphasis>General Purpose Language</emphasis> such as Java or any other common programming language.
				With a GPL you can solve every computer problem, but it might not always be the best way to solve it.
			</para>
			<para>Imagine you want to remove the core from an apple. You could of course use a Swiss army knife to cut it out, 
				and this is reasonable if you have to do it just once or twice. But if you need to do that on a regular 
				basis it might be more efficient to use an apple corer.</para>
			<para>There are a couple of well-known examples of DSLs. For instance SQL is actually a DSL which focuses on 
				querying relational databases. Other DSLs are regular expressions or even languages provided by tools 
				like MathLab. Also most XML languages are actually domain-specific languages. The whole purpose of XML is 
				to allow for easy creation of new languages. Unfortunately, XML uses a fixed concrete syntax, which is 
				very verbose and yet not adapted to be read by humans. Into the bargain, a generic syntax for everything is a compromise.</para>
			<para>Xtext is a sophisticated framework that helps to implement your very own DSL with appropriate IDE support. 
				There is no such limitation as with XML, you are free to define your concrete syntax as you like. It may 
				be as concise and suggestive as possible being a best match for your particular domain. The hard task of 
				reading your model, working with it and writing it back to your syntax is greatly simplified by Xtext.</para>
		</section>
	</chapter>
	<chapter id="getting-started">
		<title>Getting Started</title>
		<para>In this mini-tutorial we will implement a small domain-specific language and a 
			corresponding Eclipse IDE integration with Xtext. Later, we will create a code generator 
			that is capable of reading the models you create with the DSL editor and process them, i.e. 
			generate some Java code from it.</para>
		<section id="getting-started-xtext">
			<title>Creating a DSL  </title>
			<para>
				<ulink url="http://www.eclipse.org/Xtext/download/">Download and install the latest version of Xtext</ulink> and 
				set up a fresh workspace. We want to develop a small language used to define domain models.
				It is a stripped-down version of our 
				<emphasis>Domain-Model Example</emphasis> which is shipped with Xtext 
				and can be materialized into your workspace using the example wizard. The following sample 
				of a domain model should give you an idea about the language.
			</para>
			<literallayout><code>datatype String
datatype Bool

entity Session {
  title: String
  isTutorial : Bool
}

entity Conference {
  name : String
  attendees : Person*
  speakers : Speaker*
}

entity Person {
  name : String
}

entity Speaker extends Person {
  sessions : Session*
}

</code></literallayout>
			<section id="CreateanXtextProject">
				<title>Create an Xtext Project</title>
				<para>In order to get started we first need to create some Eclipse projects. Use the Xtext wizard to do so:</para> 
				<emphasis>File -&gt; New -&gt; Project...  -&gt; Xtext -&gt; Xtext project</emphasis>
				<para>Choose a meaningful project name, language name and file extension, e.g.</para>
				<informaltable>
					<tr>
						<td>
							<emphasis role="bold">Main project name:</emphasis>   
						</td>
						<td> org.eclipse.xtext.example.domainmodel  </td>
					</tr>
					<tr>
						<td>
							<emphasis role="bold">Language name:</emphasis>     
						</td>
						<td> org.eclipse.xtext.example.Domainmodel  </td>
					</tr>
					<tr>
						<td>
							<emphasis role="bold">DSL-File extension:</emphasis> 
						</td>
						<td> dmodel  </td>
					</tr>
				</informaltable>
				<para>Keep &#8222;Create generator project” checked, as we will also create a code generator in a second step.
					If you want to materialize the full blown Domainmodel example that ships with Xtext, it is
					strongly recommend to use another language name and file extension for this tutorial.</para>
				<para>Click on 
					<emphasis>Finish</emphasis> to create the projects. 
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/getting-started-wizard.png"/>
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section id="ProjectLayout">
				<title>Project Layout</title>
				<para>In the Package Explorer you can see three new projects. In 

					<emphasis>org.eclipse.xtext.example.domainmodel</emphasis> the grammar is defined and all runtime 
					aspects, such as linking, scoping and validation are developed. The IDE-aspects 
					such as the editor, any views, and incremental project builder go into 

					<emphasis>org.eclipse.xtext.example.domainmodel.ui</emphasis>. Both projects consist of generated 
					classes derived from the grammar and manual code such as the grammar itself and 
					further classes to differentiate and adapt from the default behavior. Although
					Xtext makes use of code generation, most of the code is actually written as 
					libraries, which are referenced by the means of OSGi using the Manifest.MF. 
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/getting-started-project-layout.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>It is good to be clear and unambiguous whether the code is generated or is to 
					be manipulated by the developer. Thus, the generated code should be held 
					separately from the manually written code. We follow this pattern by having a 
					folder 
					<emphasis>src/</emphasis> and a folder 
					<emphasis>src-gen/</emphasis> in each project. Keep in mind not to 
					make changes in the 
					<emphasis>src-gen/</emphasis> folder. They will be overwritten by the generator 
					without any further warning.
				</para>
				<para>A third project, 
					<emphasis>org.eclipse.xtext.example.domainmodel.generator</emphasis> will later 
					contain an Xpand code generator that leverages the model created with the DSL 
					editor. This is fully optional and it is also optional to use Xpand. In fact 
					you can use any programming language running on the JVM to implement a code 
					generator for your Xtext models. Also it is of course perfectly ok, to have no 
					code generator at all but use the models dynamically at runtime. We call these 
					kind of model processors 
					<emphasis>interpreters</emphasis>.
				</para>
			</section>
			<section id="BuildYourOwnGrammar">
				<title>Build Your Own Grammar</title>
				<para>
					<emphasis role="bold">
						<emphasis>Please note</emphasis>
					</emphasis>: If you encounter strange errors while copying and pasting
					a snippet from this document to your Eclipse editor, your documentation
					viewer most likely has inserted characters different from {space} into your 
					clipboard. Reenter the &#8222;whitespace” or type the text by hand to be sure everything
					works fine. 
				</para>
				<para>The wizard will automatically open the example grammar file 

					<emphasis>Domainmodel.xtext</emphasis> from the first project in the editor. A grammar has two 
					purposes: First, it is used to describe the concrete syntax of your language. 
					Second, it contains information about how the parser shall create a model during 
					parsing.
				</para>
				<para>The first line of the grammar is the grammar declaration:</para>
				<literallayout><code>grammar org.eclipse.xtext.example.Domainmodel 
  with org.eclipse.xtext.common.Terminals

</code></literallayout>
				<para>In Xtext each grammar has a unique name, which like public Java classes 
					needs to reflect the location of the file within the Java classpath. In our 
					case the grammar file is located in 

					<emphasis>/org/eclipse/xtext/example/Domainmodel.xtext</emphasis> therefore the name of the 
					grammar is 
					<emphasis>org.eclipse.xtext.example.Domainmodel</emphasis>. The second part of that 
					statement (
					<emphasis>with org.eclipse.xtext.common.Terminals</emphasis>) states, that this grammar 
					reuses and overrides rules from the specified grammar. The 

					<emphasis>org.eclipse.xtext.common.Terminals</emphasis> is a library grammar shipped with Xtext 
					and predefines the most common terminal rules, such as 
					<emphasis>ID</emphasis>, 
					<emphasis>STRING</emphasis> and 
					<emphasis>INT</emphasis>. 
					It also introduces single-line and multi-line comments as well as rules for 
					whitespace, which may occur everywhere by default. You can open that grammar in the 
					editor to have a look at these rules. It turns out that these set of rules are often 
					the same and often used, so that most Xtext languages extend this grammar. 
					However, it is just a library, so you won’t use it if it doesn’t fit your needs. 
					Also you can use the grammar inheritance mechanism for your own grammar libraries, 
					of course.
				</para>
				<para>The next statement declares an EMF Ecore package, aka 
					<emphasis>EPackage</emphasis>, to be derived from the grammar:
				</para>
				<literallayout><code>generate domainmodel "http://www.eclipse.org/xtext/example/Domainmodel"

</code></literallayout>
				<para>Ecore 
					<emphasis>EPackages</emphasis> are effectively a set of classes (in EMF they are called 

					<emphasis>EClass</emphasis>) which are used to represent the in-memory-model of a text file. Instead
					of 
					<emphasis>model</emphasis> we also sometimes refer to it as 
					<emphasis>semantic model</emphasis> or _Abstract Syntax 
					Tree (AST)_. Note, that in the case of Xtext it’s actually a graph rather than a 
					tree, since it also contains crosslinks. But as the term AST is so commonly 
					used and well known we are ignoring this minor detail. 
				</para>
				<para>In order to tell the parser which 
					<emphasis>EClasses</emphasis> to use when creating the AST, we 
					need to make them available by either importing existing Ecore packages or like 
					in our example let Xtext derive a package from the grammar. An 
					<emphasis>EPackage</emphasis> has a 
					mandatory name and namespace URI (short: 
					<emphasis>nsURI</emphasis>), so we have to declare these two values 
					in that statement. 
				</para>
				<para>That’s all for the prelude, now we have to define the parser rules which 
					effectively define a bi-directional mapping from text to a constructed AST. 
					It is bi-directional because Xtext not only derives a parser from the grammar but also 
					a serializer. Anyway, we will mostly talk about parsing in this chapter.</para>
				<para>Ignore and delete the parser rules generated by the wizard and start by 
					declaring an entry rule for our language. The entry rule for the parser will be 
					called 
					<emphasis>DomainModel</emphasis>. Xtext is fine with any name, it just picks the first rule 
					in a grammar and interprets it as the entry rule.
				</para>
				<para>As a 
					<emphasis>DomainModel</emphasis> consists of one or more 
					<emphasis>Entity</emphasis> entries, this rule delegates 
					to another rule named 
					<emphasis>Entity</emphasis>, which will be defined later on. As we can have an 
					arbitrary number of entities within a model, the cardinality is '
					<emphasis>*</emphasis>'. There are 
					four different cardinalities available.
				</para>
				<informaltable>
					<tr>
						<td>(no operator) </td>
						<td> exactly one  </td>
					</tr>
					<tr>
						<td>
							<emphasis>?</emphasis>     
						</td>
						<td> zero or one  </td>
					</tr>
					<tr>
						<td>
							<emphasis>*</emphasis>     
						</td>
						<td> zero or more</td>
					</tr>
					<tr>
						<td>
							<emphasis>+</emphasis>     
						</td>
						<td> one or more  </td>
					</tr>
				</informaltable>
				<para>Each rule ends with a semicolon. So our first rule reads for now as</para>
				<literallayout><code>DomainModel :
  Entity*; 

</code></literallayout>
				<para>An Xtext grammar does not only describe rules for the parser but also the 
					structure of the resulting AST. Usually, each parser rule will create a new object 
					in that tree. The type of that element can be specified after the rule name using 
					the keyword 
					<emphasis>returns</emphasis>. If the type’s name is the same as the rule’s name, it can 
					be omitted as in our case. Which effectively means that
				</para>
				<literallayout><code>DomainModel returns DomainModel: ...

</code></literallayout>
				<para>is the same as</para>
				<literallayout><code>DomainModel : ...

</code></literallayout>
				<para>In order to connect the different objects together, we have to assign the 
					elements returned by called rules to some feature of the current rule’s object. 
					This is done by using so called assignments. </para>
				<literallayout><code>DomainModel :
  (elements+=Entity)*;

</code></literallayout>
				<para>The assignment with the '
					<emphasis>+=</emphasis>' operator adds every object returned by the 

					<emphasis>Entity</emphasis> rule to the 
					<emphasis>elements</emphasis> referenced of the AST type 
					<emphasis>Model</emphasis>. If you use '
					<emphasis>+=</emphasis>' 
					as opposed to '
					<emphasis>=</emphasis>' the feature needs to be a list – the upperBound has to be -1. In addition to the 
					two mentioned assignment operators there is a third one '
					<emphasis>?=</emphasis>' which is called boolean 
					assignment and which sets a certain feature to true, if the part on the right hand 
					side was parsed successfully. Here’s the list of available assignment operators:
				</para>
				<informaltable>
					<tr>
						<th>
							<emphasis>feature=...</emphasis>   
						</th>
						<td>corresponds to 
							<emphasis>setFeature(...)</emphasis>  
						</td>
					</tr>
					<tr>
						<th>
							<emphasis>list+=...</emphasis>  
						</th>
						<td>corresponds to 
							<emphasis>getList().add(...)</emphasis>
						</td>
					</tr>
					<tr>
						<th>
							<emphasis>condition?=...</emphasis>  
						</th>
						<td>corresponds to 
							<emphasis>setCondition(true)</emphasis>
						</td>
					</tr>
				</informaltable>
				<para>The next rule on our list is the rule 
					<emphasis>Entity</emphasis>. Looking at our target syntax, 
					each entity begins with the keyword 
					<emphasis>'entity'</emphasis> followed by the entity’s name and an 
					opening curly brace (we will handle the 
					<emphasis>extends</emphasis> clause in a second step). Then, 
					an entity defines a number of features and ends with a closing curly brace. The 
					rule looks like this:
				</para>
				<literallayout><code>Entity :
  'entity' name=ID '{'
    (features+=Feature)*
  '}';
  
</code></literallayout>
				<para>Keywords are simply declared as string literals within the rules. The name 
					uses the 
					<emphasis>ID</emphasis> rule from the mixed-in grammar 
					<emphasis>org.eclipse.xtext.common.Terminals</emphasis>. 
					The 
					<emphasis>ID</emphasis> rule is a so called terminal rule which always returns simple data types, 
					such as 
					<emphasis>String</emphasis>, 
					<emphasis>Date</emphasis>, or 
					<emphasis>Integer</emphasis>. Actually any Java class can be a simple 
					EMF 
					<emphasis>EDataType</emphasis>. The 
					<emphasis>ID</emphasis> rule recognizes alphanumeric words similar to identifiers 
					in Java and returns the value as a 
					<emphasis>String</emphasis>. You can navigate to its declaration 
					using 
					<emphasis>F3</emphasis>. As mentioned before the assignment operator '
					<emphasis>=</emphasis>' denotes a single
					valued feature.
				</para>
				<para>We want to allow inheritance for entities and therefore now add an optional 
					'
					<emphasis>extends</emphasis>' part.
				</para>
				<literallayout><code>Entity :
  'entity' name=ID ('extends' superType=[Entity])? '{'
    (features+=Feature)*
  '}';

</code></literallayout>
				<para>The question mark marks an element or as in this case an entire group of elements as optional.
					The other new thing is the right hand side of of the assignment 
					<emphasis>superType=[Entity]</emphasis>.
					This is a cross-reference literal and states, that a cross-reference to an elsewhere 
					declared 
					<emphasis>Entity</emphasis> should be established. So in this case 
					<emphasis>Entity</emphasis> does not point to 
					the corresponding rule but to the 
					<emphasis>EClass</emphasis>. As both are named equally this might 
					cause a little confusion at first. The full syntax for a cross-reference is 

					<emphasis>[TypeName|RuleCall]</emphasis> where 
					<emphasis>RuleCall</emphasis> defaults to 
					<emphasis>ID</emphasis>. This means that 

					<emphasis>?</emphasis> would work equally well. The parser only parses 
					the name of the cross-referenced element using the 
					<emphasis>ID</emphasis> rule and stores it 
					internally. Later on the linker establishes the cross-reference using the name, the 
					defined cross-reference’s type (
					<emphasis>Entity</emphasis> in this case) and the defined scoping rules. 
					Scoping is not covered in this tutorial since the domain model DSL works with 
					the default scoping semantics. By default a namespace-based scoping is applied, which 
					means that all entities living in the same namespace are possible candidates for a 
					cross-reference. We talk a bit about this later on in this chapter when we introduce 
					namespaces.
				</para>
				<para>In our introductory example model we had not only defined entities but also two 
					data types. So the 
					<emphasis>DomainModel</emphasis> rule needs to be able to parse data types as well. 
					As both entities and data types will be referenced from the yet to be defined 
					<emphasis>Feature</emphasis> 
					rule, we should introduce a common super type for them.
				</para>
				<literallayout><code>DomainModel :
  (elements+=Type)*;

Type:
  DataType | Entity;
  
DataType:
  'datatype' name=ID;
 
</code></literallayout>
				<para>A 
					<emphasis>DomainModel</emphasis> now consists of types where a 
					<emphasis>Type</emphasis> can either be a 
					<emphasis>DataType</emphasis> or 
					an 
					<emphasis>Entity</emphasis>. Our rule 
					<emphasis>Type</emphasis> will just delegate to either of them, using the '
					<emphasis>|</emphasis>' 
					alternatives operator. Now that we have a common super type for 
					<emphasis>Entity</emphasis> and 
					<emphasis>DataType</emphasis> 
					we are able to refer to both types of elements with a single cross-reference.
				</para>
				<para>Next up we need to define the syntax of 
					<emphasis>Feature</emphasis>, which shouldn’t be surprising to 
					you, as we do not use any new concepts here.
				</para>
				<literallayout><code>Feature:
  name=ID ':' type=TypeRef;

</code></literallayout>
				<para>In many target platforms there is a difference between the notion of a simple 
					attribute and a reference. In relational databases, for instance, a table contains 
					the values of attributes directly, but references are &#8222;modeled” by the means of 
					foreign keys. In object-relational persistence technologies such as JPA or Hibernate 
					references can have additional life-cycle semantics, which define what to do with 
					referenced objects in certain circumstances. Therefore you typically make a distinction 
					between the two concepts, as we do in the 
					<emphasis>Domain Model Example</emphasis> you can create using 
					the wizard. However, in this small scenario we do not need a separation therefore we 
					stick with one single concept for features.
				</para>
				<para>As the type reference has an additional property for the multiplicity (many or one), 
					we make it a separate model element and parser rule 
					<emphasis>TypeRef</emphasis>. The presence of the 
					postfix &#8218;*’ in an input file should set the boolean flag to &#8218;true’ that indicates a multi-value
					type reference in the AST model. 
					This is the purpose of the assignment operator '
					<emphasis>?=</emphasis>'. The parser rule looks like this:
				</para>
				<literallayout><code>TypeRef :
  referenced=[Type] (multi?='*')?;

</code></literallayout>
				<para>Again we have specified a cross-reference, which this time not only allows to 
					reference entities but all instances of type. So far this only includes data type and entities, but 
					you may want to introduce additional concepts in a future version, like for instance a 
					Value Object as proposed in Eric Evan’s great book 
					<emphasis>Domain Driven Design</emphasis>.
				</para>
				<para>In the end your grammar editor should look like this:</para>
				<literallayout><code>grammar org.eclipse.xtext.example.Domainmodel 
  with org.eclipse.xtext.common.Terminals
  
generate domainmodel "http://www.eclipse.org/xtext/example/Domainmodel"  

DomainModel :
  (elements+=Type)*;
  
Type:
  DataType | Entity;
  
DataType:
  'datatype' name=ID;
 
Entity:
  'entity' name=ID ('extends' superType=[Entity])? '{'
    (features+=Feature)*
  '}';
 
Feature:
  name=ID ':' type=TypeRef;
  
TypeRef:
  referenced=[Type] (multi?='*')?;
  
</code></literallayout>
			</section>
			<section id="GenerateLanguageArtifacts">
				<title>Generate Language Artifacts</title>
				<para>Now that we have the grammar in place and defined we need to run the generator that will derive the
					various language components. 
					To do so locate the file 
					<emphasis>GenerateDomainmodel.mwe2</emphasis> file next to the grammar 
					file in the package explorer view. From its context menu, choose
				</para> 
				<emphasis>Run As -&gt; MWE2 Workflow</emphasis>.
				<para>That will trigger the Xtext language generator. It generates the parser and 
					serializer and some additional infrastructure code. You will see its logging 
					messages in the Console View. </para>
			</section>
			<section id="RuntheGeneratedIDEPlugin">
				<title>Run the Generated IDE Plug-in</title>
				<para>If the code generation succeeded, we are now able to test the IDE integration. 
					Right-click on the Xtext project and choose</para> 
				<emphasis>Run As -&gt; Eclipse Application</emphasis>.
				<para>This will spawn a new Eclipse workbench with your projects as plug-ins installed. 
					In the new workbench, create a new project 
					(
					<emphasis>File -&gt; New -&gt; Project...  -&gt; General -&gt; Project</emphasis>) and therein a new file 
					with the file extension you chose in the beginning (
					<emphasis>*.dmodel</emphasis>). This will open
					the generated entity editor. Try it a bit and discover the default 
					functionality for code completion (
					<emphasis>CTRL SPACE</emphasis> even for cross-references), 
					syntax highlighting, syntactic validation, linking errors, outline, find
					references etc.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/getting-started-editor.png" scale="50"/>
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section id="AddingaNamespaceConcept">
				<title>Adding a Namespace Concept</title>
				<para>At the current stage, our language puts all types into the same scope. As 
					cross-references are specified by means of names, this can easily yield collisions 
					as the model size increases. Avoiding such name clashes is why most programming 
					languages invent concepts like namespaces or modules. We will now introduce the 
					concept of a 
					<emphasis>Package</emphasis>, which effectively is a namespace. 
				</para>
				<para>Our languages’s definition of a 
					<emphasis>Package</emphasis> is as follows: A package has a name and 
					contains other named elements and namespace-imports. A named element is either another 

					<emphasis>Package</emphasis> or a 
					<emphasis>Type</emphasis>. Within a package, elements must have unique names. The 

					<emphasis>fully qualified name</emphasis> (FQN) of a named element consists of the FQN of its package, 
					a separator '
					<emphasis>.</emphasis>' and its own simple name. Elements refer to each other using their 

					<emphasis>qualified names</emphasis> which may be relative to their common namespaces or absolute. By means 
					of import statements, these names can be further abbreviated. 
				</para>
				<para>That might sound a bit complicated at first but the good thing is that Xtext 
					comes with exactly such a default semantic for namespaces, which feels very 
					natural in practice. Although all aspects of this semantic are adaptable, we 
					will stick to the defaults within this tutorial.</para>
				<para>Before we extend the grammar, let’s have a look how an example model would
					look like when using the newly introduced concepts:</para>
				<literallayout><code>package my.types {
  datatype String
  datatype Boolean
}

package my.entities {
  
  import my.types.*
  
  entity Session {
    title: String
    isTutorial : Boolean
  }

  entity Conference {
    name : String
    attendees : Person*
    speakers : Speaker*
  }

  entity Person {
    name : String
  }

  entity Speaker extends Person {
    sessions : Session*
  }
}

</code></literallayout>
				<para>Let’s start to modify our grammar now. First we introduce the rule 
					<emphasis>AbstractElement</emphasis>:
				</para>
				<literallayout><code>AbstractElement:
  PackageDeclaration | Type;

</code></literallayout>
				<para>
					<emphasis>DomainModel</emphasis> should now call 
					<emphasis>AbstractElement</emphasis> instead of 
					<emphasis>Type</emphasis>:  
				</para>
				<literallayout><code>DomainModel:
  (elements+=AbstractElement)*;

</code></literallayout>
				<para>To allow qualified names, we need a new rule 
					<emphasis>QualifiedName</emphasis>. This rule 
					returns a string. But we do not want this to be a 
					<emphasis>terminal rule</emphasis>, as terminal 
					rules have special semantics (they are used context-less in the lexer, which 
					often causes problems). Instead we want it to be a parser rule, but one which
					doesn’t return an instance of an 
					<emphasis>EClass</emphasis> from the referenced 
					<emphasis>EPackage</emphasis> but 
					just a plain String. Such rules are called 
					<emphasis>data type rules</emphasis>, because they return 
					instances of 
					<emphasis>EDataType</emphasis> as opposed to instances of 
					<emphasis>EClass</emphasis>. String is the most 
					often used 
					<emphasis>EDataType</emphasis> in this context and is therefore the default return 
					type for data type rules. The rule looks like this:
				</para>
				<literallayout><code>QualifiedName:
  ID ('.' ID)*;

</code></literallayout>
				<para>Note, that Xtext automatically figures out that the rule is a 
					<emphasis>data type rule</emphasis> 
					rather then a normal parser rule, because it doesn’t contain any assignments 
					and all rule calls go to either other 
					<emphasis>data type rules</emphasis> or 
					<emphasis>terminal rules</emphasis>. 
					For a 
					<emphasis>data type rule</emphasis> the parser simply concatenates the consumed text and returns 
					it as a string. The transformation to a user defined data type is done by so 
					called 
					<link linkend="valueconverter">ValueConverters</link>. But as we use strings we don’t need to care about 

					<emphasis>ValueConverters</emphasis> here.
				</para>
				<para>Next up we need to define the syntax of 
					<emphasis>PackageDeclarations</emphasis>, which makes use of 
					the 
					<emphasis>QualifiedName</emphasis> rule but doesn’t make use of anything we haven’t yet talked about.
				</para>
				<literallayout><code>PackageDeclaration:
  'package' name=QualifiedName '{'
    (elements+=AbstractElement)*
  '}';
  
</code></literallayout>
				<para>Having qualified names at hand, we want to specify cross-references that 
					way, too. As mentioned by default, Xtext assumes the rule 
					<emphasis>ID</emphasis> as the syntax 
					for cross-references, which has been fully sufficient so far. But now we want 
					to allow fully qualified names as well, so we explicitly specify the syntax rule 
					after a delimiter '
					<emphasis>|</emphasis>':
				</para>
				<para>fn.. Note, that the '
					<emphasis>|</emphasis>' has nothing to do with the previously introduced 
					alternative operator. In the context of a cross-reference it is simply a delimiter.  
				</para>
				<literallayout><code>Entity:
  'entity' name=ID ('extends' superType=[Entity|QualifiedName])? '{'
    (features+=Feature)*
  '}';

</code></literallayout>
				<para>and</para>
				<literallayout><code>TypeRef:
  referenced=[Type|QualifiedName] (multi?='*')?;

</code></literallayout>
				<para>As the last step, we introduce imports. An 
					<emphasis>Import</emphasis> is an instance of 

					<emphasis>AbstractElement</emphasis>, too, so that it can occur as a child of 
					<emphasis>DomainModel</emphasis> as 
					well as of 
					<emphasis>PackageDeclaration</emphasis>.
				</para>
				<literallayout><code>AbstractElement:
  PackageDeclaration | Type | Import;

</code></literallayout>
				<para>An imported namespace is not just a qualified name but it also allows an 
					optional wildcard character '
					<emphasis>*</emphasis>' at the end, so that multiple names can be 
					imported with one statement. That requires a new data type rule which we 
					name 
					<emphasis>QualifiedNameWithWildCard</emphasis>:
				</para>
				<literallayout><code>QualifiedNameWithWildCard:
  QualifiedName '.*'?;

</code></literallayout>
				<para>The declaration of the 
					<emphasis>Import</emphasis> rule should look familiar by now:
				</para>
				<literallayout><code>Import:
  'import' importedNamespace=QualifiedNameWithWildCard;

</code></literallayout>
				<para>The default scoping implementation is based on naming conventions. First 
					everything which has a name is referenceable. By default something has a name 
					if it has a property 
					<emphasis>'name'</emphasis>. If such an 
					<emphasis>EAttribute</emphasis> is available, the default 
					implementation computes a qualified name by asking the container for its name 
					and concatenates the two names separated by a dot. The computation of qualified
					names can be arbitrarily changed by implementing an 
					<emphasis>IQualifedNameProvider</emphasis>. 
					The other naming convention is that if some element has an EAttribute 
&#8218;					importedNamespace’ that value is used as a namespace import and is automatically 
					prefixed to any simple names used within that namespace. Also the asterisk '
					<emphasis>*</emphasis>' 
					is used as a wildcard by default.
				</para>
				<para>That’s all for the grammar. It should now read as </para>
				<literallayout><code>grammar org.eclipse.xtext.example.Domainmodel 
   with org.eclipse.xtext.common.Terminals

generate domainmodel "http://www.eclipse.org/xtext/example/Domainmodel"

DomainModel:
  (elements+=AbstractElement)*;

AbstractElement:
  PackageDeclaration | Type | Import;
  
Import:
  'import' importedNamespace=QualifiedNameWithWildCard;

PackageDeclaration:
  'package' name=QualifiedName '{'
    (elements+=AbstractElement)*
  '}';

Type:
  Entity | DataType;

DataType:
  'datatype' name=ID;

Entity:
  'entity' name=ID ('extends' superType=[Entity|QualifiedName])? '{'
    (features+=Feature)*
  '}';

Feature:
  name=ID ':' type=TypeRef;

TypeRef:
  referenced=[Type|QualifiedName] (multi?='*')?;

QualifiedName:
  ID ('.' ID)*;
  
QualifiedNameWithWildCard:
  QualifiedName '.*'?;

</code></literallayout>
				<para>Now you should regenerate the language infrastructure as described in the 
					previous section, and give the editor a try. You can even split up your model 
					into smaller parts and have cross-references across file boundaries, as long 
					as the referenced models are on the classpath.</para>
			</section>
		</section>
		<section id="processing_Xtext_models">
			<title>Processing Xtext Models</title>
			<para>Now that we know how to create a language we should talk about processing the parsed models somehow. 
				There are typically two useful things one can do with
				Xtext models: One is translating them to another programming language, i.e. writing a code generator, 
				the other is loading them at runtime and use them
				dynamically. We’ll talk about code generation later. In this chapter we want to see how to interact with 
				Xtext models programmatically. </para>
			<para>Text files parsed by Xtext are represented as object graphs in memory. We call these object graphs 
				<emphasis>Abstract Syntax Tree (AST)</emphasis>, 
				<emphasis>semantic model</emphasis> or 
				simply 
				<emphasis>model</emphasis> interchangeably. In Xtext models are implemented using the 
				<emphasis>Eclipse Modeling Framework (EMF)</emphasis>, which can be seen as a very powerful version 
				of JavaBeans. It not only provides the typical getter and setter methods for the different features of a model element but also comes with an long list of 
				advanced concepts and semantics, which are extremely useful in the context of Xtext.
			</para>
			<section id="resource">
				<title>Loading a 
					<emphasis>Resource</emphasis> 
				</title>
				<para>EMF models can be persisted by the means of a so called 
					<emphasis>Resource</emphasis>. Xtext languages implement the 
					<emphasis>Resource</emphasis> interface which is why you can use the EMF API to
					load a model into memory (and also save them):
				</para>
				<literallayout><code>new DomainmodelStandaloneSetup().createInjectorAndDoEMFRegistration();

ResourceSet rs = new ResourceSetImpl();
Resource resource = rs.getResource(URI.createURI("./mymodel.dmodel"), true);
EObject eobject = resource.getContents().get(0);
 
</code></literallayout>
				<para>The first line initializes the language infrastructure to run in 
					<emphasis>standalone</emphasis> mode. That is EMF is designed to work in Eclipse and therefore makes use of 
					Equinox extension points in order to register factories and the like. In a vanilla Java project there is no Equinox, hence we do the registration programmaticly.
					The generated 
					<emphasis>MyLanguageStandaloneSetup</emphasis> class does just that. You don’t have to do this kind of initialization when you run your plug-ins within Eclipse, since in that case 
					the extension point declarations are used.
				</para>
				<para>The other thing the 
					<emphasis>StandaloneSetup</emphasis> takes care of is creating a Guice 
					<emphasis>injector</emphasis>. The use of Guice and Dependency Injection is explained 
					<link linkend="dependencyInjection">here</link>. 
				</para>
				<para>Now that the language infrastructure is initialized and the different contributions to EMF are registered, we want to load a 
					<emphasis>Resource</emphasis>. To do so we first create a 

					<emphasis>ResourceSet</emphasis>, which as the name suggests represents a set of Resources. If one 
					<emphasis>Resource</emphasis> references another 
					<emphasis>Resource</emphasis>, EMF will automatically load that other 
					<emphasis>Resource</emphasis>
					into the same 
					<emphasis>ResourceSet</emphasis> as soon as the cross-reference is resolved. Resolution of cross-references is done lazy, i.e. on first access.
				</para>
				<para>The 4th line loads the 
					<emphasis>Resource</emphasis> using the resource set. We pass in a URI which points to the file in the file system. 
					EMF’s URI is a powerful concept. It supports a lot of different schemes to load resources from file system, web sites, jars, OSGi bundles or even 
					from Java’s classpath. And if that is not enough you can come up with your own schemes. Also a URI can not only point to a resource but also to any 
					<emphasis>EObject</emphasis> in a resource.
					This is done by appending a so called 
					<emphasis>URI fragment</emphasis> to the URI. 
				</para>
				<para>The second parameter denotes whether the resource should automatically be loaded if it wasn’t already before. Alternatively we could have written</para>
				<literallayout><code>Resource resource = rs.getResource(URI.createURI("./mymodel.dmodel"), false);
resource.load(null);

</code></literallayout>
				<para>The load method optionally takes a map of properties, which allows to define a contract between a client and the specific implementation. In Xtext, for instance, we use 
					the map to state whether cross-references should be eagerly resolved. In order to find out what properties are supported, it’s usually best to look into 
					the concrete implementations. That said, in most cases you don’t need to pass any properties at all.</para>
				<para>The last line </para>
				<literallayout><code>EObject eobject = resource.getContents().get(0);

</code></literallayout>
				<para>assigns the root element to a local variable.
					Actually it is the first element from the contents list of a 
					<emphasis>Resource</emphasis>, but in Xtext a 
					<emphasis>Resource</emphasis> always has just one root element.
				</para>
			</section>
			<section id="programmatic_EMF">
				<title>Working with EMF Models</title>
				<para>We have previously talked about Ecore models, which effectively is an 
					<emphasis>EPackage</emphasis> containing a any number of 
					<emphasis>EClasses</emphasis> with 
					<emphasis>EAttributes</emphasis> and 
					<emphasis>EReferences</emphasis>. 
					Ecore defines additional concepts but they are not so important here. An 
					<emphasis>EObject</emphasis> is an instance of an 
					<emphasis>EClass</emphasis>. For instance, the root element
					of a domain model would be an instance of the EClass 
					<emphasis>DomainModel</emphasis>, as defined in the grammar in the last chapter. EMF provides a reflection layer to work
					with EObjects in a generic way. 
				</para>
				<literallayout><code>assertEquals("DomainModel", eobject.eClass().getName());
 
</code></literallayout>
				<para>It is also possible to create new instances or get and set values using the reflection layer. That reflection layer is very helpful when creating generic 
					libraries for EMF models, however if you know what kind of model you are working with it’s much nicer to program against the generated Java classes. 
					As we know that the root element is an instance of DomainModel we can just cast it to the Java interface generated by EMF:</para>
				<literallayout><code>DomainModel domainModel = (DomainModel) eobject;

</code></literallayout>
				<para>The generated Java types provide getter and setter methods for each 
					<emphasis>EAttribute</emphasis> and 
					<emphasis>EReference</emphasis>, so that you can easily navigate the model using Java:
				</para>
				<literallayout><code>EList&lt;AbstractElement&gt; elements = domainModel.getElements();
for (AbstractElement abstractElement : elements) {
  if (abstractElement instanceof Entity) {
    Entity entity = ((Entity)abstractElement);
    System.out.println("entity "
    	+ entity.getName()
    	+ " extends "
    	+ entity.getSuperType().getName());
  } else if (abstractElement instanceof PackageDeclaration) {
  	PackageDeclaration pkgDecl = (PackageDeclaration) abstractElement;
  	System.out.println("package "
    	+ pkgDecl.getName());
  }
}

</code></literallayout>
				<para>Note that you’ll find a lot of convenience API in EMF’s 
					<emphasis>EcoreUtil</emphasis> and Xtext’s 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/EcoreUtil2.java?root=Modeling_Project&amp;view=co">EcoreUtil2</ulink>. 
				</para>
			</section>
			<section id="node_model">
				<title>Working with the Parse Tree (aka Node Model)</title>
				<para>In many situations the information from the 
					<emphasis>AST</emphasis> is sufficient, but in some situations you need additional syntactical information. In Xtext not only
					an 
					<emphasis>AST</emphasis> is constructed while parsing but also a so called 
					<emphasis>parse tree</emphasis>, which contains all the textual information chunked in so called tokens. The 
					<emphasis>parse tree</emphasis>, also 
					called 
					<emphasis>node model</emphasis>, consists of two different kinds of nodes. 
				</para>
				<para>
					<emphasis>LeafNodes</emphasis> as the name suggests represent the leafs of the parse tree. Each leaf node represents one 
					token. If you go through all leaf nodes of a parse tree and concatenate all the tokens to one string, you’ll end up with the whole textual representation 
					of the model, including all hidden tokens such as whitespace and comments. The following code does exactly that:
				</para>
				<literallayout><code>CompositeNode node = NodeUtil.getNode(domainModel);
Iterable&lt;AbstractNode&gt; contents = NodeUtil.getAllContents(node);
StringBuffer text = new StringBuffer();
for (AbstractNode abstractNode : contents) {
  if (abstractNode instanceof LeafNode)
    text.append(((LeafNode)abstractNode).getText());
}
System.out.println(text);

</code></literallayout>
				<para>In addition to the text 
					<emphasis>LeafNodes</emphasis> also hold information about the line, the offset and the length of that token.
				</para>
				<para>The other node type is called 
					<emphasis>CompositeNode</emphasis> and is created for almost each grammar element. A composite node can contain other composite nodes and leaf nodes.
					The super type of both node types is 
					<emphasis>AbstractNode</emphasis>. One can find a couple of convenience methods in 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/NodeUtil.java?root=Modeling_Project&amp;view=co">NodeUtil</ulink> and 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/ParseTreeUtil.java?root=Modeling_Project&amp;view=co">ParseTreeUtil</ulink>.
				</para>
			</section>
			<section id="working_with_grammar_model">
				<title>Working with the Grammar</title>
				<para>Also the grammar is represented as an EMF model and can be used in Java. In fact each node of the 
					<emphasis>node model</emphasis> references
					the element from the grammar which was responsible for parsing or lexing that node:
				</para>
				<literallayout><code>DomainModel domainModel = (DomainModel) eObject;
CompositeNode node = NodeUtil.getNode(domainModel);
ParserRule parserRule = (ParserRule) node.getGrammarElement();
assertEquals("DomainModel", parserRule.getName());

</code></literallayout>
			</section>
			<section id="WorkingwithLiveModels">
				<title>Working with Live Models</title>
				<para>In a running Xtext Workbench, there are a number of components which access the semantic model of an open editor, i.e. the parser, the linker, the validator, the outline, the index builder etc. While some of these components are executed by the display thread, others like the parser or the indexer use different concurrent threads to not deteriorate the editing experience. If you for example want to have a consistent outline of your model, it is essential to keep other threads from modifying the model while the outline component reads it.</para>
				<para>Many of the prominent locations where users can hook in their own code in Xtext are already called from within a thread safe context, e.g. the API for 
					<link linkend="quickfixes">quick fixes</link>. Consequently, the following usually applies only if you add additional functionality on top of Xtext, e.g. custom UI actions.
				</para>
				<para>Each 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/XtextEditor.java?root=Modeling_Project&amp;view=co">XtextEditor</ulink> uses an 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/model/IXtextDocument.java?root=Modeling_Project&amp;view=co">IXtextDocument</ulink> to store its model. To avoid synchronization trouble, neither of them provides direct access to the 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java?root=Modeling_Project&amp;view=co">XtextResource</ulink> storing the semantic model. Instead, the 
					<emphasis>IXtextDocument</emphasis> has two methods 
					<emphasis>readOnly()</emphasis> and 
					<emphasis>modify()</emphasis>. Both take an argument of type 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.util/src/org/eclipse/xtext/util/concurrent/IUnitOfWork.java?root=Modeling_Project&amp;view=co">IUnitOfWork</ulink>
					<emphasis>(&lt;T&gt;, IXtextResource)</emphasis> which defines a method 
					<emphasis>&lt;T&gt; exec(IXtextResource)</emphasis> that contains what you want to do with the model and allows to deliver a result of arbitrary type.
				</para>
				<para>So here is an example of safely reading a model:</para>
				<literallayout><code>IXtextDocument myDocument = ...;
String rootElementName =  myDocument.readOnly(
  new IUnitOfWork(){
    public String exec(IXtextResource resource) {
      MyType type = (MyType)resource.getContents().get(0);
      return myType.getName();
    }
  });

</code></literallayout>
				<para>Direct write-access on the document is usually only performed inside the framework. If you want to change a document by means of its semantic model, you should rather use an 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/model/edit/IDocumentEditor.java?root=Modeling_Project&amp;view=co">IDocumentEditor</ulink> which uses the 
					<emphasis>modify()</emphasis> method internally but takes care of synchronizing the 
					<link linkend="node_model">node model</link>, too:
				</para>
				<literallayout><code>@Inject
private IDocumentEditor documentEditor;

public void setRootName(IXtextDocument myDocument,
                        final String newName) {
 documentEditor.process(
    new IUnitOfWork.Void() {
       public void process(IXtextResource resource) {
          MyType type = (MyType)resource.getContents().get(0);
          myType.setName(newName);
       }
    }, myDocument);
}

</code></literallayout>
			</section>
			<section id="Summary">
				<title>Summary</title>
				<para>Let’s summarize what we have learned: An Xtext model is loaded by an EMF Resource. The main model is represented as an instance of so called 
					<emphasis>EClasses</emphasis> which are themselves
					declared within Ecore models. A 
					<emphasis>parse tree</emphasis> is created as well, which effectively acts as a tracing model between the text, the 
					<emphasis>AST</emphasis> and the grammar. The following
					diagram illustrates the four different kinds of models.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/xtext_data_structures.png" scale="50"/>
						</imageobject>
					</mediaobject>
				</para>
			</section>
		</section>
		<section id="getting-started-xpand">
			<title>Writing a Code Generator</title>
			<para>In the previous section we’ve seen how to process Xtext files in general (e.g. with Java). 
				If you need late binding, loading models dynamically and interpreting them is a good idea. 
				If you do not need late binding, code generation is a viable option which is widely used to make models executable. </para>
			<para>You could of course use Java to do the code generation, but unfortunately Java doesn’t support this task very well.
				Therefore we use a language specialized on code generation: M2T Xpand.</para>
			<section id="XpandandMWE2">
				<title>Xpand and MWE2</title>
				<para>Xpand is also part of Eclipse and ships with its own documentation, so we don’t need to explain all the details here, but
					rather want to point you to the existing documentation. Instead this chapter is about providing some information about how to
					use Xtext and Xpand together. </para>
				<para>The other technology we are going to use here is the 
					<link linkend="MWE2">Modeling Workflow Engine 2</link>. It is used to describe the generation workflow,
					that is how and which models should be loaded, how they should be validated post-processed and where and how code generation should take place.
				</para>
				<para>This section is based on the 
					<link linkend="getting-started-xtext">Getting Started</link> section and uses the code generator project which is created by Xtext’s project wizard.
				</para>
			</section>
			<section id="TheEmptyGeneratorProject">
				<title>The Empty Generator Project</title>
				<para>Previously when we created the projects to develop the domain model language, we had checked the option 
					<emphasis>Create a generator project</emphasis> in the wizard, which as 
					a result created a third project for us in the workspace. If you’ve followed along you should have a project called 
&#8218;					org.eclipse.xtext.example.domainmodel.generator’ in your workspace. It should look like shown in the following screenshot:
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/generator-project.png" scale="50"/>
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section id="ReplacingtheExampleModelFile1">
				<title>Replacing the Example Model File (1)</title>
				<para>The four files shown in the image above are very simple stubs generated for the &#8218;Hello World’-language the wizard creates as a starting point. 
					We’ll have to adapt them to match the domain model language we have developed in the 
					<link linkend="getting-started-xtext">getting started section</link>. The first 
					thing we should do is open up the example model file (1) and replace its contents with an instance of the domain model language. To do so 
					copy and paste the following into the editor:
				</para>
				<literallayout><code>package java.lang {
  datatype String
  datatype Boolean
}

package my.entities {
  
  import java.lang.*
  
  entity Session {
    title: String
    isTutorial : Boolean
  }

  entity Conference {
    name : String
    attendees : Person*
    speakers : Speaker*
  }

  entity Person {
    name : String
  }

  entity Speaker extends Person {
    sessions : Session*
  }
} 

</code></literallayout>
			</section>
			<section id="TheModelingWorkflowEngineFile2">
				<title>The Modeling Workflow Engine File (2) </title>
				<para>As mentioned MWE2 is used to define and configure the generation process. Actually, it is much more general and can be useful for a lot of other things as well.
					Let’s have a look at the MWE2 file as generated by the wizard:</para>
				<literallayout><code>module workflow.DomainmodelGenerator

import org.eclipse.emf.mwe.utils.*

var targetDir = "src-gen"
var fileEncoding = "ISO-8859-1"
var modelPath = "src/model"

Workflow {

	component = org.eclipse.xtext.mwe.Reader {
		// lookup all resources on the classpath
		// useJavaClassPath = true

		// or define search scope explicitly
		path = modelPath

		// this class will be generated by the xtext generator 
		register = org.eclipse.xtext.example.DomainmodelStandaloneSetup {}
		load = {
			slot = "greetings"
			type = "Greeting"
		}
	}

	component = org.eclipse.xpand2.Generator {
		expand = "templates::Template::main FOREACH greetings"
		outlet = {
			path = targetDir
		}
		fileEncoding = fileEncoding
	}
}

</code></literallayout>
				<para>The first line just declares a name for this workflow file. Any qualified Java identifier is allowed, but it should 
					match the file name of the MWE2 file (and in future versions we might make this mandatory). It is followed by an 
					<emphasis>import</emphasis> statement.
					MWE2 references Java classes and to make that convenient, you can specify imports after the module declaration. Next up we 
					see a couple of 
					<emphasis>vars</emphasis> are declared. Such 
					<emphasis>vars</emphasis> can be overridden when invoking a workflow file. 
				</para>
				<para>The important part is the 
					<emphasis>Workflow</emphasis> part. There we declare an instance of 
					<emphasis>org.eclipse.emf.mwe.utils.Workflow</emphasis> and add two instances to the 
					<emphasis>component</emphasis>
					property. The first one is a 
					<emphasis>Reader</emphasis> which is used to initialize Xtext languages, read in Xtext files, and fetch specific elements from those models in order to
					make them available to following workflow components (such as the declared 
					<emphasis>Generator</emphasis>). 
				</para>
				<para>Xtext language initialization is done by specifying any number of 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/ISetup.java?root=Modeling_Project&amp;view=co">ISetup</ulink> implementations. In our case the generated 
					<emphasis>DomainModelStandaloneSetup</emphasis> is
					registered, which makes sure that the infrastructure of your domain model language is set up properly. If you have multiple languages just add additional assignments for each language.
				</para>
				<para>You have to tell the 
					<emphasis>Reader</emphasis> which paths to scan for model files. In this particular case we just specified one path. Another convenient option is to reuse the Java classpath, as suggested in the comments.
				</para>
				<para>The 
					<emphasis>load</emphasis> section specifies which elements to fetch from the loaded resources. In this case we state that we want all elements of type 
					<emphasis>Greeting</emphasis>.
					Note that this is completely file agnostic, it will provide you with all elements from all files the 
					<emphasis>Reader</emphasis> could find on the specified paths.
					The slot name is the name by which other workflow components can access the stored elements.
				</para>
				<para>The second workflow component is an instance of 
					<emphasis>org.eclipse.xpand2.Generator</emphasis>, which is the MWE2 facade to the Xpand template language. 
					The Xpand generator needs to know which template to invoke for which models. Qualified names in Xpand are separated by a double colon 
					<emphasis>'::'</emphasis>. That
					is the name 
					<emphasis>'templates::Template::main'</emphasis> points to the definition 
					<emphasis>main</emphasis> in the file 
					<emphasis>templates/Template.xpt</emphasis> on the Java classpath. The second part

					<emphasis>FOREACH greetings</emphasis> references the 
					<emphasis>greetings</emphasis> slot which has previously been populated by the reader component.
				</para>
				<para>An 
					<emphasis>Outlet</emphasis> describes where to put the generated sources. In Xpand there is a file-statement which refers to outlets. If you only have one outlet 
					you don’t have to give it a name, but you need to declare where the root folder for that outlet can be found in the file system. I.e. you specifiy where the generated code should go.
					Oulets allow you to specify a couple of other things as well. As MWE2 just instantiates Java objects, you can go to the Java code of 
					<emphasis>org.eclipse.xpand2.output.Outlet</emphasis>
					 in order to find out (see the adder and setter methods). 
					about the different options.
				</para>
				<para>Now that we understood the most important things in the workflow we have to adapt it to match our domain model language. We only have to change the type
					which is used to fetch and filter the elements in the load section. We want to generate code for entities, therefore we change it to Entity. We should change the slot’s 
					name, too:</para>
				<literallayout><code>module workflow.DomainmodelGenerator

import org.eclipse.emf.mwe.utils.*

var targetDir = "src-gen"
var fileEncoding = "ISO-8859-1"
var modelPath = "src/model"

Workflow {

	component = org.eclipse.xtext.mwe.Reader {
		// lookup all resources on the classpath
		// useJavaClassPath = true

		// or define search scope explicitly
		path = modelPath

		// this class will be generated by the xtext generator 
		register = org.eclipse.xtext.example.DomainmodelStandaloneSetup {}
		load = {
			slot = "entities" //changed to entities
			type = "Entity"   //changed to Entity
		}
	}

	component = org.eclipse.xpand2.Generator {
		expand = "templates::Template::main FOREACH entities" //changed to entities
		outlet = {
			path = targetDir
		}
		fileEncoding = fileEncoding
	}
}

</code></literallayout>
			</section>
			<section id="UsingXpand3andXtend4forCodeGeneration">
				<title>Using Xpand (3) and Xtend (4) for Code Generation</title>
				<para>The MWE2 file invokes an Xpand definition called 
					<emphasis>main</emphasis> located in 
					<emphasis>templates/Template.xpt</emphasis>. 
					Please open that file and replace its contents with the following Xpand code:
				</para>
				<literallayout><code>«IMPORT org::eclipse::xtext::example::domainmodel»
«EXTENSION templates::Extensions»

«DEFINE main FOR Entity-»
«FILE qualifiedName().replaceAll("\\.","/")+".java"-»
package «packageName()»;

public class «name» «IF superType != null» extends «superType.name»«ENDIF»{
{
  «EXPAND property FOREACH features»
}
«ENDFILE»
«ENDDEFINE»

«DEFINE property FOR Feature»
  private «type.referenced.qualifiedName()» «name»;
  
  public void set«name.toFirstUpper()»(
       «type.referenced.qualifiedName()» «name») {
    this.«name» = «name»;
  } 
  public «type.referenced.qualifiedName()» get«name.toFirstUpper()»() {
    return «name»;
  } 
«ENDDEFINE»

</code></literallayout>
				<para>You might get a couple of error markers, because the Xpand file references another file (
					<emphasis>Extensions.ext</emphasis> (4)) which has not yet been updated. 
					Let’s ignore this for a moment and have a look at the general structure of an Xpand template file. In the first line we import the namespace (i.e. Java package)
					of the generated AST classes, that is Entity and Feature, we want to refer to in the generator. Next up the previously mentioned Xtend file is imported. An Xtend file defines 
					functions which can be used in Xpand. 
				</para>
				<para>The rest of the file contains two so called definitions. A definition in Xpand is similar to a function in that it can be called, it has a name and it is defined
					for one or more arguments. The general syntax is as follows:</para>
				<literallayout><code>«DEFINE name(ArgType1 arg1, ArgType2 arg2) FOR MainArgType»

</code></literallayout>
				<para>Where 
					<emphasis>MainArgType</emphasis> is bound to the variable name 
					<emphasis>this</emphasis> which can like in Java be omitted when referring to.
				</para>
				<para>The first definition 
					<emphasis>main</emphasis> is defined for 
					<emphasis>Entity</emphasis> and is the one invoked from the previously discussed MWE2 file (2). 
					The first thing the definition does is opening a file using the 
					<emphasis>qualifiedName()</emphasis> of the given 
					<emphasis>Entity</emphasis>. 
					The function 
					<emphasis>qualifiedName()</emphasis> should be declared in the referenced Xtend file (4). To do so open that file and replace its
					current contents by the following snippet:
				</para>
				<literallayout><code>import org::eclipse::xtext::example::domainmodel;

packageName(Type this) :
	qualifiedName(eContainer());
	
packageName(Void this) : null;
	
String qualifiedName(Object this) : null;
	
String qualifiedName(Type this) : 
	packageName()==null? name : packageName()+"."+name;
	
String qualifiedName(PackageDeclaration this) :
	if qualifiedName(eContainer())==null 
		then name
		else qualifiedName(eContainer())+'.'+name;
	
</code></literallayout>
				<para>It defines the 
					<emphasis>qualifiedName()</emphasis> function not only for 
					<emphasis>Entity</emphasis> but also generally for types. Note how it computes the qualified name by calling

					<emphasis>qualifiedName()</emphasis> recursively on its 
					<emphasis>eContainer()</emphasis>. Both Xpand and Xtend are based on the same expression language, which is statically typed and 
					allows for very convenient navigation over object graphs and collections.
				</para>
				<para>Back to the Xpand file (3) we see some static text which goes directly into the opened file. The 
					<emphasis>EXPAND</emphasis> statement calls the other definition defined in this file.
					It will effectively generate a Java field and two accessor-methods for each 
					<emphasis>Feature</emphasis>. 
				</para>
				<para>You’ll now able able to run the generator by opening the context menu on the 
					<emphasis>*.mwe2</emphasis> file (2) and choose 
					<emphasis>Run As-&gt;MWE2 Workflow</emphasis>.
					For more information on Xpand and Xtend see the corresponding language documentation (available through Eclipse Help). MWE2 is explained in detail 
					in 
					<link linkend="MWE2">a later section</link>. 
				</para>
			</section>
		</section>
	</chapter>
	<chapter id="grammarLanguage">
		<title>The Grammar Language</title>
		<para>The 
			<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/Xtext.xtext?root=Modeling_Project&amp;view=markup">grammar language</ulink> 
			is the corner stone of Xtext. It is a domain-specific language, carefully designed for the description of textual languages.
			The main idea is to describe the concrete syntax and how it is mapped to an in-memory model created during parsing. 
		</para>
		<section id="AFirstExample">
			<title>A First Example</title>
			<para>To get an idea of how it works we’ll start by implementing a 
				<ulink url="http://martinfowler.com/dslwip/Intro.html">simple example</ulink> 
				introduced by Martin Fowler. It’s mainly about describing state machines used as the (un)lock mechanism of secret compartments.
				People who have secret compartments control their access in a very old-school way, e.g. by opening the door first and 
				turning on the light afterwards. Then the secret compartment, for instance a panel, opens up. One of those state machines 
				could look like this:
			</para>
			<literallayout><code>events
  doorClosed  D1CL
  drawOpened  D2OP
  lightOn     L1ON
  doorOpened  D1OP
  panelClosed PNCL
end
 
resetEvents
  doorOpened
end
 
commands
  unlockPanel PNUL
  lockPanel   PNLK
  lockDoor    D1LK
  unlockDoor  D1UL
end
 
state idle
  actions {unlockDoor lockPanel}
  doorClosed =&gt; active
end
 
state active
  drawOpened =&gt; waitingForLight
  lightOn    =&gt; waitingForDraw
end
 
state waitingForLight
  lightOn =&gt; unlockedPanel
end
 
state waitingForDraw
  drawOpened =&gt; unlockedPanel
end
 
state unlockedPanel
  actions {unlockPanel lockDoor}
  panelClosed =&gt; idle
end

</code></literallayout>
			<para>So, we have a bunch of declared events, commands, and states. Within states there are references to declared actions,
				which should be executed when entering such a state. Also there are transitions consisting of a reference to an event and 
				a state. Please read 
				<ulink url="http://martinfowler.com/dslwip/Intro.html">Martin’s description</ulink> if you want to read the whole story.
			</para>
			<para>In order to implment this little language with Xtext, you need to write the following grammar:</para>
			<literallayout><code>grammar my.pack.SecretCompartments 
   with org.eclipse.xtext.common.Terminals

generate secretcompartment "http://www.eclipse.org/secretcompartment"
 
Statemachine :
  'events'
     (events+=Event)+
  'end'
  ('resetEvents'
     (resetEvents+=[Event])+
  'end')?
  'commands'
     (commands+=Command)+
  'end'
  (states+=State)+;
 
Event :
  name=ID code=ID;
 
Command :
  name=ID code=ID;
 
State :
  'state' name=ID
     ('actions' '{' (actions+=[Command])+ '}')?
     (transitions+=Transition)*
  'end';
 
Transition :
  event=[Event] '=&gt;' state=[State];
  
</code></literallayout>
			<para>Martin uses this example throughout his book &#8222;Domain-Specific Languages” to implement external and internal DSLs using
				different technologies. Note, that none of his implmentations is nearly as readable and concise as the description in
				Xtext’s grammar language above. That is of course because the grammar language is designed to do just that, i.e. it is 
				specific to the domain of language descriptions.</para>
		</section>
		<section id="syntax">
			<title>The Syntax</title>
			<para>In the following the different concepts and syntactical constructs of the grammar language are explained. </para>
			<section id="LanguageDeclaration">
				<title>Language Declaration</title>
				<para>The first line in every grammar ... </para>
				<literallayout><code>grammar my.pack.SecretCompartments with org.eclipse.xtext.common.Terminals
</code></literallayout>
				<para>declares the name of the grammar. Xtext leverages Java’s classpath mechanism. This means that the name 
					can be any valid Java qualifier. The file name needs to correspond to the grammar name and have the file 
					extension '
					<emphasis>.xtext</emphasis>'. This means that the name has to be 
					<emphasis>SecretCompartments.xtext</emphasis> and must be placed 
					in a package 
					<emphasis>my.pack</emphasis> somewhere on your project’s classpath.
				</para>
				<para>The first line is also used to declare any used language (for mechanism details see 
					<link linkend="grammarMixins">Grammar Mixins</link>).
				</para>
			</section>
			<section id="package_declarations">
				<title>EPackage Declarations</title>
				<para>Xtext parsers create in-memory object graphs while parsing text. Such object-graphs are 
					instances of EMF Ecore models. An Ecore model basically consists of an 
					<emphasis>EPackage</emphasis> containing 
					<emphasis>EClasses</emphasis>, 

					<emphasis>EDataTypes</emphasis> and 
					<emphasis>EEnums</emphasis> (See the 
					<link linkend="model_metamodel">section on EMF</link> for more details).
					Xtext can infer Ecore models from a grammar (see 
					<link linkend="metamodelInference">Ecore model inference</link>) but it is also 
					possible to reuse existing Ecore models. You can even mix this and use multiple existing Ecore models and 
					infer some others from one grammar. 
				</para>
				<section id="EPackageGeneration">
					<title>EPackage Generation</title>
					<para>The easiest way to get started is to let Xtext infer the Ecore model from your grammar. This is what is done in the 
						secret compartment example. To do so just state:</para>
					<literallayout><code>generate secretcompartment 'http://www.eclipse.org/secretcompartment'
</code></literallayout>
					<para>That statement means: generate an 
						<emphasis>EPackage</emphasis> with the 
						<emphasis>name</emphasis> &#8222;secretcompartment” and the 
						<emphasis>nsURI</emphasis> &#8222;http://www.eclipse.org/secretcompartment”. 
						Actually these are the properties that are required to create an 
						<emphasis>EPackage</emphasis>.
						Xtext will then add 
						<emphasis>EClasses</emphasis> with properties (
						<emphasis>EAttributes</emphasis> and 
						<emphasis>EReferences</emphasis>) for the different rules, as described in

						<link linkend="metamodelInference">Ecore model inference</link>. 
					</para>
				</section>
				<section id="EPackageImport">
					<title>EPackage Import</title>
					<para>If you already have an existing 
						<emphasis>EPackage</emphasis>, you can import it using either a namespace URI or a resource URI. 
						An 
						<ulink url="http://www.ietf.org/rfc/rfc2396.txt">URI</ulink> (Uniform Resource Identifier) provides a simple and extensible 
						means for identifying an abstract or physical resource. For all the niftx details about EMF URIs 
						please see its 
						<ulink url="http://help.eclipse.org/help32/topic/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/common/util/URI.html">documentation</ulink>.
					</para>
					<section id="UsingResourceURIstoImportExistingEPackages">
						<title>Using Resource URIs to Import Existing EPackages</title>
						<para>In order to import an existing Ecore model, you’ll have to have the *.ecore file describing the 
							<emphasis>EPackage</emphasis> you want to 
							use somewhere in your workspace. In order to refer to that file you make use of the platform:/resource scheme.
							Platform URIs are a special EMF concept, which allow to reference elements in the workspace 
							independent of the location of the workspace. 
						</para>
						<para>An import statement referring to an Ecore file by a 
							<emphasis>platform:/resource/</emphasis>-URI looks like this: 
						</para>
						<literallayout><code>import 'platform:/resource/my.project/src/my/pack/SecretCompartments.ecore'
</code></literallayout>
						<para>If you want to mix generated and imported Ecore models you’ll have to configure the generator fragment 
							in your MWE file responsible for generating the Ecore classes 
							(
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/ecore/EcoreGeneratorFragment.java?root=Modeling_Project&amp;view=co">EcoreGeneratorFragment</ulink>) 
							with resource URIs that point to the 
							<link linkend="emf_codegen">generator models</link> of the referenced Ecore models.
						</para>
						<para>The *.genmodel provides all kind of generator configuration used by EMF’s code generator. Xtext will automatically create
							a *.genmodel for generated ecore models, but if such a model references an existing imported Ecore model, the code generator 
							needs to know how that code was generated in order to generate valid references in Java for the new Ecore model. </para>
						<para>Example:</para>
						<literallayout><code>fragment = org.eclipse.xtext.generator.ecore.EcoreGeneratorFragment {
  genModels =
    "platform:/resource/my.project/src/my/pack/SecretCompartments.genmodel"
}

</code></literallayout>
					</section>
					<section id="UsingClasspathURIstoImportExistingEPackages">
						<title>Using Classpath URIs to Import Existing EPackages</title>
						<para>We like to leverage Java’s classpath mechanism, because besides that it is well understood and designed it allows us to
							package libraries as jars. If you want to reference an *.ecore file which is contained in a jar, you can make use of the 
							classpath scheme we’ve introduced. For instance if you want to reference Java elements, you can use the JvmType Ecore model 
							which is shipped as part of Xtext. </para>
						<para>Example:</para>
						<literallayout><code>import 'classpath:/model/JvmTypes.ecore' as types
</code></literallayout>
						<para>As with platform resource URIs you’ll also have to tell the generator where the corresponding *.genmodel can be found:</para>
						<literallayout><code>fragment = org.eclipse.xtext.generator.ecore.EcoreGeneratorFragment {
  genModels =
    "classpath:/model/JvmTypes.genmodel"
}

</code></literallayout>
						<para>See the section on 
							<link linkend="jvmtypes">Referring Java Types</link> for a full explanation of this useful feature.
						</para>
					</section>
					<section id="UsingNamespaceURIstoImportExistingEPackages">
						<title>Using Namespace URIs to Import Existing EPackages</title>
						<para>You can also use nsURI in order to import existing 
							<emphasis>EPackage</emphasis>. Note that this is generally not
							preferrable, because you’ll have to have the corresponding EPackage installed in the workbench.
							There’s mainly just one exception, that is Ecore itself. So if you refer to Ecore it is best
							to use its nsURI :
						</para>
						<literallayout><code>import "http://www.eclipse.org/emf/2002/Ecore" as ecore
</code></literallayout>
					</section>
				</section>
				<section id="EcoreModelAliasesforEPackages">
					<title>Ecore Model Aliases for EPackages</title>
					<para>If you want to use multiple 
						<emphasis>EPackages</emphasis> you need to specify aliases in the following way:
					</para>
					<literallayout><code>generate secretcompartment 'http://www.eclipse.org/secretcompartment'
import 'http://www.eclipse.org/anotherPackage' as another

</code></literallayout>
					<para>When referring to a type somewhere in the grammar you need to qualify the reference using that 
						alias (example 
						<emphasis>another::CoolType</emphasis>). We’ll see later where such type references occur.
					</para>
					<para>It is also supported to put multiple 
						<emphasis>EPackage</emphasis> imports into one alias. This is no problem as 
						long as there are not any two 
						<emphasis>EClassifiers</emphasis> with the same name. In such cases none of them can be referenced. 
						It is even possible to 
						<emphasis>import</emphasis> multiple and 
						<emphasis>generate</emphasis> one Ecore model and all of them are declared for 
						the same alias. If you do so, for a reference to an 
						<emphasis>EClassifier</emphasis> first the imported 
						<emphasis>EPackages</emphasis> are 
						scanned before it is assumed that a type needs to by generated into the to-be-generated package. 
					</para>
					<para>Note, that using this feature is not recommended, because it might cause problems, which are hard to track down.
						For instance, a reference to 
						<emphasis>classA</emphasis> would as well be linked to a newly created 
						<emphasis>EClass</emphasis>, because the 
						corresponding type in 
						<emphasis>http://www.eclipse.org/packContainingClassA</emphasis> is spelled with a capital letter.
					</para>
				</section>
			</section>
			<section id="Rules">
				<title>Rules</title>
				<para>Basically parsing can be separated in the following phases. </para>
				<orderedlist>
					<listitem>
						<para>lexing</para>
					</listitem>
					<listitem>
						<para>parsing</para>
					</listitem>
					<listitem>
						<para>linking</para>
					</listitem>
					<listitem>
						<para>validation</para>
					</listitem>
				</orderedlist>
				<section id="TerminalRules">
					<title>Terminal Rules</title>
					<para>In the first stage called 
						<emphasis>lexing</emphasis>, a sequence of characters (the text input) is transformed into a sequence of so 
						called tokens. In this context, a token is sort of a strongly typed part of the input sequence. It consists of one 
						or more characters and was matched by a particular terminal rule or keyword and therefore represents an atomic symbol.
						Terminal rules are also referred to as 
						<emphasis>token rules</emphasis> or 
						<emphasis>lexer rules</emphasis>. There is an informal naming convention that 
						names of terminal rules are all upper-case.
					</para>
					<para>In the secret compartments example there are no explicitly defined terminal rules, since it only uses the 
						<emphasis>ID</emphasis> rule 
						which is inherited from the grammar 
						<emphasis>org.eclipse.xtext.common.Terminals</emphasis> (cf. 
						<link linkend="grammarMixins">Grammar Mixins</link>).
						Therein the 
						<emphasis>ID</emphasis> rule is defined as follows:
					</para>
					<literallayout><code>terminal ID : 
  ('^')?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*; 
    
</code></literallayout>
					<para>It says that a token 
						<emphasis>ID</emphasis> starts with an optional 
						<emphasis>'^'</emphasis> character (caret), followed by a letter 
						<emphasis>(&#8218;a’..&#8218;z’|&#8218;A’..&#8218;Z’)</emphasis> 
						or underscore (&#8218;_’) followed by any number of letters, underscores and numbers 
						<emphasis>(&#8218;0’..&#8218;9’)</emphasis>. 
					</para>
					<para>The caret is used to escape an identifier for cases where there are conflicts with keywords. It is removed 
						by the 
						<emphasis>ID</emphasis> rule’s 
						<link linkend="valueconverter">ValueConverter</link>. 
					</para>
					<para>This is the formal definition of terminal rules:</para>
					<literallayout><code>TerminalRule :
  'terminal' name=ID ('returns' type=TypeRef)? ':' 
    alternatives=TerminalAlternatives ';'
;

</code></literallayout>
					<para>Note, that 
						<emphasis>the order of terminal rules is crucial for your grammar</emphasis>, as they may hide each other. 
						This is especially important for newly introduced rules in connection with mixed rules from used grammars. 
					</para>
					<para>If you for instance want to add a rule to allow fully qualified names in addition to simple IDs, you should 
						implement it as a 
						<link linkend="datatypeRules">data type rule</link>, instead of adding another terminal rule.
					</para>
					<section id="ReturnTypes">
						<title>Return Types</title>
						<para>A terminal rule returns a value, which is a string (type 
							<emphasis>ecore::EString</emphasis>) by default.
							However, if you want to have a different type you can specify it. For instance, the rule 
							<emphasis>INT</emphasis> is defined as:
						</para>
						<literallayout><code>terminal INT returns ecore::EInt : 
  ('0'..'9')+;

</code></literallayout>
						<para>This means that the terminal rule 
							<emphasis>INT</emphasis> returns instances of 
							<emphasis>ecore::EInt</emphasis>. It is possible to define any 
							kind of data type here, which just needs to be an instance of 
							<emphasis>ecore::EDataType</emphasis>. In order to tell the parser 
							how to convert the parsed string to a value of the declared data type, you need to provide your own 
							implementation of 
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverterService.java?root=Modeling_Project&amp;view=co">IValueConverterService</ulink> (cf. 

							<link linkend="valueconverter">value converters</link>). The value converter is also the point where you can remove things 
							like quotes from string literals or the caret (&#8218;^’) from identifiers. Its implementation needs to be registered 
							as a service (cf. 
							<link linkend="dependencyInjection">Service Framework</link>).
						</para>
					</section>
				</section>
				<section id="ExtendedBackusNaurFormExpressions">
					<title>Extended Backus-Naur Form Expressions</title>
					<para>Token rules are described using &#8222;Extended Backus-Naur Form”-like (EBNF) expressions. The different expressions 
						are described in the following. The one thing all of these expressions have in common is the cardinality operator.
						There are four different possible cardinalities</para>
					<orderedlist>
						<listitem>
							<para>exactly one (the default, no operator)</para>
						</listitem>
						<listitem>
							<para>one or none (operator 
								<emphasis>?</emphasis>)
							</para>
						</listitem>
						<listitem>
							<para>any (zero or more, operator 
								<emphasis>*</emphasis>)
							</para>
						</listitem>
						<listitem>
							<para>one or more (operator 
								<emphasis>+</emphasis>)
							</para>
						</listitem>
					</orderedlist>
					<section id="Keywords">
						<title>Keywords / Characters</title>
						<para>Keywords are a kind of token rule literals. 
							The 
							<emphasis>ID</emphasis> rule in 
							<emphasis>org.eclipse.xtext.common.Terminals</emphasis> for instance starts with a keyword:
						</para>
						<literallayout><code>terminal ID : '^'? .... ;
</code></literallayout>
						<para>The question mark sets the cardinality to &#8222;none or one” (i.e. optional) like explained above.</para>
						<para>Note that a keyword can have any length and contain arbitrary characters. </para>
						<para>The following standard Java notations for special characters are allowed: 
							<emphasis>\n</emphasis>, 
							<emphasis>\r</emphasis>,
							 
							<emphasis>\t</emphasis>, 
							<emphasis>\b</emphasis>, and 
							<emphasis>\f</emphasis>. We currently don’t support quoted unicode character notation, as 
							<emphasis>\u123</emphasis>.
						</para>
					</section>
					<section id="CharacterRanges">
						<title>Character Ranges</title>
						<para>A character range can be declared using the &#8218;..’ operator.</para>
						<para>Example:</para>
						<literallayout><code>terminal INT returns ecore::EInt: ('0'..'9')+;
</code></literallayout>
						<para>In this case an 
							<emphasis>INT</emphasis> is comprised of one or more (note the 
							<emphasis>+</emphasis> operator) characters 
							between (and including) 
							<emphasis>'0'</emphasis> and 
							<emphasis>'9'</emphasis>.
						</para>
					</section>
					<section id="Wildcard">
						<title>Wildcard</title>
						<para>If you want to allow any character you can simple write the wildcard operator '
							<emphasis>.</emphasis>' (dot):
							Example:
						</para>
						<literallayout><code>FOO : 'f' . 'o';
</code></literallayout>
						<para>The rule above would allow expressions like &#8218;foo’, &#8218;f0o’ or even &#8218;f\no’.</para>
					</section>
					<section id="UntilToken">
						<title>Until Token</title>
						<para>With the until token it is possible to state that everything should be consumed until a certain token occurs.
							The multi-line comment is implemented this way:</para>
						<literallayout><code>terminal ML_COMMENT	: '/*' -&gt; '*/';
</code></literallayout>
						<para>This is the rule for Java-style comments that begin with '
							<emphasis>/*</emphasis>' and end with '
							<emphasis>*/</emphasis>'.
						</para>
					</section>
					<section id="NegatedToken">
						<title>Negated Token</title>
						<para>All the tokens explained above can be inverted using a preceding exclamation mark:</para>
						<literallayout><code>terminal BETWEEN_HASHES	: '#' (!'#')* '#';
</code></literallayout>
					</section>
					<section id="RuleCalls">
						<title>Rule Calls</title>
						<para>Rules can refer to other rules. This is done by writing the name of the rule to be called.
							We refer to this as rule calls. Rule calls in terminal rules can only point to terminal rules.</para>
						<para>Example:</para>
						<literallayout><code>terminal DOUBLE : INT '.' INT;
</code></literallayout>
					</section>
					<section id="Alternatives">
						<title>Alternatives </title>
						<para>Using alternatives one can state multiple different alternatives.
							For instance, the whitespace rule uses alternatives like this:</para>
						<literallayout><code>terminal WS : (' '|'\t'|'\r'|'\n')+;
</code></literallayout>
						<para>That is a WS can be made of one or more whitespace characters (including &#8218; ’, '
							<emphasis>\t</emphasis>', '
							<emphasis>\r</emphasis>', '
							<emphasis>\n</emphasis>').
						</para>
					</section>
					<section id="Groups">
						<title>Groups</title>
						<para>Finally, if you put tokens one after another, the whole sequence is referred to as a group.
							Example:</para>
						<literallayout><code>terminal ASCII : '0x' ('0'..'7') ('0'..'9'|'A'..'F');
</code></literallayout>
						<para>That is the 2-digit hexadecimal code of ASCII characters.</para>
					</section>
				</section>
			</section>
			<section id="parser_rules">
				<title>Parser Rules</title>
				<para>The parser reads a sequence of terminals and walks through the parser rules. Hence a parser rule - 
					contrary to a terminal rule – does not produce a single terminal token but a tree of non-terminal 
					and terminal tokens. They lead to a so called 
					<link linkend="node_model">parse tree</link> (in Xtext it is also referred 
					as node model). Furthermore, parser rules are handled as kind of a building plan for the creation of 
					the 
					<emphasis>EObjects</emphasis> that form the semantic model (the linked abstract syntax graph or AST). Due to this 
					fact, parser rules are even called production rules. The different constructs like actions and 
					assignments are used to derive types and initialize the semantic objects accordingly. 
				</para>
				<section id="ExtendedBackusNaurFormExpressions2">
					<title>Extended Backus-Naur Form Expressions</title>
					<para>Not all the expressions that are available in terminal rules can be used in parser rules. Character 
						ranges, wildcards, the until token and the negation are only available for terminal rules. </para>
					<para>The elements that are available in parser rules as well as in terminal rules are</para>
					<orderedlist>
						<listitem>
							<para>groups, </para>
						</listitem>
						<listitem>
							<para>
								<link linkend="Alternatives">alternatives</link>, 
							</para>
						</listitem>
						<listitem>
							<para>
								<link linkend="Keywords">keywords</link> and 
							</para>
						</listitem>
						<listitem>
							<para>rule calls.</para>
						</listitem>
					</orderedlist>
					<para>In addition to these elements, there are some expressions used to direct how the AST 
						is constructed, which are listed and explained in the following.</para>
					<section id="assignments">
						<title>Assignments </title>
						<para>Assignments are used to assign the parsed information to a feature of the current object. 
							The type of the current object, its 
							<emphasis>EClass</emphasis>, is specified by the return type of the parser 
							rule. If it is not explicitly stated it is implied that the type’s name equals the rule’s name. 
							The type of the feature is inferred from the right hand side of the assignment.
						</para>
						<para>Example:</para>
						<literallayout><code>State :
  'state' name=ID
    ('actions' '{' (actions+=[Command])+ '}')?
    (transitions+=Transition)*
  'end'
;

</code></literallayout>
						<para>The syntactic declaration for states in the state machine example starts with a keyword 
							<emphasis>state</emphasis> followed by an assignment:
						</para>
						<literallayout><code>name=ID
</code></literallayout>
						<para>The left hand side refers to a feature '
							<emphasis>name</emphasis>' of the current object (which has the 
							<emphasis>EClass</emphasis> '
							<emphasis>State</emphasis>' in this case). 
							The right hand side can be a rule call, a keyword, a cross-reference (explained later) or even an 
							alternative comprised by the former. The type of the feature needs to be compatible with the type of the
							 expression on the right. As 
							<emphasis>ID</emphasis> returns an 
							<emphasis>EString</emphasis> in this case, the feature '
							<emphasis>name</emphasis>' needs to be 
							 of type 
							<emphasis>EString</emphasis> as well.
						</para>
						<para>
							<emphasis role="bold">Assignment Operators</emphasis>
						</para>
						<para>There are three different assignment operators, each with different semantics.</para>
						<orderedlist>
							<listitem>
								<para>The simple equal sign '
									<emphasis>=</emphasis>' is the straight forward assignment, and used for features which take only one element.
								</para>
							</listitem>
							<listitem>
								<para>The '
									<emphasis>+=</emphasis>' sign (the add operator) expects a multi-valued feature and adds the value on the right hand to that feature, which is a list feature.
								</para>
							</listitem>
							<listitem>
								<para>The '
									<emphasis>?=</emphasis>' sign (boolean assignment operator) expects a feature of type 
									<emphasis>EBoolean</emphasis> and sets it to true if the right hand side was consumed independently from the concrete value of the right hand side.
								</para>
							</listitem>
						</orderedlist>
						<para>The used assignment operator does not effect the cardinality of the expected symbols on the right hand side. </para>
					</section>
					<section id="CrossReferences">
						<title>Cross-References </title>
						<para>A unique feature of Xtext is the ability to declare crosslinks in the grammar. In traditional compiler 
							construction the crosslinks are not established during parsing but in a later linking phase. This is the 
							same in Xtext, but we allow to specify crosslink information in the grammar. This information is used by the linker.
							The syntax for crosslinks is:</para>
						<literallayout><code>CrossReference :
  '[' type=TypeRef ('|' ^terminal=CrossReferenceableTerminal )? ']'
;

</code></literallayout>
						<para>For example, the transition is made up of two cross-references, pointing to an event and a state:</para>
						<literallayout><code>Transition :
  event=[Event] '=&gt;' state=[State]
;

</code></literallayout>
						<para>It is important to understand that the text between the square brackets does not refer to another rule, but to a type!
							This is sometimes confusing, because one usually uses the same name for the rules and the returned types.
							That is if we had named the type for events differently like in the following the cross-reference needs 
							to be adapted as well:</para>
						<literallayout><code>Transition :
  event=[MyEvent] '=&gt;' state=[State]
;
 
Event returns MyEvent : ....;

</code></literallayout>
						<para>Looking at the syntax definition of cross-references, there is an optional part starting with a vertical 
							bar (pipe) followed by 
							<emphasis>CrossReferenceableTerminal</emphasis>. This is the part describing the concrete text, from 
							which the crosslink later should be established. If the terminal is omitted, it is expected to be 
							<emphasis>ID</emphasis>.
						</para>
						<para>You may even use alternatives as the referencable terminal. This way, either an 
							<emphasis>ID</emphasis> or a 
							<emphasis>STRING</emphasis> may be 
							used as the referencable terminal, as it is possible in many SQL dialects.
						</para>
						<literallayout><code>TableRef: table=[Table|(ID|STRING)];
</code></literallayout>
						<para>Have a look at the 
							<link linkend="linking">linking section</link> in order to understand how linking is done.
						</para>
					</section>
					<section id="unordered_groups">
						<title>Unordered Groups</title>
						<para>The elements of an unordered group can occur in any order but each element must appear once. Unordered 
							groups are separated with '
							<emphasis>&amp;</emphasis>', e.g.
						</para>
						<literallayout><code>Modifier: 
	static?='static'? &amp; final?='final'? &amp; visibility=Visibility;

enum Visibility:
	PUBLIC='public' | PRIVATE='private' | PROTECTED='protected';
	
</code></literallayout>
						<para>allows</para>
						<literallayout><code>public static final
static protected 
final private static
public

</code></literallayout>
						<para>but not</para>
						<literallayout><code>static final static // ERROR: static appears twice
public static final private // ERROR: visibility appears twice
final // ERROR: visibility is missing

</code></literallayout>
						<para>Note that if you want an element of an unordered group to appear once or not at all, 
							you have to choose a cardinality of '
							<emphasis>?</emphasis>'. In the example, the visibility is mandatory, 
							while '
							<emphasis>static</emphasis>' or '
							<emphasis>final</emphasis>' are optional. Elements with a cardinality of '
							<emphasis>*</emphasis>' or '
							<emphasis>+</emphasis>'
							have to appear continuously without interruption, i.e.
						</para>
						<literallayout><code>Rule:
	values+=INT* &amp; name=ID;

</code></literallayout>
						<para>will parse</para>
						<literallayout><code>0 8 15 x
x 0 8 15 

</code></literallayout>
						<para>but not </para>
						<literallayout><code>0 x 8 15 // wrong, as values cannot be interrupted.

</code></literallayout>
					</section>
					<section id="SimpleActions">
						<title>Simple Actions </title>
						<para>By default the object to be returned by a parser rule is created lazily on the first assignment. Then the type of the 
							<emphasis>EObject</emphasis> to be created is determined from the specified return type or the rule name if no explicit return type is specified.
							With Actions however, the creation of returned 
							<emphasis>EObject</emphasis> can be made explicit. Xtext supports two kinds of Actions:
						</para>
						<orderedlist>
							<listitem>
								<para>simple actions, and</para>
							</listitem>
							<listitem>
								<para>assigned actions.</para>
							</listitem>
						</orderedlist>
						<para>If at some point you want to enforce the creation of a specific type you can use alternatives or simple actions.
							In the following example 
							<emphasis>TypeB</emphasis> must be a subtype of 
							<emphasis>TypeA</emphasis>. An expression 
							<emphasis>A ident</emphasis> should create an instance of 

							<emphasis>TypeA</emphasis>, whereas 
							<emphasis>B ident</emphasis> should instantiate 
							<emphasis>TypeB</emphasis>.
						</para>
						<para>Example with alternatives:</para>
						<literallayout><code>MyRule returns TypeA :
  "A" name=ID |
  MyOtherRule
; 
 
MyOtherRule returns TypeB :
  "B" name = ID
;

</code></literallayout>
						<para>Example with simple actions:  </para>
						<literallayout><code>MyRule returns TypeA :
  "A" name=ID |
  "B" {TypeB} name=ID
; 

</code></literallayout>
						<para>Generally speaking, the instance is created as soon as the parser hits the first assignment. However, actions 
							allow to explicitly instantiate any 
							<emphasis>EObject</emphasis>. The notation 
							<emphasis>{TypeB}</emphasis> will create an instance of TypeB and assign 
							it to the result of the parser rule. This allows parser rules without any assignment and object creation without 
							the need to introduce unnecessary rules.
						</para>
					</section>
					<section id="UnassignedRuleCalls">
						<title>Unassigned Rule Calls </title>
						<para>We previously explained, that the 
							<emphasis>EObject</emphasis> to be returned is created lazily when the first assignment occurs or 
							when a simple action is evaluated. There is another way one can set the 
							<emphasis>EObject</emphasis> to be returned, which we call 
							an &#8222;unassigned rule call”.
						</para>
						<para>Unassigned rule calls (the name suggests it) are rule calls to other parser rules, which are not used within an 
							assignment. If there is no feature the returned value shall be assigned to, the value is assigned to the 
&#8222;							to-be-returned” result of the calling rule.</para>
						<para>With unassigned rule calls one can, for instance, create rules which just dispatch between several other rules:</para>
						<literallayout><code>AbstractToken :
  TokenA |
  TokenB |
  TokenC
;

</code></literallayout>
						<para>As 
							<emphasis>AbstractToken</emphasis> could possibly return an instance of 
							<emphasis>TokenA</emphasis>, 
							<emphasis>TokenB</emphasis> or 
							<emphasis>TokenC</emphasis> its type must by a 
							super type of these types. It is now for instance as well possible to further change the state of the AST 
							element by assigning additional things.
						</para>
						<para>Example:</para>
						<literallayout><code>AbstractToken :
  ( TokenA |
    TokenB |
    TokenC ) (cardinality=('?'|'+'|'*'))?
;

</code></literallayout>
						<para>This way the 
							<emphasis>cardinality</emphasis> is optional (last question mark) and can be represented 
							by a question mark, a plus, or an asterisk. It will be assigned to either an 

							<emphasis>EObject</emphasis> of type 
							<emphasis>TokenA</emphasis>,  
							<emphasis>TokenB</emphasis>, or 
							<emphasis>TokenC</emphasis> which are all subtypes of 

							<emphasis>AbstractToken</emphasis>. The rule in this example will never create an instance of 
							<emphasis>AbstractToken</emphasis> directly 
							as long as the preceeding 
							<emphasis>TokenX</emphasis> rule call returns an element. 
						</para>
					</section>
					<section id="grammarActions">
						<title>Assigned Actions </title>
						<para>LL-parsing has some significant advantages over LR algorithms. The most important ones for Xtext are, that the generated code is much simpler to understand and debug and that it is easier to recover from errors. Especially ANTLR has a very nice generic error recovery mechanism. This allows to construct an AST even if there are syntactic errors in the text. You wouldn’t get any of the nice IDE features as soon as there is one little error, if we hadn’t error recovery.</para>
						<para>However, LL also has some drawbacks. The most important one is that it does not allow left recursive grammars.
							For instance, the following is not allowed in LL-based grammars, because 
							<emphasis>Expression &#8218;+’ Expression</emphasis> is left recursive:
						</para>
						<literallayout><code>Expression :
  Expression '+' Expression |
  '(' Expression ')' |
  INT
;

</code></literallayout>
						<para>Instead one has to rewrite such things by &#8222;left-factoring” it:</para>
						<literallayout><code>Expression :
  TerminalExpression ('+' TerminalExpression)?
;
 
TerminalExpression :
  '(' Expression ')' |
  INT
;

</code></literallayout>
						<para>In practice this is always the same pattern and therefore not that problematic. 
							However, by simply applying the Xtext AST construction features we’ve covered so far, a grammar ...</para>
						<literallayout><code>Expression :
  {Operation} left=TerminalExpression (op='+' right=TerminalExpression)?
;
 
TerminalExpression returns Expression:
  '(' Expression ')' |
  {IntLiteral} value=INT
;

</code></literallayout>
						<para>... would result in unwanted elements in the AST.
							For instance the expression 
							<emphasis>(42)</emphasis> would result in a tree like this:
						</para>
						<literallayout><code>Operation {
  left=Operation {
    left=IntLiteral {
      value=42
    }
  }
}

</code></literallayout>
						<para>Typically one would only want to have one instance of 
							<emphasis>IntLiteral</emphasis> instead.
						</para>
						<para>One can solve this problem using a combination of unassigned rule calls and assigned actions:</para>
						<literallayout><code>Expression :
  TerminalExpression ({Operation.left=current} 
    op='+' right=Expression)?
;
 
TerminalExpression returns Expression:
  '(' Expression ')' |
  {IntLiteral} value=INT
;

</code></literallayout>
						<para>In the example above 
							<emphasis>{Operation.left=current}</emphasis> is a so called tree rewrite action, which creates a new instance of the stated 
							<emphasis>EClass</emphasis> (
							<emphasis>Operation</emphasis> in this case) and assigns the element currently to-be-returned (
							<emphasis>current</emphasis> variable) to a feature of the newly created object (in this case feature 
							<emphasis>left</emphasis> of the 
							<emphasis>Operation</emphasis> instance).
							In Java these semantics could be expressed as:
						</para>
						<literallayout><code>Operation temp = new Operation();
temp.setLeft(current);
current = temp;

</code></literallayout>
					</section>
				</section>
			</section>
			<section id="hidden_terminals">
				<title>Hidden Terminal Symbols</title>
				<para>Because parser rules describe not a single token, but a sequence of patterns in the input, it is necessary to define the interesting parts of the input. Xtext introduces the concept of hidden tokens to handle semantically unimportant things like whitespaces, comments, etc. in the input sequence gracefully. It is possible to define a set of terminal symbols, that are hidden from the parser rules and automatically skipped when they are recognized. Nevertheless, they are transparently woven into the node model, but not relevant for the semantic model. </para>
				<para>Hidden terminals may (or may not) appear between any other terminals in any cardinality. They can be described per rule or for the whole grammar. When 
					<link linkend="grammarMixins">reusing a single grammar</link> its definition of hidden tokens is reused as well. The grammar 
					<emphasis>org.eclipse.xtext.common.Terminals</emphasis> comes with a reasonable default and hides all comments and whitespace from the parser rules.
				</para>
				<para>If a rule defines hidden symbols, you can think of a kind of scope that is automatically introduced. Any rule that is called from the declaring rule uses the same hidden terminals as the calling rule, unless it defines other hidden tokens itself.</para>
				<literallayout><code>Person hidden(WS, ML_COMMENT, SL_COMMENT): 
  name=Fullname age=INT ';'
;

Fullname: 
  (firstname=ID)? lastname=ID
;

</code></literallayout>
				<para>The sample rule &#8222;Person” defines multiline comments (_ML_COMMENT_), single-line comments (_SL_COMMENT_), and whitespace (
					<emphasis>WS</emphasis>) to be allowed between the 
					<emphasis>Fullname</emphasis> and the 
					<emphasis>age</emphasis>. Because the rule 
					<emphasis>Fullname</emphasis> does not introduce another set of hidden terminals, it allows the same symbols to appear between 
					<emphasis>firstname</emphasis> and 
					<emphasis>lastname</emphasis> as the calling rule 
					<emphasis>Person</emphasis>. Thus, the following input is perfectly valid for the given grammar snippet:
				</para>
				<literallayout><code>John /* comment */ Smith // line comment
/* comment */
      42      ; // line comment

</code></literallayout>
				<para>A list of all default terminals like 
					<emphasis>WS</emphasis> can be found in section 
					<link linkend="grammarMixins">Grammar Mixins</link>.
				</para>
			</section>
			<section id="datatypeRules">
				<title>Data Type Rules</title>
				<para>Data type rules are parsing-phase rules, which create instances of 
					<emphasis>EDataType</emphasis> instead of 
					<emphasis>EClass</emphasis>. Thinking about it, one may discover that they are quite similar to terminal rules.
					However, the nice thing about data type rules is that they are actually parser rules and are therefore 
				</para>
				<orderedlist>
					<listitem>
						<para>context sensitive and </para>
					</listitem>
					<listitem>
						<para>allow for use of hidden tokens.</para>
					</listitem>
				</orderedlist>
				<para>If you, for instance, want to define a rule to consume Java-like qualified names (e.g. &#8222;foo.bar.Baz”)
					you could write:</para>
				<literallayout><code>QualifiedName :
  ID ('.' ID)*
;

</code></literallayout>
				<para>In contrast to a terminal rule this is only valid in certain contexts, i.e. it won’t conflict with the rule 
					<emphasis>ID</emphasis>.
					If you had defined it as a terminal rule, it would possibly hide the 
					<emphasis>ID</emphasis> rule.
				</para>
				<para>In addition when this has been defined as a data type rule, it is allowed to use hidden tokens (e.g. &#8222;/* comment **/”) between the IDs and dots (e.g. 
					<emphasis>foo/* comment */. bar . Baz</emphasis>).
				</para>
				<para>Return types can be specified in the same way as in terminal rules:</para>
				<literallayout><code>QualifiedName returns ecore::EString : 
  ID ('.' ID)*
;

</code></literallayout>
				<para>Note that if a rule does not call another parser rule and does neither contain any actions nor 
					<link linkend="assignments">assignments</link>, it is considered to be a data type rule and the data type 
					<emphasis>EString</emphasis> is implied if none has been explicitly declared. You have to import Ecore with the alias 
					<emphasis>ecore</emphasis> in this case.
				</para>
				<para>For conversion again value converters are responsible (cf. 
					<link linkend="valueconverter">value converters</link>).
				</para>
			</section>
			<section id="EnumRules">
				<title>Enum Rules</title>
				<para>Enum rules return enumeration literals from strings. They can be seen as a shortcut for data type rules with specific value converters.
					The main advantage of enum rules is their simplicity, type safety and therefore nice validation. Furthermore it is possible to infer enums and their respective literals during the Ecore model transformation.</para>
				<para>If you want to define a 
					<emphasis>ChangeKind</emphasis> 
					<ulink url="http://help.eclipse.org/stable/index.jsp?topic=/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/change/impl/package-summary.html">org.eclipse.emf.ecore.change/model/Change.ecore</ulink> with 
					<emphasis>ADD</emphasis>, 
					<emphasis>MOVE</emphasis> and 
					<emphasis>REMOVE</emphasis> you could write:
				</para>
				<literallayout><code>enum ChangeKind :
  ADD | MOVE | REMOVE
;

</code></literallayout>
				<para>It is even possible to use alternative literals for your enums or reference an enum value twice:</para>
				<literallayout><code>enum ChangeKind :
  ADD = 'add' | ADD = '+' | 
  MOVE = 'move' | MOVE = '-&gt;' | 
  REMOVE = 'remove' | REMOVE = '-'
;

</code></literallayout>
				<para>Please note, that Ecore does not support unset values for enums. If you formulate a grammar like</para>
				<literallayout><code>Element: "element" name=ID (value=SomeEnum)?;
</code></literallayout>
				<para>with the input of</para>
				<literallayout><code>element Foo
</code></literallayout>
				<para>the resulting value of the element 
					<emphasis>Foo</emphasis> will hold the enum value with the internal representation of &#8218;0’ (zero). When generating the 
					<emphasis>EPackage</emphasis> from your grammar this will be the first literal you define. As a workaround you could introduce a dedicated none-value or order the enums accordingly. Note that it is not possible to define an enum literal with an empty textual representation.
				</para>
				<literallayout><code>enum Visibility: 
  package | private | protected | public
;
 
</code></literallayout>
				<para>You can overcome this by modifying the infered Ecore model through a 
					<link linkend="customPostProcessing">model to model transformation</link>.
				</para>
			</section>
		</section>
		<section id="metamodelInference">
			<title>Ecore Model Inference</title>
			<para>The Ecore model (or meta model) of a textual language describes the structure of its abstract syntax trees (AST). </para>
			<para>Xtext uses Ecore’s 
				<emphasis>EPackages</emphasis> to define Ecore models. Ecore models are declared to be either inferred (generated) from the grammar or imported. 
				By using the 
				<emphasis>generate</emphasis> directive, one tells Xtext to derive an 
				<emphasis>EPackage</emphasis> from the grammar. 
			</para>
			<section id="TypeandPackageGeneration">
				<title>Type and Package Generation</title>
				<para>Xtext creates</para>
				<itemizedlist>
					<listitem>
						<para>an 
							<emphasis>EPackage</emphasis>
						</para>
						<itemizedlist>
							<listitem>
								<para>for each generate-package declaration. After the directive 
									<emphasis>generate</emphasis> a list of parameters follows. The 
									<emphasis>name</emphasis> of the 
									<emphasis>EPackage</emphasis> will be set to the first parameter, its 
									<emphasis>nsURI</emphasis> to the second parameter. An optional alias as the third parameter allows to distinguish generated 
									<emphasis>EPackages</emphasis> later. Only one generated package declaration per alias is allowed.
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<para>an 
							<emphasis>EClass</emphasis>
						</para>
						<itemizedlist>
							<listitem>
								<para>for each return type of a parser rule. If a parser rule does not define a return type, an implicit one with the same name as the rule itself is assumed. You can specify more than one rule that return the same type but only one 
									<emphasis>EClass</emphasis> will be generated.
								</para>
							</listitem>
							<listitem>
								<para>for each type defined in an action or a cross-reference.</para>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<para>an 
							<emphasis>EEnum</emphasis>
						</para>
						<itemizedlist>
							<listitem>
								<para>for each return type of an enum rule.</para>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<para>an 
							<emphasis>EDataType</emphasis>
						</para>
						<itemizedlist>
							<listitem>
								<para>for each return type of a terminal rule or a data type rule.</para>
							</listitem>
						</itemizedlist>
					</listitem>
				</itemizedlist>
				<para>All 
					<emphasis>EClasses</emphasis>, 
					<emphasis>EEnums</emphasis>, and 
					<emphasis>EDataTypes</emphasis> are added to the 
					<emphasis>EPackage</emphasis> referred to by the alias provided in the type reference they were created from.
				</para>
			</section>
			<section id="FeatureandTypeHierarchyGeneration">
				<title>Feature and Type Hierarchy Generation</title>
				<para>While walking through the grammar, the algorithm keeps track of a set of the currently possible return types to add features to. </para>
				<itemizedlist>
					<listitem>
						<para>Entering a parser rule the set contains only the return type of the rule. </para>
					</listitem>
					<listitem>
						<para>Entering a group in an alternative the set is reset to the same state it was in when entering the first group of this alternative. </para>
					</listitem>
					<listitem>
						<para>Leaving an alternative the set contains the union of all types at the end of each of its groups.</para>
					</listitem>
					<listitem>
						<para>After an optional element, the set is reset to the same state it was before entering it. </para>
					</listitem>
					<listitem>
						<para>After a mandatory (non-optional) rule call or mandatory action the set contains only the return type of the called rule or action. </para>
					</listitem>
					<listitem>
						<para>An optional rule call does not modify the set.</para>
					</listitem>
					<listitem>
						<para>A rule call is optional, if its cardinality is '
							<emphasis>?</emphasis>' or '
							<emphasis>*</emphasis>'.
						</para>
					</listitem>
				</itemizedlist>
				<para>While iterating the parser rules Xtext creates</para>
				<itemizedlist>
					<listitem>
						<para>an 
							<emphasis>EAttribute</emphasis> in each current return type
						</para>
						<itemizedlist>
							<listitem>
								<para>of type 
									<emphasis>EBoolean</emphasis> for each feature assignment using the '
									<emphasis>?=</emphasis>' operator. No further 
									<emphasis>EReferences</emphasis> or 
									<emphasis>EAttributes</emphasis> will be generated from this assignment.
								</para>
							</listitem>
							<listitem>
								<para>for each assignment with the '
									<emphasis>=</emphasis>' or '
									<emphasis>+=</emphasis>' operator calling a terminal rule. Its type will be the return type of the called rule.
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<para>an 
							<emphasis>EReference</emphasis> in each current return type
						</para>
						<itemizedlist>
							<listitem>
								<para>for each assignment with the '
									<emphasis>=</emphasis>' or '
									<emphasis>+=</emphasis>' operator in a parser rule calling a parser rule. The 
									<emphasis>EReference</emphasis>'s type will be the return type of the called parser rule.
								</para>
							</listitem>
							<listitem>
								<para>for each assigned action. The reference’s type will be set to the return type of the current calling rule. </para>
							</listitem>
						</itemizedlist>
					</listitem>
				</itemizedlist>
				<para>Each 
					<emphasis>EAttribute</emphasis> or 
					<emphasis>EReference</emphasis> takes its name from the assignment or action that caused it. Multiplicities will be 0...1 for assignments with the '
					<emphasis>=</emphasis>' operator and 0...* for assignments with the '
					<emphasis>+=</emphasis>' operator. 
				</para>
				<para>Furthermore, each type that is added to the currently possible return types automatically extends the current return type of the parser rule. You can specify additional common super types by means of &#8222;artificial” parser rules, that are never called, e.g.</para>
				<literallayout><code>CommonSuperType:
  SubTypeA | SubTypeB | SubTypeC;

</code></literallayout>
			</section>
			<section id="EnumLiteralGeneration">
				<title>Enum Literal Generation</title>
				<para>For each alternative defined in an enum rule, the transformer creates an enum literal, when another literal with the same name cannot be found. The 
					<emphasis>literal</emphasis> property of the generated enum literal is set to the right hand side of the declaration. If it is omitted, you will get an enum literal with equal 
					<emphasis>name</emphasis> and 
					<emphasis>literal</emphasis> attributes.
				</para>
				<literallayout><code>enum MyGeneratedEnum:
  NAME = 'literal' | EQUAL_NAME_AND_LITERAL;

</code></literallayout>
			</section>
			<section id="FeatureNormalization">
				<title>Feature Normalization</title>
				<para>In the next step the generator examines all generated 
					<emphasis>EClasses</emphasis> and lifts up similar features to super types if there is more than one subtype and the feature is defined in every subtypes. This does even work for multiple super types.
				</para>
			</section>
			<section id="customPostProcessing">
				<title>Customized Post Processing</title>
				<para>As a last step, the generator invokes the post processor for every generated Ecore model. The post processor expects an Xtend file with name 
					<emphasis>MyDslPostProcessor.ext</emphasis> (if the name of the grammar file is 
					<emphasis>MyDsl.xtext</emphasis>) in the same folder as the grammar file. Further, for a successful invocation, the Xtend file must declare an extension with signature 
					<emphasis>process(xtext::GeneratedMetamodel)</emphasis>. E.g.
				</para>
				<literallayout><code>process(xtext::GeneratedMetamodel this) :
  process(ePackage)
;
 
process(ecore::EPackage this) :
  ... do something
;

</code></literallayout>
				<para>The invoked extension can then augment the generated Ecore model in place. Some typical use cases are to:</para>
				<itemizedlist>
					<listitem>
						<para>set default values for attributes,</para>
					</listitem>
					<listitem>
						<para>add container references as opposites of existing containment references, or</para>
					</listitem>
					<listitem>
						<para>add operations with implementation using a body annotation.</para>
					</listitem>
				</itemizedlist>
				<para>Great care must be taken to not modify the Ecore model in a way preventing the Xtext parser from working correctly (e.g. removing or renaming model elements).</para>
			</section>
			<section id="ErrorConditions">
				<title>Error Conditions</title>
				<para>The following conditions cause an error</para>
				<itemizedlist>
					<listitem>
						<para>An 
							<emphasis>EAttribute</emphasis> or 
							<emphasis>EReference</emphasis> has two different types or different cardinality.
						</para>
					</listitem>
					<listitem>
						<para>There is an 
							<emphasis>EAttribute</emphasis> and an 
							<emphasis>EReference</emphasis> with the same name in the same 
							<emphasis>EClass</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>There is a cycle in the type hierarchy.</para>
					</listitem>
					<listitem>
						<para>An new 
							<emphasis>EAttribute</emphasis>, 
							<emphasis>EReference</emphasis> or super type is added to an imported type.
						</para>
					</listitem>
					<listitem>
						<para>An 
							<emphasis>EClass</emphasis> is added to an imported 
							<emphasis>EPackage</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>An undeclared alias is used. </para>
					</listitem>
					<listitem>
						<para>An imported Ecore model cannot be loaded.</para>
					</listitem>
				</itemizedlist>
			</section>
		</section>
		<section id="grammarMixins">
			<title>Grammar Mixins</title>
			<para>Xtext supports the reuse of existing grammars. Grammars that are created via the Xtext wizard use 
				<emphasis>org.eclipse.xtext.common.Terminals</emphasis> by default which introduces a common set of terminal rules and defines reasonable defaults for hidden terminals.
			</para>
			<literallayout><code>grammar org.xtext.example.MyDsl with org.eclipse.xtext.common.Terminals
 
generate myDsl 'http://www.xtext.org/example/MyDsl'
 
... some rules

</code></literallayout>
			<para>Mixing in another grammar makes the rules defined in that grammar referable. It is also possible to overwrite rules from the used grammar. </para>
			<para>Example :</para>
			<literallayout><code>grammar my.SuperGrammar
...
RuleA : "a" stuff=RuleB;
RuleB : "{" name=ID "}";

grammar my.SubGrammar with my.SuperGrammar

Model : (ruleAs+=RuleA)*;

// overrides my.SuperGrammar.RuleB
RuleB : '[' name=ID ']';

</code></literallayout>
			<para>Note that declared terminal rules always get a higher priority then imported terminal rules.</para>
		</section>
		<section id="CommonTerminals">
			<title>Common Terminals</title>
			<para>Xtext ships with a default set of predefined, reasonable and often required terminal rules. This grammar is defined as follows:</para>
			<literallayout><code>grammar org.eclipse.xtext.common.Terminals 
  hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

terminal ID : 
  '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')* ;
terminal INT returns ecore::EInt: ('0'..'9')+ ;
terminal STRING	: 
  '"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
  "'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'"; 
terminal ML_COMMENT	: '/*' -&gt; '*/' ;
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')? ;
terminal WS		: (' '|'\t'|'\r'|'\n')+ ;
terminal ANY_OTHER:	. ;

</code></literallayout>
		</section>
	</chapter>
	<chapter id="configuration">
		<title>Configuration</title>
		<section id="generator">
			<title>The Generator</title>
			<para>Xtext provides lots of generic implementations for your language’s
				infrastructure but also uses code generation to generate some of the 
				components. Those generated components are for instance the parser, the 
				serializer, the inferred Ecore model (if any) and a couple of convenient base classes for 
				content assist, etc.</para>
			<para>The generator also contributes to shared project resources such as the 

				<emphasis>plugin.xml</emphasis>, 
				<emphasis>MANIFEST.MF</emphasis> and the 
				<link linkend="guicemodules">Guice modules</link>.
			</para>
			<para>Xtext’s generator leverages 
				<link linkend="MWE2">MWE2 – the modeling workflow engine</link> 
				from EMFT to configure the generator.
			</para>
			<section id="short_intro_to_mwe">
				<title>A Short Introduction to MWE2</title>
				<para>MWE2 allows to compose object graphs declaratively in a very compact manner. The nice thing about it is that it just 
					instantiates Java classes and the configuration is done through public setter and adder methods as one is used to 
					from Java Beans encapsulation principles. An in-depth documentation can be found in the chapter 
					<link linkend="MWE2">MWE2</link>.
				</para>
				<para>Given the following simple Java class (POJO):</para>
				<literallayout><code>package com.mycompany;
  
public class Person {
     
  private String name;
     
  public void setName(String name) { 
    this.name = name;
  }
     
  private final List&lt;Person&gt; children = new ArrayList&lt;Person&gt;();
     
  public void addChild(Person child) {
    this.children.add(child);
  }
}
  
</code></literallayout>
				<para>One can create a family tree with MWE2 easily by describing it in a declarative manner 
					without writing a single line of Java code and without the need to compile classes:</para>
				<literallayout><code>module com.mycompany.CreatePersons

Person {
	name = "Grandpa"
	child = {
		name = "Father"
		child = {
			name = "Son"
		}
	}
}

</code></literallayout>
				<para>These couple of lines will, when interpreted by MWE2, result in an 
					object tree consisting of three instances of 
					<emphasis>com.mycompany.Person</emphasis>.
					The interpreter will basically do the same as the following 
					<emphasis>main</emphasis> method: 
				</para>
				<literallayout><code>package com.mycompany;

public class CreatePersons {
	public static void main(String[] args) {
		Person grandpa = new Person();
		grandpa.setName("Grandpa");
		Person father = new Person();
		father.setName("Father");
		grandpa.addChild(father);
		Person son = new Person();
		son.setName("Son");
		father.addChild(son);
	}
}

</code></literallayout>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/family_tree.png" scale="50"/>
						</imageobject>
					</mediaobject> 
				</para>
				<para>The root element is a class-name following the Java classpath visibility rules. As the module is a sibling to the class

					<emphasis>com.mycompany.Person</emphasis> it is not necessary to use use fully qualified name. There are other packages implicitly imported
					into this workflow as well to make it convenient to instantiate actual workflows and components, but these ones are covered 
					in depth in the appropriate 
					<link linkend="MWE2">chapter</link>. The constructed objects are furthermore configured according to the declaration 
					in the module, e.g. a second instance of Person will be created and added to the list of children of &#8222;Grandpa” while the third 
					person – the class is inferred from the assigned feature – becomes a child of &#8222;Father”. All three instances will have 
					their respective 
					<emphasis>name</emphasis> assigned via a reflective invocation 
					<emphasis>setName</emphasis>. If one wants to add another child to &#8222;Father”, she
					can simply repeat the child assignment:
				</para>
				<literallayout><code>child = com.mycompany.Person {
	name = "Father"
	child = {
		name = "Son"
	}
	child = {
		name = "Daughter"
	}
}

</code></literallayout>
				<para>As you can see in the example above MWE2 can be used to instantiate arbitrary Java object models without any dependency or
					limitation to MWE2 specific implementations. This is conceptually very close to the dependency injection mechanism and 
					the XML language in the 
					<ulink url="http://www.springframework.org">Spring Framework</ulink>. 
				</para>
				<para>
					<emphasis role="bold">Tip</emphasis>

					<emphasis role="italic">Whenever you are in an *.mwe2 file and wonder what kind of configuration the underlying component may accept:</emphasis>

					<emphasis role="italic">Just use the Content Assist in the MWE2 Editor or navigate directly to the declaration of the underlying Java</emphasis> 

					<emphasis role="italic">implementation by means of F3 (Go To Declaration).</emphasis>
				</para>
				<para>This is the basic idea of the MWE2 language. There are of course a couple of additional concepts and features in the 
					language and we also have not yet talked about the runtime workflow model. Please refer to the dedicated MWE2 

					<link linkend="MWE2">reference documentation</link> for additional information.
				</para>
			</section>
			<section id="GeneralArchitecture">
				<title>General Architecture </title>
				<para>Of course a generator in Xtext is not composed of fathers and sons, but of so called language configurations. 
					For each language configuration a URI pointing to 
					its grammar file and the file extensions for the DSL must be provided. 
					In addition, a language is configured with a list of 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/IGeneratorFragment.java?root=Modeling_Project&amp;view=co">IGeneratorFragment</ulink>s.
					The whole generator is composed of theses fragments. We have fragments for generating parsers, the serializer, the EMF code, 
					the outline view, etc. 
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/generator-structure.png" scale="50"/>
						</imageobject>
					</mediaobject>
				</para>
				<section id="generator_fragment">
					<title>Generator Fragments</title>
					<para>Each fragment gets the grammar of the language as an EMF model passed in. A fragment is able to generate code in one 
						of the configured locations and contribute to several shared artifacts. The main interface 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/IGeneratorFragment.java?root=Modeling_Project&amp;view=co">IGeneratorFragment</ulink> is supported by a convenient 
						abstract base class 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/AbstractGeneratorFragment.java?root=Modeling_Project&amp;view=co">AbstractGeneratorFragment</ulink>, which 
						by default delegates to an Xpand template with the same qualified name as the class and delegates some of the 
						calls to Xpand template definitions.
					</para>
					<para>We suggest to have a look at the fragment we have written for label providers (
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/labeling/LabelProviderFragment.java?root=Modeling_Project&amp;view=co">LabelProviderFragment</ulink>). It is pretty trivial and at the same time uses the most important call backs. In addition, the structure is not cluttered with too much extra noise so that the whole package can serve as a template to write your own fragment.
					</para>
				</section>
				<section id="Configuration">
					<title>Configuration</title>
					<para>As already explained we use MWE2 from EMFT in order to instantiate, configure and execute this structure of components. 
						In the following we see an exemplary Xtext generator configuration written in MWE2 configuration code:  </para>
					<literallayout><code>module org.xtext.example.MyDsl

import org.eclipse.emf.mwe.utils.*
import org.eclipse.xtext.generator.*
import org.eclipse.xtext.ui.generator.*

var grammarURI = "classpath:/org/xtext/example/MyDsl.xtext"
var file.extensions = "mydsl"
var projectName = "org.xtext.example.mydsl"
var runtimeProject = "../${projectName}"

Workflow {
	bean = StandaloneSetup {
		platformUri = "${runtimeProject}/.."
	}

	component = DirectoryCleaner {
		directory = "${runtimeProject}/src-gen"
	}

	component = DirectoryCleaner {
		directory = "${runtimeProject}.ui/src-gen"
	}

	component = Generator {
		pathRtProject = runtimeProject
		pathUiProject = "${runtimeProject}.ui"
		projectNameRt = projectName
		projectNameUi = "${projectName}.ui"

		language = {
			uri = grammarURI
			fileExtensions = file.extensions

			// Java API to access grammar elements
			fragment = grammarAccess.GrammarAccessFragment {}

			/* more fragments to configure the language */
			...
		}
	}
}

</code></literallayout>
					<para>Here the root element is 
						<emphasis>Workflow</emphasis> and is part of the very slim runtime model shipped with MWE2. It accepts 

						<emphasis role="italic">bean</emphasis> s and 
						<emphasis role="italic">component</emphasis> s. The 
						<emphasis>var</emphasis> declaration is a first class concept of MWE2’s configuration language 
						and defines the interface of the module. They allow to externalize some common configuration parameters. This 
						comes especially handy in String variables where one can easily use 
						<emphasis>${variable}</emphasis> to concatenate values. 
					</para>
					<para>The method 
						<emphasis>Workflow.addBean(Object)</emphasis> does nothing but provides a means to apply global side-effects, which 
						unfortunately is required sometimes. In this example we do a so called 
						<emphasis role="italic">EMF stand-alone setup</emphasis>. This class 
						initializes a bunch of things for a non-OSGi environment that are otherwise configured by means of extension points, 
						e.g. it allows to populate EMF’s singletons like the 
						<emphasis>EPackage.Registry</emphasis>.
					</para>
					<para>Following the 
						<emphasis>bean</emphasis> assignment there are three 
						<emphasis>component</emphasis> elements. The 
						<emphasis>Workflow.addComponent()</emphasis> method 
						accepts instances of 
						<emphasis>IWorkflowComponent</emphasis>, which is the primary concept of MWE2’s workflow model. Xtext’s generator 
						itself is an instance of 
						<emphasis>IWorkflowComponent</emphasis> and can therefore be used within MWE2 workflows. 
					</para>
					<para>There are two fragments 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/ImplicitRuntimeFragment.java?root=Modeling_Project&amp;view=co">ImplicitRuntimeFragment</ulink> and 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/ImplicitUiFragment.java?root=Modeling_Project&amp;view=co">ImplicitUiFragment</ulink> will be called implicitly if 
						the required paths and project names are set. They take care of common defaults.  
					</para>
				</section>
			</section>
			<section id="StandardGeneratorFragments">
				<title>Standard Generator Fragments</title>
				<para>In the following table the most important standard generator fragments are listed. Please refer to the Javadocs for more detailed documentation.</para>
				<informaltable>
					<tr>
						<th>Class</th>
						<th>Generated Artifacts</th>
						<th>Related Documentation</th>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/ecore/EcoreGeneratorFragment.java?root=Modeling_Project&amp;view=co">EcoreGeneratorFragment</ulink>
						</td>
						<td>EMF code for generated models</td>
						<td>
							<link linkend="metamodelInference">Model inference</link>
						</td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/parser/antlr/XtextAntlrGeneratorFragment.java?root=Modeling_Project&amp;view=co">XtextAntlrGeneratorFragment</ulink>
						</td>
						<td>ANTLR grammar, parser, lexer and related services</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/grammarAccess/GrammarAccessFragment.java?root=Modeling_Project&amp;view=co">GrammarAccessFragment</ulink>
						</td>
						<td>Access to the grammar</td>
						<td></td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/resourceFactory/ResourceFactoryFragment.java?root=Modeling_Project&amp;view=co">ResourceFactoryFragment</ulink>
						</td>
						<td>EMF resource factory</td>
						<td>
							<link linkend="xtext_resource">Xtext Resource</link>
						</td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/parseTreeConstructor/ParseTreeConstructorFragment.java?root=Modeling_Project&amp;view=co">ParseTreeConstructorFragment</ulink>
						</td>
						<td>Model-to-text serialization</td>
						<td>
							<link linkend="serialization">Serialization</link>
						</td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/scoping/ImportNamespacesScopingFragment.java?root=Modeling_Project&amp;view=co">ImportNamespacesScopingFragment</ulink>
						</td>
						<td>Index-based scoping</td>
						<td>
							<link linkend="index_based">Index-based namespace scoping</link>
						</td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/validation/JavaValidatorFragment.java?root=Modeling_Project&amp;view=co">JavaValidatorFragment</ulink>
						</td>
						<td>Model validation</td>
						<td>
							<link linkend="custom_validation">Model validation</link>
						</td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/formatting/FormatterFragment.java?root=Modeling_Project&amp;view=co">FormatterFragment</ulink>
						</td>
						<td>Code formatter</td>
						<td>
							<link linkend="declarativeformatter">Declarative formatter</link>
						</td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/labeling/LabelProviderFragment.java?root=Modeling_Project&amp;view=co">LabelProviderFragment</ulink>
						</td>
						<td>Label provider</td>
						<td>
							<link linkend="labelProvider">Label provider</link>
						</td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/outline/OutlineNodeAdapterFactoryFragment.java?root=Modeling_Project&amp;view=co">OutlineNodeAdapterFactoryFragment</ulink>
						</td>
						<td>Outline view configuration</td>
						<td>
							<link linkend="outline">Outline</link>
						</td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/outline/TransformerFragment.java?root=Modeling_Project&amp;view=co">TransformerFragment</ulink>
						</td>
						<td>Outline view configuration</td>
						<td>
							<link linkend="outline">Outline</link>
						</td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/contentAssist/JavaBasedContentAssistFragment.java?root=Modeling_Project&amp;view=co">JavaBasedContentAssistFragment</ulink>
						</td>
						<td>Java-based content assist</td>
						<td>
							<link linkend="contentAssist">Content assist</link>
						</td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/parser/antlr/XtextAntlrUiGeneratorFragment.java?root=Modeling_Project&amp;view=co">XtextAntlrUiGeneratorFragment</ulink>
						</td>
						<td>Content assist helper based on ANTLR</td>
						<td>
							<link linkend="contentAssist">Content assist</link>
						</td>
					</tr>
					<tr>
						<td>
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/projectWizard/SimpleProjectWizardFragment.java?root=Modeling_Project&amp;view=co">SimpleProjectWizardFragment</ulink>
						</td>
						<td>New project wizard</td>
						<td>
							<link linkend="projectwizard">Project wizard</link>
						</td>
					</tr>
				</informaltable>
			</section>
		</section>
		<section id="dependencyInjection">
			<title>Dependency Injection in Xtext with Google Guice</title>
			<para>All Xtext components are assembled by means of Dependency Injection (DI). This means basically that whenever some code is in need for functionality (or state) 
				from another component, one just declares the dependency rather then stating how to resolve it, i.e. obtaining that component.</para>
			<para>For instance when some code wants to use a scope provider, it just declares a field (or method or constructor) and 
				adds the @Inject annotation: </para>
			<literallayout><code>public class MyLanguageLinker extends Linker {

  @Inject
  private IScopeProvider scopeProvider;

}
 
</code></literallayout>
			<para>It is not the duty of the code to care about where the 
				<emphasis>IScopeProvider</emphasis> comes from or how it is created. When above’s
				class is instantiated, Guice sees that it requires an instance of IScopeProvider and assigns it to the specified field or method parameter.
				This of course only works, if the object itself is created by Guice. In Xtext almost every instance is created that way 
				and therefore the whole dependency net is controlled and configured by the means of Google Guice.
			</para>
			<para>Guice of course needs to know how to instantiate real objects for declared dependencies. This is done in so called 
				<emphasis>Modules</emphasis>.
				A 
				<emphasis>Module</emphasis> defines a set of mappings from types to either existing instances, instance providers or concrete
				classes. Modules are implemented in Java. Here’s an example:
			</para>
			<literallayout><code>public class MyDslRuntimeModule extends AbstractMyDslRuntimeModule {
	@Override
	public void configure(Binder binder) {
		super.configure(binder);
		binder.bind(IScopeProvider.class).to(MyConcreteScopeProvider.class);
	}
}

</code></literallayout>
			<para>With plain Guice modules one implements a method called configure and gets a so called 
				<emphasis>Binder</emphasis> passed in.
				That binder provides a fluent API to define the mentioned mappings. This was just a very brief and simplified description.
				We highly recommend to have a look at 
				<ulink url="http://code.google.com/p/google-guice/">the website Google Guice</ulink> to learn more.  
			</para>
			<section id="guicemodules">
				<title>The Module API</title>
				<para>Xtext comes with a slightly enhanced module API. For your language you get two different modules: One for the runtime bundle
					which is used when executing your language infrastructure outside of Eclipse such as on the build server. The other is
					located in the UI bundle and adds or overrides bindings when Xtext is used within an Eclipse environment. </para>
				<para>The enhancement we added to Guice’s Module API is that we provide an abstract base class, which reflectively looks for certain 
					methods in order to find declared bindings. The most common kind of method is :</para>
				<literallayout><code>public Class&lt;? extends IScopeProvider&gt; bindIScopeProvider() {
	return MyConcreteScopeProvider.class;
}

</code></literallayout>
				<para>which would do the same as the code snippet above. It simply declares a binding from 
					<emphasis>IScopeProvider</emphasis> to 
					<emphasis>MyConcreteScopeProvider</emphasis>.
					That binding will make Guice instantiate and inject a new instance of 
					<emphasis>MyConcreteScopeProvider</emphasis> whenever a dependency 
					to 
					<emphasis>IScopeProvider</emphasis> is declared.
				</para>
				<para>Having a method per binding allows to deactivate individual bindings by overriding the corresponding methods and either change 
					the binding by returning a different target type or removing that binding completely by returning null.</para>
				<para>There are two additional kinds of binding-methods supported. The first one allows to configure a provider. A 
					<emphasis>Provider</emphasis> is
					an interface with just one method : 
				</para>
				<literallayout><code>public interface Provider&lt;T&gt; {

  /**
   * Provides an instance of {@code T}. Must never return {@code null}.
   */
  T get();
}

</code></literallayout>
				<para>This one can be used if you need a hook whenever an instance of a certain type is created. For instance if you want to 
					provide lazy access to a singleton or you need to do some computation each time an instance is created (i.e. factory). If you want 
					to point to a provider rather than to a concrete class you can use the following binding method.</para>
				<literallayout><code>public Class&lt;? extends Provider&lt;IScopeProvider&gt;&gt; provideIScopeProvider() {
	return MyConcreteScopeProviderFactory.class;
}

</code></literallayout>
				<para>
					<emphasis role="italic">(Please forgive us the overuse of the term</emphasis> provider. 
					<emphasis role="italic">The IScopeProvider is not a Guice</emphasis> provider 
					<emphasis role="italic">.)</emphasis>
				</para>
				<para>That binding tells Guice to instantiate 
					<emphasis>MyConcreteScopeProviderFactory</emphasis> and invoke get() in order to obtain an instance of 

					<emphasis>IScopeProvider</emphasis> 
					for clients having declared a dependency to that type. Both mentioned methods are allowed to return an instance instead of a type. This
					may be useful if some global state should be shared in the application:
				</para>
				<literallayout><code>public Provider&lt;IScopeProvider&gt; provideIScopeProvider() {
	return new MyConcreteScopeProviderFactory();
}

</code></literallayout>
				<para>or</para>
				<literallayout><code>public IScopeProvider bindIScopeProvider() {
	return new MyConcreteScopeProvider();
}

</code></literallayout>
				<para>respectively.</para>
				<para>The last binding method provided by Xtext allows to do anything you can do with Guice’s binding API, since it allows you to 
					use it directly. If your method’s name starts with the name &#8218;configure’, has a return type 
					<emphasis>void</emphasis> and accepts one argument of 
					type 
					<emphasis>Binder</emphasis>
				</para>
				<literallayout><code>public void configureIScopeProvider(Binder binder) {
	binder.bind(IScopeProvider.class).to(MyConcreteScopeProvider.class);
} 

</code></literallayout>
			</section>
			<section id="ObtaininganInjector">
				<title>Obtaining an 
					<emphasis>Injector</emphasis>
				</title>
				<para>In every application wired up with Guice there is usually one point where you initialize a so called 
					<emphasis>Injector</emphasis> using the 
					modules declared and after that using that injector to create the root instance of the whole application. In plain Java environments
					this is something that’s done in the main method. It could look like this:
				</para>
				<literallayout><code>public static void main(String[] args) {
	Injector injector = Guice.createInjector(new MyDslRuntimeModule());
	MyApplication application = injector.getInstance(MyApplication.class);
	application.run();
}

</code></literallayout>
				<para>Xtext uses EMF which makes use of a couple of global registries, which have to be configured on startup. Because we
					of course want to leverage Guice also for all factories, etc. that we put into those registries, we have introduced a so called

					<emphasis>ISetup</emphasis> which provides a method called 
					<emphasis>Injector createInjectorAndDoEMFRegistration()</emphasis>. So instead of using the plain Guice
					code shown above you rather use the 
					<emphasis>ISetup</emphasis> class generated for your language, which, as the method name suggests, creates
					an 
					<emphasis>Injector</emphasis> and uses it to initialize a couple of EMF objects and register them in the corresponding registries.
				</para>
				<literallayout><code>Injector injector = 
    new MyStandaloneSetup().createInjectorAndDoEMFRegistration(); 

</code></literallayout>
				<para>These are the basic ideas around Guice and the small extension Xtext provides on top. For more information we 
					strongly encourage you to read through the documentation on 
					<ulink url="http://code.google.com/p/google-guice/">the website of Google Guice</ulink>.
				</para>
			</section>
		</section>
	</chapter>
	<chapter id="runtime_concepts">
		<title>Runtime Concepts</title>
		<para>Xtext itself and every language infrastructure developed with Xtext is configured and wired-up using 

			<link linkend="dependencyInjection">dependency injection</link>. Xtext may be used in different environments which introduce 
			different constraints. Especially important is the difference between OSGi managed containers and plain 
			vanilla Java programs. To honor these differences Xtext uses the concept of 

			<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/ISetup.java?root=Modeling_Project&amp;view=co">ISetup</ulink>-implementations in normal mode and uses Eclipse’s 
			extension mechanism when it should be configured in an OSGi environment.   
		</para>
		<section id="RuntimeSetupISetup">
			<title>Runtime Setup (ISetup)</title>
			<para>For each language there is an implementation of 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/ISetup.java?root=Modeling_Project&amp;view=co">ISetup</ulink> 
				generated. It implements a method called 
				<emphasis>createInjectorAndDoEMFRegistration()</emphasis>, which can be called 
				to do the initialization of the language infrastructure. This class is intended to be used for 
				runtime and for unit testing, only.
			</para>
			<para>The setup method returns an 
				<emphasis>Injector</emphasis>, which can further be used to obtain a parser, etc. It also 
				registers the ResourceFactory and generated 
				<emphasis>EPackages</emphasis> at the respective global registries provided 
				by EMF. So basically you can just run the setup and start using EMF API to load and store models of 
				your language.
			</para>
		</section>
		<section id="SetupwithinEclipseEquinoxOSGi">
			<title>Setup within Eclipse-Equinox (OSGi)</title>
			<para>Within Eclipse we have a generated 
				<emphasis>Activator</emphasis>, which creates a Guice injector using the 
				<link linkend="guicemodules">modules</link>.
				In addition an 
				<emphasis>IExecutableExtensionFactory</emphasis> is generated for each language, which is used to create 
				<emphasis>ExecutableExtensions</emphasis>.
				This means that everything which is created via extension points is managed by Guice as well, i.e. you can declare dependencies and get them injected upon creation. 
			</para>
			<para>The only thing you have to do in order to use this factory is to prefix the class with the factory 
				<emphasis>ExecutableExtensionFactory</emphasis> name followed by a colon.
			</para>
			<literallayout><code>&lt;extension
  point="org.eclipse.ui.editors"&gt;
  &lt;editor
    class="&lt;MyLanguageName&gt;ExecutableExtensionFactory:
      org.eclipse.xtext.ui.editor.XtextEditor"
    contributorClass=
      "org.eclipse.ui.editors.text.TextEditorActionContributor"
    default="true"
    extensions="ecoredsl"
    id="org.eclipse.xtext.example.EcoreDsl"
    name="EcoreDsl Editor"&gt;
  &lt;/editor&gt;
&lt;/extension&gt;

</code></literallayout>
		</section>
		<section id="Logging">
			<title>Logging</title>
			<para>Xtext uses Apache’s log4j for logging. It is configured using the so called 
				<emphasis>log4j.properties</emphasis>, which is looked up in the root of the Java classpath. If you want to change or provide configuration at runtime (i.e. non-OSGI), all you have to do is putting such a 
				<emphasis>log4j.properties</emphasis> in place and make sure that it is not overridden by other 
				<emphasis>log4j.properties</emphasis> in previous classpath entries.
			</para>
			<para>In OSGi you provide configuration by creating a fragment for 
				<emphasis>org.apache.log4j</emphasis>. In this case you need to make sure that there’s no second fragment contributing a 
				<emphasis>log4j.properties</emphasis> file.
			</para>
		</section>
		<section id="validation">
			<title>Validation</title>
			<para>Static analysis or validation is one of the most interesting aspects when developing a programming language. The users of your languages will be grateful
				if they get informative feedback as they type. 
				In Xtext there are basically three different kinds of validation.</para>
			<section id="AutomaticValidation">
				<title>Automatic Validation</title>
				<para>Some implementation aspects (e.g. the grammar, scoping) of a language have an impact on what is required for a document or semantic model to be valid. Xtext automatically takes care of this. </para>
				<section id="syntactical_validation">
					<title>Lexer/Parser: Syntactical Validation</title>
					<para>The syntactical correctness of any textual input is validated automatically by the parser. The error messages are generated by the underlying parser technology.
						One can use the 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parser/antlr/ISyntaxErrorMessageProvider.java?root=Modeling_Project&amp;view=co">ISyntaxErrorMessageProvider</ulink>-API to customize this messages.
						Any syntax errors can be retrieved from the Resource using the common EMF API:
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>org.eclipse.emf.ecore.resource.Resource.getErrors()</emphasis>
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>org.eclipse.emf.ecore.resource.Resource.getWarnings()</emphasis>
							</para>
						</listitem>
					</itemizedlist>
				</section>
				<section id="linking_validation">
					<title>Linker: Crosslink Validation</title>
					<para>Any broken crosslinks can be checked generically. As crosslink resolution is done lazily (see 
						<link linkend="linking">linking</link>), any broken links are resolved lazily as well.
						If you want to validate whether all links are valid, you will have to navigate through the model so that all installed EMF proxies get resolved. This is done automatically in the editor.
					</para>
					<para>Similar to syntax errors, any unresolvable crosslinks will be reported and can be obtained through:</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>org.eclipse.emf.ecore.resource.Resource.getErrors()</emphasis>
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>org.eclipse.emf.ecore.resource.Resource.getWarnings()</emphasis>
							</para>
						</listitem>
					</itemizedlist>
				</section>
				<section id="concrete_syntax_validation">
					<title>Serializer: Concrete Syntax Validation</title>
					<para>The 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxValidator.java?root=Modeling_Project&amp;view=co">IConcreteSyntaxValidator</ulink> validates all constraints that are implied by a grammar. Meeting these constraints for a model is mandatory to be serialized.
					</para>
					<para>Example:</para>
					<literallayout><code>MyRule:
  ({MySubRule} "sub")? (strVal+=ID intVal+=INT)*;
	
</code></literallayout>
					<para>This implies several constraints:</para>
					<orderedlist>
						<listitem>
							<para>Types: only instances of 
								<emphasis>MyRule</emphasis> and 
								<emphasis>MySubRule</emphasis> are allowed for this rule. Sub-types are prohibited, since the parser never instantiates unknown sub-types.
							</para>
						</listitem>
						<listitem>
							<para>Features: In case the 
								<emphasis>MyRule</emphasis> and 
								<emphasis>MySubRule</emphasis> have 
								<emphasis>EStructuralFeatures</emphasis> besides 
								<emphasis>strVal</emphasis> and 
								<emphasis>intVal</emphasis>, only 
								<emphasis>strVal</emphasis> and 
								<emphasis>intVal</emphasis> may have 
								<link linkend="transientvalues">non-transient values</link>.
							</para>
						</listitem>
						<listitem>
							<para>Quantities: The following condition must be true: 
								<emphasis>strVal.size() == intVal.size()</emphasis>.
							</para>
						</listitem>
						<listitem>
							<para>Values: It must be possible to 
								<link linkend="valueconverter">convert all values</link> to valid tokens for terminal rule 
								<emphasis>STRING</emphasis>.  The same is true for 
								<emphasis>intVal</emphasis> and 
								<emphasis>INT</emphasis>.
							</para>
						</listitem>
					</orderedlist>
					<para>The typical use cases for the concrete syntax validator are validation in non-Xtext-editors that, however, use an 
						<emphasis>XtextResource</emphasis>. This is, for example, the case when combining GMF and Xtext. Another use case is when the semantic model is modified &#8222;manually” (not by the parser) and then serialized again. Since it is very difficult for the serializer to provide 
						<link linkend="parsetreeconstructor">meaningful error messages</link>, the concrete syntax validator is executed by default before serialization. A textual Xtext editor itself, however, is 
						<emphasis>not</emphasis> a valid use case. Here, the parser ensures that all syntactical constraints are met. Therefore, there is no value in additionally running the concrete syntax validator.  
					</para>
					<para>There are some limitations to the concrete syntax validator which result from the fact that it treats the grammar as declarative, which is something the parser doesn’t always do.</para>
					<itemizedlist>
						<listitem>
							<para>Grammar rules containing assigned actions (e.g. 
								<emphasis>{MyType.myFeature=current}</emphasis> are ignored. Unassigned actions (e.g. 
								<emphasis>{MyType}</emphasis>), however, are supported. 
							</para>
						</listitem>
						<listitem>
							<para>Grammar rules that delegate to one or more rules containing assigned actions via unassigned rule calls are ignored.</para>
						</listitem>
						<listitem>
							<para>Orders within list-features can not be validated. e.g. 
								<emphasis>Rule: (foo+=R1 foo+=R2)*</emphasis> implies that 
								<emphasis>foo</emphasis> is expected to contain instances of 
								<emphasis>R1</emphasis> and 
								<emphasis>R2</emphasis> in an alternating order. 
							</para>
						</listitem>
					</itemizedlist>
					<para>To use concrete syntax validation you can let Guice inject an instance of 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxValidator.java?root=Modeling_Project&amp;view=co">IConcreteSyntaxValidator</ulink> and use it directly. 
						Furthermore, there is an adapter (
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/impl/ConcreteSyntaxEValidator.java?root=Modeling_Project&amp;view=co">ConcreteSyntaxEValidator</ulink>) 
						allows integrating of the concrete syntax validator as an 
						<emphasis>EValidator</emphasis>. You can, for example, enable it in 
						your runtime module, by adding:
					</para>
					<literallayout><code>@SingletonBinding(eager = true)
public Class&lt;? extends ConcreteSyntaxEValidator&gt; 
      bindConcreteSyntaxEValidator() {
  return ConcreteSyntaxEValidator.class;
}
</code></literallayout>
					<para>To customize error messages please see 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/IConcreteSyntaxDiagnosticProvider.java?root=Modeling_Project&amp;view=co">IConcreteSyntaxDiagnosticProvider</ulink> and subclass 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/impl/ConcreteSyntaxDiagnosticProvider.java?root=Modeling_Project&amp;view=co">ConcreteSyntaxDiagnosticProvider</ulink>.
					</para>
				</section>
			</section>
			<section id="custom_validation">
				<title>Custom Validation</title>
				<para>In addition to the afore mentioned kinds of validation, which are more or less done automatically, you can specify additional constraints specific for your Ecore model.
					We leverage existing EMF API (mainly 
					<emphasis>EValidator</emphasis>) and have put some convenience stuff on top. 
					Basically all you need to do is to make sure that an 
					<emphasis>EValidator</emphasis> is registered for your 
					<emphasis>EPackage</emphasis>. The registry for 
					<emphasis>EValidators</emphasis> (
					<emphasis>EValidator.Registry.INSTANCE</emphasis>) can only be filled programmatically.
					That means contrary to the EPackage and 
					<emphasis>Resource.Factory</emphasis> registries there is no Equinox extension point to populate the validator registry.
				</para>
				<para>For Xtext we provide a 
					<link linkend="generator_fragment">generator fragment</link> for the convenient Java-based 
					<emphasis>EValidator</emphasis> API. Just add the following fragment to your generator configuration and you are good to go:
				</para>
				<literallayout><code>fragment = org.eclipse.xtext.generator.validation.JavaValidatorFragment {}

</code></literallayout>
				<para>The generator will provide you with two Java classes. An abstract class generated to 
					<emphasis>src-gen/</emphasis> which extends the library class 
					<emphasis>AbstractDeclarativeValidator</emphasis>. This one just registers the EPackages for which this validator introduces constraints.
					The other class is a subclass of that abstract class and is generated to the 
					<emphasis>src/</emphasis> folder in order to be edited by you. That’s where you put the constraints in.
				</para>
				<para>The purpose of the 
					<emphasis>AbstractDeclarativeValidator</emphasis> is to allow you to write constraints in a declarative way – as the class name already suggests. That is instead of writing exhaustive if-else constructs or extending the generated EMF switch you just have to add the 
					<emphasis>@Check</emphasis> annotation to any method and it will be invoked automatically when validation takes place.
					Moreover you can state for what type the respective constraint method is, just by declaring a typed parameter. This also lets you avoid any type casts.  
					In addition to the reflective invocation of validation methods the 
					<emphasis>AbstractDeclarativeValidator</emphasis> provides a couple of convenient assertions.
				</para>
				<para>All in all this is very similar to how JUnit works. Here is an example:</para>
				<literallayout><code>public class DomainmodelJavaValidator 
  extends AbstractDomainmodelJavaValidator {
    
  @Check
  public void checkTypeNameStartsWithCapital(Type type) {
    if (!Character.isUpperCase(type.getName().charAt(0)))
      warning("Name should start with a capital", 
        DomainmodelPackage.TYPE__NAME);
  }
}

</code></literallayout>
				<para>You can also implement quick fixes for individual validation errors and warnings. See the 
					<link linkend="quickfixes">chapter on quick fixes</link> for details.
				</para>
			</section>
			<section id="check_based_validation">
				<title>Validation with the Check Language</title>
				<para>In addition to the Java-based validation code you can use the language Check (from M2T/Xpand) to implement constraint checks against your model. To do so, you have to configure the 
					<link linkend="generator">generator</link> with the

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/validation/CheckFragment.java?root=Modeling_Project&amp;view=co">CheckFragment</ulink>.
					Please note, that you can combine both types of validation in your project. 
				</para>
				<literallayout><code>fragment = org.eclipse.xtext.generator.validation.CheckFragment {}
  
</code></literallayout>
				<para>After regenerating your language artifacts you will find three new files &#8222;YourLanguageChecks.chk”, &#8222;YourLanguageFastChecks.chk” and &#8222;YourLanguageExpensiveChecks.chk” in the 
					<emphasis>src/</emphasis> folder in the sub-package 
					<emphasis>validation</emphasis>.  The checks in these files will be executed when saving a file, while typing (FastChecks) or when triggering the validation explicitly (ExpensiveChecks). When using Check the example of the previous chapter could be written like this.
				</para>
				<literallayout><code>context Type#name WARNING "Name should start with a capital":
  name.toFirstUpper() == name;  

</code></literallayout>
				<para>Each check works in a specific context (here: 
					<emphasis>Type</emphasis>) and can further denote a feature to which a warning or error should be attached to (here: 
					<emphasis>name</emphasis>). Each check could either be a 
					<emphasis>WARNING</emphasis> or an 
					<emphasis>ERROR</emphasis> with a given string to explain the situation. The essential part of each check is an invariant that must hold true for the given context. If it fails the check will produce an issue with the provided explanation.
				</para>Please read more about the Check language as well as the underlying expression language in Xpand’s reference documentation which is shipped as Eclipse help. 
			</section>
			<section id="ValidatingManually">
				<title>Validating Manually</title>
				<para>As noted above, Xtext uses EMF’s 
					<emphasis>EValidator</emphasis> API to register Java or Check validators. You can run the validators on your model programmatically using EMF’s 
					<emphasis>Diagnostician</emphasis>, e.g.
				</para>
				<literallayout><code>EObject myModel = myResource.getContents().get(0);
Diagnostic diagnostic = Diagnostician.INSTANCE.validate(myModel);
switch (diagnostic.getSeverity()) {
  case Diagnostic.ERROR:
    System.err.println("Model has errors: ",diagnostic);
    break;
  case Diagnostic.WARNING:
    System.err.println("Model has warnings: ",diagnostic);
}

</code></literallayout>
			</section>
			<section id="test_validators">
				<title>Test Validators</title>
				<para>If you have implemented your validators by extending 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/AbstractDeclarativeValidator.java?root=Modeling_Project&amp;view=co">AbstractDeclarativeValidator</ulink>, there are helper classes which may assist you when testing your validators.
				</para>
				<para>Testing validators typically works as follows: </para>
				<orderedlist>
					<listitem>
						<para>The test creates some models which intentionally violate some constraints.</para>
					</listitem>
					<listitem>
						<para>The test runs some choosen @Check-methods from the validator.</para>
					</listitem>
					<listitem>
						<para>The test asserts whether the @Check-methods have raised the expected warnings and errors.</para>
					</listitem>
				</orderedlist>
				<para>To create models, you can either use EMF’s 
					<emphasis>ResourceSet</emphasis> to load models from your hard disk or you can utilize the 
					<emphasis>Factory</emphasis> (which EMF generates for each 
					<emphasis>EPackage</emphasis>) to construct the needed model elements manually. While the fist option has the advantages that you can edit your models in your textual concrete syntax, the second option has the advantage that you can create partial models.
				</para>
				<para>To run the @Check-methods and ensure they raise the intended errors and warnings, you can utilize 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/junit/validation/ValidatorTester.java?root=Modeling_Project&amp;view=co">ValidatorTester</ulink> as shown by the following example:
				</para>
				<para>Validator:</para>
				<literallayout><code>public class MyLanguageValidator extends AbstractDeclarativeValidator {
  @Check
  public void checkFooElement(FooElement element) {
    if(element.getBarAttribute().contains("foo"))
      error("Only Foos allowed", element, 
        MyLanguagePackage.FOO_ELEMENT__BAR_ATTRIBUTE, 101);
  }
}

</code></literallayout>
				<para>JUnit-Test:</para>
				<literallayout><code>public class MyLanguageValidatorTest extends AbstractXtextTests {

  private ValidatorTester&lt;MyLanguageValidator&gt; tester;

  @Override
  public void setUp() {
    with(MyLanguageStandaloneSetup.class);
    MyLanguageValidator validator = get(MyLanguageValidator.class);
    tester = new ValidatorTester&lt;TestingValidator&gt;(validator);
  }

  public void testError() {
    FooElement model = MyLanguageFactory.eINSTANCE.createFooElement()
    model.setBarAttribute("barbarbarbarfoo");
    
    tester.validator().checkFooElement(model);
    tester.diagnose().assertError(101);
  }
  
  public void testError2() {
    FooElement model = MyLanguageFactory.eINSTANCE.createFooElement()
    model.setBarAttribute("barbarbarbarfoo");
    
    tester.validate(model).assertError(101);
  }
}

</code></literallayout>
				<para>This example uses JUnit 3, but since the involved classes from Xtext have no dependency on JUnit 
					whatsoever, JUnit 4 and other testing frameworks will work as well.  JUnit runs the 
					<emphasis>setUp()</emphasis>-method 
					before each testcase and thereby helps to create some common state. In this example, the validator 
					(
					<emphasis>MyLanguageValidator</emphasis>) is instantiated by means of Google Guice. As we inherit from the 
					<emphasis>AbstractXtextTests</emphasis>
					there are a plenty of useful methods available and the state of the global EMF singletons will be restored in the

					<emphasis>tearDown()</emphasis>. 
					Afterwards, the 
					<emphasis>ValidatorTester</emphasis> is created and parameterized with the actual validator. It acts as 
					a wrapper for the validator, ensures that the validator has a valid state and provides convenient 
					access to the validator itself (
					<emphasis>tester.validator()</emphasis>) as well as to the utility classes which 
					assert diagnostics created by the validator (
					<emphasis>tester.diagnose()</emphasis>). Please be aware that you have to 
					call 
					<emphasis>validator()</emphasis> before you can call 
					<emphasis>diagnose()</emphasis>. However, you can call 
					<emphasis>validator()</emphasis> multiple 
					times in a row.
				</para>
				<para>While 
					<emphasis>validator()</emphasis> allows to call the validator’s @Check-methods directly, 
					<emphasis>validate(model)</emphasis> leaves it 
					to the framework to call the applicable @Check-methods. However, to avoid side-effects between tests, 
					it is recommended to call the @Check-methods directly.
				</para>
				<para>
					<emphasis>diagnose()</emphasis> and 
					<emphasis>validate(model)</emphasis> return an object of type 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.junit/src/org/eclipse/xtext/junit/validation/AssertableDiagnostics.java?root=Modeling_Project&amp;view=co">AssertableDiagnostics</ulink> which provides 
					several 
					<emphasis>assert</emphasis>-methods to verify whether the expected diagnostics are present:
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis>assertError(int code)</emphasis>: There must be one diagnostic with severity ERROR and the supplied error code.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>assertErrorContains(String messageFragment)</emphasis>:  There must be one diagnostic with severity ERROR and its message must contain 
							<emphasis>messageFragment</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>assertError(int code, String messageFragment)</emphasis>: Verifies severity, error code and messageFragment.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>assertWarning(...)</emphasis>: This method is available for the same combination of parameters as 
							<emphasis>assertError()</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>assertOK()</emphasis>: Expects that no diagnostics (errors, warnings etc.) have been raised.   
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>assertDiagnostics(int severity, int code, String messageFragment)</emphasis>: Verifies severity, error code and messageFragment.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>assertAll(DiagnosticPredicate... predicates)</emphasis>: Allows to describe multiple diagnostics at the same time and verifies that all of them are present. Class 
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/junit/validation/AssertableDiagnostics.java?root=Modeling_Project&amp;view=co">AssertableDiagnostics</ulink> contains static 
							<emphasis>error()</emphasis> and 
							<emphasis>warning()</emphasis>-methods which help to create the needed 
							<emphasis>DiagnosticPredicate</emphasis>. Example: 
							<emphasis>assertAll(error(123), warning(&#8222;some part of the message”))</emphasis>. 
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis>assertAny(DiagnosticPredicate predicate)</emphasis>: Asserts that a diagnostic exists which matches the predicate. 
						</para>
					</listitem>
				</itemizedlist>
			</section>
		</section>
		<section id="linking">
			<title>Linking</title>
			<para>The linking feature allows for specification of cross-references within an Xtext grammar.
				The following things are needed for the linking:</para>
			<orderedlist>
				<listitem>
					<para>declaration of a crosslink in the grammar (at least in the Ecore model)</para>
				</listitem>
				<listitem>
					<para>specification of linking semantics (usually provided via the 
						<link linkend="scoping">scoping API</link>)
					</para>
				</listitem>
			</orderedlist>
			<section id="DeclarationofCrosslinks">
				<title>Declaration of Crosslinks</title>
				<para>In the grammar a cross-reference is specified using square brackets.</para>
				<literallayout><code>CrossReference :
  '[' type=ReferencedEClass ('|' terminal=CrossReferenceableTerminal)? ']'
;

</code></literallayout>
				<para>Example:</para>
				<literallayout><code>ReferringType :
  'ref' referencedObject=[Entity|STRING]
;

</code></literallayout>
				<para>The 
					<link linkend="metamodelInference">Ecore model inference</link> would create an 
					<emphasis>EClass</emphasis> 
					<emphasis>ReferringType</emphasis> with an 

					<emphasis>EReference</emphasis> 
					<emphasis>referencedObject</emphasis> of type 
					<emphasis>Entity</emphasis> (
					<emphasis>containment=false</emphasis>). The referenced object would 
					be identified either by a 
					<emphasis>STRING</emphasis> and the surrounding information in the current context 
					(see 
					<link linkend="scoping">scoping</link>). If you do not use 
					<emphasis>generate</emphasis> but 
					<emphasis>import</emphasis> an existing Ecore model, 
					the class 
					<emphasis>ReferringType</emphasis> (or one of its super types) would need to have an 
					<emphasis>EReference</emphasis> of type 

					<emphasis>Entity</emphasis> (or one of its super types) declared. Also the 
					<emphasis>EReference</emphasis>'s containment and container 
					properties needs to be set to 
					<emphasis>false</emphasis>. 
				</para>
			</section>
			<section id="DefaultRuntimeBehaviorLazyLinking">
				<title>Default Runtime Behavior (Lazy Linking)</title>
				<para>Xtext uses lazy linking by default and we encourage users to stick to this because it provides  
					many advantages. One of which is improved performance in all scenarios where you don’t have to load 
					the whole closure of all transitively referenced resources. Furthermore it automatically solves 
					situations where one link relies on other links. Though cyclic linking dependencies are not 
					supported by Xtext at all. </para>
				<para>When parsing a given input string, say</para>
				<literallayout><code>ref Entity01
</code></literallayout>
				<para>the 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/linking/lazy/LazyLinker.java?root=Modeling_Project&amp;view=co">LazyLinker</ulink> first creates an EMF proxy and 
					assigns it to the corresponding 
					<emphasis>EReference</emphasis>. In EMF a proxy is described by a URI, which points to the 
					real 
					<emphasis>EObject</emphasis>. In the case of lazy linking the stored URI comprises of the context information given 
					at parse time, which is the 
					<emphasis>EObject</emphasis> containing the cross-reference, the actual 
					<emphasis>EReference</emphasis>, the 
					index (in case it’s a multi-valued cross-reference) and the string which represented the crosslink 
					in the concrete syntax. The latter usually corresponds to the name of the referenced 
					<emphasis>EObject</emphasis>. 
					In EMF a URI consists of information about the resource the 
					<emphasis>EObject</emphasis> is contained in as well as a so 
					called fragment part, which is used to find the 
					<emphasis>EObject</emphasis> within that resource. When an  EMF proxy 
					is resolved, the current 
					<emphasis>ResourceSet</emphasis> is asked. The resource set uses the first part to obtain 
					(i.e. load if it is not already loaded) the resource. Then the resource is asked to return the 

					<emphasis>EObject</emphasis> based on the fragment in the URI. The actual cross-reference resolution is done by 

					<emphasis>LazyLinkingResource.getEObject(String)</emphasis> which receives the fragment and delegates to the implementation 
					of the 
					<emphasis>ILinkingService</emphasis>. The default implementation in turn delegates to the 
					<link linkend="scoping">scoping API</link>.
				</para>
				<para>A simple implementation of the linking service (the 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/linking/impl/DefaultLinkingService.java?root=Modeling_Project&amp;view=co">DefaultLinkingService</ulink>) is shipped with Xtext 
					and used for any grammar per default. Usually any necessary customization of the linking behavior 
					can best be described using the 
					<link linkend="scoping">scoping API</link>.
				</para>
			</section>
		</section>
		<section id="scoping">
			<title>Scoping</title>
			<para>Using the scoping API one defines which elements are referable by a certain reference. For instance, 
				using the introductory example (fowler’s state machine language)
				a transition contains two cross-references: One to a declared event and one to a declared state.</para>
			<para>Example:</para>
			<literallayout><code>events
  nothingImportant  MYEV
end
 
state idle
  nothingImportant =&gt; idle
end
  
</code></literallayout>
			<para>The grammar rule for transitions looks like this:</para>
			<literallayout><code>Transition :
  event=[Event] '=&gt;' state=[State];

</code></literallayout>
			<para>The grammar states that for the reference 
				<emphasis>event</emphasis> only instances of the type 
				<emphasis>Event</emphasis> are allowed and 
				that for the EReference 
				<emphasis>state</emphasis> only instances of type 
				<emphasis>State</emphasis> can be referenced. However, this simple 
				declaration doesn’t say anything about where to find the states or events. That is the duty of scopes.  
			</para>
			<para>An 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScopeProvider.java?root=Modeling_Project&amp;view=co">IScopeProvider</ulink> is responsible for providing 
				an 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IScope.java?root=Modeling_Project&amp;view=co">IScope</ulink> for a given context 
				<emphasis>EObject</emphasis> and 

				<emphasis>EReference</emphasis>. The returned 
				<emphasis>IScope</emphasis> should contain all target candidates for the given object and cross-reference.
			</para>
			<literallayout><code>public interface IScopeProvider {

	/**
	 * Returns a scope for the given context. The scope 
	 * provides access to the compatible visible EObjects 
	 * for a given reference.
	 *
	 * @param context the element from which an element shall be referenced
	 * @param reference the reference to be used to filter the elements.
	 * @return {@link IScope} representing the inner most {@link IScope} for 
	 *         the passed context and reference. Note for implementors: The 
	 *         result may not be &lt;code&gt;null&lt;/code&gt;. Return 
	 *         &lt;code&gt;IScope.NULLSCOPE&lt;/code&gt; instead.
	 */
	IScope getScope(EObject context, EReference reference);

}

</code></literallayout>
			<para>A single 
				<emphasis>IScope</emphasis> represents an element of a linked list of scopes. That means that a scope can be 
				nested within an outer scope. Each scope works like a symbol table or a map where the keys are strings 
				and the values are so called 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java?root=Modeling_Project&amp;view=co">IEObjectDescription</ulink>, 
				which is effectively an abstract description of a real 
				<emphasis>EObject</emphasis>. 
			</para>
			<section id="global_scopes">
				<title>Global Scopes and 
					<emphasis>IResourceDescriptions</emphasis>
				</title>
				<para>In the state machine example we don’t have references across model files. Also there is no concept like 
					a namespace which would make scoping a bit more complicated. Basically, every 
					<emphasis>State</emphasis> and every 
					<emphasis>Event</emphasis> 
					declared in the same resource is visible by their name. However in the real world things are most likely 
					not that simple: What if you want to reuse certain declared states and events across different 
					state machines and you want to share those as library between different users? You would want to introduce 
					some kind of cross resource reference. 
				</para>
				<para>Defining what is visible from outside the current resource is the responsibility of global scopes. 
					As the name suggests, global scopes are provided by instances of the 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IGlobalScopeProvider.java?root=Modeling_Project&amp;view=co">IGlobalScopeProvider</ulink>. The data structures used to 
					store its elements are described in the next section.
				</para>
				<section id="resourcedescriptions">
					<title>
						<emphasis>Resource</emphasis> and 
						<emphasis>EObject</emphasis> Descriptions (
						<emphasis>IResourceDescription</emphasis>, 
						<emphasis>IEObjectDescription</emphasis>)
					</title>
					<para>In order to make states and events of one file referable from another file you need to export them as 
						part of a so called 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescription.java?root=Modeling_Project&amp;view=co">IResourceDescription</ulink>. 
					</para>
					<para>A 
						<emphasis>IResourceDescription</emphasis> contains information about the resource itself (primarily its 
						<emphasis>URI</emphasis>), a list 
						of exported 
						<emphasis>EObjects</emphasis> (in the form of 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java?root=Modeling_Project&amp;view=co">IEObjectDescription</ulink>) 
						as well as information about outgoing cross-references and qualified names it references. The cross 
						references contain only resolved references, while the list of imported qualified names also contain 
						those names, which couldn’t be resolved. This information is important in order to compute the transitive 
						hull of dependent resources, which the shipped index infrastructure automatically does for you.
					</para>
					<para>For users and especially in the context of scoping the most important information is the list of 
						exported 
						<emphasis>EObjects</emphasis>. An 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IEObjectDescription.java?root=Modeling_Project&amp;view=co">IEObjectDescription</ulink> 
						contains information about the 
						<emphasis>URI</emphasis> to the actual 
						<emphasis>EObject</emphasis> and the qualified name of that element 
						as well as the corresponding 
						<emphasis>EClass</emphasis>. In addition one can export arbitrary information using the 

						<emphasis>user data</emphasis> map. The following diagram gives an overview on the description classes and their relationships.
					</para>
					<para>
						<mediaobject>
							<imageobject>
								<imagedata fileref="images/index_datamodel.png"/>
							</imageobject>
						</mediaobject>
					</para>
					<para>A language is configured with a default implementation of 
						<emphasis>IResourceDescription.Manager</emphasis> which computes 
						the list of exported 
						<emphasis>IEObjectDescriptions</emphasis> by iterating the whole EMF model and applying the 

						<emphasis>getQualifiedName(EObject obj)</emphasis> from 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java?root=Modeling_Project&amp;view=co">IQualifiedNameProvider</ulink> 
						on each 
						<emphasis>EObject</emphasis>. If the object has a qualified name an 
						<emphasis>IEObjectDescription</emphasis> is created and exported 
						(i.e. added to the list). If an 
						<emphasis>EObject</emphasis> doesn’t have a qualified name, the element is considered to 
						be not referable from outside the resource and consequently not indexed. If you don’t like this behavior, 
						you can implement and bind your own implementation of 
						<emphasis>IResourceDescription.Manager</emphasis>.  
					</para>
					<para>There are also two different default implementations of 
						<emphasis>IQualifiedNameProvider</emphasis>. Both work by looking 
						up an 
						<emphasis>EAttribute</emphasis> &#8218;name’. The 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/SimpleNameProvider.java?root=Modeling_Project&amp;view=co">SimpleNameProvider</ulink> 
						simply returns the plain value, while the 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/DefaultDeclarativeQualifiedNameProvider.java?root=Modeling_Project&amp;view=co">DefaultDeclarativeQualifiedNameProvider</ulink> concatenates 
						the simple name with the qualified name of its parent exported 
						<emphasis>EObject</emphasis>. This effectively simulates 
						the qualified name computation of most namespace-based languages (like e.g. Java). 
					</para>
					<para>As mentioned above, in order to calculate an 
						<emphasis>IResourceDescription</emphasis> for a resource the framework asks 
						the 
						<emphasis>IResourceDescription.Manager</emphasis>. Here’s some Java code showing how to do that:
					</para>
					<literallayout><code>Manager manager = // obtain an instance of IResourceDescription.Manager
IResourceDescription description = manager.getResourceDescription(resource);
for (IEObjectDescription objDescription : description.getExportedObjects()) {
  System.out.println(objDescription.getQualifiedName());
} 
  
</code></literallayout>
					<para>In order to obtain an 
						<emphasis>IResourceDescription.Manager</emphasis> it is best to ask the corresponding 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceServiceProvider.java?root=Modeling_Project&amp;view=co">IResourceServiceProvider</ulink>. That is because each 
						language might have a totally different implementation and as you might refer from your language to a 
						different language you can’t reuse your language’s 
						<emphasis>IResourceDescription.Manager</emphasis>. One basically asks 
						the 
						<emphasis>IResourceServiceProvider.Registry</emphasis> (there is usually one global instance) for an 

						<emphasis>IResourceServiceProvider</emphasis>, which in turn provides an 
						<emphasis>IResourceDescription.Manager</emphasis> along other 
						useful services.
					</para>
					<para>If you’re running in a Guice enabled scenario, the code looks like this:</para>
					<literallayout><code>@Inject 
private IResourceServiceProvider.Registry resourceServiceProviderRegistry;
	
private IResourceDescription.Manager getManager(Resource res) {
  IResourceServiceProvider resourceServiceProvider = 
    resourceServiceProviderRegistry.getResourceServiceProvider(res.getURI());
  return resourceServiceProvider.getResourceDescriptionManager();
}

</code></literallayout>
					<para>If you don’t run in a Guice enabled context you will likely have to directly access the singleton:</para>
					<literallayout><code>private IResourceServiceProvider.Registry resourceServiceProviderRegistry = 
  IResourceServiceProvider.Registry.INSTANCE;

</code></literallayout>
					<para>However, we strongly encourage you to use dependency injection.
						Now, that we know how to export elements to be referenceable from other resources, we need to learn 
						how those exported 
						<emphasis>IEObjectDescriptions</emphasis> can be made available to the referencing resources. That is 
						the responsibility of global scoping (i.e. 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/IGlobalScopeProvider.java?root=Modeling_Project&amp;view=co">IGlobalScopeProvider</ulink>) which is described in the 
						following chapter.
					</para>
				</section>
				<section id="import_uri">
					<title>Global Scopes Based On Explicit Imports (ImportURI Mechanism)</title>
					<para>A simple and straight forward solution is to have explicit references to other resources in your 
						file by explicitly listing pathes (or 
						<emphasis>URIs</emphasis>) to all referenced resources in your model file. That is 
						for instance what most include mechanisms use. In Xtext we provide a handy implementation of an 

						<emphasis>IGlobalScopeProvider</emphasis> which is based on a naming convention and makes this semantics very easy to use. 
						Talking of the introductory example and given you would want to add support for referencing external 

						<emphasis>States</emphasis> and 
						<emphasis>Events</emphasis> from within your state machine, all you had to do is add something like the 
						following to the grammar definition:
					</para>
					<literallayout><code>Statemachine :
  (imports+=Import)* // allow imports
  'events'
     (events+=Event)+
  'end'
  ('resetEvents'
     (resetEvents+=[Event])+
  'end')?
  'commands'
     (commands+=Command)+
  'end'
  (states+=State)+;

Import : 
  'import' importURI=STRING; // feature must be named importURI

</code></literallayout>
					<para>This effectively allows import statements to be declared before the events section. In addition 
						you’ll have to make sure that you have bound the 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/ImportUriGlobalScopeProvider.java?root=Modeling_Project&amp;view=co">ImportUriGlobalScopeProvider</ulink> for the type 

						<emphasis>IGlobalScopeProvider</emphasis> by the means of 
						<link linkend="dependencyInjection">Guice</link>. That implementation looks up any 

						<emphasis>EAttributes</emphasis> named &#8218;importURI’ in your model and interprets their values as URIs that point to imported
						resources. That is it adds the corresponding resources to the current resource’s resource set. In 
						addition the scope provider uses the 
						<link linkend="resourcedescriptions">
							<emphasis>IResourceDescription.Manager</emphasis>
						</link> of that 
						imported resource to compute all the 
						<emphasis>IEObjectDescriptions</emphasis> returned by the 
						<emphasis>IScope</emphasis>.  
					</para>
					<para>Global scopes based on import URIs are available if you use the 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/scoping/ImportURIScopingFragment.java?root=Modeling_Project&amp;view=co">ImportURIScopingFragment</ulink> in the 
						workflow of your language. It will bind an 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/ImportUriGlobalScopeProvider.java?root=Modeling_Project&amp;view=co">ImportUriGlobalScopeProvider</ulink> 
						(
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/ignorecase/IgnoreCaseImportUriGlobalScopeProvider.java?root=Modeling_Project&amp;view=co">IgnoreCaseImportUriGlobalScopeProvider</ulink> 
						if the 
						<emphasis>caseInsensitve</emphasis> flag is set) that handles 
						<emphasis>importURI</emphasis> features.
					</para>
				</section>
				<section id="index_based">
					<title>Global Scopes Based On External Configuration (e.g. Classpath-Based)</title>
					<para>Instead of explicitly referring to imported resources, the other possibility is to have some kind of 
						external configuration in order to define what is visible from outside a resource. Java for instances 
						uses the notion of classpaths to define containers (jars and class folders) which contain any 
						referenceable elements. In the case of Java also the order of such entries is important. </para>
					<para>Since version 1.0.0 Xtext provides support for this kind of global scoping. To enable it, a 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/DefaultGlobalScopeProvider.java?root=Modeling_Project&amp;view=co">DefaultGlobalScopeProvider</ulink> has to be bound to 
						the 
						<emphasis>IGlobalScopeProvider</emphasis> interface. For case insensitive names use the 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/ignorecase/IgnoreCaseDefaultGlobalScopeProvider.java?root=Modeling_Project&amp;view=co">IgnoreCaseDefaultGlobalScopeProvider</ulink>.
					</para>
					<para>By default Xtext leverages the classpath mechanism since it is well designed and already understood 
						by most of our users. The available tooling provided by JDT and PDE to configure the classpath adds 
						even more value. However, it is just a default: You can reuse the infrastructure without using Java 
						and independent from the JDT.</para>
					<para>In order to know what is available in the &#8222;world” a global scope provider which relies on external 
						configuration needs to read that configuration in and be able to find all candidates for a certain 

						<emphasis>EReference</emphasis>. If you don’t want to force users to have a folder and file name structure reflecting 
						the actual qualified names of the referenceable 
						<emphasis>EObjects</emphasis>, you’ll have to load all resources up front 
						and either keep holding them in memory or remembering all information which is needed for the 
						resolution of cross-references. In Xtext that information is provided by a so called 

						<link linkend="resourcedescriptions">
							<emphasis>IEObjectDescription</emphasis>
						</link>. 
					</para>
					<section id="containers">
						<title>About the Index, Containers and Their Manager </title>
						<para>Xtext ships with an index which remembers all 
							<emphasis>IResourceDescription</emphasis> and their 
							<emphasis>IEObjectDescription</emphasis> 
							objects. In the IDE-context (i.e. when running the editor, etc.) the index is updated by an incremental 
							project builder. As opposed to that, in a non-UI context you typically do not have to deal with changes 
							such that the infrastructure can be much simpler. In both situations the global index state is held 
							by an implementation of 
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IResourceDescriptions.java?root=Modeling_Project&amp;view=co">IResourceDescriptions</ulink> 
							(Note the plural form!). The bound singleton in the UI scenario is even aware of unsaved editor changes, 
							such that all linking happens to the latest maybe unsaved version of the resources. You will find the 
							Guice configuration of the global index in the UI scenario in 

							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui.shared/src/org/eclipse/xtext/ui/shared/internal/SharedModule.java?root=Modeling_Project&amp;view=co">SharedModule</ulink>.
						</para>
						<para>The index is basically a flat list of instances of 
							<emphasis>IResourceDescription</emphasis>. The index itself doesn’t 
							know about visibility constraints due to classpath restriction. Rather than that, they are defined by 
							the referencing language by means of so called 
							<emphasis>IContainers</emphasis>: While Java might load a resource 
							via 
							<emphasis>ClassLoader.loadResource()</emphasis> (i.e. using the classpath mechanism), another language could load 
							the same resource using the file system paths. 
						</para>
						<para>Consequently, the information which container a resource belongs to depends on the referencing 
							context. Therefore an 
							<emphasis>IResourceServiceProvider</emphasis> provides another interesting service, which is called

							<emphasis>IContainer.Manager</emphasis>. For a given 
							<emphasis>IResourceDescription</emphasis>, the 
							<emphasis>IContainer.Manager</emphasis> provides you with 
							the 
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IContainer.java?root=Modeling_Project&amp;view=co">IContainer</ulink> as well as with a list of all 

							<emphasis>IContainers</emphasis> which are visible from there. Note that the index (
							<emphasis>IResourceDesciptions</emphasis>) is globally 
							shared between all languages while the 
							<emphasis>IContainer.Manager</emphasis> that adds the semantics of containers can 
							be very different depending on the language. The following method lists all resources visible from a 
							given 
							<emphasis>Resource</emphasis>:  
						</para>
						<literallayout><code>@Inject
IContainer.Manager manager;

public void listVisibleResources(
        Resource myResource, IResourceDescriptions index) {
  IResourceDescription descr = 
        index.getResourceDescription(myResource.getURI());
  for(IContainer visibleContainer: 
  	    manager.getVisibleContainers(descr, index)) { 
    for(IResourceDescription visibleResourceDesc:
            visibleContainer.getResourceDescription()) { 
      System.out.println(visibleResourceDesc.getURI());
    }
  }
}

</code></literallayout>
						<para>Xtext ships two implementations of 
							<emphasis>IContainer.Manager</emphasis> which are as usual bound with Guice: The 
							default binding is to 

							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/SimpleResourceDescriptionsBasedContainerManager.java?root=Modeling_Project&amp;view=co">SimpleResourceDescriptionsBasedContainerManager</ulink>, 
							which assumes all 
							<emphasis>IResourceDescription</emphasis> to be in a single common container. If you don’t care about 
							container support, you’ll be fine with this one. Alternatively, you can bind 

							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/StateBasedContainerManager.java?root=Modeling_Project&amp;view=co">StateBasedContainerManager</ulink> and an 
							additional 
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/IAllContainersState.java?root=Modeling_Project&amp;view=co">IAllContainersState</ulink> which 
							keeps track of the set of available containers and their visibility relationships.  
						</para>
						<para>Xtext offers a couple of strategies for managing containers: If you’re running an Eclipse workbench, 
							you can define containers based on Java projects and their classpaths or based on plain Eclipse projects. 
							Outside Eclipse, you can provide a set of file system paths to be scanned for models. All of these only 
							differ in the bound instance of 
							<emphasis>IAllContainerState</emphasis> of the referring language. These will be described 
							in detail in the following sections.
						</para>
						<para>
							<mediaobject>
								<imageobject>
									<imagedata fileref="images/index_container.png"/>
								</imageobject>
							</mediaobject>
						</para>
					</section>
					<section id="jdt_based_containers">
						<title>JDT-Based Container Manager </title>
						<para>As JDT is an Eclipse feature, this JDT-based container management is only available in the UI scenario. 
							It assumes so called 
							<emphasis>IPackageFragmentRoots</emphasis> as containers. An 
							<emphasis>IPackageFragmentRoot</emphasis> in JDT is the 
							root of a tree of Java model elements. It usually refers to 
						</para>
						<itemizedlist>
							<listitem>
								<para>a source folder of a Java project,</para>
							</listitem>
							<listitem>
								<para>a referenced jar, </para>
							</listitem>
							<listitem>
								<para>a classpath entry of a referenced Java project, or</para>
							</listitem>
							<listitem>
								<para>the exported packages of a required PDE plug-in.</para>
							</listitem>
						</itemizedlist>
						<para>So for an element to be referable, its resource must be on the classpath of the caller’s Java project 
							and it must be exported (as described above). </para>
						<para>As this strategy allows to reuse a lot of nice Java things like jars, OSGi, maven, etc. it is part of 
							the default: You should not have to reconfigure anything to make it work. Nevertheless, if you messed 
							something up, make sure you bind</para>
						<literallayout><code>public Class&lt;? extends IContainer.Manager&gt; bindIContainer$Manager() {
  return StateBasedContainerManager.class;
}

</code></literallayout>
						<para>in the runtime module and </para>
						<literallayout><code>public Provider&lt;IAllContainersState&gt; provideIAllContainersState() {
  return org.eclipse.xtext.ui.shared.Access.getJavaProjectsState();
  // return org.eclipse.xtext.ui.shared.Access.getStrictJavaProjectsState();
}

</code></literallayout>
						<para>in the UI module of the referencing language. The latter looks a bit more difficult than a common 
							binding, as we have to bind a global singleton to a Guice provider. The 
							<emphasis>StrictJavaProjectsState</emphasis> 
							requires all elements to be on the classpath, while the default 
							<emphasis>JavaProjectsState</emphasis> also allows models 
							in non-source folders. 
						</para>
					</section>
					<section id="project_based_containers">
						<title>Eclipse Project-Based Containers</title>
						<para>If the classpath-based mechanism doesn’t work for your case, Xtext offers an alternative container 
							manager based on plain Eclipse projects: Each project acts as a container and the project references 

							<emphasis>Properties-&gt;Project References</emphasis> are the visible containers. 
						</para>
						<para>In this case, your runtime module should define</para>
						<literallayout><code>public Class&lt;? extends IContainer.Manager&gt; bindIContainer$Manager() {
  return StateBasedContainerManager.class;
}

</code></literallayout>
						<para>and the UI module should bind </para>
						<literallayout><code>public Provider&lt;IAllContainersState&gt; provideIAllContainersState() {
  return org.eclipse.xtext.ui.shared.Access.getWorkspaceProjectsState();
}

</code></literallayout>
					</section>
					<section id="resource_set_containers">
						<title>
							<emphasis>ResourceSet</emphasis>-Based Containers
						</title>
						<para>If you need an 
							<emphasis>IContainer.Manager</emphasis> that is independent of Eclipse projects, you can use the 

							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/containers/ResourceSetBasedAllContainersState.java?root=Modeling_Project&amp;view=co">ResourceSetBasedAllContainersState</ulink>. 
							This one can be configured with a mapping of container handles to resource URIs.
						</para>
						<para>It is unlikely you want to use this strategy directly in your own code, but it is used in the back-end 
							of the MWE2 workflow component 
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/mwe/Reader.java?root=Modeling_Project&amp;view=co">Reader</ulink>. This is responsible 
							for reading in models in a workflow, e.g. for later code generation. The 
							<emphasis>Reader</emphasis> allows to either scan 
							the whole classpath or a set of paths for all models therein. When paths are given, each path entry 
							becomes an 
							<emphasis>IContainer</emphasis> of its own. In the following snippet,
						</para>
						<literallayout><code>component = org.eclipse.xtext.mwe.Reader {
  // lookup all resources on the classpath
  // useJavaClassPath = true
	
  // or define search scope explicitly
  path = "src/models"
  path = "src/further-models"

  ...
}
 
</code></literallayout>
					</section>
				</section>
			</section>
			<section id="local_scoping">
				<title>Local Scoping</title>
				<para>We now know how the outer world of referenceable elements can be defined in Xtext. Nevertheless, not 
					everything is available in any context and with a global name. Rather than that, each context can usually 
					have a different scope. As already stated, scopes can be nested, i.e. a scope can in addition to its 
					own elements contain elements of a parent scope. When parent and child scope contain different elements 
					with the same name, the parent scope’s element will usually be 
					<emphasis>shadowed</emphasis> by the element from the child scope.      
				</para>
				<para>To illustrate that, let’s have a look at Java: Java defines multiple kinds of scopes 
					(object scope, type scope, etc.). For Java one would create the scope hierarchy as commented in the 
					following example:</para>
				<literallayout><code>// file contents scope
import static my.Constants.STATIC;

public class ScopeExample { // class body scope
  private Object field = STATIC;

  private void method(String param) { // method body scope
    String localVar = "bar";
    innerBlock: { // block scope
      String innerScopeVar = "foo";
      Object field = innerScopeVar;
      // the scope hierarchy at this point would look like this:
      //  blockScope{field,innerScopeVar}-&gt;
      //  methodScope{localVar, param}-&gt;
      //  classScope{field}-&gt; ('field' is shadowed)
      //  fileScope{STATIC}-&gt;
      //  classpathScope{
      //      'all qualified names of accessible static fields'} -&gt;
      //  NULLSCOPE{}
      //
    }
    field.add(localVar);
  }
}

</code></literallayout>
				<para>In fact the classpath scope should also reflect the order of classpath entries.
					For instance:</para>
				<literallayout><code>classpathScope{stuff from bin/}
-&gt; classpathScope{stuff from foo.jar/}
-&gt; ...
-&gt; classpathScope{stuff from JRE System Library}
-&gt; NULLSCOPE{}

</code></literallayout>
				<para>Please find the motivation behind this and some additional details in 

					<ulink url="http://blog.efftinge.de/2009/01/xtext-scopes-and-emf-index.html">this blog post</ulink> .
				</para>
				<section id="DeclarativeScoping">
					<title>Declarative Scoping</title>
					<para>If you have to define scopes for certain contexts, the base class 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/AbstractDeclarativeScopeProvider.java?root=Modeling_Project&amp;view=co">AbstractDeclarativeScopeProvider</ulink> allows to do 
						that in a declarative way. It looks up methods which have either of the following two signatures:
					</para>
					<literallayout><code>IScope scope_&lt;RefDeclaringEClass&gt;_&lt;Reference&gt;(
    &lt;ContextType&gt; ctx, EReference ref)

IScope scope_&lt;TypeToReturn&gt;(&lt;ContextType&gt; ctx, EReference ref)

</code></literallayout>
					<para>The former is used when evaluating the scope for a specific cross-reference and here 
						<emphasis>ContextReference</emphasis> 
						corresponds to the name of this reference (prefixed with the name of the reference’s declaring type and 
						separated by an underscore). The 
						<emphasis>ref</emphasis> parameter represents this cross-reference.
					</para>
					<para>The latter method signature is used when computing the scope for a given element type and is applicable 
						to all cross-references of that type. Here 
						<emphasis>TypeToReturn</emphasis> is the name of that type. 
					</para>
					<para>So if you for example have a state machine with a  
						<emphasis>Transition</emphasis> object owned by its source 
						<emphasis>State</emphasis> and 
						you want to compute all reachable states (i.e. potential target states), the corresponding method could 
						be declared as follows (assuming the cross-reference is declared by the 
						<emphasis>Transition</emphasis> type and is called 
						<emphasis>target</emphasis>):
					</para>
					<literallayout><code>IScope scope_Transition_target(Transition this, EReference ref)
</code></literallayout>
					<para>If such a method does not exist, the implementation will try to find one for the context object’s container. 
						Thus in the example this would match a method with the same name but 
						<emphasis>State</emphasis> as the type of the first 
						parameter. It will keep on walking the containment hierarchy until a matching method is found. This 
						container delegation allows to reuse the same scope definition for elements in different places of the 
						containment hierarchy. Also it may make the method easier to implement as the elements comprising the 
						scope are quite often owned or referenced by a container of the context object. In the example the 

						<emphasis>State</emphasis> objects could for instance be owned by a containing 
						<emphasis>StateMachine</emphasis> object.
					</para>
					<para>If no method specific to the cross-reference in question was found for any of the objects in the 
						containment hierarchy, the implementation will start looking for methods matching the other signature. Again it will first attempt to match the context object. Thus in the 
						example the signature first matched would be:</para>
					<literallayout><code>IScope scope_State(Transition this, EReference ref)
</code></literallayout>
					<para>If no such method exists, the implementation will again try to find a method matching the context object’s 
						container objects. In the case of the state machine example you might want to declare the scope with 
						available states at the state machine level:</para>
					<literallayout><code>IScope scope_State(StateMachine this, EReference ref)
</code></literallayout>
					<para>This scope can now be used for any cross-references of type 
						<emphasis>State</emphasis> for context objects owned by the 
						state machine.
					</para>
				</section>
			</section>
			<section id="ImportedNamespaceAwareScoping">
				<title>Imported Namespace-Aware Scoping</title>
				<para>The imported namespace aware scoping is based on qualified names and namespaces. It adds namespace 
					support to your language, which is comparable and similar to the one in Scala and C#. Scala and C# both 
					allow to have multiple nested packages within one file and you can put imports per namespace, so that 
					imported names are only visible within that namespace. See the domain model example: its scope provider 
					extends 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/ImportedNamespaceAwareLocalScopeProvider.java?root=Modeling_Project&amp;view=co">ImportedNamespaceAwareLocalScopeProvider</ulink>.
				</para>
				<section id="org.eclipse.xtextsrcorg.eclipse.xtext.naming.IQualifiedNameProvider">
					<title>
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java?root=Modeling_Project&amp;view=co">IQualifiedNameProvider</ulink>
					</title>
					<para>The 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/scoping/impl/ImportedNamespaceAwareLocalScopeProvider.java?root=Modeling_Project&amp;view=co">ImportedNamespaceAwareLocalScopeProvider</ulink> 
						makes use of the so called 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/IQualifiedNameProvider.java?root=Modeling_Project&amp;view=co">IQualifiedNameProvider</ulink> 
						service. It computes qualified names for EObjects. The default implementation 
						(
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/naming/DefaultDeclarativeQualifiedNameProvider.java?root=Modeling_Project&amp;view=co">DefaultDeclarativeQualifiedNameProvider</ulink>) uses 
						a simple name look up and concatenates the result to the qualified name of its parent object using a dot 
						as separator. 
					</para>
					<para>It also allows to override the name computation declaratively. The following snippet shows how you could 
						make 
						<emphasis>Transitions</emphasis> in the state machine example referable by giving them a name. Don’t forget to bind 
						your implementation in your runtime module. 
					</para>
					<literallayout><code>FowlerDslQualifiedNameProvider 
      extends DefaultDeclarativeQualifiedNameProvider {
  public String qualifiedName(Transition t) {
    if(t.getEvent() == null ||&#xa0;!(t.eContainer() instanceof State)) 
      return null;
    else 
      return ((State)t.eContainer()).getName() + "." t.getEvent().getName();
  }
}

</code></literallayout>
				</section>
				<section id="ImportingNamespaces">
					<title>Importing Namespaces</title>
					<para>The 
						<emphasis>ImportedNamespaceAwareLocalScopeProvider</emphasis> looks up 
						<emphasis>EAttributes</emphasis> with name &#8218;importedNamespace’ and 
						interprets them as import statements. By default qualified names with or without a wildcard at the end 
						are supported. For an import of a qualified name the simple name is made available as we know from e.g. 
						Java, where
					</para>
					<literallayout><code>import java.util.Set;
</code></literallayout>
					<para>makes it possible to refer to &#8218;java.util.Set’ by its simple name &#8218;Set’.
						Contrary to Java the import is not active for the whole file but only for the namespace it is declared 
						in and its child namespaces. That is why you can write the following in the example DSL:</para>
					<literallayout><code>package foo {
  import bar.Foo
  entity Bar extends Foo {
  }
}

package bar {
  entity Foo {}
}

</code></literallayout>
					<para>Of course the declared elements within a package are as well referable by their simple name:</para>
					<literallayout><code>package bar {
  entity Bar extends Foo {}
  entity Foo {}
}

</code></literallayout>
					<para>The following would as well be ok:</para>
					<literallayout><code>package bar {
  entity Bar extends bar.Foo {}
  entity Foo {}
}

</code></literallayout>
					<para>See the JavaDocs and 
						<ulink url="http://blog.efftinge.de/2009/07/xtext-scopes-and-emf-index-in-action.html">this blog post</ulink> 
						for details.
					</para>
				</section>
			</section>
		</section>
		<section id="valueconverter">
			<title>Value Converter</title>
			<para>Value converters are registered to convert the parsed text into a certain data type instance and vice versa.
				The primary hook is called 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverterService.java?root=Modeling_Project&amp;view=co">IValueConverterService</ulink> 
				and the concrete implementation can be registered via the runtime 
				<link linkend="guicemodules">Guice module</link>.
				To do so override the corresponding binding in your runtime module like shown in this example:
			</para>
			<literallayout><code>@Override
public Class&lt;? extends IValueConverterService&gt; bindIValueConverterService() {
  return MySpecialValueConverterService.class;
}

</code></literallayout>
			<section id="AnnotationBasedValueConverters">
				<title>Annotation-Based Value Converters</title>
				<para>The most simple way to register additional value converters is to make use of 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/impl/AbstractDeclarativeValueConverterService.java?root=Modeling_Project&amp;view=co">AbstractDeclarativeValueConverterService</ulink>, 
					which allows to declaratively register an 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/IValueConverter.java?root=Modeling_Project&amp;view=co">IValueConverter</ulink>
					by means of an annotated method. 
				</para>
				<para>If you use the common terminals grammar 
					<emphasis>org.eclipse.xtext.common.Terminals</emphasis> you should subclass 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/common/services/DefaultTerminalConverters.java?root=Modeling_Project&amp;view=co">DefaultTerminalConverters</ulink> and override or 
					add additional value converters by adding the respective methods. In addition to the explicitly 
					defined converters in the default implementation, a delegating converter is registered for each 
					available 
					<emphasis>EDataType</emphasis> that reuses the functionality of the corresponding EMF 
					<emphasis>EFactory</emphasis>.
				</para>
				<para>As qualified names – i.e. names composed of namespaces separated by a delimiter – are expected to occur often, we’ve added a 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/impl/QualifiedNameValueConverter.java?root=Modeling_Project&amp;view=co">QualifiedNameValueConverter</ulink>. This one removes comments and whitespaces and delegates to another value converter for each segment, allowing individually quoted segments. The domainmodel example shows how to use it. 
				</para>
				<para>The protocol of an 
					<emphasis>IValueConverter</emphasis> allows to throw a 
					<emphasis>ValueConverterException</emphasis> if something went wrong.
					The exception is propagated as a syntax error by the parser or as a validation problem by the 

					<emphasis>ConcreteSyntaxValidator</emphasis> if the value cannot be converted to a valid string. The 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/impl/AbstractLexerBasedConverter.java?root=Modeling_Project&amp;view=co">AbstractLexerBasedConverter</ulink> is useful when 
					implementing a custom value converter. If the converter needs to know about the rule that it currently 
					works with, it may implement the interface 
					<emphasis>IValueConverter.RuleSpecific</emphasis>. The framework will set the
					rule such as the implementation may use it afterwards.
				</para>
			</section>
		</section>
		<section id="serialization">
			<title>Serialization</title>
			<para>Serialization is the process of transforming an EMF model into its textual representation. Thereby, 
				serialization complements parsing and lexing.</para>
			<para>In Xtext, the process of serialization is split into the following steps:</para>
			<orderedlist>
				<listitem>
					<para>Validating the semantic model. This is optional, enabled by default, done by the 
						<link linkend="concrete_syntax_validation">concrete syntax validator</link> and can be turned off in the 
						<link linkend="saveoptions">save options</link>. 
					</para>
				</listitem>
				<listitem>
					<para>Matching the model elements with the grammar rules and creating a stream of tokens. This is done by the 
						<link linkend="parsetreeconstructor">parse tree constructor</link>.
					</para>
				</listitem>
				<listitem>
					<para>Associating comments with semantic objects. This is done by the 
						<link linkend="commentassociater">comment associator</link>.
					</para>
				</listitem>
				<listitem>
					<para>Associating existing nodes from the node model with tokens from the token stream.</para>
				</listitem>
				<listitem>
					<para>
						<link linkend="hiddentokenmerger">Merging existing whitespace</link> and line-wraps into to token stream. 
					</para>
				</listitem>
				<listitem>
					<para>Adding further needed whitespace or replacing all whitespace using a 
						<link linkend="formatting">formatter</link>.  
					</para>
				</listitem>
			</orderedlist>
			<para>Serialization is invoked when calling 

				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java?root=Modeling_Project&amp;view=co">XtextResource</ulink>.save(...). Furthermore, 

				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/Serializer.java?root=Modeling_Project&amp;view=co">Serializer</ulink> provides resource-independent 
				support for serialization. Serialization is 
				<emphasis>not</emphasis> called when a textual editors contents is saved to disk. 
				Another situation that triggers serialization is applying 
				<link linkend="quickfixes">Quick Fixes</link> with semantic modifications.
			</para>
			<section id="serializationcontract">
				<title>The Contract</title>
				<para>The contract of serialization says that a model that is serialized to its textual representation 
					and then loaded (parsed) again should yield a loaded model that equals the original model. Please be 
					aware that this does 
					<emphasis>not</emphasis> imply, that loading a textual representation and serializing it back produces 
					identical textual representations. For example, this is the case when a default value is used in a 
					textual representation and the assignment is optional. Another example is:
				</para>
				<literallayout><code>MyRule:
  (xval+=ID | yval+=INT)*;
  
</code></literallayout>
				<para>
					<emphasis>MyRule</emphasis> in this example reads 
					<emphasis>ID</emphasis>- and 
					<emphasis>INT</emphasis>-elements which may occur in an arbitrary order in 
					the textual representation. However, when serializing the model all 
					<emphasis>ID</emphasis>-elements will be written 
					first and then all 
					<emphasis>INT</emphasis>-elements. If the order is important it can be preserved by storing all elements 
					in the same list – which may require wrapping the 
					<emphasis>ID</emphasis>- and 
					<emphasis>INT</emphasis>-elements into objects.
				</para>
			</section>
			<section id="RolesoftheSemanticModelandtheNodeModelDuringSerialization">
				<title>Roles of the Semantic Model and the Node Model During Serialization</title>
				<para>A serialized document represents the state of the semantic model. However, if there is a node model available (i.e. the semantic model has been created by the parser), the serializer</para>
				<itemizedlist>
					<listitem>
						<para>preserves 
							<link linkend="hiddentokenmerger">existing whitespaces</link> from the node model.
						</para>
					</listitem>
					<listitem>
						<para>preserves 
							<link linkend="commentassociater">existing comments</link> from the node model.
						</para>
					</listitem>
					<listitem>
						<para>preserves the representation of cross-references: If a cross-referenced object can be identified by multiple names (i.e. scoping returns multiple EObjectDescriptions for the same object), the serializer tries to keep the previously used name. </para>
					</listitem>
					<listitem>
						<para>preserves the representation of values: For values handled by the 
							<link linkend="valueconverter">value converter</link>, the serializer checks whether the textual representation converted to a value equals the value from the semantic model. If that is true, the textual representation is kept.  
						</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="parsetreeconstructor">
				<title>Parse Tree Constructor</title>
				<para>The parse tree constructor usually does not need to be customized since it is automatically derived 
					from the 
					<link linkend="grammarLanguage">Xtext Grammar</link>. However, it can be helpful to look into it to understand 
					its error messages and its runtime performance.
				</para>
				<para>For serialization to succeed, the parse tree constructor must be able to 
					<emphasis>consume</emphasis> every non-transient 
					element of the to-be-serialized EMF model. To 
					<emphasis>consume</emphasis> means, in this context, to write the element to 
					the textual representation of the model. This can turn out to be a not-so-easy-to-fulfill requirement, 
					since a grammar usually introduces implicit constraints to the EMF model as explained for the 

					<link linkend="concrete_syntax_validation">concrete syntax validator</link>.
				</para>
				<para>If a model can not be serialized, an 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/XtextSerializationException.java?root=Modeling_Project&amp;view=co">XtextSerializationException</ulink> is thrown. 
					Possible reasons are listed below:
				</para>
				<itemizedlist>
					<listitem>
						<para>A model element can not be consumed. This can have the following reasons/solutions:</para>
						<itemizedlist>
							<listitem>
								<para>The model element should not be stored in the model.</para>
							</listitem>
							<listitem>
								<para>The grammar needs an assignment which would consume the model element.</para>
							</listitem>
							<listitem>
								<para>The 
									<link linkend="transientvalues">transient value service</link> can be used to indicate that this model element should not be consumed. 
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<para>An assignment in the grammar has no corresponding model element. The default transient value service considers a model element to be transient if it is 
							<emphasis>unset</emphasis> or equals its default value. However, the parse tree constructor may serialize default values if this is required by a grammar constraint to be able to serialize another model element. The following solution may help to solve such a scenario:
						</para>
						<itemizedlist>
							<listitem>
								<para>A model element should be added to the model.</para>
							</listitem>
							<listitem>
								<para>The assignment in the grammar should be made optional.</para>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<para>The type of the model element differs from the type in the grammar. The type of the model element must be identical to the return type of the grammar rule or the action’s type. Sub-types are not allowed.</para>
					</listitem>
					<listitem>
						<para>
							<link linkend="valueconverter">Value conversion</link> fails. The value converter can indicate that a value is not serializeable by throwing a 
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/conversion/ValueConverterException.java?root=Modeling_Project&amp;view=co">ValueConverterException</ulink>.
						</para>
					</listitem>
					<listitem>
						<para>An enum literal is not allowed at this position. This can happen if the referenced enum rule only lists a subset of the literals of the actual enumeration.</para>
					</listitem>
				</itemizedlist>
				<para>To understand error messages and performance issues of the parse tree constructor it is important to 
					know that it implements a backtracking algorithm. This basically means that the grammar is used to 
					specify the structure of a tree in which one path (from the root node to a leaf node) is a valid 
					serialization of a specific model. The parse tree constructor’s task is to find this path – with the 
					condition, that all model elements are consumed while walking this path. The parse tree constructor’s 
					strategy is to take the most promising branch first (the one that would consume the most model elements). 
					If the branch leads to a dead end (for example, if a model element needs to be consumed that is not 
					present in the model), the parse tree constructor goes back the path until a different branch can be 
					taken. This behavior has two consequences:</para>
				<itemizedlist>
					<listitem>
						<para>In case of an error, the parse tree constructor has found only dead ends but no leaf. It cannot tell which dead end is actually erroneous. Therefore, the error message lists dead ends of the longest paths, a fragment of their serialization and the reason why the path could not be continued at this point. The developer has to judge on his own which reason is the actual error.</para>
					</listitem>
					<listitem>
						<para> For reasons of performance, it is critical that the parse tree constructor takes the most promising branch first and detects wrong branches early. One way to achieve this is to avoid having many rules which return the same type and which are called from within the same alternative in the grammar.</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="saveoptions">
				<title>Options</title>
				<para>
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/SaveOptions.java?root=Modeling_Project&amp;view=co">SaveOptions</ulink> can be passed to 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java?root=Modeling_Project&amp;view=co">XtextResource</ulink>.save(options) and to 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/Serializer.java?root=Modeling_Project&amp;view=co">Serializer</ulink>.serialize(..). 
					Available options are:
				</para>
				<itemizedlist>
					<listitem>
						<para>
							<emphasis role="bold">Formatting</emphasis>. Default: 
							<emphasis>false</emphasis>. If enabled, it is the 
							<link linkend="formatting">formatters</link> job to determine all whitespace information during serialization. If disabled, the formatter only defines whitespace information for the places in which no whitespace information can be preserved from the node model. E.g. When new model elements are inserted or there is no node model.
						</para>
					</listitem>
					<listitem>
						<para>
							<emphasis role="bold">Validating</emphasis>. Default: 
							<emphasis>true</emphasis>: Run the 
							<link linkend="concrete_syntax_validation">concrete syntax validator</link> before serializing the model.
						</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="commentassociater">
				<title>Preserving Comments from the Node Model</title>
				<para>The 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ICommentAssociater.java?root=Modeling_Project&amp;view=co">ICommentAssociater</ulink> associates 
					comments with semantic objects. This is important in case an element in the semantic model is moved 
					to a different position and the model is serialized, one expects the comments to be moved to the 
					new position in the document as well.
				</para>
				<para>Which comment belongs to which semantic object is surely a very subjective issue. The default 
					implementation (
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/impl/DefaultCommentAssociater.java?root=Modeling_Project&amp;view=co">DefaultCommentAssociater</ulink>) 
					behaves as follows, but can be customized:
				</para>
				<itemizedlist>
					<listitem>
						<para>If there is a semantic token before a comment and in the same line, the comment is associated with this token’s semantic object.</para>
					</listitem>
					<listitem>
						<para>In all other cases, the comment is associated with the semantic object of the next following object.</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="transientvalues">
				<title>Transient Values</title>
				<para>Transient values are values or model elements which are not persisted (written to the textual 
					representation in the serialization phase). If a model contains model elements which can not be serialized 
					with the current grammar, it is critical to mark them transient using the 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ITransientValueService.java?root=Modeling_Project&amp;view=co">ITransientValueService</ulink>, or serialization 
					will fail. The default implementation marks all model elements transient, which are 
					<emphasis>eStructuralFeature.isTransient()</emphasis> 
					or not 
					<emphasis>eObject.eIsSet(eStructuralFeature)</emphasis>. By default, EMF returns 
					<emphasis>false</emphasis> for 
					<emphasis>eIsSet(...)</emphasis> if the 
					value equals the default value.    
				</para>
			</section>
			<section id="unassignedtext">
				<title>Unassigned Text</title>
				<para>If there are calls of data type rules or terminal rules that do not reside in an assignment, 
					the serializer by default doesn’t know which value to use for serialization.  </para>
				<para>. Example:</para>
				<literallayout><code>PluralRule:
  'contents:' count=INT Plural;
  
terminal Plural: 
  'item' | 'items';
  
</code></literallayout>
				<para>Valid models for this example are 
					<emphasis>contents 1 item</emphasis> or 
					<emphasis>contents 5 items</emphasis>. However, it is not stored 
					in the semantic model whether the keyword 
					<emphasis>item</emphasis> or 
					<emphasis>items</emphasis> has been parsed. This is due to the fact 
					that the rule call 
					<emphasis>Plural</emphasis> is unassigned. However, the 
					<link linkend="parsetreeconstructor">parse tree constructor</link> 
					needs to decide which value to write during serialization. This decision can be be made by customizing 
					the 
					<emphasis>IValueSerializer.serializeUnassignedValue(EObject, RuleCall, AbstractNode)</emphasis>.  
				</para>
			</section>
			<section id="crossreferenceserializer">
				<title>Cross-Reference Serializer</title>
				<para>The cross-reference serializer specifies which values are to be written to the textual representation 
					for cross-references. This behavior can be customized by implementing 

					<emphasis>ICrossReferenceSerializer</emphasis>. 
					The default implementation delegates to various other services such as the 
					<emphasis>IScopeProvider</emphasis> or the 

					<emphasis>LinkingHelper</emphasis> each of which may be the better place for customization.
				</para>
			</section>
			<section id="hiddentokenmerger">
				<title>Merge Whitespaces</title>
				<para>After the 
					<link linkend="parsetreeconstructor">parse tree constructor</link> has done its job to create a stream of 
					tokens which are to be written to the textual representation, and the 
					<link linkend="commentassociater">comment associator</link> 
					has done its work, existing whitespace form the node model is merged into the stream. 
				</para>
				<para>The strategy is as follows: If two tokens follow each other in the stream and the corresponding 
					nodes in the node model follow each other as well, then the whitespace information in between is kept. 
					In all other cases it is up to the 
					<link linkend="formatting">formatter</link> to calculate new whitespace information. 
				</para>
			</section>
			<section id="tokenstream">
				<title>Token Stream</title>
				<para>The 
					<link linkend="parsetreeconstructor">parse tree constructor</link> and the 
					<link linkend="formatting">formatter</link> use an 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/ITokenStream.java?root=Modeling_Project&amp;view=co">ITokenStream</ulink> for their output, and the 
					latter for its input as well. This makes them chainable. Token streams can be converted to a 
					<emphasis>String</emphasis> 
					using the 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/impl/TokenStringBuffer.java?root=Modeling_Project&amp;view=co">TokenStringBuffer</ulink> and to 
					a 
					<emphasis>Writer</emphasis> using the 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parsetree/reconstr/impl/WriterTokenStream.java?root=Modeling_Project&amp;view=co">WriterTokenStream</ulink>.
				</para>
				<literallayout><code>public interface ITokenStream {
  void flush() throws IOException;
  void writeHidden(EObject grammarElement, String value) throws IOException;
  void writeSemantic(EObject grammarElement, String value) throws IOException;
}

 

</code></literallayout>
			</section>
		</section>
		<section id="formatting">
			<title>Formatting (Pretty Printing)</title>
			<para>A formatter can be implemented via the 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/IFormatter.java?root=Modeling_Project&amp;view=co">IFormatter</ulink> 
				service. Technically speaking, a formatter is a 
				<link linkend="tokenstream">Token Stream</link> which 
				inserts/removes/modifies hidden tokens (whitespace, line-breaks, comments).
			</para>
			<para>The formatter is invoked during the 
				<link linkend="serialization">serialization phase</link> and when the user triggers 
				formatting in the editor (for example, using the CTRL+SHIFT+F shortcut).
			</para>
			<para>Xtext ships with two formatters:</para>
			<itemizedlist>
				<listitem>
					<para>The 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/OneWhitespaceFormatter.java?root=Modeling_Project&amp;view=co">OneWhitespaceFormatter</ulink> simply writes one whitespace between all tokens.
					</para>
				</listitem>
				<listitem>
					<para>The 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/AbstractDeclarativeFormatter.java?root=Modeling_Project&amp;view=co">AbstractDeclarativeFormatter</ulink> allows advanced configuration using a 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/FormattingConfig.java?root=Modeling_Project&amp;view=co">FormattingConfig</ulink>. Both are explained in the 
						<link linkend="declarativeformatter">next chapter</link>.
					</para>
				</listitem>
			</itemizedlist>
			<section id="declarativeformatter">
				<title>Declarative Formatter</title>
				<para>A declarative formatter can be implemented by sub-classing 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/AbstractDeclarativeFormatter.java?root=Modeling_Project&amp;view=co">AbstractDeclarativeFormatter</ulink>, as shown in 
					the following example:
				</para>
				<literallayout><code>public class ExampleFormatter extends AbstractDeclarativeFormatter {

  @Override
  protected void configureFormatting(FormattingConfig c) {
    ExampleLanguageGrammarAccess f = getGrammarAccess();
    
    c.setAutoLinewrap(120);
    
    // find common keywords an specify formatting for them
    for (Pair&lt;Keyword, Keyword&gt; pair : f.findKeywordPairs("(", ")")) {
      c.setNoSpace().after(pair.getFirst());
      c.setNoSpace().before(pair.getSecond());
    }
    for (Keyword comma : f.findKeywords(",")) {
      c.setNoSpace().before(comma);
    }

    // formatting for grammar rule Line
    c.setLinewrap(2).after(f.getLineAccess().getSemicolonKeyword_1());
    c.setNoSpace().before(f.getLineAccess().getSemicolonKeyword_1());
    
    // formatting for grammar rule TestIndentation
    c.setIndentationIncrement().after(
        f.getTestIndentationAccess().getLeftCurlyBracketKeyword_1());
    c.setIndentationDecrement().before(
        f.getTestIndentationAccess().getRightCurlyBracketKeyword_3());
    c.setLinewrap().after(
        f.getTestIndentationAccess().getLeftCurlyBracketKeyword_1());
    c.setLinewrap().after(
        f.getTestIndentationAccess().getRightCurlyBracketKeyword_3());
    
    // formatting for grammar rule Param
    c.setNoLinewrap().around(f.getParamAccess().getColonKeyword_1());
    c.setNoSpace().around(f.getParamAccess().getColonKeyword_1());
    
    // formatting for Comments 
    cfg.setLinewrap(0, 1, 2).before(g.getSL_COMMENTRule());
    cfg.setLinewrap(0, 1, 2).before(g.getML_COMMENTRule());
    cfg.setLinewrap(0, 1, 1).after(g.getML_COMMENTRule());
  }
}

</code></literallayout>
				<para>The formatter has to implement the method 
					<emphasis>configureFormatting(...)</emphasis> which declaratively sets up 
					a 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/FormattingConfig.java?root=Modeling_Project&amp;view=co">FormattingConfig</ulink>.
				</para>
				<para>The 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/impl/FormattingConfig.java?root=Modeling_Project&amp;view=co">FormattingConfig</ulink> consist of general 
					settings and a set of formatting instructions:
				</para>
				<section id="GeneralFormattingConfigSettings">
					<title>General FormattingConfig Settings</title>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>setAutoLinewrap(int)</emphasis> defines the amount of characters after which a line-break should be dynamically inserted between two tokens. The instructions 
								<emphasis>setNoLinewrap().???()</emphasis>,  
								<emphasis>setNoSpace().???()</emphasis> and 
								<emphasis>setSpace(space).???()</emphasis> suppress this behavior locally. The default is 80.
							</para>
						</listitem>
					</itemizedlist>
				</section>
				<section id="FormattingConfigInstructions">
					<title>FormattingConfig Instructions</title>
					<para>Per default, the 
						<link linkend="declarativeformatter">declarative formatter</link> inserts one whitespace between two 
						tokens. Instructions can be used to specify a different behavior. They consist of two parts: 
						<emphasis>When</emphasis> 
						to apply the instruction and 
						<emphasis>what</emphasis> to do.
					</para>
					<para>To understand 
						<emphasis>when</emphasis> an instruction is applied think of a stream of tokens whereas each token is 
						associated with the corresponding grammar element. The instructions are matched against these grammar 
						elements. The following matching criteria exist:
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>after(ele)</emphasis>: The instruction is applied after the grammar element 
								<emphasis>ele</emphasis> has been matched. For example, if your grammar uses the keyword &#8222;;” to end lines, this can instruct the formatter to insert a line break after the semicolon.  
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>before(ele)</emphasis>: The instruction is executed before the matched element. For example, if your grammar contains lists which separate their values with the keyword &#8222;,”, you can instruct the formatter to suppress the whitespace before the comma.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>around(ele)</emphasis>: This is the same as 
								<emphasis>before(ele)</emphasis> combined with  
								<emphasis>after(ele)</emphasis>.  
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>between(ele1, ele2)</emphasis>: This matches if 
								<emphasis>ele2</emphasis> directly follows 
								<emphasis>ele1</emphasis> in the document. There may be no other tokens in between 
								<emphasis>ele1</emphasis> and 
								<emphasis>ele2</emphasis>.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>bounds(ele1, ele2)</emphasis>: This is the same as 
								<emphasis>after(ele1)</emphasis> combined with  
								<emphasis>before(ele2)</emphasis>.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>range(ele1, ele2)</emphasis>: The rule is enabled when 
								<emphasis>ele1</emphasis> is matched, and disabled when 
								<emphasis>ele2</emphasis> is matched. Thereby, the rule is active for the complete region which is surrounded by 
								<emphasis>ele1</emphasis> and 
								<emphasis>ele2</emphasis>.
							</para>
						</listitem>
					</itemizedlist>
					<para>The term 
						<emphasis>tokens</emphasis> is used slightly different here compared to the parser/lexer. Here, a token is a 
						keyword or the string that is matched by a terminal rule, data type rule or cross-reference. In the 
						terminology of the lexer a data type rule can match a composition of multiple tokens.
					</para>
					<para>The parameter 
						<emphasis>ele</emphasis> can be a grammar’s 
						<emphasis>AbstractElement</emphasis> or a grammar’s 
						<emphasis>AbstractRule</emphasis>. All grammar 
						rules and almost all abstract elements can be matched. This includes rule calls, parser rules, groups 
						and alternatives. The semantic of 
						<emphasis>before(ele)</emphasis>, 
						<emphasis>after(ele)</emphasis>, etc. for rule calls and parser rules is 
						identical to when the parser would &#8222;pass” this part of the grammar. The stack of called rules is taken 
						into account. The following abstract elements can 
						<emphasis role="bold">not</emphasis> have assigned formatting instructions:
					</para>
					<itemizedlist>
						<listitem>
							<para>Actions. E.g. 
								<emphasis>{MyAction}</emphasis> or 
								<emphasis>{MyAction.myFeature=current}</emphasis>.
							</para>
						</listitem>
						<listitem>
							<para>Grammar elements nested in data type rules. This is due to to the fact that tokens matched by a data type rule are treated as atomic by the serializer. To format these tokens, please implement a 
								<link linkend="valueconverter">ValueConverter</link>. 
							</para>
						</listitem>
						<listitem>
							<para>Grammar elements nested in 
								<emphasis>CrossReferences</emphasis>.
							</para>
						</listitem>
					</itemizedlist>
					<para>After having explained how rules can be activated, this is what they can do:</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>setIndentationIncrement()</emphasis> increments indentation by one unit at this position. Whether one unit consists of one tab-character or spaces is defined by 
								<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/formatting/IIndentationInformation.java?root=Modeling_Project&amp;view=co">IIndentationInformation</ulink>. The default implementation consults Eclipse’s 
								<emphasis>PreferenceStore</emphasis>.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>setIndentationDecrement()</emphasis> decrements indentation by one unit.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>setLinewrap()</emphasis>: Inserts a line-wrap at this position.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>setLinewrap(int count)</emphasis>: Inserts 
								<emphasis>count</emphasis> numbers of line-wrap at this position.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>setLinewrap(int min, int default, int max)</emphasis>: If the amount of line-wraps that have been at this position before formatting can be determined (i.g. when a node model is present), then the amount of of line-wraps is adjusted to be within the interval [
								<emphasis>min</emphasis>, 
								<emphasis>max</emphasis>] and is then reused. In all other cases 
								<emphasis>default</emphasis> line-wraps are inserted. Example: 
								<emphasis>setLinewrap(0, 0, 1)</emphasis> will preserve existing line-wraps, but won’t allow more than one line-wrap between two tokens.    
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>setNoLinewrap()</emphasis>: Suppresses automatic line wrap, which may occur when the line’s length exceeds the defined limit.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>setSpace(String space)</emphasis>: Inserts the string 
								<emphasis>space</emphasis> at this position. If you use this to insert something else than whitespace, tabs or newlines, a small puppy will die somewhere in this world.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>setNoSpace()</emphasis>: Suppresses the whitespace between tokens at this position. Be aware that between some tokens a whitespace is required to maintain a valid concrete syntax. 
							</para>
						</listitem>
					</itemizedlist>
				</section>
				<section id="GrammarElementFinders">
					<title>Grammar Element Finders</title>
					<para>Sometimes, if a grammar contains many similar elements for which the same formatting instructions ought 
						to apply, it can be tedious to specify them for each grammar element individually. The 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/IGrammarAccess.java?root=Modeling_Project&amp;view=co">IGrammarAccess</ulink> provides convenience methods for this. The 
						find methods are available for the grammar and for each parser rule.
					</para>
					<itemizedlist>
						<listitem>
							<para>
								<emphasis>findKeywords(String... keywords)</emphasis> returns all keywords that equal one of the parameters.
							</para>
						</listitem>
						<listitem>
							<para>
								<emphasis>findKeywordPairs(String leftKw, String rightKw)</emphasis>: returns tuples of keywords from the same grammar rule. Pairs are matched nested and sequentially.  Example: for 
								<emphasis>Rule: &#8218;(’ name=ID (&#8218;(’ foo=ID &#8218;)’) &#8218;)’ | &#8218;(’ bar=ID ')'</emphasis> 
								<emphasis>findKeywordPairs(&#8222;(”, &#8222;)”)</emphasis> returns three pairs.
							</para>
						</listitem>
					</itemizedlist>
				</section>
			</section>
			<section id="fragmentProvider">
				<title>Fragment Provider (Referencing Xtext Models From Other EMF Artifacts)</title>
				<para>Although inter-Xtext linking is not done by URIs, you may want to be able to reference your 
					<emphasis>EObject</emphasis> 
					from non-Xtext models. In those cases URIs are used, which are made up of a part identifying the resource 
					and a second part that points to an object. 
					Each 
					<emphasis>EObject</emphasis> contained in a resource can be identified by a so called 
					<emphasis>fragment</emphasis>.
				</para>
				<para>A fragment is a part of an EMF URI and needs to be unique per resource.</para>
				<para>The generic resource shipped with EMF provides a generic path-like computation of fragments. These 
					fragment paths are unique by default and do not have to be serialized. On the other hand, they can be 
					easily broken by reordering the elements in a resource. </para>
				<para>With an XMI or other binary-like serialization it is also common and possible to use UUIDs. UUIDs 
					are usually binary and technical, so you don’t want them in human readable representations.</para>
				<para>However with a textual concrete syntax we want to be able to compute fragments out of the human readable 
					information. We don’t want to force people to use UUIDs (i.e. synthetic identifiers) or fragile, relative, generic 
					paths in order to refer to 
					<emphasis>EObjects</emphasis>.
				</para>
				<para>Therefore one can contribute a so called 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/IFragmentProvider.java?root=Modeling_Project&amp;view=co">IFragmentProvider</ulink> 
					per language. It has two methods: 
					<emphasis>getFragment(EObject, Fallback)</emphasis> to calculate the fragment of an 

					<emphasis>EObject</emphasis> and 
					<emphasis>getEObject(Resource, String, Fallback)</emphasis> to go the opposite direction. The 
					<emphasis>Fallback</emphasis> 
					interface allows to delegate to the default strategy – usually the fragment paths described above. 
				</para>
				<para>The following snippet from the 
					<link linkend="gmf_integration">GMF Example</link> shows how to use qualified names as fragments:   
				</para>
				<literallayout><code>public QualifiedNameFragmentProvider implements IFragmentProvider {

  @Inject
  private IQualifiedNameProvider qualifiedNameProvider;

  public String getFragment(EObject obj, Fallback fallback) {
    String qualifiedName = qualifiedNameProvider.getQualifiedName(obj);
    return qualifiedName != null ? qualifiedName : fallback.getFragment(obj);
  }

  public EObject getEObject(Resource resource, 
                            String fragment, 
                            Fallback fallback) {
    if (fragment != null) {
      Iterator&lt;EObject&gt; i = EcoreUtil.getAllContents(resource, false);
      while(i.hasNext()) {
        EObject eObject = i.next();
        String candidateFragment = (eObject.eIsProxy()) 
            ? ((InternalEObject) eObject).eProxyURI().fragment()
            : getFragment(eObject, fallback);
        if (fragment.equals(candidateFragment)) 
          return eObject;
      }
    }
    return fallback.getEObject(fragment);
  }
}

</code></literallayout>
				<para>For performance reasons it is usually a good idea to navigate the resource based on the fragment 
					information instead of traversing it completely. If you know that your fragment is computed from 
					qualified names and your model contains something like 
					<emphasis>NamedElements</emphasis>, you should split your fragment
					into those parts and query the root elements, the children of the best match and so on.
				</para>
				<para>Furthermore it’s a good idea to have some kind of conflict resolution strategy to be able to distinguish
					between equally named elements that actually are different, e.g. properties may have the very same qualified
					name as entities. </para>
			</section>
		</section>
		<section id="encoding">
			<title>Encoding in Xtext</title>
			<para>
				<emphasis>Encoding</emphasis>, AKA 
				<emphasis>character set</emphasis>, describes the way characters are encoded into bytes and vice versa. 
				Famous standard encodings are &#8222;UTF-8” or &#8222;ISO-8859-1”. The list of available encodings can be determined
				by calling 
				<emphasis>java.nio.Charset.availableCharsets()</emphasis>. There is also a list of encodings and their 
				canonical Java names in the 
				<ulink url="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html">API docs</ulink>.
			</para>
			<para>Unfortunately, each platform and/or spoken language tends to define its own native encoding, 
				e.g. 
				<emphasis>Cp1258</emphasis> on Windows in Vietnamese or 
				<emphasis>MacIceland</emphasis> on Mac OS X in Icelandic. 
			</para>
			<para>In an Eclipse workspace, files, folders, projects can have individual encodings, which are stored
				in the hidden file 
				<emphasis>.settings/org.eclipse.core.resources.prefs</emphasis> in each project. If a resource does not have an 
				explicit encoding, it inherits the one from its parent recursively. Eclipse chooses the native
				platform encoding as the default for the workspace root. You can change the default workspace 
				encoding in the Eclipse preferences 
				<emphasis>Preferences-&gt;Workspace-&gt;Default text encoding</emphasis>. If you develop on
				different platforms, you should consider choosing an explicit common encoding for your text or code
				files, especially if you use special characters. 
			</para>
			<para>While Eclipse allows to define and inspect the encoding of a file, your file system usually doesn’t. 
				Given an arbitrary text file there is no general strategy to tell how it was encoded. If you deploy 
				an Eclipse project as a jar (even a plug-in), any encoding information not stored in the file itself 
				is lost, too. Some languages define the encoding of a file explicitly, as in the first processing 
				instruction of an XML file. Most languages don’t. Others imply a fixed encoding or offer enhanced 
				syntax for character literals, e.g. 
				<emphasis>\uXXXX</emphasis> in Java. 
			</para>
			<para>As Xtext is about textual modeling, it allows to tweak the encoding in various places.</para>
			<section id="EncodingatLanguageDesignTime">
				<title>Encoding at Language Design Time</title>
				<para>The plug-ins created by the 
					<emphasis>New Xtext Project</emphasis> wizard are by default encoded in the workspace’s standard
					encoding. The same holds for all files that Xtext generates in there.
					If you want to change that, e.g. because your grammar uses/allows special characters, you should manually 
					set the encoding in the properties of these projects after their creation. Do this before 
					adding special characters to your grammar or at least make sure the grammar reads correctly after the 
					encoding change. To tell the Xtext generator to generate files in the same encoding, set the encoding 
					property in the workflow next to your grammar, e.g.
				</para>
				<literallayout><code>Generator {
	encoding ="UTF-8"
	...

</code></literallayout>
			</section>
			<section id="EncodingatLanguageRuntime">
				<title>Encoding at Language Runtime</title>
				<para>As each language could handle the encoding problem differently, Xtext offers a service here. 
					The 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parser/IEncodingProvider.java?root=Modeling_Project&amp;view=co">IEncodingProvider</ulink> has a single method 

					<emphasis>getEncoding(URI)</emphasis> to define the encoding of the resource with the given URI. Users can implement 
					their own strategy but keep in mind that this is not intended to be a long running method. If the 
					encoding is stored within the model file itself, it should be extractable in an easy way, like from 
					the first line in an XML file. The default implementation returns the default Java character set 
					in the runtime scenario. 
				</para>
				<para>In the UI scenario, when there is a workspace, users will expect the encoding of the model files 
					to be settable the same way as for other files in the workspace. The default implementation 
					of the 
					<emphasis>IEncodingProvider</emphasis> in the UI scenario therefore returns the file’s workspace encoding 
					for files in the workspace and delegates to the runtime implementation for all other resources, 
					e.g. models in a jar or from a deployed plug-in. Keep in mind that you are going to loose the 
					workspace encoding information as soon as you leave this workspace, e.g. deploy your project.
				</para>
				<para>Unless you want to enforce a uniform encoding for all models of your language, we advise to 
					override the runtime service only. It is bound in the runtime module using the binding annotation 

					<emphasis>@Runtime</emphasis>:
				</para>
				<literallayout><code>@Override
public void configureRuntimeEncodingProvider(Binder binder) {
    binder.bind(IEncodingProvider.class)
          .annotatedWith(DispatchingProvider.Runtime.class)
          .to(MyEncodingProvider.class);
}

</code></literallayout>
				<para>For the uniform encoding, bind the plain 
					<emphasis>IEncodingProvider</emphasis> to the same implementation 
					in both modules:
				</para>
				<literallayout><code>@Override
public Class&lt;? extends IEncodingProvider&gt; bindIEncodingProvider() {
    return MyEncodingProvider.class;
}
	
	
</code></literallayout>
			</section>
			<section id="EncodingofanXtextResource">
				<title>Encoding of an XtextResource</title>
				<para>An 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java?root=Modeling_Project&amp;view=co">XtextResource</ulink> uses the 
					<emphasis>IEncodingProvider</emphasis> 
					of your language by default. You can override that by passing an option on load and save, e.g.
				</para>
				<literallayout><code>Map&lt;?,?&gt; options = new HashMap();
options.put(XtextResource.OPTION_ENCODING, "UTF-8");
myXtextResource.load(options);
options.put(XtextResource.OPTION_ENCODING, "ISO-8859-1");
myXtextResource.save(options);

</code></literallayout>
			</section>
			<section id="EncodinginNewModelProjects">
				<title>Encoding in New Model Projects</title>
				<para>The 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/projectWizard/SimpleProjectWizardFragment.java?root=Modeling_Project&amp;view=co">SimpleProjectWizardFragment</ulink> 
					generates a wizard that clients of your language can use to create model 
					projects. This wizard expects its templates to be in the encoding of the Generator that created it 
					(see above). As for every new project wizard, its output will be encoded in the default encoding of the 
					target workspace. 
				</para>
			</section>
			<section id="EncodingofXtextSourceCode">
				<title>Encoding of Xtext Source Code</title>
				<para>The source code of the Xtext framework itself is completely encoded in &#8222;ISO 8859-1”, which is necessary 
					to make the Xpand templates work everywhere (they use french quotation markup). That encoding is hard 
					coded into the Xtext generator code. You are likely never going to change that. </para>
			</section>
		</section>
	</chapter>
	<chapter id="MWE2">
		<title>MWE2</title>
		<para>The Modeling Workflow Engine 2 (MWE2) is a rewritten backwards 
			compatible implementation of the Modeling Workflow Engine (MWE). It 
			is a declarative, externally configurable generator engine. Users 
			can describe arbitrary object compositions by means of a simple, 
			concise syntax that allows to declare object instances, attribute 
			values and references. One use case – that’s where the name had its 
			origins – is the definition of workflows. Such a workflow consists 
			usually of a number of components that interact with each other. 
			There are components to read EMF resources, to perform 
			operations (transformations) on them and to write them back or to generate 
			any number of other artifacts out of the information. Workflows are 
			typically executed in a single JVM. However there are no constraints 
			the prevent implementors to provide components that spawn multiple 
			threads or new processes.</para>
		<section id="MWE2Exampe">
			<title>Examples</title>
			<para>Let’s start with a couple of examples to demonstrate some usage 
				scenarios for MWE2. The first examples is a simple 
				<emphasis>HelloWorld</emphasis> 
				module that does nothing but print a message to standard out. The 
				second module is assembled of three components that read an Ecore 
				file, transform the contained classifier-names to upper-case and 
				serialize the resource back to a new file. The last examples uses 
				the life-cycle methods to print the execution time of the workflow.
			</para>
			<section id="MWE2HelloWorld">
				<title>The Simplest Workflow</title>
				<para>The arguably shortest MWE2 module may look like the following 
					snippet.</para>
				<literallayout><code>module HelloWorld 

SayHello {
  message = "Hello World!"
}
</code></literallayout>
				<para>It configures a very simple workflow component with a message 
					that should be printed to 
					<emphasis>System.out</emphasis> when the workflow is 
					executed. The module begins with a declaration of its name. It must 
					fulfill the Java conventions for fully qualified class-names. That’s 
					why the module 
					<emphasis>HelloWorld</emphasis> has to be placed into the default 
					package of a Java source folder. The second element in the module is 
					the class-name 
					<emphasis>SayHello</emphasis> which introduces the root element of the 
					module. The interpreter will create an instance of the given 
					type and configure it as declared between the curly braces. E.g. the 
					assignment 
					<emphasis>message = "Hello World!"</emphasis> in the module will be 
					interpreted as an invocation of the 
					<emphasis>setMessage(String)</emphasis> on the 
					instantiated object. As one can easily imagine, the implementation 
					of the class 
					<emphasis>SayHello</emphasis> looks straight forward:
				</para>
				<literallayout><code>import org.eclipse.emf.mwe2.runtime.workflow.IWorkflowComponent;
import org.eclipse.emf.mwe2.runtime.workflow.IWorkflowContext;

public class SayHello implements IWorkflowComponent {

  private String message = "Hello World!";
  public void setMessage(String message) {
    this.message = message;
  }
  public String getMessage() {
    return message;
  }

  public void invoke(IWorkflowContext ctx) {
    System.out.println(getMessage());
  }

  public void postInvoke() {}
  public void preInvoke() {}
}
</code></literallayout>
				<para>It looks like a simple POJO and that’s the philosophy behind MWE2. 
					It is easily possible to assemble completely independent objects in 
					a declarative manner. To make the workflow executable with the 

					<emphasis>WorkflowRunner</emphasis>, the component 
					<emphasis>SayHello</emphasis> must be nested in a root 
					workflow:
				</para>
				<literallayout><code>module HelloWorld 

Workflow {
	component = SayHello {
		message = "Hello World!"
	}
}
</code></literallayout>
				<para>The class 
					<emphasis>Workflow</emphasis> is actually 

					<emphasis>org.eclipse.emf.mwe2.runtime.workflow.Workflow</emphasis> but its package is 
					implicitly imported in MWE2 modules to make the the modules more 
					concise. The execution result of this workflow will be revealed 
					after a quick 
					<emphasis>Run As .. -&gt; MWE2 Workflow</emphasis> in the console as 
				</para>
				<literallayout><code>Hello World!
</code></literallayout>
			</section>
			<section id="MWE2SimpleTransformation">
				<title>A Simple Transformation</title>
				<para>The following workflow solves the exemplary task to rename every 
					<emphasis>EClassifier</emphasis> in an 
					<emphasis>*.ecore</emphasis> file.
					It consists of three components that read, modify and write the model file:
				</para>
				<literallayout><code>module Renamer
Workflow {
  component = ResourceReader {
        uri = "model.ecore"
  }
  component = RenamingTransformer {}
  component = ResourceWriter {
        uri = "uppercaseModel.ecore"
  }
}
</code></literallayout>
				<para>The implementation of these components is surprisingly simple. It is easily possible to create
					own components even for minor operations to automate a process.</para>
				<para>The 
					<emphasis>ResourceReader</emphasis> simply reads the file with the given 
					<emphasis>URI</emphasis> and stores it in a so called

					<emphasis>slot</emphasis> of the workflow context. A slot can be understood as a dictionary or map-entry.
				</para>
				<literallayout><code>public class ResourceReader extends WorkflowComponentWithSlot {
  private String uri;
  public void invoke(IWorkflowContext ctx) {
    ResourceSet resourceSet = new ResourceSetImpl();
    URI fileURI = URI.createFileURI(uri); 
    Resource resource = resourceSet.getResource(fileURI, true);
    ctx.put(getSlot(), resource);
  }
	
  public void setUri(String uri) {
    this.uri = uri;
  }
  public String getUri() {
    return uri;
  }
}
</code></literallayout>
				<para>The actual transformer takes the model from the slot and modifies it. It simply iterates the content
					of the resource, identifies each 
					<emphasis>EClassifier</emphasis> and sets its name. 
				</para>
				<literallayout><code>public class RenamingTransformer extends WorkflowComponentWithSlot {
  private boolean toLowerCase = false;
  public void invoke(IWorkflowContext ctx) {
    Resource resource = (Resource) ctx.get(getSlot());
    EcoreUtil.resolveAll(resource);
    Iterator&lt;Object&gt; contents = EcoreUtil.getAllContents(resource, true);
    Iterator&lt;EClassifier&gt; iter = 
        Iterators.filter(contents, EClassifier.class);
    while(iter.hasNext()) {
      EClassifier classifier = (EClassifier) iter.next();
      classifier.setName(isToLowerCase() 
          ? classifier.getName().toLowerCase()
          : classifier.getName().toUpperCase());
    }
  }

  public void setToLowerCase(boolean toLowerCase) {
    this.toLowerCase = toLowerCase;
  }
  public boolean isToLowerCase() {
    return toLowerCase;
  }
}
</code></literallayout>
				<para>After the model has been modified it should be written to a new file. That’s what the 

					<emphasis>ResourceWriter</emphasis> does. It actually takes the resource from the given 
					<emphasis>slot</emphasis> and saves it with
					the configured 
					<emphasis>URI</emphasis>:
				</para>
				<literallayout><code>public class ResourceWriter extends WorkflowComponentWithSlot {
  private String uri;
  public void invoke(IWorkflowContext ctx) {
    Resource resource = (Resource) ctx.get(getSlot());
    URI uri = URI.createFileURI(getUri());
    uri = resource.getResourceSet().getURIConverter().normalize(uri);
    resource.setURI(uri);
    try {
      resource.save(null);
    } catch (IOException e) {
      throw new WrappedException(e);
    }
  }

  public void setUri(String uri) {
    this.uri = uri;
  }
  public String getUri() {
    return uri;
  }
}
</code></literallayout>
				<para>Last but not least, the common super-type for those components looks like this:</para>
				<literallayout><code>public abstract class WorkflowComponentWithSlot 
      implements IWorkflowComponent {
  private String slot = "model";
  public void setSlot(String slot) {
    this.slot = slot;
  }
  public String getSlot() {
    return slot;
  }
	
  public void postInvoke() {}
  public void preInvoke() {}
}
</code></literallayout>
				<para>Each of the mentioned implementations is rather simple and can be done in a couple of minutes. 
					This is true for many tedious tasks that developers face in their daily work. MWE2 can be used to
					automize these tasks with minimum effort.</para>
			</section>
			<section id="MWE2Stopwatch">
				<title>A Stopwatch</title>
				<para>The last example demonstrates how to combine the MWE2 concepts to create a simple stopwatch that
					allows to measure the execution time of a set of components. The idea is to add the very same stopwatch
					twice as a component to a workflow. It will measure the time from the first pre-invoke to the last
					post-invoke event and print the elapsed milliseconds to the console.</para>
				<literallayout><code>public class StopWatch implements IWorkflowComponent {
  private long start;
  private boolean shouldStop = false;
  public void invoke(IWorkflowContext ctx) {}

  public void postInvoke() {
    if (shouldStop) {
      long elapsed = System.currentTimeMillis() - start;
      System.out.println("Time elapsed: " + elapsed + " ms");
    }
    shouldStop = true;
  }

  public void preInvoke() {
    start = System.currentTimeMillis();
  }
}
</code></literallayout>
				<para>Clients who want to leverage this kind of stopwatch may use the following pattern. The stopwatch-instance 
					will be added as the first component and the last component to a workflow. Everything in between will
					be measured. In this case, it is another workflow that does not need know about this decoration. The idea
					is to use a local identifier for the instantiated 
					<emphasis>StopWatch</emphasis> and reuse this one at the end to receive
					the post-invoke life-cycle event twice. 
				</para>
				<literallayout><code>module MeasuredWorkflow

Workflow {
  component = StopWatch: stopWatch {}
  component = @OtherWorkflow {}
  component = stopWatch
}

</code></literallayout>
			</section>
		</section>
		<section id="MWE2LanguageReference">
			<title>Language Reference</title>
			<para>MWE2 has a few well defined concepts which can be combined to 
				assemble arbitrary object graphs in a compact and declarative 
				manner.</para>
			<itemizedlist>
				<listitem>
					<para>A MWE2 file defines a 
						<emphasis>module</emphasis> which exposes its root 
						<emphasis>component</emphasis> as reusable artifact.
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Properties</emphasis> can be used to extract reusable, configurable parts of the workflow.
					</para>
				</listitem>
				<listitem>
					<para>Components are mapped to plain vanilla 
						<emphasis>Java objects</emphasis>. Arbitrary 
						<emphasis>set- and add-methods</emphasis> are used to configure them.
					</para>
				</listitem>
			</itemizedlist>
			<para>Let’s consider the follow short example module and 
				<emphasis>SampleClass</emphasis> to 
				explain these concepts.
			</para>
			<literallayout><code>module com.mycompany.Example

import java.util.*

SampleClass {
  singleValue = 'a string'
  multiValue = ArrayList {}
  child = {}
} 

</code></literallayout>
			<literallayout><code>package com.mycompany;

import java.util.List;

public class SampleClass {
  public void setSingleValue(String value) {..}
  public void addMultiValue(List&lt;?&gt; value) {..}
  public void addChild(SampleClass value) {..}
}

</code></literallayout>
			<section id="MWE2JavaReferences">
				<title>Mapping to Java Classes</title>
				<para>The module 
					<emphasis>com.mycompany.Example</emphasis> defines a root component of 
					type 
					<emphasis>com.mycompany.SampleClass</emphasis>. It is possible to use the simple 
					class-name because MWE2 uses the very same visibility rules as the 
					Java compiler. Classes that are in the same package as the module 
					can be referenced by their simple name. The same rule applies for 
					classes from the 
					<emphasis>java.lang</emphasis> package. For convenience reasons is the 
					package 
					<emphasis>org.eclipse.emf.mwe2.runtime.workflow</emphasis> implicitly imported 
					as well as it exposes some library workflow components. However, the
					imports are more flexible then in Java since MWE2-imports can be relative, e.g. 
					the 
					<emphasis>import java.*</emphasis> resolves the reference 
					<emphasis>util.ArrayList</emphasis> to 

					<emphasis>java.util.ArrayList</emphasis>.  
				</para>
				<para>The root instance of type 
					<emphasis>SampleClass</emphasis> has to be configured 
					after it has been created. Therefore the method 
					<emphasis>setSingleValue</emphasis> 
					will be called at first. The given parameter is 

					<emphasis>'a string'</emphasis>. The method is identified by its name which starts with 

					<emphasis>set</emphasis>. To allow to assign multi-value properties, MWE provides 
					access to methods called 
					<emphasis>add*</emphasis> as well. 
				</para>
				<para>If the right side of the assignment in the workflow file does not 
					define a class explicitly, its type is inferred from the method 
					parameter. The line 
					<emphasis>child = {}</emphasis> is equivalent to 

					<emphasis>child = SampleClass {}</emphasis> and creates a new instance of 
					<emphasis>SampleClass</emphasis>.
				</para>
				<para>MWE2 ships with nice tool support. The editor will provide 
					content assist for the allowed types and highlight incompatible 
					assignments. The available properties for Java classes will be 
					proposed as well.</para>
			</section>
			<section id="MWE2Module">
				<title>Module </title>
				<para>As MWE2 modules have a fully qualified name, it is possible to refer
					to them from other modules. The type of the module is derived from
					the type of its root component. The 
					<emphasis>com.mycompany.Example</emphasis> can be
					assigned at any place where a 
					<emphasis>com.mycompany.SampleClass</emphasis> is expected.
				</para>
				<para>Let’s create a second module 
					<emphasis>com.mycompany.Second</emphasis> like this:
				</para>
				<literallayout><code>module com.mycompany.sub.Second

import com.mycompany.*

SampleClass {
  child = @Example {}
} 
</code></literallayout>
				<para>The 
					<emphasis>child</emphasis> value will be assigned to an instance of 
					<emphasis>SampleClass</emphasis> 
					that is configured as in the first example workflow. This enables
					nice composition and a very focused, reusable component design. 
				</para>
				<para>As the same rules apply in MWE2 like in Java, the module 

					<emphasis>com.mycompany.sub.Second</emphasis> has to be defined in a file called 

					<emphasis>Second.mwe2</emphasis> in the package 
					<emphasis>com.mycompany.sub</emphasis>. The import semantic
					for other modules is the same as for classes. The import statement
					allows to refer to 
					<emphasis>com.mycompany.Example</emphasis> with a shortened name.
				</para>
			</section>
			<section id="MWE2Properties">
				<title>Properties</title>
				<para>MWE2 allows to extract arbitrary information into properties to 
					ensure that these pieces are not cluttered around the workflow and 
					to allow for easier external customization. The exemplary component 
					definition was only changed slightly by introducing a property 

					<emphasis>value</emphasis>.
				</para>
				<literallayout><code>module com.mycompany.Example

var value = 'a string'

SampleClass {
  singleValue = value
}
</code></literallayout>
				<para>The type of the property will be derived from the default value 
					similar to the mechanism that is already known from 
					<emphasis>set</emphasis>- and 

					<emphasis>add</emphasis>-methods. If no default value is given, 
					<emphasis>java.lang.String</emphasis> will
					be assumed. However, properties are not limited to strings. The 
					second built in type is boolean via the familiar literals 
					<emphasis>true</emphasis> and

					<emphasis>false</emphasis>. More flexibility is available via actual component literals.
				</para>
				<literallayout><code>module com.mycompany.Example

var childInstance = SampleClass {
                      singleValue = "child"
                    }

SampleClass {
  child = childInstance
}
</code></literallayout>
				<para>If one wants to define string properties that are actual reusable
					parts for other properties, she may use defined variables inside other
					literals like this: </para>
				<literallayout><code>var aString = "part"
var anotherString = "reuse the ${part} here"
</code></literallayout>
				<para>This is especially useful for file paths in workflows as one would
					usually want to define some common root directories only ones in the
					workflow and reuse this fragment across certain other file locations.</para>
			</section>
			<section id="MWE2Mandatory">
				<title>Mandatory Properties</title>
				<para>It is not always feasible to define default values for properties. 
					That is where mandatory properties come into play. Modules define their
					interface not only via their fully qualified name and the type of the
					root component but also by means of the defined properties.    </para>
				<literallayout><code>module com.mycompany.Example

var optional = 'a string'
var mandatory

SampleClass {
  singleValue = optional
  child = {
    singleValue = mandatory
  }
}
</code></literallayout>
				<para>This version of the example module exposes two externally assignable
					properties. The second one has no default value assigned and is 
					thereby considered to be mandatory. The mandatory value must be assigned
					if we reuse 
					<emphasis>org.mycompany.Example</emphasis> in another module like this:
				</para>
				<literallayout><code>module com.mycompany.Second

var newMandatory

@Example {
  mandatory = "mandatoryValue"
  optional = newMandatory
} 
</code></literallayout>
				<para>Note that it is even possible to reuse another module as the root
					component of a new module. In this case we set the mandatory 
					property of 
					<emphasis>Example</emphasis> to a specific constant value while the previously
					optional value is now redefined as mandatory by means of a new property
					without a default value.
				</para>
				<para>It is not only possible to define mandatory properties for MWE2 
					modules but for classes as well. Therefore MWE2 ships with the 

					<emphasis>@Mandatory</emphasis> annotation. If a 
					<emphasis>set</emphasis>- or 
					<emphasis>add</emphasis>-method is marked as

					<emphasis>mandatory</emphasis>, the module validation will fail if no value was assigned
					to that feature.
				</para>
			</section>
			<section id="MWE2NamedComponents">
				<title>Named Components</title>
				<para>Properties are not the only way to define something that can be reused.
					It is possible to assign a name to any instantiated component whether it’s
					created from a class literal or from another component. This allows
					to refer to previously created and configured instances. Named instances
					can come handy for notification and call-back mechanisms or more general
					in terms of defined life-cycle events. </para>
				<para>If we wanted to assign the created instance to a property of itself,
					we could use the following syntax:</para>
				<literallayout><code>module com.mycompany.Example

SampleClass : self {
  child = self
}
</code></literallayout>
				<para>A named component can be referenced immediately after its creation but
					it is not possible to define forward references in a MWE2 file.</para>
			</section>
			<section id="MWE2AutoInject">
				<title>Auto Injection</title>
				<para>Existing modules or classes often expose a set of properties that 
					will be assigned to features of its root component or set- and add- 
					methods respectively. In many cases its quite hard to come up with 
					yet another name for the very same concept which leads to the situation
					where the properties itself have the very same name as the component’s
					feature. To avoid the overall repetition of assignments, MWE2 offers
					the possibility to use the 
					<emphasis>auto-inject</emphasis> modifier on the component 
					literal:
				</para>
				<literallayout><code>module com.mycompany.Example

var child = SampleClass {}

SampleClass auto-inject {
}
</code></literallayout>
				<para>This example will implicitly assign the value of the property

					<emphasis>child</emphasis> to the feature 
					<emphasis>child</emphasis> of the root component. This is especially
					useful for highly configurable workflows that expose dozens of optional
					parameters each of which can be assigned to one or more components.
				</para>
				<para>The 
					<emphasis>auto-inject</emphasis> modifier can be used for a subset of the available
					features as well. It will suppressed for the explicitly set values
					of a component.        
				</para>
			</section>
		</section>
		<section id="MWE2SyntaxReference">
			<title>Syntax Reference</title>
			<para>The following chapter serves as a reference for the concrete syntax of 
				MWE2. The building blocks of a module will be described in a few words.</para>
			<para>MWE2 is not sensitive to white-space and allows to define line-comments
				and block comments everywhere. The syntax is the same as one is used 
				to from the Java language:</para>
			<literallayout><code>// This is a comment
/* 
  This is another one.
*/
</code></literallayout>
			<para>Every name in MWE2 can be a fully qualified identifier and must follow 
				the Java conventions. However, in contrast to Java identifiers it is 
				not allowed to use German umlauts or Unicode escape sequences in 
				identifiers. A valid ID-segment in MWE2 starts with a letter or an 
				underscore and is followed by any number of letters, numbers or underscores.
				An identifier is composed from one or more segments which are delimited
				by a &#8218;.’ dot.</para>
			<literallayout><code>Name: ID ('.' ID)*;
ID: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*; 
</code></literallayout>
			<para>MWE2 does not use a semicolon as statement delimiter at any place.</para>
			<section id="MWE2ModuleSyntax">
				<title>Module</title>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/mwe2/module.png" scale="50"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>A 
					<emphasis>module</emphasis> consists of four parts. The very first statement in a 

					<emphasis>*.mwe2</emphasis> file is the module declaration. The name of the module must 
					follow the naming convention for Java classes. That MWE2 file’s name 
					must therefore be the same as the last segment of the module-name 
					and it has to be placed in the appropriate package of a Java source 
					path.
				</para>
				<para>It is allowed to define any number of import statements in a module.
					Imports are either suffixed by a wild-card or concrete for a class 
					or module. MWE2 can handle relative imports in case one uses the 
					wild-card notation:</para>
				<literallayout><code>'import' name '.*'?   

</code></literallayout>
			</section>
			<section id="MWE2PropertySyntax">
				<title>Property</title>
				<para>The list of declared properties follows the optional import section.
					It is allowed to define modules without any properties. </para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/mwe2/property.png" scale="50"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>Each declared property is locally visible in the module. It 
					furthermore defines an assignable feature of the module in case one 
					refers to it from another module. Properties may either have a 
					default value or they are considered to be mandatory. If the type
					of property is omitted it will be inferred from the default value. The
					default type of a property is 
					<emphasis>java.lang.String</emphasis> so if no default
					value is available, the property is mandatory and of type 
					<emphasis>String</emphasis>.
				</para>
				<para>There are four types of values available in MWE2. One may either
					define a string, boolean or component literal or a reference to a
					previously defined property. </para>
			</section>
			<section id="MWE2ComponentSyntax">
				<title>Component</title>
				<para>The last part of a module is the root component. It defines the externally
					visible type of the module and may either be created from a Java 
					type or from another module.</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/mwe2/component.png" scale="50"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>The type of the component can be derived in many cases except for 
					the root component. That’s why it’s optional in the component literal.
					If no type is given, it will be inferred from the left side of the
					assignment. The assigned feature can either be a declared property
					of the module or a 
					<emphasis>set</emphasis>- or 
					<emphasis>add</emphasis>-method of a Java class.
				</para>
				<para>Components can be named to make them referable in subsequent assignments.
					Following the 
					<emphasis>':'</emphasis> keyword, one can define an identifier for the 
					instantiated component. The identifier is locally visible in the module
					and any assignment that is defined after the named component can refer
					to this identifier and thereby point to exactly the instantiated object.
				</para>
				<para>The next option for a component is 
					<emphasis>auto-inject</emphasis>. If this modifier
					is set on a component, any available feature of the component that has
					the same name as a property or previously created named component will
					be automatically assigned.
				</para>
				<para>The core of a component is the list of assignments between the curly 
					braces. An arbitrary number of values can be set on the component by
					means of feature-to-value pairs. </para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/mwe2/assignment.png" scale="50"/>
						</imageobject>
					</mediaobject> 
				</para>
				<para>The available constructs on the right hand side of the assignment
					are the same as for default values for properties. </para>
			</section>
			<section id="MWE2StringLiteralsSyntax">
				<title>String Literals</title>
				<para>String values are likely to be the most used literals in MWE2. There 
					is a convenient syntax for string concatenation available due to
					the high relevance in a description object composition and configuration 
					language. MWE2 strings are multi-line strings and can be composed of
					several parts.</para>
				<literallayout><code>var aString = 'a value'
var anotherString = 'It is possible to embed ${aString} into
 a multi-line string'
</code></literallayout>
				<para>This is especially convenient for path-substitution if one defines
					e.g. a common root directory and wants to specify other paths relative
					to the base. </para>
				<para>There are two different delimiters available for strings. Users 
					are free to either use single- or double-quotes to start and end strings. 
					If a certain string contains a lot of single-quotes one would better
					choose double-quotes as delimiter and vice versa. There is no semantic 
					difference between both notations.</para>
				<para>The escape character in MWE2 is the back-slash 
					<emphasis>"\"</emphasis>. It can be used
					to write line-breaks or tabular characters explicitly and to escape
					the beginning of substitution variables 
					<emphasis>${</emphasis> and the quotes itself. Allowed
					escape sequences are:
				</para>
				<literallayout><code>\n  .. line break
\r  .. carriage return
\t  .. tabular character
\'  .. single-quote (can be omitted in double-quoted strings)
\"  .. double-quote (can be omitted in single-quoted strings)
\${ .. escape the substitution variable start ${
\\  .. the back-slash itself
</code></literallayout>
				<para>Other escape sequence are illegal in MWE2 strings.</para>
			</section>
			<section id="MWE2BooleanLiterals">
				<title>Boolean Literals</title>
				<para>MWE2 has native support for the boolean type. The literals are 
					<emphasis>true</emphasis> and 
					<emphasis>false</emphasis>.
				</para>
			</section>
			<section id="MWE2References">
				<title>References</title>
				<para>Each assigned value in MWE2 either as default for properties or in a
					component assignment can be a reference to a previously declared property
					or named component. The can be referenced intuitively by their name.</para>
			</section>
		</section>
	</chapter>
	<chapter id="ide_concepts">
		<title>IDE Concepts</title>
		<para>For the following part we will refer to a concrete example grammar in order to explain certain aspect 
			of the UI more clearly. The used example grammar is as follows:</para>
		<literallayout><code>grammar org.eclipse.text.documentation.Sample 
    with org.eclipse.xtext.common.Terminals

generate gen 'http://www.eclipse.org/xtext/documentation/Sample'

Model :
  "model" intAttribute=INT (stringDescription=STRING)? "{" 
     (rules += AbstractRule)* 
  "}" 
;

AbstractRule:
  RuleA | RuleB
;

RuleA :
   "RuleA" "(" name = ID ")" ;

RuleB return gen::CustomType:
   "RuleB" "(" ruleA = [RuleA] ")" ;

</code></literallayout>
		<para></para>
		<section id="labelProvider">
			<title>Label Provider</title>
			<para>There are various places in the UI in which model elements have to be presented to the user: In the 

				<link linkend="outline">outline view</link>, in 
				<link linkend="hyperlinking">hyper links</link>, in 
				<link linkend="contentAssist">content proposals</link>, 
				find dialogs etc. Xtext allows to customize each of these appearances by individual 
				<emphasis>ILabelProviders</emphasis>. 
			</para>
			<para>An 
				<emphasis>ILabelProvider</emphasis> has two methods: 
				<emphasis>getText(Object)</emphasis> returns the text in an object’s label, 
				while 
				<emphasis>getImage(Object)</emphasis> returns the icon. In addition, the Eclipse UI framework offers the 

				<emphasis>IStyledLabelProvider</emphasis>, which returns a styled string (i.e. with custom fonts, colors etc.) in the 

				<emphasis>getStyledText(Object)</emphasis> method. 
			</para>
			<para>Almost all label providers in the Xtext framework inherit from the base class 

				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/label/AbstractLabelProvider.java?root=Modeling_Project&amp;view=co">AbstractLabelProvider</ulink> which unifies both 
				approaches. Subclasses can either return a styled string or a string in the 
				<emphasis>doGetText(Object)</emphasis> method. 
				The framework will automatically convert it to a styled text (with default styles) or to a plain text 
				in the respective methods. 
			</para>
			<para>Dealing with images can be cumbersome, too, as image handles tend to be scarce system resources. 
				The 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/label/AbstractLabelProvider.java?root=Modeling_Project&amp;view=co">AbstractLabelProvider</ulink> helps you managing 
				the images: In your implementation of 
				<emphasis>doGetImage(Object)</emphasis> you can as well return an 
				<emphasis>Image</emphasis> or a string, 
				representing a path in the 
				<emphasis>icons/</emphasis> folder of the containing plug-in. This path is actually 
				configurable by Google Guice. Have a look at the 

				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/PluginImageHelper.java?root=Modeling_Project&amp;view=co">PluginImageHelper</ulink> to learn about the 
				customizing possibilities.
			</para>
			<para>If you have the 

				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/labeling/LabelProviderFragment.java?root=Modeling_Project&amp;view=co">LabelProviderFragment</ulink> in the 
				list of generator fragments in the MWE2 workflow for your language, it will automatically create 
				stubs and bindings for an 
				<link linkend="EObjectLabelProvider">
					<emphasis>EObjectLabelProvider</emphasis>
				</link> and an 

				<link linkend="DescriptionLabelProvider">
					<emphasis>DescriptionLabelProvider</emphasis>
				</link> which you can implement by manually. 
			</para>
			<section id="EObjectLabelProvider">
				<title>Label Providers For EObjects</title>
				<para>The first set of label providers refers to actually loaded and thereby available model elements. 
					By default, Xtext binds the 
					<emphasis>DefaultEObjectLabelProvider</emphasis> to all use cases, but you can change the 
					binding individually for the Outline, Content Assist or other places. For that purpose, there is a 
					so called 
					<emphasis>binding annotation</emphasis> for each use case. For example, to use a custom 

					<emphasis>MyContentAssistLabelProvider</emphasis> to display elements in the content assist, you have to override
				</para>
				<literallayout><code>@Override
public void configureContentProposalLabelProvider(Binder binder) {
  binder.bind(ILabelProvider.class)
    .annotatedWith(ContentProposalLabelProvider.class)
    .to(MyContentAssistLabelProvider.class);
}

p.in your language's UI module. 

</code></literallayout>
				<para>If your grammar uses an imported 
					<emphasis>EPackage</emphasis>, there may be an existing 
					<emphasis>.edit</emphasis> plug-in generated 
					by EMF that also provides label providers for model elements. To use this as a fallback, your label 
					provider should call the constructor with the 
					delegate parameter and use DI for the initialization, e.g.
				</para>
				<literallayout><code>public class MyLabelProvider {
	@Inject	
	public MyLabelProvider(AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}
	...
}  

</code></literallayout>
				<section id="DefaultEObjectLabelProvider">
					<title>DefaultEObjectLabelProvider</title>
					<para>The default implementation of the 
						<emphasis>LabelProvider</emphasis> interface utilizes the polymorphic dispatcher idiom 
						to implement an external visitor as the requirements of the LabelProvider are kind of a best match for 
						this pattern. It comes down to the fact that the only thing you need to do is to implement a method 
						that matches a specific signature. It either provides a image filename or the text to be used to 
						represent your model element. Have a look at following example to get a more detailed idea about 
						the 
						<emphasis>DefaultEObjectLabelProvider</emphasis>.
					</para>
					<literallayout><code>public class SampleLabelProvider extends DefaultLabelProvider {

  String text(RuleA rule) {
    return "Rule: " + rule.getName();
  }
  
  String image(RuleA rule) {
    return "ruleA.gif";
  }
  
  String image(RuleB rule) {
    return "ruleB.gif";
  }
}
	
</code></literallayout>
					<para>What is especially nice about the default implementation is the actual reason for its class 
						name: It provides very reasonable defaults. To compute the label for a certain model element, it will 
						at first have a look for an EAttribute 
						<emphasis>name</emphasis> and try to use this one. If it cannot find such a feature, 
						it will try to use the first feature, that can be used best as a label. At worst it will return the 
						class name of the model element, which is kind of unlikely to happen.
					</para>
					<para>You can a also customize error handling by overriding the methods 
						<emphasis>handleTextError()</emphasis> or 

						<emphasis>handleImageError()</emphasis>.
					</para>
				</section>
			</section>
			<section id="DescriptionLabelProvider">
				<title>Label Providers For Index Entries</title>
				<para>Xtext maintains an index of all model elements to allow quick searching and linking without loading 
					the referenced resource (See the chapter on 
					<link linkend="index_based">index-based scopes</link> for details). The 
					elements from this index also appear in some UI contexts, e.g. in the 
					<emphasis>Find model elements</emphasis> dialog or 
					in the 
					<emphasis>Find references</emphasis> view. For reasons of scalability, the UI should not automatically load 
					resources, so we need another implementation of a label provider that works with the elements from the 
					index, i.e. 
					<emphasis>IResourceDescription</emphasis>, 
					<emphasis>IEObjectDescription</emphasis>, and 
					<emphasis>IReferenceDescription</emphasis>.
				</para>
				<para>The default implementation of this service is the 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/label/DefaultDescriptionLabelProvider.java?root=Modeling_Project&amp;view=co">DefaultDescriptionLabelProvider</ulink>. It employs the 
					same polymorphic dispatch mechanism as the 
					<link linkend="DefaultEObjectLabelProvider">DefaultEObjectLabelProvider</link>. 
					The default text of an 
					<emphasis>EObjectDescription</emphasis> is its indexed name. The image is resolved by dispatching 
					to 
					<emphasis>image(EClass)</emphasis> with the 
					<emphasis>EClass</emphasis> of the described object. This is likely the only method you want 
					to override. 
					<emphasis>IResourceDescriptions</emphasis> will be represented with their path and the icon registered for 
					your language’s editor. 
				</para>
				<para>To have a custom description label provider, make sure it is bound in your UI module:</para>
				<literallayout><code>public void configureResourceUIServiceLabelProvider(Binder binder) {
  binder.bind(ILabelProvider.class)
    .annotatedWith(ResourceServiceDescriptionLabelProvider.class)
    .to(MyCustomDefaultDescriptionLabelProvider.class);
}
</code></literallayout>
			</section>
		</section>
		<section id="contentAssist">
			<title>Content Assist</title>
			<para>The Xtext generator, amongst other things, generates the following two content assist (CA) related artifacts:</para>
			<itemizedlist>
				<listitem>
					<para>an abstract proposal provider class named 
						<emphasis>Abstract[Language]ProposalProvider</emphasis> generated into the 
						<emphasis>src-gen</emphasis> folder within the 
						<emphasis>ui</emphasis> project
					</para>
				</listitem>
				<listitem>
					<para>a concrete sub-class in the 
						<emphasis>src</emphasis>-folder of the 
						<emphasis>ui</emphasis> project called 
						<emphasis>ProposalProvider</emphasis>
					</para>
				</listitem>
			</itemizedlist>
			<para>First we will investigate the generated 
				<emphasis>Abstract[Language]ProposalProvider</emphasis> with methods that look like this:
			</para>
			<section id="ProposalProvider">
				<title>ProposalProvider</title>
				<literallayout><code>public void complete[TypeName]_[FeatureName](
  EObject model, 
  Assignment assignment, 
  ContentAssistContext context, 
  ICompletionProposalAcceptor acceptor) {
  // clients may override
}

public void complete_[RuleName](
  EObject model, 
  RuleCall ruleCall, 
  ContentAssistContext context, 
  ICompletionProposalAcceptor acceptor) {
  // clients may override
}

</code></literallayout>
				<para>The snippet above indicates that the generated ProposalProvider class contains a 
					<emphasis>complete*</emphasis>-method 
					for each assigned feature in the grammar and for each rule. The brackets are place-holders that should 
					give a clue about the naming scheme used to create the various entry points for clients. The generated 
					proposal provider falls back to some default behavior for cross-references and keywords. Furthermore 
					it inherits the logic that was introduced in reused grammars. 
				</para>
				<para>Clients who want to customize the behavior may override the methods from the 

					<emphasis>AbstractProposalProvider</emphasis> or introduce new methods with a specialized first parameter. The framework 
					dispatches method calls according to the current context to the most concrete implementation, that 
					can be found.
				</para>
				<para>It is important to know, that for a given offset in a model file, many possible grammar elements exist. 
					The framework dispatches to the method declarations for any valid element. That means, that a bunch 
					of 
					<emphasis>complete*</emphasis> methods may be called.
				</para>
			</section>
			<section id="SampleImplementation">
				<title>Sample Implementation</title>
				<para>To provide a dummy proposal for the description of a model object, you may introduce a specialization 
					of the generated method and implement it as follows. This will give &#8218;Description for model #7’ for a 
					model with the intAttribute '7'</para>
				<literallayout><code>public void completeModel_StringDescription (
  Model model, 
  Assignment assignment, 
  ContentAssistContext context, 
  ICompletionProposalAcceptor acceptor) {
  // call implementation in superclass
  super.completeModel_StringDescription(
    model, 
    assignment, 
    context, 
    acceptor);

  // compute the plain proposal
  String proposal = "Description for model #" + model.getIntAttribute();

  // convert it to a valid STRING-terminal
  proposal = getValueConverter().toString(proposal, "STRING");

  // create the completion proposal
  // the result may be null as the createCompletionProposal(..) methods 
  // check for valid prefixes
  // and terminal token conflicts
  ICompletionProposal completionProposal = 
    createCompletionProposal(proposal, context);

  // register the proposal, the acceptor handles null-values gracefully
  acceptor.accept(completionProposal);
}

</code></literallayout>
			</section>
		</section>
		<section id="quickfixes">
			<title>Quick Fixes</title>
			<para>For validations written using the 
				<link linkend="custom_validation">AbstractDeclarativeValidator</link> 
				it is possible to provide corresponding quick fixes in the editor. To be able to implement a quick fix 
				for a given diagnostic (a warning or error) the underlying 
				<emphasis>cause</emphasis> of the diagnostic must be known 
				(i.e. what actual problem does the diagnostic represent?), otherwise the fix doesn’t know what needs 
				to be done. As we don’t want to deduce this from the diagnostic’s error message we associate a problem 
				specific 
				<emphasis>code</emphasis> with the diagnostic.
			</para>
			<para>In the following example taken from the 
				<emphasis>DomainmodelJavaValidator</emphasis> 
				the diagnostic’s 
				<emphasis>code</emphasis> is given by the third argument to the 
				<emphasis>warning()</emphasis> method and it is a reference 
				to the static 
				<emphasis>String</emphasis> field _==INVALID_TYPE_NAME==_ in the validator class.
			</para>
			<literallayout><code>warning("Name should start with a capital", 
    DomainmodelPackage.TYPE__NAME, INVALID_TYPE_NAME, type.getName());

</code></literallayout>
			<para>Now that the validation has a unique code identifying the problem we can register quick fixes for it. 
				We start by adding the 

				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/quickfix/QuickfixProviderFragment.java?root=Modeling_Project&amp;view=co">QuickfixProviderFragment</ulink> 
				to our workflow and after regenerating the code we should find an empty class 
				<emphasis>MyDslQuickfixProvider</emphasis> 
				in our DSL’s UI project and new entries in the _==plugin.xml_gen==_ file.
			</para>
			<para>Continuing with the _==INVALID_TYPE_NAME==_ problem from the Domainmodel example we add a method with which 
				the problem can be fixed (have a look at the 
				<emphasis>DomainmodelQuickfixProvider</emphasis> for details):
			</para>
			<literallayout><code>@Fix(DomainmodelJavaValidator.INVALID_TYPE_NAME)
public void fixName(final Issue issue, IssueResolutionAcceptor acceptor) {
  acceptor.accept(issue, 
    "Capitalize name", // quick fix label
    "Capitalize name  of '" + issue.getData()[0] + "'",  // description 
    "upcase.png",      // quick fix icon
    new IModification() {
      public void apply(IModificationContext context) 
                                             throws BadLocationException {
        IXtextDocument xtextDocument = context.getXtextDocument();
        String firstLetter = xtextDocument.get(issue.getOffset(), 1);
        xtextDocument.replace(issue.getOffset(), 1, 
                              Strings.toFirstUpper(firstLetter));
      }
    }
  );
}

</code></literallayout>
			<para>By using the correct signature (see below) and annotating the method with the 
				<emphasis>@Fix</emphasis> annotation 
				referencing the previously specified issue code from the validator, Xtext knows that this method 
				implements a fix for the problem. This also allows us to annotate multiple methods as fixes for the 
				same problem.
			</para>
			<para>The first three parameters given to the 

				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/quickfix/IssueResolutionAcceptor.java?root=Modeling_Project&amp;view=co">IssueResolutionAcceptor</ulink> define the 
				UI representation of the quick fix. As the document is not necessarily loaded when the quick fix is 
				offered, we need to provide any additional data from the model that we want to refer to in the UI 
				when creating the issue in the validator above. In this case, we provided the existing type name. 
				The additional data is available as 
				<emphasis>Issue.getData()</emphasis>. As it is persisted in markers, only strings 
				are allowed. 
			</para>
			<para>The actual model modification is implemented in the 

				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/model/edit/IModification.java?root=Modeling_Project&amp;view=co">IModification</ulink>. 
				The 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/model/edit/IModificationContext.java?root=Modeling_Project&amp;view=co">IModificationContext</ulink> provides 
				access to the erroneous document. In this case, we’re using Eclipse’s 
				<emphasis>IDocument</emphasis> API to replace a 
				text region.    
			</para>
			<para>If you prefer to implement the quick fix in terms of the semantic model use a 

				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/model/edit/ISemanticModification.java?root=Modeling_Project&amp;view=co">ISemanticModification</ulink> instead. 
				Its 
				<emphasis>apply(EObject, IModificationContext)</emphasis> method will be invoked inside a modify-transaction and the 
				first argument will be the erroneous semantic element. This makes it very easy for the fix method to 
				modify the model as necessary. After the method returns the model as well as the Xtext editor’s content 
				will be updated accordingly. If the method fails (throws an exception) the change will not be committed. 
				The following snippet shows a semantic quick fix for a similar problem.
			</para>
			<literallayout><code>@Fix(DomainmodelJavaValidator.INVALID_FEATURE_NAME)
public void fixFeatureName(final Issue issue, 
                           IssueResolutionAcceptor acceptor) {
  acceptor.accept(issue, 
    "Uncapitalize name",    // label
    "Uncapitalize name of '" + issue.getData()[0] + "'", // description
    "upcase.png",           // icon 
    new ISemanticModification() {
      public void apply(EObject element, IModificationContext context) {
        ((Feature) element).setName(
            Strings.toFirstLower(issue.getData()[0]));
      }
    }
  );
}

</code></literallayout>
			<section id="QuickfixesforLinkingErrorsandSyntaxErrors">
				<title>Quickfixes for Linking Errors and Syntax Errors</title>
				<para>You can even define quick fixes for linking errors. The issue codes are assigned by the 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/linking/ILinkingDiagnosticMessageProvider.java?root=Modeling_Project&amp;view=co">ILinkingDiagnosticMessageProvider</ulink>. Have a look at the domain model example how to add quick fixes for these errors.
				</para>
				<para>Analogously, there is the 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/parser/antlr/ISyntaxErrorMessageProvider.java?root=Modeling_Project&amp;view=co">ISyntaxErrorMessageProvider</ulink> to assign issue codes to syntactical errors.
				</para>
			</section>
		</section>
		<section id="templates">
			<title>Template Proposals</title>
			<para>Xtext-based editors automatically support code templates. That means that you get the corresponding 
				preference page where users can add and change template proposals. If you want to ship a couple of 
				default templates, you have to put a file named 
				<emphasis>templates.xml</emphasis> inside the 
				<emphasis>templates</emphasis> directory of 
				the generated UI-plug-in. This file contains templates in a format as described in the 

				<ulink url="http://help.eclipse.org/ganymede/topic/org.eclipse.cdt.doc.user/tasks/cdt_t_imp_code_temp.htm">Eclipse online help</ulink> .
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/preferences_templates.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>By default Xtext registers 
				<emphasis>ContextTypes</emphasis> for each rule (
				<emphasis>.[RuleName]</emphasis>) and for each 
				keyword (
				<emphasis>.kw</emphasis>[keyword]_). If you don’t 
				like these defaults you’ll have to subclass 

				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/templates/XtextTemplateContextTypeRegistry.java?root=Modeling_Project&amp;view=co">XtextTemplateContextTypeRegistry</ulink> 
				and configure it via 
				<link linkend="guicemodules">Guice</link>. 
			</para>
			<para>In addition to the standard template proposal extension mechanism, Xtext ships with a predefined set 
				of 
				<emphasis>TemplateVariableResolvers</emphasis> to resolve special variable types inside a given template 
				(i.e. 
				<emphasis>TemplateContext</emphasis>). Besides the standard template variables available in 

				<emphasis>org.eclipse.jface.text.templates.GlobalTemplateVariables</emphasis> like 
				<emphasis>${user}</emphasis>, 
				<emphasis>${date}</emphasis>, 
				<emphasis>${time}</emphasis>, 

				<emphasis>${cursor}</emphasis>, etc., these 
				<emphasis>TemplateVariableResolver</emphasis> support the automatic resolving of 
				CrossReferences (type 
				<emphasis>CrossReferences</emphasis>) and Enumerations (type 
				<emphasis>Enum</emphasis>) like it is explained in the 
				following sections.
			</para>
			<para>It is best practice to edit the templates in the preferences page, export them into the 

				<emphasis>templates.xml</emphasis>-file and put this one into the 
				<emphasis>templates</emphasis> folder of your UI-plug-in. However, these 
				templates will not be visible by default. To fix it, you have to manually edit the xml-file and insert 
				an ID attribute for each template element.
			</para>
			<section id="CrossReferenceTemplateVariableResolver">
				<title>CrossReference TemplateVariableResolver</title>
				<para>Xtext comes with a specific template variable resolver 
					<emphasis>TemplateVariableResolver</emphasis> called 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/templates/CrossReferenceTemplateVariableResolver.java?root=Modeling_Project&amp;view=co">CrossReferenceTemplateVariableResolver</ulink>, 
					which can be used to place cross-references within a template.
				</para>
				<para>The syntax is as follows:</para>
				<literallayout><code>${&lt;displayText&gt;:CrossReference([&lt;MyPackageName&gt;.]&lt;MyType&gt;.&lt;myRef&gt;)}
</code></literallayout>
				<para>For example the following template:</para>
				<literallayout><code>&lt;template name="transition" description="event transition" id="transition"
  context="org.eclipse.xtext.example.FowlerDsl.Transition" enabled="true"&gt;
    ${event:CrossReference('Transition.event')} =&gt; 
    	${state:CrossReference('Transition.state')
&lt;/template&gt;

</code></literallayout>
				<para>yields the text 
					<emphasis>event =&gt; state</emphasis> and allows selecting any events and states using a drop down.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/templates_crossref.png"/>
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section id="EnumerationTemplateVariableResolver">
				<title>Enumeration TemplateVariableResolver</title>
				<para>The 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/templates/EnumTemplateVariableResolver.java?root=Modeling_Project&amp;view=co">EnumTemplateVariableResolver</ulink> 
					resolves a template variable to 
					<emphasis>EEnumLiteral</emphasis> literals
					which are assignment-compatible to the enumeration type declared as the first parameter of the the 
					<emphasis>Enum</emphasis> 
					<emphasis>TemplateVariable</emphasis>. 
				</para>
				<para>The syntax is as follows:   </para>
				<literallayout><code>${&lt;displayText&gt;:Enum([&lt;MyPackage&gt;.]&lt;EnumType&gt;)
</code></literallayout>
				<para>For example the following template (taken from the domainmodel example):</para>
				<literallayout><code>&lt;template name="Operation" description="template for an Operation"
  id="org.eclipse.xtext.example.Domainmodel.Operation"
  context="org.eclipse.xtext.example.Domainmodel.Operation"
  enabled="true"&gt;
    ${visibility:Enum('Visibility')} op ${name}(${cursor}):
        ${type:CrossReference('Operation.type')}
&lt;/template&gt;

</code></literallayout>
				<para>yields the text 
					<emphasis>public op name(): type</emphasis> where the display text &#8218;public’ is replaced with a drop 
					down filled with the literal values as defined in the 
					<emphasis>EEnum</emphasis> 
					<emphasis>Visibility</emphasis>. Also, 
					<emphasis>name</emphasis> and 
					<emphasis>type</emphasis> 
					are template variables.
				</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/templates_enum.png"/>
						</imageobject>
					</mediaobject>
				</para>
			</section>
		</section>
		<section id="outline">
			<title>Outline View</title>
			<para>Xtext provides an outline view to help you navigate your models. By default, it provides a hierarchical 
				view on your model and allows you to sort tree elements alphabetically. Selecting an element in the 
				outline will highlight the corresponding element in the text editor. Users can choose to synchronize 
				the outline with the editor selection by clicking the 
				<emphasis>Link with Editor</emphasis> button.
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/sample_outline.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>You can customize various aspects of the outline by providing implementation for its various interfaces. 
				The following sections show how to do this.</para>
			<section id="InfluencingtheOutlineStructure">
				<title>Influencing the Outline Structure</title>
				<para>In its default implementation, the outline view shows the containment hierarchy of your model. 
					This should be sufficient in most cases. If you want to adjust the structure of the outline, i.e., 
					by omitting a certain kind of node or by introducing additional even virtual nodes, you customize 
					the outline by implementing 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/transformer/ISemanticModelTransformer.java?root=Modeling_Project&amp;view=co">ISemanticModelTransformer</ulink>.
				</para>
				<para>The Xtext wizard creates an empty transformer class (
					<emphasis>MyDslTransformer</emphasis>) for your convenience. To 
					transform the semantic model delivered by the Xtext parser, you need to provide transformation methods 
					for each of the EClasses that are of interest:
				</para>
				<literallayout><code>public class MyDslTransformer extends 
    AbstractDeclarativeSemanticModelTransformer { 
  /**
   * This method will be called by naming convention:
   * - method name must be createNode
   * - first param: subclass of EObject
   * - second param: ContentOutlineNode 
   */
  public ContentOutlineNode createNode(
      Attribute semanticNode, ContentOutlineNode parentNode) {
    ContentOutlineNode node = super.newOutlineNode(semanticNode, parentNode);
    node.setLabel("special " + node.getLabel());
    return node;
  }
  
  public ContentOutlineNode createNode(
      Property semanticNode, ContentOutlineNode parentNode) {
    ContentOutlineNode node = super.newOutlineNode(semanticNode, parentNode);
    node.setLabel("pimped " + node.getLabel());
    return node;
  }

  /**
   * This method will be called by naming convention:
   * - method name must be getChildren
   * - first param: subclass of EObject
   */
  public List&lt;EObject&gt; getChildren(Attribute attribute) {
    return attribute.eContents();
  }

  public List&lt;EObject&gt; getChildren(Property property) {
    return NO_CHILDREN;
  }
}

</code></literallayout>
				<para>To make sure Xtext picks up your new outline transformer, you have to register your implementation 
					with your UI module. This binding is usually added by the respective generator fragment.</para>
				<literallayout><code>public class MyDslUiModule extends AbstractMyDslUiModule {

  @Override
  public Class&lt;? extends ISemanticModelTransformer&gt; 
  		bindISemanticModelTransformer() {
    return MyDslTransformer.class;
  }
  ...
}

</code></literallayout>
			</section>
			<section id="Filtering">
				<title>Filtering</title>
				<para>Often, you want to allow users to filter the contents of the outline to make it easier to concentrate 
					on the relevant aspects of the model. To add filtering capabilities to your outline, you need to add 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/actions/AbstractFilterAction.java?root=Modeling_Project&amp;view=co">AbstractFilterAction</ulink>s to the 
					outline. Actions can be contributed by implementing and registering a 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/actions/DeclarativeActionBarContributor.java?root=Modeling_Project&amp;view=co">DeclarativeActionBarContributor</ulink>.
				</para>
				<para>To register a 
					<emphasis>DeclarativeActionBarContributor</emphasis>, add the following lines to your 
					<emphasis>MyDslUiModule</emphasis> class:
				</para>
				<literallayout><code>public class MyDslUiModule extends AbstractMyDslUiModule {

  @Override
  public Class&lt;? extends IActionBarContributor&gt; bindIActionBarContributor() {
    return MyDslActionBarContributor.class;
  }
  ...
}

</code></literallayout>
				<para>The action bar contributor will look like this:</para>
				<literallayout><code>public class MyDslActionBarContributor extends
    DeclarativeActionBarContributor {
  public Action addFilterParserRulesToolbarAction(
      XtextContentOutlinePage page) {
    return new FilterFooAction(page);
  }
}

</code></literallayout>
				<para>Filter actions must extend 
					<emphasis>AbstractFilterAction</emphasis> (this ensures that the action toggle state is 
					handled correctly):
				</para>
				<literallayout><code>public class FilterFooAction extends AbstractFilterAction {

  public FilterFooAction(XtextContentOutlinePage outlinePage) {
    super("Filter Foo", outlinePage);
    setToolTipText("Show / hide foo");
    setDescription("Show / hide foo");
    setImageDescriptor(Activator.getImageDescriptor("icons/foo.gif"));
    setDisabledImageDescriptor(
    	Activator.getImageDescriptor("icons/foo.gif"));
  }

  @Override
  protected String getToggleId() {
    return "FilterFooAction.isChecked";
  }
	
  @Override
  protected ViewerFilter createFilter() {
    return new FooOutlineFilter();
  }

}

</code></literallayout>
				<para>The filtering itself will be performed by 
					<emphasis>FooOutlineFilter</emphasis>:
				</para>
				<literallayout><code>public class FooOutlineFilter extends ViewerFilter {

  @Override
  public boolean select(
      Viewer viewer, Object parentElement, Object element) {
    if ((parentElement != null) 
        &amp;&amp; (parentElement instanceof ContentOutlineNode)) {
      ContentOutlineNode parentNode = (ContentOutlineNode) parentElement;
      EClass clazz = parentNode.getClazz();
      if (clazz.equals(MyDslPackage.Literals.ATTRIBUTE)) {
        return false;
      }
    }
    return true;
  }

}

</code></literallayout>
			</section>
			<section id="Contextmenus">
				<title>Context menus</title>
				<para>You might want to register context menu actions for specific elements in the outline, e.g. to allow 
					users of your DSL to invoke a generator or to validate the selected element. As all elements in the 
					outline are 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/ContentOutlineNode.java?root=Modeling_Project&amp;view=co">ContentOutlineNode</ulink>s, you 
					cannot easily register an 
					<ulink url="http://help.eclipse.org/stable/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/workbench_basicext_popupMenus.htm">Object contribution</ulink>. 
					(Besides, using the extension point 
					<emphasis>org.eclipse.ui.popupMenus</emphasis> is regarded somewhat old school - 
					you should rather use the new command and expression framework, as depicted below).
				</para>
				<para>To register context menus for specific node types of your Ecore model, we need to:</para>
				<itemizedlist>
					<listitem>
						<para>implement 
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/actions/IContentOutlineNodeAdapterFactory.java?root=Modeling_Project&amp;view=co">IContentOutlineNodeAdapterFactory</ulink> which will translate 
							<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/ContentOutlineNode.java?root=Modeling_Project&amp;view=co">ContentOutlineNode</ulink>s to their underlying node type
						</para>
					</listitem>
					<listitem>
						<para>register a menu contribution to add a command / handler pair to the context menu for the specific node types you’re interested in.</para>
					</listitem>
				</itemizedlist>
				<section id="RegisteringanIContentOutlineNodeAdapterFactory">
					<title>Registering an 
						<emphasis>IContentOutlineNodeAdapterFactory</emphasis>
					</title>
					<para>The Xtext code generator creates a subclass of 

						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/outline/actions/DefaultContentOutlineNodeAdapterFactory.java?root=Modeling_Project&amp;view=co">DefaultContentOutlineNodeAdapterFactory</ulink>. 
						All we need to do is specify a list of types that we later want to bind context menu contributions to. 
					</para>
					<literallayout><code>public class MyDslContentOutlineNodeAdapterFactory extends 
    DefaultContentOutlineNodeAdapterFactory {
  private static final Class&lt;?&gt;[] types = { Attribute.class };

  public Class&lt;?&gt;[] getAdapterList() {
    return types;
  }
}

</code></literallayout>
					<para>If you want to bind context menu actions to nodes representing 
						<emphasis>Attribute</emphasis> and 
						<emphasis>Entity</emphasis>, you need to 
						change the declaration of _types as follows:
					</para>
					<literallayout><code>private static final Class&lt;?&gt;[] types = { Attribute.class, Entity.class };
</code></literallayout>
				</section>
				<section id="RegisteringaMenuContribution">
					<title>Registering a Menu Contribution</title>
					<para>You can now add command / handler pairs to the context menu.</para>
					<para>First, you need to define a command – it will serve as a handle to glue together the handler 
						and the menu contribution:</para>
					<literallayout><code>&lt;extension
  point="org.eclipse.ui.commands"&gt;
  &lt;command
    id="org.example.mydsl.ui.editor.outline.SampleOutlineCommand"
    name="Sample Command"
    description="Just a sample command"&gt;
  &lt;/command&gt;
&lt;/extension&gt;

</code></literallayout>
					<para>Next, you need to define a handler which will eventually execute the code to operate on the 
						selected node. Please pay special attention to the attribute 
						<emphasis>commandId</emphasis> - it must match the 
						<emphasis>id</emphasis> 
						attribute of your command. 
					</para>
					<literallayout><code>&lt;extension
  point="org.eclipse.ui.handlers"&gt;
  &lt;handler
    class="org.example.mydsl.ui.editor.outline.SampleOutlineNodeHandler"
    commandId="org.example.mydsl.ui.editor.outline.SampleOutlineCommand"&gt;
  &lt;/handler&gt;
&lt;/extension&gt;

</code></literallayout>
					<para>Finally, define a 
						<emphasis>menuContribution</emphasis> to add the command to the context menu:
					</para>
					<literallayout><code>&lt;extension
  point="org.eclipse.ui.menus"&gt;
  &lt;menuContribution
    locationURI="popup:org.eclipse.xtext.ui.outline?after=additions"&gt;
    &lt;command
      commandId="org.example.mydsl.ui.editor.outline.SampleOutlineCommand"
      label="Sample action registered for Attributes"&gt;
      &lt;visibleWhen checkEnabled="false"&gt;
        &lt;iterate&gt;
          &lt;adapt type="org.example.mydsl.Attribute" /&gt;
        &lt;/iterate&gt;
      &lt;/visibleWhen&gt;
    &lt;/command&gt;
  &lt;/menuContribution&gt;
&lt;/extension&gt;

</code></literallayout>
					<para>Again, pay attention to the 
						<emphasis>commandId</emphasis> attribute. The connection between your node type(s) and 
						the menu contribution is made by the part 
						<emphasis><adapt type="org.example.mydsl.Attribute" /></emphasis>. 
					</para>
				</section>
			</section>
			<section id="quick_outline">
				<title>Quick Outline </title>
				<para>Xtext also provides a quick outline: If you press CTRL-O in an Xtext editor, the outline of the model is shown 
					in a popup window. The quick outline also supports drill-down search with wildcards. To enable the quick outline,
					you have to put the 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/ui/generator/outline/QuickOutlineFragment.java?root=Modeling_Project&amp;view=co">QuickOutlineFragment</ulink> 
					into your workflow.
				</para>
			</section>
		</section>
		<section id="hyperlinking">
			<title>Hyperlinking</title>
			<para>The Xtext editor provides hyperlinking support for any tokens corresponding to cross-references in your 
				grammar definition. You can either CTRL-click on any of these tokens or hit F3 
				while the cursor position is at the token in question and this will take you to the referenced model 
				element. As you’d expect this works for references to elements in the same resource as well as for 
				references to elements in other resources. In the latter case the referenced resource will first be 
				opened using the corresponding editor.</para>
			<section id="locationProvider">
				<title>Location Provider</title>
				<para>When navigating a hyperlink, Xtext will also select the text region corresponding to the referenced model 
					element. Determining this text region is the responsibility of the 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/ILocationInFileProvider.java?root=Modeling_Project&amp;view=co">ILocationInFileProvider</ulink>. The default implementation 
					(
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/DefaultLocationInFileProvider.java?root=Modeling_Project&amp;view=co">DefaultLocationInFileProvider</ulink>) implements a best 
					effort strategy which can be summarized as:
				</para>
				<orderedlist>
					<listitem>
						<para>If the model element’s type (i.e. 
							<emphasis>EClass</emphasis>) declares a feature 
							<emphasis>name</emphasis> then return the region of the corresponding token(s). As a fallback also check for a feature 
							<emphasis>id</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>If the model element’s parse tree contains any top-level tokens corresponding to 
							<emphasis>ID</emphasis> rule calls in the grammar then return a region spanning all those tokens.
						</para>
					</listitem>
					<listitem>
						<para>As a last resort return the region corresponding to the first keyword token of the referenced model element.</para>
					</listitem>
				</orderedlist>
				<section id="CustomizedLocationProvider">
					<title>Customized Location Provider</title>
					<para>As the default strategy is a best effort it may not always result in the selection you want. If that’s 
						the case you can 
						<link linkend="guicemodules">override</link> the 
						<emphasis>ILocationInFileProvider</emphasis> binding in the UI module as 
						in the following example:
					</para>
					<literallayout><code>public class MyDslUiModule extends AbstractMyDslUiModule {

  @Override
  public Class&lt;? extends ILocationInFileProvider&gt; 
  		bindILocationInFileProvider() {
    return MyDslLocationInFileProvider.class;
  }
  ...
}

</code></literallayout>
					<para>Often the default strategy only needs some guidance (e.g. selecting the text corresponding to another 
						feature than 
						<emphasis>name</emphasis>). In that case you can simply subclass 
						<emphasis>DefaultLocationInFileProvider</emphasis> and override 
						the methods 
						<emphasis>getIdentifierFeature()</emphasis> and / or 
						<emphasis>useKeyword()</emphasis> to guide the first and last steps of the strategy 
						as described above (see 
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.xtext.ui/src/org/eclipse/xtext/xtext/ui/XtextLocationInFileProvider.java?root=Modeling_Project&amp;view=co">XtextLocationInFileProvider</ulink> 
						for an example).
					</para>
				</section>
			</section>
			<section id="CustomizingAvailableHyperlinks">
				<title>Customizing Available Hyperlinks</title>
				<para>The hyperlinks are provided by the 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/hyperlinking/HyperlinkHelper.java?root=Modeling_Project&amp;view=co">HyperlinkHelper</ulink>
					which will create links for cross-referenced objects by default. Clients may want to override 

					<emphasis>createHyperlinksByOffset(XtextResource, int, IHyperlinkAcceptor)</emphasis> to provide additional links or 
					supersede the default implementation. 
				</para>
			</section>
		</section>
		<section id="highlighting">
			<title>Syntax Coloring</title>
			<para>Besides the already mentioned advanced features like content assist and code formatting the powerful 
				editor for your DSL is capable to mark up your model-code to improve the overall readability. It is 
				possible to use different colors and fonts according to the meaning of the different parts of your 
				input file. One may want to use some decent colors for large blocks of comments while identifiers, 
				keywords and strings should be colored differently to make it easier to distinguish between them. 
				This kind of text decorating markup does not influence the semantics of the various sections but 
				helps to understand the meaning and to find errors in the source code.</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/highlighting.png" scale="100"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>The highlighting is done in two stages. This allows for sophisticated algorithms that are executed 
				asynchronously to provide advanced coloring while simple pattern matching may be used to highlight 
				parts of the text instantaneously. The latter is called lexical highlighting while the first is based 
				on the meaning of your different model elements and therefore called semantic highlighting.</para>
			<para>When you introduce new highlighting styles, the preference page for your DSL is automatically 
				configured and allows the customization of any registered highlighting setting. They are automatically 
				persisted and reloaded on startup.</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/preferences_syntax.png" scale="50"/>
					</imageobject>
				</mediaobject>
			</para>
			<section id="LexicalHighlighting">
				<title>Lexical Highlighting</title>
				<para>The lexical highlighting can be customized by providing implementations of the interface 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/IHighlightingConfiguration.java?root=Modeling_Project&amp;view=co">IHighlightingConfiguration</ulink> and 
					the abstract class 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/AbstractTokenScanner.java?root=Modeling_Project&amp;view=co">AbstractTokenScanner</ulink>. 
					The latter fulfills the interface 
					<emphasis>ITokenScanner</emphasis> from the underlying JFace Framework, which may be 
					implemented by clients directly.
				</para>
				<para>The 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/IHighlightingConfiguration.java?root=Modeling_Project&amp;view=co">IHighlightingConfiguration</ulink> is used
					to register any default style without a specific binding to 
					a pattern in the model file. It is used to populate the preferences page and to initialize the 

					<emphasis>ITextAttributeProvider</emphasis>, which in turn is the component that is used to obtain the actual settings 
					for a style’s id. An implementation will usually be very similar to the 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/DefaultHighlightingConfiguration.java?root=Modeling_Project&amp;view=co">DefaultHighlightingConfiguration</ulink> and read like this: 
				</para>
				<literallayout><code>public class DefaultHighlightingConfiguration 
    implements IHighlightingConfiguration {

  public static final String KEYWORD_ID = "keyword";
  public static final String COMMENT_ID = "comment";

  public void configure(IHighlightingConfigurationAcceptor acceptor) {
    acceptor.acceptDefaultHighlighting(KEYWORD_ID, "Keyword", 
        keywordTextStyle());
    acceptor.acceptDefaultHighlighting(COMMENT_ID, "Comment", // ...
    // ...
  }
  
  public TextStyle keywordTextStyle() {
    TextStyle textStyle = new TextStyle();
    textStyle.setColor(new RGB(127, 0, 85));
    textStyle.setStyle(SWT.BOLD);
    return textStyle;
  }
  
  // ...
}

</code></literallayout>
				<para>Implementations of the 
					<emphasis>ITokenScanner</emphasis> are responsible for splitting the content of a document into 
					various parts, the so called tokens, and return the highlighting information for each identified range. 
					It is critical that this is done very fast because this component is used on each keystroke. Xtext 
					ships with a default implementation that is based on the lexer that is generated by ANTLR which is very 
					lightweight and fast. This default implementation can be customized by clients easily. They simply have 
					to bind another implementation of the 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/AbstractAntlrTokenToAttributeIdMapper.java?root=Modeling_Project&amp;view=co">AbstractAntlrTokenToAttributeIdMapper</ulink>. 
					To get an idea about it, have a look at the 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/DefaultAntlrTokenToAttributeIdMapper.java?root=Modeling_Project&amp;view=co">DefaultAntlrTokenToAttributeIdMapper</ulink>.
				</para>
			</section>
			<section id="SemanticHighlighting">
				<title>Semantic Highlighting</title>
				<para>The semantic highlighting stage is executed asynchronously in the background and can be used to calculated 
					highlighting states based on the meaning of the different model elements. Users of the editor will 
					notice a very short delay after they have edited the text until the styles are actually applied to the 
					document. This keeps the editor responsive while providing aid when reading and writing your model.</para>
				<para>As for the lexical highlighting the interface to register the available styles is the 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/IHighlightingConfiguration.java?root=Modeling_Project&amp;view=co">IHighlightingConfiguration</ulink>. 
					The 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/ISemanticHighlightingCalculator.java?root=Modeling_Project&amp;view=co">ISemanticHighlightingCalculator</ulink> 
					is the primary hook to implement the logic that will compute to-be-highlighted ranges based on the model 
					elements. 
				</para>
				<para>The framework will pass the current XtextResource and an 

					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/syntaxcoloring/IHighlightedPositionAcceptor.java?root=Modeling_Project&amp;view=co">IHighlightedPositionAcceptor</ulink> to 
					the calculator. It is ensured, that the resource will not be altered externally until the called method 

					<emphasis>provideHighlightingFor()</emphasis> returns. However, the resource may be null. The implementor’s task is to 
					navigate your semantic model and compute various ranges based on the attached node information and 
					associate styles with them. This may read similar to the following snippet:
				</para>
				<literallayout><code>public void provideHighlightingFor(XtextResource resource, 
    IHighlightedPositionAcceptor acceptor) {
  if (resource == null)
    return;
    
  Iterable&lt;AbstractNode&gt; allNodes = NodeUtil.getAllContents(
    resource.getParseResult().getRootNode());
  for (AbstractNode node : allNodes) {
    if (node.getGrammarElement() instanceof CrossReference) {
      acceptor.addPosition(node.getOffset(), node.getLength(), 
        MyHighlightingConfiguration.CROSS_REF);
    }
  }
}

</code></literallayout>
				<para>This example refers to an implementation of the 
					<emphasis>IHighlightingConfiguration</emphasis> that registers a style 
					for a cross-reference. It is pretty much the same implementation as for the previously mentioned sample 
					of a lexical 
					<emphasis>IHighlightingConfiguration</emphasis>.
				</para>
				<literallayout><code>public class HighlightingConfiguration 
    implements IHighlightingConfiguration {
  
  // lexical stuff goes here 
  // ..
  public final static String CROSS_REF = "CrossReference"; 

  public void configure(IHighlightingConfigurationAcceptor acceptor) {
    // lexical stuff goes here 
    // ..
    acceptor.acceptDefaultHighlighting(CROSS_REF, 
      "Cross-References", crossReferenceTextStyle());
  }
  
  public TextStyle crossReferenceTextStyle() {
    TextStyle textStyle = new TextStyle();
    textStyle.setStyle(SWT.ITALIC);
    return textStyle;
  }
}

</code></literallayout>
				<para>The implementor of an 
					<emphasis>IHighlightingCalculator</emphasis> should be aware of performance to ensure a good user 
					experience. It is probably not a good idea to traverse everything of your model when you will only 
					register a few highlighted ranges that can be found easier with some typed method calls. It is strongly 
					advised to use purposeful ways to navigate your model. The parts of Xtext’s core that are responsible 
					for the semantic highlighting are pretty optimized in this regard as well. The framework will only 
					update the ranges that actually have been altered, for example. This speeds up the redraw process. It 
					will even move, shrink or enlarge previously announced regions based on a best guess before the next 
					semantic highlighting pass has been triggered after the user has changed the document.
				</para>
			</section>
		</section>
		<section id="projectwizard">
			<title>Project Wizard</title>
			<para>Optionally, Xtext can generate a 
				<emphasis>New Project Wizard</emphasis> for your DSL. Using this wizard a user can create a new 
				project with only a few clicks that is configured with the right dependencies and natures. By default 
				it contains a sample model file and workflow that serve as a scaffold for the user. Furthermore it 
				has the Xtext nature and thereby the builder assigned. You enable the generation of the project wizard by adding the 

				<emphasis>SimpleProjectWizardFragment</emphasis> fragment to the 
				<link linkend="generator_fragment">workflow</link>:
			</para>
			<literallayout><code>import org.eclipse.xtext.ui.generator.* 

// project wizard fragment
fragment = projectWizard.SimpleProjectWizardFragment {
  generatorProjectName = "${projectName}.generator"
  modelFileExtension = file.extensions
}

</code></literallayout>
			<para>Here</para>
			<itemizedlist>
				<listitem>
					<para>the 
						<emphasis>generatorProjectName</emphasis> is used to specify the project that contains the workflows and templates used to generate artifacts from your DSL. The generated project wizard uses this to add a corresponding dependency to the created project.
					</para>
				</listitem>
				<listitem>
					<para>and the 
						<emphasis>modelFileExtension</emphasis> specifies the default file extension associated with your DSL. When the user clicks the 
						<emphasis>Finish</emphasis> button the project wizard will look for a file with the given extension in the created project and open a editor. 
					</para>
				</listitem>
			</itemizedlist>
			<para>After running the Xtext generator, the DSL’s UI project will contain a new Xpand template 

				<emphasis>MyDslNewProject.xpt</emphasis> in the 
				<emphasis>src</emphasis> folder in the package 
				<emphasis>.ui.wizard</emphasis>. 
				Note: It may be necessary to manually merge the new entry in the _plugin.xml___gen_ into your 

				<emphasis>plugin.xml</emphasis> of the UI project to enable the wizard contribution.
			</para>
			<para>The generated Xpand template will be expanded by the project wizard when the user clicks the 
				<emphasis>Finish</emphasis> button 
				and it is responsible for initializing the project with some sample content. When finishing the wizard 
				the template will be used to create a sample model file and a simple workflow to run the 
				model through the generator project’s 
				<emphasis>MyDslGenerator.mwe</emphasis> workflow. However, this is only a pragmatic default.
				As the Xpand template is in the 
				<emphasis>src</emphasis> source folder you may of course modify it to generate whatever 
				initial content you want for a new project. Just make sure to leave the top-level 
				<emphasis>main</emphasis> definition 
				in place, as that is the interface for the project wizard.
			</para>
			<para>
				<emphasis role="bold">Note:</emphasis> To edit the generated Xpand template you should check that the 
				<emphasis>JavaBeans meta model contributor</emphasis> 
				is enabled under 
				<emphasis>Preferences &gt; Xtend/Xpand</emphasis>. Further you should also configure the UI project with the 
				Xpand/Xtend nature using 
				<emphasis>Configure &gt; Add Xpand/Xtend Nature</emphasis> in the context menu.
			</para>
			<section id="CustomizingtheProjectWizard">
				<title>Customizing the Project Wizard</title>
				<para>To further customize the creation of the project you can implement your own 
					<emphasis>project creator</emphasis>. 
					The default project creator is represented by the generated class 
					<emphasis>MyDslProjectCreator</emphasis> in the

					<emphasis>src-gen</emphasis> folder. It is highly extensible. Without any changes it will simply create a new plug-in project 
					with the Xtext nature assigned. Afterwards it will execute the 
					<emphasis>main</emphasis> definition of the Xpand template 
					as described above.
				</para>
				<para>To add more pages or input fields to the project wizard you should subclass the class 

					<emphasis>MyDslNewProjectWizard</emphasis> as appropriate. Don’t forget to register the subclass in the UI project’s 

					<emphasis>MyDslUiModule</emphasis>. You may also want to make additionally entered user data available to the Xpand template. 
					In this case you should enhance the 
					<emphasis>MyDslProjectInfo</emphasis> to allow that one to hold the information. This is the 
					context object which gets passed to the template when it’s executed. Don’t forget that your specialized 

					<emphasis>MyDslNewProjectWizard</emphasis> has to populate the data fields of your 
					<emphasis>MyDslProjectInfo</emphasis>.
				</para>
			</section>
		</section>
	</chapter>
	<chapter id="jvmtypes">
		<title>Referring to Java Types</title>
		<para>A common use case when developing languages is the requirement to refer to existing concepts of other 
			languages. Xtext makes this very easy for other self defined languages. However, it is often very useful
			to have access to the available types of the Java Virtual Machine. The JVM types Ecore model enables
			clients to do exactly this. It is possible to create cross-references to classes, interfaces, and their 
			fields and methods. Basically every information about the structural concepts of the Java type system
			is available via the JVM types. This includes annotations and their specific values and enumeration 
			literals as well.</para>
		<para>The implementation will be selected transparently to the client code depending on where the code is 
			executed. If the environment is a plain stand-alone Java or OSGi environment, the 
			<emphasis>java.lang.reflect</emphasis> 
			API will be used to deduce the necessary data. On the contrary, the type-model will be created from the 
			live data of the JDT in an interactive Eclipse environment. All this happens behind the scenes via different
			implementations that are bound to specific interfaces with Google Guice. 
		</para>
		<section id="HowtoUseJavaTypes">
			<title>How to Use Java Types </title>
			<para>Using the JVM types model is very simple. First of all, the grammar has to import the 
				<emphasis>JavaVMTypes</emphasis> Ecore model. 
				Thanks to content assist this is easy to spot in the list of proposals.  
			</para>
			<literallayout><code>import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

</code></literallayout>
			<para>The next step is to actually refer to an imported concept. Let’s define a mapping to actually available
				Java types for the simple data types in the self defined language. By means of cross-references this works
				as one got already used to when dealing with references in Xtext.</para>
			<literallayout><code>Type:
  'type' name=ID 'mapped-to' javaType=[types::JvmType|FQN];

</code></literallayout>
			<para>Last but not least, the 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/types/TypesGeneratorFragment.java?root=Modeling_Project&amp;view=co">TypesGeneratorFragment</ulink> 
				has to be added to the workflow. The safest way is 
				to add it after the actually used scoping fragments as a specialized version of the 
				<emphasis>IGlobalScopeProvider</emphasis> 
				will be configured. Don’t forget to refer to the 
				<emphasis>genmodel</emphasis> of the Java VM types. The shortest possible
				URI is a classpath-URI.    
			</para>
			<literallayout><code>fragment = ecore.EcoreGeneratorFragment {
  referencedGenModels="classpath:/model/JavaVMTypes.genmodel"
}

...
// scoping and exporting API 
...

fragment = types.TypesGeneratorFragment {}

</code></literallayout>
			<para>After regenerating your language, it will be allowed to define a type 
				<emphasis>Date</emphasis> that maps to the 
				<emphasis>java.util.Date</emphasis>
				like this:
			</para>
			<literallayout><code>type Date mapped-to java.util.Date

</code></literallayout>
			<para>These two steps will provide a nice integration into the Eclipse JDT. There is 
				<emphasis>Find References</emphasis> on Java methods, 
				fields and types that will reveal results in your language files. 
				<emphasis>Go To Declaration</emphasis> works as expected
				and content assist will propose the list of available types. 
			</para>
		</section>
		<section id="CustomizationPoints">
			<title>Customization Points</title>
			<para>There are several customization hooks in the runtime layer and on the editor side as well:</para>
			<para>The 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.common.types/src/org/eclipse/xtext/common/types/xtext/AbstractTypeScopeProvider.java?root=Modeling_Project&amp;view=co">AbstractTypeScopeProvider</ulink> 
				can be used to create scopes for members with respect to
				the override semantics of the Java language. Of course it is possible to use this implementation to
				create scopes for types as well.
			</para>
			<para>As the Java VM types expose a lot of information about visibility, parameter- and return types, generic,
				available annotations or enumeration literals, it is very easy to define constraints for the referred types.</para>
			<para>The 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/xtext/ui/ITypesProposalProvider.java?root=Modeling_Project&amp;view=co">ITypesProposalProvider</ulink> can be
				used to provide optimized proposals based on various filter criteria. 
				The most common selector can be used directly via 
				<emphasis>createSubTypeProposals</emphasis>. The implementation is optimized
				and uses the JDT Index directly to minimize the effort for object instantiation. The class 

				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.common.types.ui/src/org/eclipse/xtext/common/types/xtext/ui/TypeMatchFilters.java?root=Modeling_Project&amp;view=co">TypeMatchFilters</ulink>
				provides a comprehensive set of reusable filters that can be easily combined to reduce the list of proposals
				to a smaller number of valid entries.
			</para>
			<literallayout><code>import static org.eclipse.xtext.common.types.xtext.ui.TypeMatchFilters.*; 
..
..

  proposalProvider.createSubTypeProposals(factory, context,
      and(not(canInstantiate()), isPublic()), acceptor);
 
 
</code></literallayout>
			<para>
				<emphasis>Since Xtext 1.0.1:</emphasis>
			</para>
			<para>Proposals can be created by means of a scoped proposal provider that is actually aware of existing import 
				statements and scoping rules while still leveraging the JDT index for faster proposal creation. Use the 

				<emphasis>ITypesProposalProvider.IScopableTypesProposalProvider</emphasis> to create a scoped proposal provider and use this 
				one instead of the plain implementation.
			</para>
			<literallayout><code>@Override
public void complete&lt;TypeName&gt;_&lt;ReferenceName&gt;(
    EObject model,
    Assignment assignment,
    ContentAssistContext context,
    ICompletionProposalAcceptor acceptor) {
  IScope scope = getScopeProvider().getScope(
      model,
      &lt;MyDsl&gt;Package.Literals.&lt;POINTER_TO_REFERENCE&gt;);
  ITypesProposalProvider scopedProposalProvider =
      scopableProposalProvider.getScopedProposalProvider(model, scope);
  scopedProposalProvider.create...
}


</code></literallayout>
		</section>
	</chapter>
	<chapter id="special_languages">
		<title>Typical Language Configurations</title>
		<section id="case_insensitive_languages">
			<title>Case Insensitive Languages</title>
			<para>In some cases, e.g. if your 
				<emphasis>SHIFT</emphasis> key is broken, you might want to design a case insensitive language. Xtext offers separate 
				<link linkend="generator_fragment">generator fragments</link> for this purpose. 
			</para>
			<para>For case insensitive keywords, open your MWE workflow and replace the Antlr related fragments: </para>
			<literallayout><code>// The antlr parser generator fragment.
fragment = parser.antlr.XtextAntlrGeneratorFragment {
//  options = {
//		backtrack = true
//	}
}
...

// generates a more lightweight Antlr parser and lexer tailored ...
fragment = parser.antlr.XtextAntlrUiGeneratorFragment {
}

</code></literallayout>
			<para>with</para>
			<literallayout><code>// The antlr parser generator fragment.
fragment = parser.antlr.ex.rt.AntlrGeneratorFragment {
    options = {
        ignoreCase = true
    }
}
...

// generates a more lightweight Antlr parser and lexer tailored ...
fragment = parser.antlr.ex.ca.ContentAssistParserGeneratorFragment {
    options = {
        ignoreCase = true
    }
}

</code></literallayout>
			<para>For case insensitve element names, use the 
				<emphasis>ignoreCase</emphasis> option in your scope fragment, i.e.
			</para>
			<literallayout><code>fragment = scoping.ImportNamespacesScopingFragment {
    ignoreCase = true
}

</code></literallayout>
			<para>or if you are using 
				<link linkend="import_uri">importURI based global scopes</link>
			</para>
			<literallayout><code>fragment = scoping.ImportURIScopingFragment {
    ignoreCase = true
}

</code></literallayout>
		</section>
		<section id="java_independent_languages">
			<title>Languages Independent of JDT</title>
			<para>The following section describes how you make your language independent of Eclipse’s Java Development Toolkit (JDT).</para>
			<para>In the 
				<emphasis>UIModule</emphasis> of your language you have to overwrite some bindings. First, remove the bindings to components with support for the '
				<emphasis>classpath:</emphasis>' URI protocol, i.e. 
			</para>
			<literallayout><code>@Override
public Class&lt;? extends IResourceForEditorInputFactory&gt;
    bindIResourceForEditorInputFactory() {
        return ResourceForIEditorInputFactory.class;
}

@Override
public Class&lt;? extends IResourceSetProvider&gt; bindIResourceSetProvider() {
    return SimpleResourceSetProvider.class;
}

</code></literallayout>
			<para>Second, configure the global scope provider to scan project root folders instead of the classpath of Java projects.   </para>
			<literallayout><code>@Override
public com.google.inject.Provider
    &lt;org.eclipse.xtext.resource.containers.IAllContainersState&gt;
    provideIAllContainersState() {
    return org.eclipse.xtext.ui.shared.Access.getWorkspaceProjectsState();
}

</code></literallayout>
			<para>The remaining steps show you how to adapt the  

				<link linkend="projectwizard">project wizard</link> for your language, if you have generated one.
				The best way to do this is to create a new subclass of the generated 

				<emphasis>IProjectCreator</emphasis> in the 
				<emphasis>src/</emphasis> folder of the 
				<emphasis>ui</emphasis> project and 
				apply the necessary changes there. First, remove the JDT project configuration 
				by overriding 
				<emphasis>configureProject</emphasis> with an empty body. 
			</para>
			<para>The next thing is to redefine the project natures and builders that should be
				applied to you language projects.</para>
			<para>In in this case just remove the JDT stuff in this way:</para>
			<literallayout><code>protected String[] getProjectNatures() {
    return new String[] {
        "org.eclipse.pde.PluginNature",
        "org.eclipse.xtext.ui.shared.xtextNature"
    };
}

protected String[] getBuilders() {
    return new String[] {
        "org.eclipse.pde.ManifestBuilder", 
        "org.eclipse.pde.SchemaBuilder"
    };
}

</code></literallayout>
			<para>After that you have to bind the new 
				<emphasis>IProjectCreator</emphasis>
			</para>
			<literallayout><code>@Override
public Class&lt;? extends IProjectCreator&gt; bindIProjectCreator() {
    return JDTFreeMyDslProjectCreator.class;
}

</code></literallayout>
			<para>That’s all. Your language and its IDE should now no longer depend on JDT.</para>
		</section>
		<section id="expressions">
			<title>Parsing Expressions with Xtext</title>
			<para>Parsing simple XML-like, structural languages with Xtext is a no-brainer. However, parsing nested expressions is often considered a bit more complicated. This is because they are more complicated due to their recursive nature and also because with Xtext you have to avoid left recursive parser rules. As the underlying parser (generated by Antlr) uses a top-down approach it would recurse endlessly if you had a left recursive grammar.</para>
			<para>Let’s have a look at parsing a simple arithmetic expression:</para>
			<literallayout><code>2 + 20 * 2
</code></literallayout>
			<para>If you know EBNF a bit and wouldn’t think about avoiding left recursion, operator precedence or associativity, you’ld probably write a grammar like this:</para>
			<literallayout><code>Expression :
  Expression '+' Expression |
  Expression '*' Expression |
  INT;

</code></literallayout>
			<para>This grammar would be left recursive because the parser reads the grammar top down and left to right and would endlessly call the Expression rule without consuming any characters, i.e. altering the underlying state of the parser. While this kind of grammar can be written for bottom-up parsers, you’ld still have to deal with operator precedence in addition. That is define that a multiplication has higher precedence than an addition for example.</para>
			<para>In Xtext you define the precedence implicitly when left-factoring such a grammar. Left-factoring means you get rid of left recursion by applying a certain technique, which we will show in the following.</para>
			<para>So here is a left-factored grammar (not yet working with Xtext) for the expression language above :</para>
			<literallayout><code>Addition :
  Multiplication ('+' Multiplication)*;

Multiplication:
  NumberLiteral ('*' NumberLiteral)*;

NumberLiteral:
  INT;

</code></literallayout>
			<para>As you can see the main difference is that we have three rules instead of one and if you look a bit closer you see, that there’s a certain delegation pattern involved. The rule Addition doesn’t call itself but calls Multiplication instead. The operator precedence is defined by the order of delegation. The later the rule is called the higher is its precedence. This is at least the case for the first two rules which are of a left recursive nature (but we’ve left-factored them now). The last rule is not left recursive which is why you can write them down without applying this pattern.</para>
			<para>We should allow users to explicitly adjust precedence by adding parenthesis, e.g. write something like (2 + 20) * 2.
				So let’s add support for that (note that the grammar is still not working with Xtext):</para>
			<literallayout><code>Addition :
  Multiplication ('+' Multiplication)*;

Multiplication:
  Primary ('*' Primary)*;

Primary :
  NumberLiteral |
  '(' Addition ')';

NumberLiteral:
  INT;
  
</code></literallayout>
			<para>So once again: if you have some construct that recurses on the left hand side, you need to put it into the delegation chain according to their operator precedence. The pattern is always the same, the thing that recurses delegates to the rule with the next higher precedence.</para>
			<section id="ConstructionofanAST">
				<title>Construction of an AST</title>
				<para>Now that we know how to avoid left recursion, let’s have a look at what the parser produces. In Xtext each rule returns some value. Parser rules return AST nodes (i.e. EObject instances), enum rules return enum literals and datatype rules as well as terminal rules return simple values like strings and the like (EDatatype in EMF jargon).
					Xtext can automatically infer whether some rule is a parser rule, i.e. constructs and returns an AST node, or if it is a datatype rule that returns a value. The grammar above only consists of datatype rules all of them returning plain strings.
					In order to construct an AST we need to add Assignments and Actions. But before we do that we need to talk about return types.</para>
				<para>The return type of a rule can be specified explicitly using the &#8218;returns’ keyword but can be inferred if the type’s name is the same as the rule’s name.
					That is</para>
				<literallayout><code>NumberLiteral : ... ;

</code></literallayout>
				<para>is a short form of</para>
				<literallayout><code>NumberLiteral returns NumberLiteral : ... ;

</code></literallayout>
				<para>However in the case of the expressions grammar above, all rules need to return the same type since they are recursive. So in order to make the grammar functional we need to add a common return type explicitly (but the grammar is still missing some bits):</para>
				<literallayout><code>Addition returns Expression:
  Multiplication ('+' Multiplication)*;
  
Multiplication returns Expression:
  Primary ('*' Primary)*;
  
Primary returns Expression:
  NumberLiteral |
  '(' Addition ')';
  
NumberLiteral:
  INT;

</code></literallayout>
				<para>The AST type inference mechanism of Xtext will infer two types: Expression and NumberLiteral. Now we need to add assignments and Actions in order to store all the important information in the AST and to create reasonable subtypes for the two operations.</para>
				<para>In the following you see the final fully working Xtext grammar:</para>
				<literallayout><code>Addition returns Expression:
  Multiplication ({Addition.left=current} '+' right=Multiplication)*;
  
Multiplication returns Expression:
  Primary ({Multiplication.left=current} '*' right=Primary)*;
  
Primary returns Expression:
  NumberLiteral |
  '(' Addition ')';
  
NumberLiteral:
  value=INT;

</code></literallayout>
				<para>Let’s go through the grammar as the parser would do it for the expression</para>
				<literallayout><code>(1 + 20) * 2

</code></literallayout>
				<para>The parser always starts with the first rule (Addition). Therein the first element is an unassigned rule call to Multiplication which in turn calls Primary. Primary now has two alternatives. The first one is calling NumberLiteral which consists only of one assignment to a feature called &#8218;value’. The type of &#8218;value’ has to be compatible to the return type of the INT rule.</para>
				<para>But as the first token in the sample expression is an opening parenthesis &#8218;(’ the parser will take the second alternative in Primary, consume the &#8218;(’ and call the rule Addition. Now the value &#8218;1’ is the lookahead token and again Addition calls Multiplication and Multiplication calls Primary. This time the parser takes the first alternative because &#8218;1’ was consumed by the INT rule (which btw. is a reused library terminal rule).</para>
				<para>As soon as the parser hits an assignment it checks whether an AST node for the current rule was already created. If not it will create one based on the return type of the current rule, which is NumberLiteral. The Xtext generator created an EClass &#8218;NumberLiteral’ before which can now be instantiated. That type will also have a property called value of type int (actually of type EInt), which will get the value &#8218;1’ set. This is what the Java equivalent would look like:</para>
				<literallayout><code>// value=INT
if (current == null)
 current = new NumberLiteral();
current.setValue(ruleINT());
...

</code></literallayout>
				<para>Now that the rule has been completed the created EObject is returned to the calling rule Primary, which in turn returns the object unchanged to its own caller. Within Multiplication the call to Primary has been successfully parsed and returned an instance of NumberLiteral. The second part of the rule (everything within the parenthesis) is a so called group. The asterisk behind the closing parenthesis states that this part can be consumed zero or more times. The first token to consume in this part is the multiplication operator &#8218;*’. Unfortunately in the current situation the next token to accept is the plus operator &#8218;+’, so the group is not consumed at all and the rule returns what they got from the unassigned rule call (the NumberLiteral).</para>
				<para>In rule Addition there’s a similar group but this time it expects the correct operator so the parser steps into the group.
					The first element in the group is a so called action. As Xtext grammars are highly declarative and bi-directional it is not a good idea to allow arbitrary expression within actions as it is usually the case with parser generators. Instead we only support two kinds of actions. This one will create a new instance of type Addition and assign what was the to-be-returned object to the feature left. In Java this would have been something like:</para>
				<literallayout><code>// Multiplication rule call
current = ruleMultiplication();
// {Addition.left=current}
Addition temp = new Addition();
temp.setLeft(current);
current = temp;
...

</code></literallayout>
				<para>As a result the rule would now return an instance of Addition which has a NumberLiteral set to its property left. Next up the parser consumes the &#8218;+’ operator. We do not store the operator in the AST because we have an explicit Addition type, which implicitly contains this information.
					The assignment (&#8218;right=Multiplication’) calls the rule Multiplication another time and assigns the returned object (a NumberLiteral of value=20) to the property named right.</para>
				<para>If we now had an additional plus operation &#8218;+’ (e.g. 1 + 2 + 3) the group would match another time and create another instance of Addition. But we don’t and therefore the rule is completed and returns the created instance of Addition to its caller which was the second alternative in Primary. Now the closing parenthesis is matched and consumed and the parser stack is reduced once more.</para>
				<para>We are now in rule Multiplication and have the multiplication operator &#8218;*’ on the lookahead. The parser goes into the group and applies the action. Finally it calls the Primary rule, gets another instance of NumberLiteral (value=2), assigns it as the &#8218;right’ operand of the Multiplication and returns the Multiplication to the rule Addition which in turn returns the very same object as there’s nothing left to parse.</para>
				<para>The resulting AST looks like this:</para>
				<para>
					<mediaobject>
						<imageobject>
							<imagedata fileref="images/expression-ast.png"/>
						</imageobject>
					</mediaobject>
				</para>
				<para>(It’s pretty hard to follow what’s going on just by reading this text. Therefore we have prepared a small video which visualizes and explains the details. see http://vimeo.com/14358869)</para>
			</section>
			<section id="Associativity">
				<title>Associativity</title>
				<para>There is still one topic we should mention, which is associativity. There is left and right associativity as well as none associativity. In the example we have seen left associativity. Associativity tells the parser how to construct the AST when there are two infix operations with the same precedence. The following example is taken from the corresponding wikipedia entry:</para>
				<para>Consider the expression a ~ b ~ c. If the operator ~ has left associativity, this expression would be interpreted as (a ~ b) ~ c and evaluated left-to-right. If the operator has right associativity, the expression would be interpreted as a ~ (b ~ c) and evaluated right-to-left. If the operator is non-associative, the expression might be a syntax error, or it might have some special meaning.
					We already know the most important form which is left associativity:</para>
				<literallayout><code>Addition returns Expression:
  Multiplication ({Addition.left=current} '+' right=Multiplication)*;

</code></literallayout>
				<para>Right associativity is done using the following pattern (note the quantity operator and the call to the rule itself at the end):</para>
				<literallayout><code>Addition returns Expression:
  Multiplication ({Addition.left=current} '+' right=Addition)?;

</code></literallayout>
				<para>And if you don’t want to allow multiple usages of the same expression in a row (hence non-associativity) you write:</para>
				<literallayout><code>Addition returns Expression:
  Multiplication ({Addition.left=current} '+' right=Multiplication)?;

</code></literallayout>
				<para>Note that sometimes it’s better to allow associativity on parser level, but forbid it later using validation, because you can come up with a better error message. Also the whole parsing process won’t be interrupted, so your tooling will generally be more forgiving.</para>
			</section>
		</section>
	</chapter>
	<chapter id="emf_integration">
		<title>Integration with EMF and Other EMF Editors</title>
		<para>Xtext relies heavily on EMF internally, but it can also be used as the serialization back-end of other EMF-based tools.
			In this section we introduce the basic concepts of the 
			<ulink url="http://www.eclipse.org/emf">Eclipse Modeling Framework (EMF)</ulink> in the context of Xtext.  
			If you want to learn more about EMF, we recommend reading the 
			<ulink url="http://www.eclipse.org/emf">EMF book</ulink>.
		</para>
		<section id="model_metamodel">
			<title>Model, Ecore Model, and Ecore </title>
			<para>When Xtext uses EMF models as the in-memory representation of any parsed text files. This in-memory object graph is called the 
				<emphasis>Abstract Syntax Tree</emphasis> (AST). 
				Depending on the community this concepts is also called 
				<emphasis>document object graph (DOM)</emphasis>, 
				<emphasis>semantic model</emphasis>, or simply 
				<emphasis>model</emphasis>. We use 
				<emphasis>model</emphasis> and 
				<emphasis>AST</emphasis> interchangeably. 
				Given the example model from the 
				<link linkend="getting-started-xtext">introduction</link>, the AST looks similar to this
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/ast.png" scale="50"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>The 
				<emphasis>AST</emphasis> should contain the essence of your textual models and abstract over syntactical information. It is used by later processing steps, 
				such as validation, compilation or interpretation. In EMF a model is made up of instances of 
				<emphasis>EObjects</emphasis> which are connected 
				and an 
				<emphasis>EObject</emphasis> is an instance of an 
				<emphasis>EClass</emphasis>. 
				A set of 
				<emphasis>EClasses</emphasis> if contained in a so called 
				<emphasis>EPackage</emphasis>, which are both concepts of 
				<emphasis>Ecore</emphasis> 
				In Xtext, meta models are either inferred from the grammar or predefined by the user (see the section on 
				<link linkend="package_declarations">package declarations</link> for details). The next diagram shows the meta model of our example:
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/metamodel.png"/>
					</imageobject>
				</mediaobject> 
			</para>
			<para>The language in which the meta model is defined is called 
				<emphasis>Ecore</emphasis>. In other words, the meta model is the Ecore model of your language. Ecore an essential part of EMF. Your your models instantiate the meta model, and your meta model instantiates Ecore. To put an end to this recursion, Ecore is defined in itself (an instance of itself). 
			</para>
			<para>The meta model defines the types of the semantic nodes as Ecore 
				<emphasis>EClasses</emphasis>. EClasses are shown as boxes in the meta mode diagram, so in our example, 
				<emphasis>Model</emphasis>, 
				<emphasis>Type</emphasis>, 
				<emphasis>SimpleType</emphasis>, 
				<emphasis>Entity</emphasis>, and 
				<emphasis>Property</emphasis> are EClasses. An EClass can inherit from other EClasses. Multiple inheritance is allowed in Ecore, but of course cycles are forbidden.  
			</para>
			<para>EClasses can have 
				<emphasis>EAttributes</emphasis> for their simple properties. These are shown inside the EClasses nodes. The example contains two EAttributes 
				<emphasis>name</emphasis> and one EAttribute 
				<emphasis>isMulti</emphasis>. The domain of values for an EAttribute is defined by its 
				<emphasis>EDataType</emphasis>. Ecore ships with some predefined 
				<emphasis>EDataTypes</emphasis>, which essentially refer to Java primitive types and other immutable classes like String. To make a distinction from the Java types, the EDataTypes are prefixed with an 
				<emphasis>E</emphasis>. In our example, that’s 
				<emphasis>EString</emphasis> and 
				<emphasis>EBoolean</emphasis>.  
			</para>
			<para>In contrast to EAttributes, 
				<emphasis>EReferences</emphasis> point to other EClasses. The 
				<emphasis>containment</emphasis> flag indicates whether an EReference is a 
				<emphasis>containment reference</emphasis> or a 
				<emphasis>cross-reference</emphasis>. In the diagram, references are edges and containment references are marked with a diamond. At the model level, each element can have at most one container, i.e. another element referring to it with a containment reference. This infers a tree structure to the models, as can be seen in the sample model diagram. On the other hand, 
				<emphasis>cross-references</emphasis> refer to elements that can be contained anywhere else. In the example, 
				<emphasis>elements</emphasis> and 
				<emphasis>properties</emphasis> are containment references, while 
				<emphasis>type</emphasis> and 
				<emphasis>extends</emphasis> are cross-references. For reasons of readability, we skipped the cross-references in the sample model diagram. Note that in contrast to other parser generators, Xtext creates ASTs with linked cross-references. 
			</para>
			<para>Other than associations in UML, EReferences in Ecore are always owned by one EClass and only navigable in the direction form the owner to the type. Bi-directional associations must be modeled as two references, being 
				<emphasis>eOpposite</emphasis> of each other and owned by either end of the associations.
			</para>
			<para>The superclass of EAttibutes and EReferences is 
				<emphasis>EStructuralFeature</emphasis> and allows to define a name and a cardinality by setting 
				<emphasis>lowerBound</emphasis> and 
				<emphasis>upperBound</emphasis>. Setting the latter to -1 means &#8218;unbounded’. 
			</para>
			<para>The common supertype of EDataType and EClass is 
				<emphasis>EClassifier</emphasis>. An 
				<emphasis>EPackage</emphasis> acts as a namespace and container of EClassifiers. 
			</para>
			<para>We have summarized these most relevant concepts of Ecore in the following diagram:  </para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/ecore.png"/>
					</imageobject>
				</mediaobject>
			</para>
		</section>
		<section id="emf_codegen">
			<title>EMF Code Generation</title>
			<para>EMF also ships with a code generator that generates Java classes from your Ecore model. The code generators input is the so called 
				<emphasis>EMF generator model</emphasis>. It decorates (references) the Ecore model and adds additional information for the Ecore -&gt; Java transformation. Xtext will automatically generate a generator model with reasonable defaults for all generated metamodels, and run the EMF code generator on them. 
			</para>
			<para>The generated classes are based on the EMF runtime library, which offers a lot of infrastructure and tools to work with your models, such as persistence, reflection, referential integrity, lazy loading etc.</para>
			<para>Among other things, the code generator will generate</para>
			<itemizedlist>
				<listitem>
					<para>A Java interface and a Java class for each EClassifier in your Ecore model. By default, all classes will implement the interface 
						<emphasis>org.eclipse.emf.ecore.EObject</emphasis>, linking a lot of runtime functionality. 
					</para>
				</listitem>
				<listitem>
					<para>A Java bean property for each EStructuralFeature (member variable, accessor methods)</para>
				</listitem>
				<listitem>
					<para>A package interface and class, holding singleton objects for all elements of your Ecore model, allowing reflection. EPackages are also registered to the 
						<emphasis>EPackage.Registry</emphasis> to be usable at runtime.
					</para>
				</listitem>
				<listitem>
					<para>A factory interface and class for creating instances</para>
				</listitem>
				<listitem>
					<para>An abstract switch class implementing a visitor pattern to avoid if-instanceof cascades in your code.</para>
				</listitem>
			</itemizedlist>
		</section>
		<section id="xtext_resource">
			<title>XtextResource Implementation</title>
			<para>Xtext provides an implementation of EMF’s resource, the 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java?root=Modeling_Project&amp;view=co">XtextResource</ulink>. This does not only encapsulate the parser that converts text to an EMF model but also the serializer working the opposite direction. That way, an Xtext model just looks like any other Ecore-based model from the outside, making it amenable for the use by other EMF based tools. In fact, the Xpand templates in the generator plug-in created by the Xtext wizard do not make any assumption on the fact that the model is described in Xtext, and they would work fine with any model based on the same Ecore model of the language. So in the ideal case, you can switch the serialization format of your models to your self-defined DSL by just replacing the resource implementation used by your other modeling tools. 
			</para>
			<para>
				<mediaobject>
					<imageobject>
						<imagedata fileref="images/emf-integration.png"/>
					</imageobject>
				</mediaobject>
			</para>
			<para>The generator fragment 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.generator/src/org/eclipse/xtext/generator/resourceFactory/ResourceFactoryFragment.java?root=Modeling_Project&amp;view=co">ResourceFactoryFragment</ulink> registers a factory for the 
				<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/resource/XtextResource.java?root=Modeling_Project&amp;view=co">XtextResource</ulink> to EMF’s resource factory registry, such that all tools using the default mechanism to resolve a resource implementation will automatically get that resource implementation.   
			</para>
			<para>Using a self-defined textual syntax as the primary storage format has a number of advantages over the default XMI serialization, e.g.</para>
			<itemizedlist>
				<listitem>
					<para>You can use well-known and easy-to-use tools and techniques for manipulation, such as text editors, regular expressions, or stream editors.</para>
				</listitem>
				<listitem>
					<para>You can use the same tools for version control as you use for source code. Merging and diffing is performed in a syntax the developer is familiar with. </para>
				</listitem>
				<listitem>
					<para>It is impossible to break the model such that it cannot be reopened in the editor again. </para>
				</listitem>
				<listitem>
					<para>Models can be fixed using the same tools, even if they have become incompatible with a new version of the Ecore model.</para>
				</listitem>
			</itemizedlist>
			<para>Xtext targets easy to use and naturally feeling languages. It focuses on the lexical aspects of a language a bit more than on the semantic ones. As a consequence, a referenced Ecore model can contain more concepts than are actually covered by the Xtext grammar. As a result, not everything that is possibly expressed in the EMF model can be serialized back into a textual representation with regards to the grammar. So if you want to use Xtext to serialize your models as described above, it is good to have a couple of things in mind:</para>
			<itemizedlist>
				<listitem>
					<para>Prefer optional rule calls (cardinality 
						<emphasis>?</emphasis> or 
						<emphasis>*</emphasis>) to mandatory ones (cardinality 
						<emphasis>+</emphasis> or default), such that missing references will not obstruct serialization. 
					</para>
				</listitem>
				<listitem>
					<para>You should not use an Xtext-Editor on the same model instance as a self-synchronizing other editor, e.g. a canonical GMF editor (see :#gmf_integration_stage_1 for details). The Xtext parser replaces re-parsed subtrees of the AST rather than modifying it, so elements will become stale. As the Xtext editor continuously re-parses the model on changes, this will happen rather often. It is safer to synchronize editors more loosely, e.g. on file changes. </para>
				</listitem>
				<listitem>
					<para>Implement an 
						<emphasis>IFragmentProvider</emphasis>:#fragmentProvider to make the XtextResource return stable fragments for its contained elements, e.g. based on composite names rather than order of appearance.
					</para>
				</listitem>
				<listitem>
					<para>Implement an 
						<emphasis>IQualifiedNameProvider</emphasis> and an 
						<emphasis>IScopeProvider</emphasis>:#scoping to make the names of all linkable elements in cross-references unique. 
					</para>
				</listitem>
				<listitem>
					<para>Provide an 
						<emphasis>IFormatter</emphasis>:#formatting to improve the readability of the generated textual models.  
					</para>
				</listitem>
				<listitem>
					<para>Register an 
						<emphasis>IReferableElementsUnloader</emphasis> to turn deleted/replaced model elements into EMF proxies. Design the rest of your application such that it does never keep references to  
						<emphasis>EObjects</emphasis> or to cope with proxies. That will improve the stability of your application drastically.
					</para>
				</listitem>
				<listitem>
					<para>Xtext will register an EMF 
						<emphasis>ResourceFactory</emphasis>, so resources with the file extension you entered when generating the Xtext plug-ins will be automatically loaded in an 
						<emphasis>XtextResource</emphasis> when you use EMF’s 
						<emphasis>ResourceSet</emphasis> API to load it.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section id="gmf_integration">
			<title>Integration with GMF Editors</title>
			<para>The 
				<ulink url="http://www.eclipse.org/modeling/gmp/?project=gmf">Graphical Modeling Framework (GMF)</ulink> allows to create graphical diagram editors for Ecore models. To illustrate how to build a GMF on top of an 
				<emphasis>XtextResource</emphasis> we have provided an example. You must have the Helios version 2.3 of GMF Notation, Runtime and Tooling and their dependencies installed in your workbench to run the example. With other versions of GMF it might work to regenerate the diagram code. Choose 
				<emphasis>New-&gt;Examples-&gt;Xtext-&gt;Xtext GMF Integration</emphasis> to import it into your workbench. The example consists of a number of plug-ins
			</para>
			<informaltable>
				<tr>
					<td>Plug-in</td>
					<td>Framework</td>
					<td>Purpose</td>
					<td>Contents</td>
				</tr>
				<tr>
					<td>o.e.x.example.gmf</td>
					<td>Xtext</td>
					<td>Xtext runtime plug-in</td>
					<td>Grammar, derived metamodel and language infrastructure</td>
				</tr>
				<tr>
					<td>o.e.x.e.g.ui</td>
					<td>Xtext</td>
					<td>Xtext UI plug-in</td>
					<td>Xtext editor and services</td>
				</tr>
				<tr>
					<td>o.e.x.e.g.edit</td>
					<td>EMF</td>
					<td>EMF.edit plug-in</td>
					<td>UI services generated from the metamodel</td>
				</tr>
				<tr>
					<td>o.e.x.e.g.models</td>
					<td>GMF</td>
					<td>GMF design models</td>
					<td>Input for the GMF code generator</td>
				</tr>
				<tr>
					<td>o.e.x.e.g.diagram</td>
					<td>GMF</td>
					<td>GMF diagram editor</td>
					<td>Purely generated from the GMF design models</td>
				</tr>
				<tr>
					<td>o.e.x.e.g.d.extensions</td>
					<td>GMF and Xtext</td>
					<td>GMF diagram editor extensions</td>
					<td>Manual extensions to the generated GMF editor for integration with Xtext</td>
				</tr>
				<tr>
					<td>o.e.x.gmf.glue</td>
					<td>Xtext and GMF</td>
					<td>Glue code</td>
					<td>Generic code to integrate Xtext and GMF</td>
				</tr>
			</informaltable>
			<para>We will elaborate the example in three stages.</para>
			<section id="gmf_integration_stage_1">
				<title>Stage 1: Make GMF Read and Write the Semantic Model As Text</title>
				<para>A diagram editor in GMF by default manages two resources: One for the semantic model, that is the model we’re actually interested in for further processing. In our example it is a model representing entities and datatypes. The second resource holds the notation model. It represents the shapes you see in the diagram and their graphical properties. Notation elements reference their semantic counterparts. An entity’s name would be in the semantic model, while the font to draw it in the diagram would be stored the notation model. Note that in the integration example we’re only trying to represent the semantic resource as text.</para>
				<para>To keep the semantic model and the diagram model in sync, GMF uses a so called 
					<emphasis>CanonicalEditPolicy</emphasis>. This component registers as a listener to the semantic model and automatically updates diagram elements when their semantic counterparts change, are added or are removed. Some notational information can be derived from the semantic model by some default mapping, but usually there is a lot of graphical stuff that the user wants to change to make the diagram look better.   
				</para>
				<para>In an Xtext editor, changes in the text are transfered to the underlying 
					<emphasis>XtextResource</emphasis> by a call to the method 
					<emphasis>org.eclipse.xtext.resource.XtextResource.update(int, int, String)</emphasis>, which will trigger a partial parsing of the dirty text region and a replacement of the corresponding subtree in the AST model (semantic model). 
				</para>
				<para>Having an Xtext editor and a canonical GMF editor on the same resource can therefore lead to loss of notational information, as a change in the Xtext editor will remove a subtree in the AST, causing the  
					<emphasis>CanonicalEditPolicy</emphasis> to remove all notational elements, even though it was customized by the user. The Xtext rebuilds the AST and the notation model is restored using the default mapping. It is therefore not recommended to let an Xtext editor and a canonical GMF editor work on the same resource.    
				</para>
				<para>In this example, we let each editor use its own memory instance of the model and synchronize on file changes only. Both frameworks already synchronize with external changes to the edited files out-of-the-box. In the glue code, a 
					<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.gmf.glue/src/org/eclipse/xtext/gmf/glue/concurrency/ConcurrentModificationObserver.java?root=Modeling_Project&amp;view=co">ConcurrentModificationObserver</ulink> warns the user if she tries to edit the same file with two different model editors concurrently.
				</para>
				<para>In the example, we started with writing an Xtext grammar for an entity language. As explained above, we preferred optional assignments and rather covered mandatory attributes in a validator. Into the bargain, we added some services to improve the EMF integration, namely a formatter, a fragment provider and an unloader. Then we let Xtext generate the language infrastructure. From the derived Ecore model and its generator model, we generated the edit plug-in (needed by GMF) and added some fancier icons. </para>
				<para>From the GMF side, we followed the default procedure and created a gmfgraph model, a gmftool model and a gmfmap model referring to the Ecore model derived form the Xtext grammar. We changed some settings in the gmfgen model derived by GMF from the gmfmap model, namely to enable printing and to enable validation and validation decorators. Then we generated the diagram editor.     </para>
				<para>Voilà, we now have a diagram editor that reads/writes its semantic model as text. Also note that the validator from Xtext is already integrated in the diagram editor via the menu bar. </para>
				<section id="Stage2CallingtheXtextParsertoParseGMFLabels">
					<title>Stage 2: Calling the Xtext Parser to Parse GMF Labels</title>
					<para>GMF’s generated parser for the labels is a bit poor: It will work on attributes only, and will fail for cross-references, e.g. an attibute’s type. So why not use the Xtext parser to process the user’s input? </para>
					<para>An 
						<emphasis>XtextResource</emphasis> keeps track of it’s concrete syntax representation by means of a so called node model (see :#parser_rules for a more detailed description). The node model represents the parse tree and provides information on the offset, length and text that has been parsed to create a semantic model element. The nodes are attached to their semantic elements by means of a node adapter.    
					</para>
					<para>We can use the node adapter to access the text block that represents an attribute, and call the Xtext parser to parse the user input. The example code is contained in  
						<ulink url="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext.gmf.glue/src/org/eclipse/xtext/gmf/glue/edit/part/AntlrParserWrapper.java?root=Modeling_Project&amp;view=co">AntlrParserWrapper</ulink>. 
						<emphasis>SimplePropertyWrapperEditPartOverride</emphasis> shows how this is integrated into the generated GMF editor. Use the 
						<emphasis>EntitiesEditPartFactoryOverride</emphasis> to instantiate it and the 
						<emphasis>EntitiesEditPartProviderOverride</emphasis> to create the overridden factory, and register the latter to the extension point. Note that this is a non-invasive way to extend generated GMF editors.
					</para>
					<para>When you test the editor, you will note that the node model will be corrupt after editing a few labels. This is because the node model is only updated by the Xtext parser and not by the serializer. So we need a way to automatically call the (partial) parser every time the semantic model is changed. You will find the required classes in the package 
						<emphasis>org.eclipse.xtext.gmf.glue.editingdomain</emphasis>. To activate node model reconciling, you have to add a line 
					</para>
					<literallayout><code>XtextNodeModelReconciler.adapt(editingDomain);

</code></literallayout>
					<para>in the method 
						<emphasis>createEditingDomain()</emphasis> of the generated 
						<emphasis>EntitiesDocumentProvider</emphasis>. To avoid changing the generated code, you can modify the code generation template for that class by setting
					</para>
					<literallayout><code>Dynamic Templates -&gt; true
	   Template Directory -&gt; "org.eclipse.xtext.example.gmf.models/templates"
	   
</code></literallayout>
					<para>in the 
						<emphasis>GenEditorGenerator</emphasis> and 
					</para>
					<literallayout><code>Required Plugins -&gt; "org.eclipse.xtext.gmf.glue" 

</code></literallayout>
					<para>in the 
						<emphasis>GenPlugin</emphasis> element of the gmfgen before generating the diagram editor anew.
					</para>
				</section>
				<section id="Stage3APopupXtextEditorexperimental">
					<title>Stage 3: A Popup Xtext Editor (experimental)</title>
					<para>
						<emphasis>SimplePropertyPopupXtextEditorEditPartOverride</emphasis> demonstrates how to spawn an Xtext editor to edit a model element. The editor pops up in its control and shows only the section of the selected element. It is a fully fledged Xtext editor, with support of validation, code assist and syntax highlighting. The edited text is only transfered back to the model if it does not have any errors.   
					</para>
					<para>Note that there still are synchronization issues, that’s why we keep this one marked as experimental.</para>
				</section>
			</section>
		</section>
	</chapter>
	<chapter id="migrating_from_0_7">
		<title>Migrating from Xtext 0.7.x to 1.0</title>
		<para>Most of the tasks when migrating to Xtext 1.0 can be automated. Some changes will be necessary in the manually written code where you have to carefully
			verify that your implementation is still working with Xtext 1.0. A reliable test-suite helps a lot. </para>
		<para>The grammar language is fully backward compatible. You should not have to apply any changes in the primary artifact. However, we introduced some additional
			validation rules that mark inconsistencies in your grammar. If you get any warnings in the grammar editor, it should be straight forward to fix them.</para>
		<para>
			<emphasis>Tip: You’ll learn something about the new features if you compare a freshly created Xtext project based on 0.7.x with a new Xtext project based on 1.0. Especially the new fragments in the workflow are a good indicator for useful new features.</emphasis> 
		</para>
		<section id="TaketheShortcut">
			<title>Take the Shortcut</title>
			<para>If you haven’t made too many customizations to the generated defaults and if you’re not referencing many classes of your Xtext language from the outside, you might consider starting with a new Xtext project, copying your grammar and then manually restoring your changes step by step. If that does not work for you, go on reading!</para>
		</section>
		<section id="MigratingStepByStep">
			<title>Migrating Step By Step</title>
			<para>Before you start the migration to Xtext 1.0, you should make sure that no old plug-ins are in your target platform. Some plug-ins from Xtext 0.7.x have been merged and 
				do no longer exist. </para>
			<para>
				<emphasis>Tip: The following steps try to use the Eclipse compiler to spot any source-incompatible changes while fixing them with only a few well described user actions. Doing these steps in another order causes most likely a higher effort.</emphasis>
			</para>
			<section id="UpdatethePluginDependenciesandImportStatements">
				<title>Update the Plug-in Dependencies and Import Statements</title>
				<para>You should update the constraints from version 
					<emphasis>0.7.x</emphasis> to 
					<emphasis>[1.0.0,2.0.0)</emphasis> in your manifest files if you specified any concrete versions.
					Make sure that your 
					<emphasis>dsl.ui</emphasis>-projects do not refer to the plug-in 
					<emphasis>org.eclipse.xtext.ui.common</emphasis> or 
					<emphasis>org.eclipse.xtext.ui.core</emphasis> but to 
					<emphasis>org.eclipse.xtext.ui</emphasis> instead. The arguably easiest way is a global text-based search and replace across the manifest files. The bundle 
					<emphasis>org.eclipse.xtext.log4j</emphasis> is obsolete as well. The generator will create 
					<emphasis>import-package</emphasis> entries in the manifests later on.
				</para>
				<para>The next step is to fix the import statements in your classes to match the refactored naming scheme in Xtext. Perform a global search for "
					<emphasis>import org.eclipse.xtext.ui.common.</emphasis>" and 
					"
					<emphasis>import org.eclipse.xtext.ui.core.</emphasis>" and replace the matches with "
					<emphasis>import org.eclipse.xtext.ui.</emphasis>". This fixes most of the problems in the manually written code. 
				</para>
			</section>
			<section id="RenamethePackagesinthedsl.uiPlugin">
				<title>Rename the Packages in the dsl.ui-Plug-in</title>
				<para>We changed the naming pattern for artifacts in the 
					<emphasis>dsl.ui</emphasis>-plug-in to match the OSGI conventions. The easiest way to update your existing projects is to apply a 
&#8222;					Rename Package” refactoring on the packages in the 
					<emphasis>src</emphasis>- and 
					<emphasis>src-gen</emphasis> folder 
					<emphasis role="bold">before</emphasis> you re-run the workflow that regenerates your language. Make sure you ticked &#8222;Rename sub-packages” in the dialog. It is error-prone to enable the search in non-Java files as this will perform incompatible changes in the manifest files. Furthermore, it is important to perform the rename operation in the 
					<emphasis>src-gen</emphasis> folder, too. This ensures that the references in your manually written code are properly updated.
				</para>
			</section>
			<section id="UpdatetheWorkflow">
				<title>Update the Workflow</title>
				<para>The 
					<emphasis>JavaScopingFragment</emphasis> does no longer exist. It has been superseded by the 
					<emphasis>ImportURIScopingFragment</emphasis> in combination with the 
					<emphasis>SimpleNamesFragment</emphasis>.
					Please replace  
				</para>
				<literallayout><code>&lt;fragment 
    class="org.eclipse.xtext.generator.scoping.JavaScopingFragment"/&gt;
</code></literallayout>
				<para>with</para>
				<literallayout><code>&lt;fragment 
    class="org.eclipse.xtext.generator.scoping.ImportURIScopingFragment"/&gt;
&lt;fragment 
    class="org.eclipse.xtext.generator.exporting.SimpleNamesFragment"/&gt;
</code></literallayout>
				<para>The 
					<emphasis>PackratParserFragment</emphasis> has been abandoned as well. It is save to remove the reference to that one if it is activated in your workflow. After you’ve changed your workflow, it should be possible to regenerate your language without any errors in the console. It is ok to have compilation errors prior to executing the workflow.
				</para>
			</section>
			<section id="MANIFEST.MFandplugin.xml">
				<title>MANIFEST.MF and plugin.xml</title>
				<para>The previous rename package refactoring updated most of the entries in the 
					<emphasis>MANIFEST.MF</emphasis> and and some entries in the 
					<emphasis>plugin.xml</emphasis>. Others have to be fixed manually. The Eclipse compiler will point to many of the remaining problems in the manifest files but it is unlikely that it will spot the erroneous references in the 
					<emphasis>plugin.xml</emphasis>.
				</para>
				<itemizedlist>
					<listitem>
						<para>In the generated UI plug-in’s 
							<emphasis>MANIFEST.MF</emphasis>, remove the package exports of no longer existing packages and make sure the bundle activator points to the newly generated one (with 
							<emphasis>.ui.</emphasis> in its package name).  
						</para>
					</listitem>
					<listitem>
						<para>It was already mentioned that the plug-ins 
							<emphasis>org.eclipse.xtext.ui.core</emphasis> and 
							<emphasis>org.eclipse.xtext.ui.common</emphasis> have been merged into a new single plug-in 
							<emphasis>org.eclipse.xtext.ui</emphasis>. The same happened to the respective Java packages. Change eventually remaining bundle-dependencies in all manifests. 
						</para>
					</listitem>
					<listitem>
						<para>The plug-in 
							<emphasis>org.eclipse.xtext.log4j</emphasis> no longer exists. We use a package import of 
							<emphasis>org.apache.log4j</emphasis> instead. Also remove the buddy registration. 
						</para>
					</listitem>
					<listitem>
						<para>Due to renamed packages, you have to fix all references to classes therein in the 
							<emphasis>plugin.xml</emphasis>. A diff with the _plugin.xml___gen_ will be a great help. If you haven’t added a lot manually, consider merging these into the generated version instead of going the other way around. Note that warnings in the 
							<emphasis>plugin.xml</emphasis> can be considered to be real errors most of the time. Make sure
						</para>
						<itemizedlist>
							<listitem>
								<para>the 
									<emphasis>ExecutableExtensionFactory</emphasis> has the 
									<emphasis>.ui.</emphasis> package prefix
								</para>
							</listitem>
							<listitem>
								<para>classes from 
									<emphasis>org.eclipse.xtext.ui.common</emphasis> and 
									<emphasis>org.eclipse.xtext.ui.core</emphasis> are now usually somewhere in 
									<emphasis>org.eclipse.xtext.ui</emphasis>. They are also referenced by the 
									<emphasis>ExecutableExtensionFactory</emphasis> and thus not covered by the editor’s validation. 
								</para>
							</listitem>
						</itemizedlist>
					</listitem>
					<listitem>
						<para>A number of new features are being registered in the 
							<emphasis>plugin.xml</emphasis>, e.g. 
							<emphasis>Find references</emphasis>, 
							<emphasis>Quick Outline</emphasis>, and 
							<emphasis>Quick Fixes</emphasis>. You can enable them by manually copying the respective entries from _plugin.xml___gen_ to  
							<emphasis>plugin.xml</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>To run MWE2 workflows later on, you must change the plug-in dependencies from 
							<emphasis>org.eclipse.emf.mwe.core</emphasis> to 
							<emphasis>org.eclipse.emf.mwe2.launch</emphasis> in your manifest. Optional resolution is fine.
						</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="NoteworthyAPIChanges">
				<title>Noteworthy API Changes </title>
				<para>The 
					<emphasis>src</emphasis> folders are generated once, so existing code will not be overwritten but has to be updated manually. At least one new class has appeared in your 
					<emphasis>src</emphasis>-folder of the 
					<emphasis>ui</emphasis> plug-in. there will now be a 
					<emphasis>StandaloneSetup</emphasis> inheriting form the generated 
					<emphasis>StandaloneSetupGenerated</emphasis> to allow customization.
				</para>
				<para>You will face a couple of compilation problems due to changes in the API. Here’s a list of the most prominent changes. It is usually only necessary to change your code, if you face any compilation problems.</para>
				<itemizedlist>
					<listitem>
						<para>The method 
							<emphasis>IScopeProvider.getScope(EObject,EClass)</emphasis> has been removed. Use  
							<emphasis>IScopeProvider.getScope(EObject,EReference)</emphasis> instead. 
						</para>
					</listitem>
					<listitem>
						<para>Renamed 
							<emphasis>DefaultScopeProvider</emphasis> to 
							<emphasis>SimpleNameScopeProvider</emphasis>. There have been further significant changes in the scoping API that allow for optimized implementations. Consult the 
							<link linkend="scoping">section on scoping</link> for details.
						</para>
					</listitem>
					<listitem>
						<para>The return type of 
							<emphasis>AbstractInjectableValidator.getEPackages()</emphasis> was changed from 
							<emphasis>List&lt;? extends EPackage&gt;</emphasis> to 
							<emphasis>List&amp;lt;EPackage&gt;</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>The parser interfaces now use 
							<emphasis>java.io.Reader</emphasis> instead of 
							<emphasis>java.io.InputStream</emphasis> to explicitly address encoding. Have a look at the 
							<link linkend="encoding">section on encoding</link> for details.
						</para>
					</listitem>
					<listitem>
						<para>The handling of 
							<emphasis>ILabelProvider</emphasis> in various contexts has been refactored. The former base class 
							<emphasis>DefaultLabelProvider</emphasis> no longer exists. Use the 
							<emphasis>DefaultEObjectLabelProvider</emphasis> instead. See the 
							<link linkend="labelProvider">section on label providers</link> for details. 
						</para>
					</listitem>
					<listitem>
						<para>We have introduced a couple of new packages to better separate concerns. Most classes should be easy to relocate. </para>
					</listitem>
					<listitem>
						<para>The runtime and UI modules have separate base classes 
							<emphasis>DefaultRuntimeModule</emphasis> and 
							<emphasis>DefaultUiModule</emphasis> now. We use Guice’s module overrides to combine them with the newly introduced 
							<emphasis>SharedModule</emphasis>.  You have to add a constructor the your 
							<emphasis>UiModule</emphasis> that takes an 
							<emphasis>AbstractUiPlugin</emphasis> as argument and pass that one to the super constructor. 
							<emphasis>Tip: There is an Eclipse quick fix available for that one.</emphasis>
						</para>
					</listitem>
					<listitem>
						<para>The interfaces 
							<emphasis>ILexicalHighlightigConfiguration</emphasis> and 
							<emphasis>ISemanticHighlightingConfiguration</emphasis> have been merged into 
							<emphasis>IHighlightingConfiguration</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>The 
							<emphasis>DefaultTemplateProposalProvider</emphasis> takes an additional, injectable constructor parameter of type 
							<emphasis>ContextTypeIdHelper</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>The 
							<emphasis>HyperlinkHelper</emphasis> uses field injection instead of constructor injection. The method 
							<emphasis>createHyperlinksByOffset</emphasis> should be overridden instead of the former 
							<emphasis>findCrossLinkedEObject</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>The API to skip a node in the outline has changed. Instead of returning the _HIDDEN_NODE_ you’ll have to implement 
							<emphasis>boolean consumeNode(MyType)</emphasis> and return 
							<emphasis>false</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>The 
							<emphasis>Readonly*Storage</emphasis> implementations have been removed. There is a new API to open editors for objects with a given URI. Please use the 
							<emphasis>IURIEditorOpener</emphasis> to create an editor or the 
							<emphasis>IStorage2UriMapper</emphasis> to obtain an 
							<emphasis>IStorage</emphasis> for a given URI.
						</para>
					</listitem>
					<listitem>
						<para>The interfaces 
							<emphasis>IStateAccess</emphasis> and 
							<emphasis>IEObjectHandle</emphasis> have been moved along with the 
							<emphasis>IUnitOfWork</emphasis> to the package 
							<emphasis>org.eclipse.xtext.util.concurrent</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>The 
							<emphasis>ValidationJobFactory</emphasis> is gone. Please implement a custom 
							<emphasis>IResourceValidator</emphasis> instead.
						</para>
					</listitem>
					<listitem>
						<para>The grammar elements 
							<emphasis>Alternatives</emphasis> and 
							<emphasis>Group</emphasis> have a new common super type 
							<emphasis>CompoundElement</emphasis>. The methods 
							<emphasis>getGroups</emphasis> and 
							<emphasis>getTokens</emphasis> have been refactored to 
							<emphasis>getElements</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>Completion proposals take a 
							<emphasis>StyledString</emphasis> instead of a plain string as display string.
						</para>
					</listitem>
					<listitem>
						<para>The 
							<emphasis>AbstractLabelProvider</emphasis> does no longer expose its 
							<emphasis>IImageHelper</emphasis>. Use 
							<emphasis>convertToImage</emphasis> instead or inject your own 
							<emphasis>IImageHelper</emphasis>.
						</para>
					</listitem>
					<listitem>
						<para>The implementation-classes from 
							<emphasis>org.eclipse.xtext.index</emphasis> were superseded by the builder infrastructure. Use the 
							<emphasis>QualifiedNamesFragment</emphasis> and the 
							<emphasis>ImportNamespacesScopingFragment</emphasis> instead of the 
							<emphasis>ImportedNamespacesScopingFragment</emphasis>. Please refer to the section about the builder infrastructure for details.
						</para>
					</listitem>
					<listitem>
						<para>All the Xtend-based fragments were removed. </para>
					</listitem>
					<listitem>
						<para>
							<emphasis>ILinkingService.getLinkText</emphasis> was removed. Have a look at the 
							<emphasis>LinkingHelper</emphasis> and the 
							<emphasis>CrossReferenceSerializer</emphasis> if you relied on this method.
						</para>
					</listitem>
					<listitem>
						<para>The 
							<emphasis>SerializerUtil</emphasis> was renamed to 
							<emphasis>Serializer</emphasis>. There were other heavy refactorings that involved the serializer and its components (like e.g. the 
							<emphasis>ITransientValueService</emphasis>) but it should be pretty straight forward to migrate existing client code.
						</para>
					</listitem>
					<listitem>
						<para>The method-signatures of the 
							<emphasis>IFragmentProvider</emphasis> have changed. The documentation will give a clue on how to update existing implementations.
						</para>
					</listitem>
					<listitem>
						<para>Some static methods were removed from utility classes such as 
							<emphasis>EcoreUtil2</emphasis> and 
							<emphasis>ParsetreeUtil</emphasis> in favor of more sophisticated implementations.
						</para>
					</listitem>
				</itemizedlist>
			</section>
		</section>
		<section id="NowGoForTheNewFeatures">
			<title>Now Go For The New Features</title>
			<para>After migrating, some of the new features in Xtext 1.0 will be automatically available. Others require further configuration.
				We recommend reading the sections about</para>
			<itemizedlist>
				<listitem>
					<para>
						<link linkend="index_based">qualified names and namespace imports</link>
					</para>
				</listitem>
				<listitem>
					<para>
						<link linkend="containers">the builder infrastructure</link>
					</para>
				</listitem>
				<listitem>
					<para>
						<link linkend="quickfixes">quick fixes</link>
					</para>
				</listitem>
				<listitem>
					<para>
						<link linkend="unordered_groups">unordered groups</link>
					</para>
				</listitem>
				<listitem>
					<para>
						<link linkend="quick_outline">quick outline</link>
					</para>
				</listitem>
				<listitem>
					<para>
						<link linkend="MWE2">MWE2</link>
					</para>
				</listitem>
				<listitem>
					<para>
						<link linkend="jvmtypes">refering to Java elements</link>
					</para>
				</listitem>
			</itemizedlist>
			<para>For an overview over the new features consult our 
				<ulink url="http://www.eclipse.org/Xtext/documentation/helios/new_and_noteworthy.php">New and Noteworthy</ulink> online. 
			</para>
		</section>
	</chapter>
	<chapter id="antlr_ip_issue">
		<title>The ANTLR IP Issue (Or Which Parser To Use?)</title>
		<para>In order to be able to parse models written in your language, Xtext needs to provide a special parser 
			for it. The parser is generated from the self defined language grammar. </para>
		<para>It is recommended to use the 
			<ulink url="http://www.antlr.org">ANTLR</ulink> -based parser.
			ANTLR is a very sophisticated parser generator framework which implements a so called LL(*) algorithm.
			It is fast, simple and at the same time has some very nice and sophisticated features. Especially its 
			support for error recovery is much better than what other parser generators provide.
		</para>
		<para>Xtext uses ANTLR 3 which comes in two parts: the runtime and the generator.
			Both are shipped under the BSD license and have a clean intellectual property history. 
			However the ANTLR parser generator is unfortunately still implemented in an older version of itself 
			(v 2.x), where it was not possible for the Eclipse Foundation to ensure where exactly every line of 
			code originated. Therefore ANTLR 2 didn’t get the required IP approval. Eclipse has a strict IP policy, 
			which makes sure that everything provided by Eclipse can be consumed under the terms of the Eclipse 
			Public License. The details are described in 

			<ulink url="http://www.eclipse.org/org/documents/Eclipse_IP_Policy.pdf">this document</ulink>. That is why we are not 
			allowed to ship Xtext with the ANTLR generator but only with the IP approvied runtime components. We 
			have to provide it separately and for your convenience you’ll be asked to download the ANTLR generator 
			when you run your language generator for the first time. You can even download it directly or install 
			an additional plug-in into Eclipse: 
		</para>
		<itemizedlist>
			<listitem>
				<para>
					<ulink url="http://download.itemis.com/antlr-generator-3.0.1.jar">http://download.itemis.com/antlr-generator-3.0.1.jar</ulink>
				</para>
			</listitem>
			<listitem>
				<para>or use the update site at 
					<ulink url="http://download.itemis.com/updates">http://download.itemis.com/updates</ulink>
				</para>
			</listitem>
		</itemizedlist>
		<para>The workflow will not bother you with this issue on subsequent executions as the archive will be stored
			in your project’s root directory and can thereby be reused during the next run. </para>
		<para>
			<emphasis role="bold">IMPORTANT</emphasis> :

			<emphasis role="italic">Although if you use the non-IP approved ANTLR generator, you can still ship any languages and the IDEs you’ve developed with Xtext without any worrying, because it is not needed at runtime</emphasis>
		</para>
	</chapter>
</book>