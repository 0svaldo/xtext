
h2(#validation). Validation

Static analysis or validation is one of the most interesting aspects when developing a programming language. The users of your languages will be grateful
if they get informative feedback as they type. 
In Xtext there are basically three different kinds of validation.

h3. Automatic Validation

Some implementation aspects (e.g. the grammar, scoping) of a language have an impact on what is required for a document or semantic model to be valid. Xtext automatically takes care of this. 

h4(#syntactical_validation). Lexer/Parser: Syntactical Validation

The syntactical correctness of any textual input is validated automatically by the parser. The error messages are generated by the underlying parser technology and cannot be customized using a general hook.
Any syntax errors can be retrieved from the Resource using the common EMF API:

* @org.eclipse.emf.ecore.resource.Resource.getErrors()@
* @org.eclipse.emf.ecore.resource.Resource.getWarnings()@
 
h4(#linking_validation). Linker: Crosslink Validation

Any broken crosslinks can be checked generically. As crosslink resolution is done lazily (see "linking":#linking), any broken links are resolved lazily as well.
If you want to validate whether all links are valid, you will have to navigate through the model so that all installed EMF proxies get resolved. This is done automatically in the editor.

Any unresolvable crosslinks will be reported and can be obtained through:

* @org.eclipse.emf.ecore.resource.Resource.getErrors()@
* @org.eclipse.emf.ecore.resource.Resource.getWarnings()@

h4(#concrete_syntax_validation). Serializer: Concrete Syntax Validation

The ${org.eclipse.xtext/src/org.eclipse.xtext.validation.IConcreteSyntaxValidator} validates all constraints that are implied by a grammar. Meeting these constraints for a model is mandatory to be serialized.

Example:

bc.. MyRule:
  ({MySubRule} "sub")? (strVal+=ID intVal+=INT)*;
	
p. This implies several constraints:
# Types: only instances of @MyRule@ and @MySubRule@ are allowed for this rule. Sub-types are prohibited, since the parser never instantiates unknown sub-types.
# Features: In case the @MyRule@ and @MySubRule@ have @EStructuralFeatures@ besides @strVal@ and @intVal@, only @strVal@ and @intVal@ may have "non-transient values":#transientvalues.
# Quantities: The following condition must be true: @strVal.size() == intVal.size()@.
# Values: It must be possible to "convert all values":#valueconverter to valid tokens for terminal rule @STRING@.  The same is true for @intVal@ and @INT@.

p. The typical use cases for the concrete syntax validator are validation in non-Xtext-editors that, however, use an @XtextResource@. This is, for example, the case when combining GMF and Xtext. Another use case is when the semantic model is modified "manually" (not by the parser) and then serialized again. Since it is very difficult for the serializer to provide "meaningful error messages":#parsetreeconstructor, the concrete syntax validator is executed by default before serialization. A textual Xtext editor itself, however, is _not_ a valid use case. Here, the parser ensures that all syntactical constraints are met. Therefore, the is no value in additionally running the concrete syntax validator.  

p. There are some limitations to the concrete syntax validator which result from the fact that it treats the grammar as declarative, which is something the parser doesn't always do.
* Grammar rules containing assigned actions (e.g. @{MyType.myFeature=current}@ are ignored. Unassigned actions (e.g. @{MyType}@), however, are supported. 
* Grammar rules that delegate to one or more rules containing assigned actions via unassigned rule calls are ignored.
* Orders within list-features can not be validated. e.g. @Rule: (foo+=R1 foo+=R2)*@ implies that @foo@ is expected to contain instances of @R1@ and @R1@ in an alternating order. 

p. To use concrete syntax validation you can let Guice inject an instance of ${org.eclipse.xtext/src/org.eclipse.xtext.validation.IConcreteSyntaxValidator} and use it directly. Furthermore, there is an adapter (${org.eclipse.xtext/src/org.eclipse.xtext.validation.impl.ConcreteSyntaxEValidator}) allows integrating of the concrete syntax validator as an @EValidator@. You can, for example, enable it in your runtime module, by adding:

bc.. @SingletonBinding(eager = true)
public Class<? extends ConcreteSyntaxEValidator> bindConcreteSyntaxEValidator() {
  return ConcreteSyntaxEValidator.class;
}
p. To customize error messages please see ${org.eclipse.xtext/src/org.eclipse.xtext.validation.IConcreteSyntaxDiagnosticProvider} and subclass ${org.eclipse.xtext/src/org.eclipse.xtext.validation.impl.ConcreteSyntaxDiagnosticProvider}.


h3(#custom_validation). Custom Validation

In addition to the afore mentioned kinds of validation, which are more or less done automatically, you can specify additional constraints specific for your Ecore model.
We leverage existing EMF API (mainly @EValidator@) and have put some convenience stuff on top. 
Basically all you need to do is to make sure that an @EValidator@ is registered for your @EPackage@. The registry for @EValidators@ (@EValidator.Registry.INSTANCE@) can only be filled programmatically.
That means contrary to the EPackage and @Resource.Factory@ registries there is no Equinox extension point to populate the validator registry.

For Xtext we provide a "generator fragment":#generator_fragment for the convenient Java-based @EValidator@ API. Just add the following fragment to your generator configuration and you are good to go:

bc.. <fragment class=
  "org.eclipse.xtext.generator.validation.JavaValidatorFragment"/>

p. The generator will provide you with two Java classes. An abstract class generated to @src-gen/@ which extends the library class @AbstractDeclarativeValidator@. This one just registers the EPackages for which this validator introduces constraints.
The other class is a subclass of that abstract class and is generated to the @src/@ folder in order to be edited by you. That's where you put the constraints in.

The purpose of the @AbstractDeclarativeValidator@ is to allow you to write constraints in a declarative way - as the class name already suggests. That is instead of writing exhaustive if-else constructs or extending the generated EMF switch you just have to add the <code>@Check</code> annotation to any method and it will be invoked automatically when validation takes place.
Moreover you can state for what type the respective constraint method is, just by declaring a typed parameter. This also lets you avoid any type casts.  
In addition to the reflective invocation of validation methods the @AbstractDeclarativeValidator@ provides a couple of convenient assertions.

All in all this is very similar to how JUnit works. Here is an example:

bc.. 
public class DomainmodelJavaValidator 
  extends AbstractDomainmodelJavaValidator {
    
  @Check
  public void checkTypeNameStartsWithCapital(Type type) {
    if (!Character.isUpperCase(type.getName().charAt(0)))
      warning("Name should start with a capital", 
        DomainmodelPackage.TYPE__NAME);
  }
}

h3(#quickfixes). Quickfixes

For validations written using the @AbstractDeclarativeValidator@ it is possible to provide corresponding quickfixes in the editor. To be able to implement a quickfix for a given diagnostic (a warning or error) the underlying _cause_ of the diagnostic must be known (i.e. what actual problem does the diagnostic represent?), otherwise the fix doesn't know what needs to be done. As we don't want to deduce this from the diagnostic's error message we associate a problem specific _code_ with the diagnostic.

In the following example (from ${org.eclipse.xtext.example.domainmodel/src/org.eclipse.xtext.example.validation.DomainmodelJavaValidator}) the diagnostic's _code_ is given by the last argument to the @warning()@ method and it is a reference to the static @String@ field @INVALID_TYPE_NAME@ in the validator class.

bc.. 
      warning("Name should start with a capital", 
        DomainmodelPackage.TYPE__NAME, INVALID_TYPE_NAME, type.getName());

p. Now that the validation has a unique code identifying the problem we can register quickfixes against it. We start by adding the @org.eclipse.xtext.ui.generator.quickfix.QuickfixProviderFragment@ to our workflow and after regenerating the code we should find an empty class @MyDslQuickfixProvider@ in our DSL's UI project.

Continuing with the @INVALID_TYPE_NAME@ problem from the Domainmodel example we add a method with which the problem can be fixed (see also ${org.eclipse.xtext.example.domainmodel.ui/src/org.eclipse.xtext.example.quickfix.DomainmodelQuickfixProvider}):

bc.. 
@Fix(DomainmodelJavaValidator.INVALID_TYPE_NAME)
public void fixName(final Issue issue, IssueResolutionAcceptor acceptor) {
		acceptor.accept(issue, "Capitalize name", "Capitalize name  of '" + issue.getData()[0] + "'", "upcase.png", new IModification() {
		public void apply(IModificationContext context) throws BadLocationException {
			IXtextDocument xtextDocument = context.getXtextDocument();
			String firstLetter = xtextDocument.get(issue.getOffset(), 1);
			xtextDocument.replace(issue.getOffset(), 1, Strings.toFirstUpper(firstLetter));
	}
	});
}

p. By using the correct signature (see below) and annotating the method with the @Fix@ annotation referencing the code we specified in the validator, Xtext knows that this method implements a fix for the problem. This also allows us to annotate multiple methods as fixes for the same problem.

The first three parameters given to the ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor} define the UI representation of the quickfix. As the document is not necessarily loaded when the quickfix is offered, we need to provide any additional data from the model that we want to refer to in the UI when creating the issue in the validator above. In this case, we provided the existing type name.

The actual model modification is implemented in the ${org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/model/edit/IModification}. The ${org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/model/edit/IModificationContext} provides access to the erroneous document.  

If you prefer to implement the quickfix in terms of the semantic model use a ${org.eclipse.xtext.ui/src/org/eclipse/xtext/ui/editor/model/edit/ISemanticModification.java} instead. Its @apply(EObject, IModificationContext)@ method will be invoked inside a modification transaction and the first argument will be the erroneous semantic element. This makes it very easy for the fix method to modify the model as necessary. After the method returns the model as well as the Xtext editor's content will be updated accordingly. If the method fails (throws an exception) the change will not be committed.

h3(#check_based_validation). Validation with the Check language

In addition to the Java-based validation code you can use the language Check (from M2T/Xpand) to implement constraint checks against your model. To do so, you have to configure the "generator":#generator with the
${org.eclipse.xtext.generator/src/org.eclipse.xtext.generator.validation.CheckFragment}.
Please note, that you can combine both types of validation in your project. 

bc.. <fragment class=
  "org.eclipse.xtext.generator.validation.CheckFragment"/>
  
p. After regenerating your language artifacts you will find three new files "YourLanguageChecks.chk", "YourLanguageFastChecks.chk" and "YourLanguageExpensiveChecks.chk" in the @src/@ folder in the sub-package @validation@.  The checks in these files will be executed when saving a file, while typing (FastChecks) or when triggering the validation explicitly (ExpensiveChecks). When using Check the example of the previous chapter could be written like this.

bc.. context Type#name WARNING "Name should start with a capital":
  name.toFirstUpper() == name;  

p. Each check works in a specific context (here: @Type@) and can further denote a feature to which a warning or error should be attached to (here: @name@). Each check could either be a @WARNING@ or an @ERROR@ with a given string to explain the situation. The essential part of each check is an invariant that must hold true for the given context. If it fails the check will produce an issue with the provided explanation.

 Please read more about the Check language as well as the underlying expression language in Xpand's reference documentation which is shipped as Eclipse help. 
 
h3(#test_validators). Test Validators
 
If you have implemented your validators by extending ${org.eclipse.xtext/src/org.eclipse.xtext.validation.AbstractDeclarativeValidator}, there are helper classes which may assist you when testing your validators.

Testing validators typicallally works as follows: 
# The test creates some models which intentionally violate some constraints.
# The test runs some choosen @Check-methods from the validator.
# The test asserts whether the @Check-methods have raised the expected warnings and errors.

To create models, you can either use EMF's @ResourceSet@ to load models from your hard disk or you can utilize the @<MyLanguage>Factory@ (which EMF generates for each @EPackage@) to construct the needed model elements manually. While the fist option has the advantages that you can edit your models in your textual concrete syntax, the second option has the advantage that you can create partial models.

To run the @Check-methods and ensure they raise the intended errors and warnings, you can utilize ${org.eclipse.xtext/src/org.eclipse.xtext.validation.ValidatorTester} as shown by the following example:

p. Validator:

bc.. public class MyLanguageValidator extends AbstractDeclarativeValidator {
  @Check
  public void checkFooElement(FooElement element) {
    if(element.getBarAttribute().contains("foo"))
      error("Only Foos allowed", element, MyLanguagePackage.FOO_ELEMENT__BAR_ATTRIBUTE, 101);
  }
}

p. JUnit-Test:

bc.. public class MyLanguageValidatorTest extends TestCase {

  private ValidatorTester<MyLanguageValidator> tester;

  @Override
  public void setUp() {
    MyLanguageValidator val = new MyLanguageValidator();
    new MyLanguageStandaloneSetup().createInjectorAndDoEMFRegistration().injectMembers(val);
    tester = new ValidatorTester<TestingValidator>(val);
  }

  public void testError() {
    FooElement model = MyLanguageFactory.eINSTANCE.createFooElement()
    model.setBarAttribute("barbarbarbarfoo");
    
    tester.validator().checkFooElement(model);
    tester.diagnose().assertError(101);
  }
  
  public void testError2() {
    FooElement model = MyLanguageFactory.eINSTANCE.createFooElement()
    model.setBarAttribute("barbarbarbarfoo");
    
    tester.validate(model).assertError(101);
  }
}

p. This example uses JUnit 3, but since the involved classes from Xtext have no dependency on JUnit whatsoever, JUnit 4 and other testing frameworks will work as well.  JUnit runs the @setUp()@-method before each testcase and thereby helps to create some common state. In this example, the validator (@MyLanguageValidator@) is instantiated manually and initialized via Google Guice's dependency injection. Then the @ValidatorTester@ is created. It acts as a wrapper for the validator, ensures that the validator has a valid state and provides convenient access to the validator itself (@tester.validator()@) as well as to the utility classes which assert diagnostics created by the validator (@tester.diagnose()@). Please be aware that you have to call @validator()@ before you can call @diagnose()@. However, you can call @validator()@ multiple times in a row.

While @validator()@ allows to call the validator's @Check-methods directly, @validate(model)@ leaves it to the framework to call the applicable @Check-methods. However, to avoid side-effects between tests, it is recommended to call the @Check-methods directly.

@diagnose()@ and @validate(model)@ return an object of type @{org.eclipse.xtext/src/org/eclipse/xtext/validation/AssertableDiagnostics} which provides several @assert@-methods to verify whether the expected diagnostics are present:

* @assertError(int code)@: There must be one diagnostic with severity ERROR and the supplied error code.
* @assertErrorContains(String messageFragment)@:  There must be one diagnostic with severity ERROR and its message must contain @messageFragment@.
* @assertError(int code, String messageFragment)@: Verifies severity, error code and messageFragment.
* @assertWarning(...)@: This method is available for the same combination of parameters as @assertError()@.
* @assertOK()@: Expects that no diagnostics (errors, warnings etc.) have been raised.   
* @assertDiagnostics(int severity, int code, String messageFragment)@: Verifies severity, error code and messageFragment.
* @assertAll(DiagnosticPredicate... predicates)@: Allows to describe multiple diagnostics at the same time and verifies that all of them are present. Class @{org.eclipse.xtext/src/org/eclipse/xtext/validation/AssertableDiagnostics} contains static @error()@ and @warning()@-methods which help to create the needed @DiagnosticPredicate@. Example: @assertAll(error(123), warning("some part of the message"))@. 
* @assertAny(DiagnosticPredicate predicate)@: Asserts that a diagnostic exists which matches the predicate. 

