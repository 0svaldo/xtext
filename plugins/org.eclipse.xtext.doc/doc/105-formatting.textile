
h2(#formatting). Formatting (Pretty Printing)

p. A formatter can be implemented via the ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.IFormatter} 
service. Technically speaking, a formatter is a "Token Stream":#tokenstream which 
inserts/removes/modifies hidden tokens (whitespace, line-breaks, comments).

The formatter is invoked during the "serialization phase":#serialization and when the user triggers 
formatting in the editor (for example, using the CTRL+SHIFT+F shortcut).

Xtext ships with two formatters:
* The ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.OneWhitespaceFormatter} simply writes one whitespace between all tokens.
* The ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter} allows advanced configuration using a ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.FormattingConfig}. Both are explained in the "next chapter":#declarativeformatter.

h3(#declarativeformatter). Declarative Formatter

p. A declarative formatter can be implemented by sub-classing 
${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter}, as shown in 
the following example:

bc.. 
public class ExampleFormatter extends AbstractDeclarativeFormatter {

  @Override
  protected void configureFormatting(FormattingConfig c) {
    ExampleLanguageGrammarAccess f = getGrammarAccess();
    
    c.setAutoLinewrap(120);
    
    // find common keywords an specify formatting for them
    for (Pair<Keyword, Keyword> pair : f.findKeywordPairs("(", ")")) {
      c.setNoSpace().after(pair.getFirst());
      c.setNoSpace().before(pair.getSecond());
    }
    for (Keyword comma : f.findKeywords(",")) {
      c.setNoSpace().before(comma);
    }

    // formatting for grammar rule Line
    c.setLinewrap(2).after(f.getLineAccess().getSemicolonKeyword_1());
    c.setNoSpace().before(f.getLineAccess().getSemicolonKeyword_1());
    
    // formatting for grammar rule TestIndentation
    c.setIndentationIncrement().after(
        f.getTestIndentationAccess().getLeftCurlyBracketKeyword_1());
    c.setIndentationDecrement().before(
        f.getTestIndentationAccess().getRightCurlyBracketKeyword_3());
    c.setLinewrap().after(
        f.getTestIndentationAccess().getLeftCurlyBracketKeyword_1());
    c.setLinewrap().after(
        f.getTestIndentationAccess().getRightCurlyBracketKeyword_3());
    
    // formatting for grammar rule Param
    c.setNoLinewrap().around(f.getParamAccess().getColonKeyword_1());
    c.setNoSpace().around(f.getParamAccess().getColonKeyword_1());
    
    // formatting for Comments 
    cfg.setLinewrap(0, 1, 2).before(g.getSL_COMMENTRule());
    cfg.setLinewrap(0, 1, 2).before(g.getML_COMMENTRule());
    cfg.setLinewrap(0, 1, 1).after(g.getML_COMMENTRule());
  }
}

p. The formatter has to implement the method _configureFormatting(...)_ which declaratively sets up 
a ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.FormattingConfig}.

The ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.FormattingConfig} consist of general 
settings and a set of formatting instructions:

h4. General FormattingConfig Settings

* _setAutoLinewrap(int)_ defines the amount of characters after which a line-break should be dynamically inserted between two tokens. The instructions _setNoLinewrap().???()_,  _setNoSpace().???()_ and _setSpace(space).???()_ suppress this behavior locally. The default is 80.

h4. FormattingConfig Instructions

p. Per default, the "declarative formatter":#declarativeformatter inserts one whitespace between two 
tokens. Instructions can be used to specify a different behavior. They consist of two parts: _When_ 
to apply the instruction and _what_ to do.

To understand _when_ an instruction is applied think of a stream of tokens whereas each token is 
associated with the corresponding grammar element. The instructions are matched against these grammar 
elements. The following matching criteria exist:
* _after(ele)_: The instruction is applied after the grammar element _ele_ has been matched. For example, if your grammar uses the keyword ";" to end lines, this can instruct the formatter to insert a line break after the semicolon.  
* _before(ele)_: The instruction is executed before the matched element. For example, if your grammar contains lists which separate their values with the keyword ",", you can instruct the formatter to suppress the whitespace before the comma.
* _around(ele)_: This is the same as _before(ele)_ combined with  _after(ele)_.  
* _between(ele1, ele2)_: This matches if _ele2_ directly follows _ele1_ in the document. There may be no other tokens in between _ele1_ and _ele2_.
* _bounds(ele1, ele2)_: This is the same as _after(ele1)_ combined with  _before(ele2)_.
* _range(ele1, ele2)_: The rule is enabled when _ele1_ is matched, and disabled when _ele2_ is matched. Thereby, the rule is active for the complete region which is surrounded by _ele1_ and _ele2_.

p. The term _tokens_ is used slightly different here compared to the parser/lexer. Here, a token is a 
keyword or the string that is matched by a terminal rule, data type rule or cross reference. In the 
terminology of the lexer a data type rule can match a composition of multiple tokens.

p. The parameter _ele_ can be a grammar's _AbstractElement_ or a grammar's _AbstractRule_. All grammar 
rules and almost all abstract elements can be matched. This includes rule calls, parser rules, groups 
and alternatives. The semantic of _before(ele)_, _after(ele)_, etc. for rule calls and parser rules is 
identical to when the parser would "pass" this part of the grammar. The stack of called rules is taken 
into account. The following abstract elements can *not* have assigned formatting instructions:
* Actions. E.g. _{MyAction}_ or _{MyAction.myFeature=current}_.
* Grammar elements nested in data type rules. This is due to to the fact that tokens matched by a data type rule are treated as atomic by the serializer. To format these tokens, please implement a "ValueConverter":#valueconverter. 
* Grammar elements nested in _CrossReferences_.

After having explained how rules can be activated, this is what they can do:
* _setIndentationIncrement()_ increments indentation by one unit at this position. Whether one unit consists of one tab-character or spaces is defined by ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.IIndentationInformation}. The default implementation consults Eclipse's _PreferenceStore_.
* _setIndentationDecrement()_ decrements indentation by one unit.
* _setLinewrap()_: Inserts a line-wrap at this position.
* _setLinewrap(int count)_: Inserts _count_ numbers of line-wrap at this position.
* _setLinewrap(int min, int default, int max)_: If the amount of line-wraps that have been at this position before formatting can be determined (i.g. when a node model is present), then the amount of of line-wraps is adjusted to be within the interval [_min_, _max_] and is then reused. In all other cases _default_ line-wraps are inserted. Example: _setLinewrap(0, 0, 1)_ will preserve existing line-wraps, but won't allow more than one line-wrap between two tokens.    
* _setNoLinewrap()_: Suppresses automatic line wrap, which may occur when the line's length exceeds the defined limit.
* _setSpace(String space)_: Inserts the string _space_ at this position. If you use this to insert something else than whitespace, tabs or newlines, a small puppy will die somewhere in this world.
* _setNoSpace()_: Suppresses the whitespace between tokens at this position. Be aware that between some tokens a whitespace is required to maintain a valid concrete syntax. 

h4. Grammar Element Finders

Sometimes, if a grammar contains many similar elements for which the same formatting instructions ought 
to apply, it can be tedious to specify them for each grammar element individually. The 
${org.eclipse.xtext/src/org.eclipse.xtext.IGrammarAccess} provides convenience methods for this. The 
find methods are available for the grammar and for each parser rule.

* _findKeywords(String... keywords)_ returns all keywords that equal one of the parameters.
* _findKeywordPairs(String leftKw, String rightKw)_: returns tuples of keywords from the same grammar rule. Pairs are matched nested and sequentially.  Example: for _Rule: '(' name=ID ('(' foo=ID ')') ')' | '(' bar=ID ')'_ _findKeywordPairs("(", ")")_ returns three pairs.