
h2(#quickfixes). Quick Fixes

For validations written using the 
${org.eclipse.xtext/src/org.eclipse.xtext.validation.AbstractDeclarativeValidator}:#custom_validation 
it is possible to provide corresponding quick fixes in the editor. To be able to implement a quick fix 
for a given diagnostic (a warning or error) the underlying _cause_ of the diagnostic must be known 
(i.e. what actual problem does the diagnostic represent?), otherwise the fix doesn't know what needs 
to be done. As we don't want to deduce this from the diagnostic's error message we associate a problem 
specific _code_ with the diagnostic.

In the following example taken from the _DomainmodelJavaValidator_ 
the diagnostic's _code_ is given by the third argument to the _warning()_ method and it is a reference 
to the static _String_ field _INVALID_TYPE_NAME_ in the validator class.

bc.. warning("Name should start with a capital", 
    DomainmodelPackage.TYPE__NAME, INVALID_TYPE_NAME, type.getName());

p. Now that the validation has a unique code identifying the problem we can register quick fixes for it. 
We start by adding the 
${org.eclipse.xtext.generator/src/org.eclipse.xtext.ui.generator.quickfix.QuickfixProviderFragment} 
to our workflow and after regenerating the code we should find an empty class _MyDslQuickfixProvider_ 
in our DSL's UI project and new entries in the _plugin.xml___gen_ file.

Continuing with the _INVALID_TYPE_NAME_ problem from the Domainmodel example we add a method with which 
the problem can be fixed (have a look at the _DomainmodelQuickfixProvider_ for details):

bc.. @Fix(DomainmodelJavaValidator.INVALID_TYPE_NAME)
public void fixName(final Issue issue, IssueResolutionAcceptor acceptor) {
  acceptor.accept(issue, 
    "Capitalize name", // quick fix label
    "Capitalize name  of '" + issue.getData()[0] + "'",  // description 
    "upcase.png",      // quick fix icon
    new IModification() {
      public void apply(IModificationContext context) 
                                             throws BadLocationException {
        IXtextDocument xtextDocument = context.getXtextDocument();
        String firstLetter = xtextDocument.get(issue.getOffset(), 1);
        xtextDocument.replace(issue.getOffset(), 1, 
                              Strings.toFirstUpper(firstLetter));
      }
    }
  );
}

p. By using the correct signature (see below) and annotating the method with the _@Fix_ annotation 
referencing the previously specified issue code from the validator, Xtext knows that this method 
implements a fix for the problem. This also allows us to annotate multiple methods as fixes for the 
same problem.

The first three parameters given to the 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor} define the 
UI representation of the quick fix. As the document is not necessarily loaded when the quick fix is 
offered, we need to provide any additional data from the model that we want to refer to in the UI 
when creating the issue in the validator above. In this case, we provided the existing type name. 
The additional data is available as _Issue.getData()_. As it is persisted in markers, only strings 
are allowed. 

The actual model modification is implemented in the 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.model.edit.IModification}. 
The ${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.model.edit.IModificationContext} provides 
access to the erroneous document. In this case, we're using Eclipse's _IDocument_ API to replace a 
text region.    

If you prefer to implement the quick fix in terms of the semantic model use a 
${org.eclipse.xtext.ui/src/org.eclipse.xtext.ui.editor.model.edit.ISemanticModification} instead. 
Its _apply(EObject, IModificationContext)_ method will be invoked inside a modify-transaction and the 
first argument will be the erroneous semantic element. This makes it very easy for the fix method to 
modify the model as necessary. After the method returns the model as well as the Xtext editor's content 
will be updated accordingly. If the method fails (throws an exception) the change will not be committed. 
The following snippet shows a semantic quick fix for a similar problem.

bc.. @Fix(DomainmodelJavaValidator.INVALID_FEATURE_NAME)
public void fixFeatureName(final Issue issue, 
                           IssueResolutionAcceptor acceptor) {
  acceptor.accept(issue, 
    "Uncapitalize name",    // label
    "Uncapitalize name of '" + issue.getData()[0] + "'", // description
    "upcase.png",           // icon 
    new ISemanticModification() {
      public void apply(EObject element, IModificationContext context) {
        ((Feature) element).setName(
            Strings.toFirstLower(issue.getData()[0]));
      }
    }
  );
}

