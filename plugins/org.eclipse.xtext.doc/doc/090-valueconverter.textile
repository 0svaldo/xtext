
h2(#valueconverter). Value Converter

Value converters are registered to convert the parsed text into a certain data type instance and vice versa.
The primary hook is called ${org.eclipse.xtext/src/org.eclipse.xtext.conversion.IValueConverterService} 
and the concrete implementation can be registered via the runtime "Guice module":#guicemodules.
To do so override the corresponding binding in your runtime module like shown in this example:

bc.. @Override
public Class<? extends IValueConverterService> bindIValueConverterService() {
  return MySpecialValueConverterService.class;
}

h3. Annotation-Based Value Converters

The most simple way to register additional value converters is to make use of 
${org.eclipse.xtext/src/org.eclipse.xtext.conversion.impl.AbstractDeclarativeValueConverterService}, 
which allows to declaratively register an ${org.eclipse.xtext/src/org.eclipse.xtext.conversion.IValueConverter}
by means of an annotated method. 

p. If you use the common terminals grammar _org.eclipse.xtext.common.Terminals_ you should subclass 
${org.eclipse.xtext/src/org.eclipse.xtext.common.services.DefaultTerminalConverters} and override or 
add additional value converters by adding the respective methods. In addition to the explicitly 
defined converters in the default implementation, a delegating converter is registered for each 
available _EDataType_ that reuses the functionality of the corresponding EMF _EFactory_.

p. As qualified names - i.e. names composed of namespaces separated by a delimiter - are expected to occur often, we've added a ${org.eclipse.xtext/src/org.eclipse.xtext.conversion.impl.QualifiedNameValueConverter}. This one removes comments and whitespaces and delegates to another value converter for each segment, allowing individually quoted segments. The domainmodel example shows how to use it. 

p. The protocol of an _IValueConverter_ allows to throw a _ValueConverterException_ if something went wrong.
The exception is propagated as a syntax error by the parser or as a validation problem by the 
_ConcreteSyntaxValidator_ if the value cannot be converted to a valid string. The 
${org.eclipse.xtext/src/org.eclipse.xtext.conversion.impl.AbstractLexerBasedConverter} is useful when 
implementing a custom value converter. If the converter needs to know about the rule that it currently 
works with, it may implement the interface _IValueConverter.RuleSpecific_. The framework will set the
rule such as the implementation may use it afterwards.