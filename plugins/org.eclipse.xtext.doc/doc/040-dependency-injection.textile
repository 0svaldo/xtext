
h2(#dependencyInjection). Dependency Injection in Xtext with Google Guice

In Xtext, there are many Java classes which implement logic, behavior, or supply configuration. These classes implement Java interfaces and are typically only supposed to be accessed through these interfaces, which makes their implementations interchangeable. This is where Xtext utilizes "Google Guice":http://code.google.com/p/google-guice/: 
* Guice manages the instantiation of the classes: instead of constructing a class with @new@, the <code>@Inject</code> annotation instructs Guice to supply an object for a certain interface. Such an object is called "Service":#guiceservice.
* Guice allows to configure which implementations are to be supplied for which interface. This configuration consists of so-called "modules":#guicemodules.

h3(#guiceservice). Services

The most parts of Xtext are implemented as _services_. A service is an object which implements a certain interface and which is instantiated and provided by Guice.

Xtext ships with generic default implementations for the most services or uses "generator fragments":#generator to automatically generate service implementations for a grammar. Thereby, Xtext strives to provide meaningful implementations out of the box and to allow customization wherever needed. Developers are encouraged to sub-class existing services and configure them for their languages in their "modules":#guicemodules.  

When Guice instantiates an object, it also supplies this instance with all its dependent services. All a service does is to request "some implementation for a certain interface" using the <code>@Inject</code>-annotation. Based on the "modules configuration":#guicemodules Guice decides which class to instantiate or which object to reuse. 

For example, Guice can automatically initialize member variables with the needed services. 

bc.. 
public class MyLanguageLinker extends Linker {

  @Inject
  private IScopeProvider scopeProvider;

  @Inject(optional=true)
  private IXtext2EcorePostProcessor postProcessor;
  
  (...)
}

p. Furthermore, Guice can pass the needed services as constructor parameters.

bc.. 
public class MyLanguageGrammarAccess implements IGrammarAccess {
	
  private final GrammarProvider grammarProvider;

  private TerminalsGrammarAccess gaTerminals;

  @Inject
  public MyLanguageGrammarAccess(GrammarProvider grammarProvider,
    TerminalsGrammarAccess gaTerminals) {
    this.grammarProvider = grammarProvider;
    this.gaTerminals = gaTerminals;
  }
	
  (...)
}

p. For further details, please refer to the "Google Guice Documentation":http://code.google.com/docreader/#p=google-guice&s=google-guice&t=UsersGuide

h3(#guicemodules). Modules

The configuration of services for a language built with  Xtext is done via modules:
* Modules map (bind) arbitrary Java interfaces to their implementation classes or directly to instances of their implementation classes.
* A module itself is a plain Java class.
* Modules can inherit from each other and override bindings that are declared in super-modules.
* In Xtext, there is a "generic default module":#guicedefaultmodule for all languages, there are automatically "generated modules":#guicegeneratedmodule and there are modules which are "intended to be customized manually":#guicemanualmodules.  
* Furthermore, Xtext distinguishes between modules for runtime-services and modules related to services needed for the user interface.

In total, this leads to five modules for a typical Xtext Language. They are visualized in the image below. The image is further explained in the following subsections. 

!{width:80%}images/modules_hierarchy.png!

h4(#guicemanualmodules). Modules intended for customization

When the "generator":#generator runs the first time, it creates two modules named @<MyLanguage>RuntimeModule@ and @<MyLanguage>UIModule@. They are placed in the language's root-package in the @src/@-folder of the language's runtime-project and the language's UI-project. Both are initially empty and will never be overwritten by the generator. They are "intended for customization":guicecustomize. By default, they extend a "generated module":#guicegeneratedmodule.  

h4(#guicegeneratedmodule). Generated Modules

The fully generated modules (never touch them!) are called @Abstract<MyLanguage>RuntimeModule@ and @Abstract<MyLanguage>UiModule@ respectively. They contain all components which have been generated specifically for the language at hand. What goes into these modules depends on the fragments you use in the generator.

h4(#guicedefaultmodule). Default Module

Finally the fully generated modules extend the ${org.eclipse.xtext/src/org.eclipse.xtext.service.DefaultRuntimeModule}, which contains all the default configuration. The default configuration consists of all components for which we have generic default implementations. 

h4(#guicecustomize). Changing Configuration

We use the primary modules (@<MyLanguage>RuntimeModule@ and @<MyLanguage>UiModule@) in order to change the configuration. 
These classes are initially empty and have been generated to allow customization.

In order to provide a simple and convenient way, the DefaultModule extends ${org.eclipse.xtext/src/org.eclipse.xtext.service.AbstractGenericModule}. 
Which does not provide any bindings but comes up with a convenient and declarative way to specify mappings. The default API provided by Guice is based on fluent API and a builder pattern.
This is also very readable but does not allow sub modules to change any of the bindings.   
The ${org.eclipse.xtext/src/org.eclipse.xtext.service.AbstractGenericModule} allows to declare and override bindings in all subclasses like this:

bc.. public Class<? extends IFooService> bindIFooService() {
     return MyFooServiceImpl.class;
}

p. Such a method will be interpreted as a binding from @IFooService@ to @MyFooServiceImpl.class@. Note that you simply have to override a method from a super class (e.g. from the generated or default module) in order to change the respective binding. For example, in the picture above, the @DefaultRuntimeModule@ configures the ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.IFormatter} to be implemented by the ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.impl.OneWhitespaceFormatter} and @AbstractMyLanguageModule@ overrides this binding by binding the ${org.eclipse.xtext/src/org.eclipse.xtext.formatting.IFormatter} to @MyLanguageFormatter@.
The type to type binding will create a new instance of the given target type for each dependency. If you want to make it a singleton, so that only one instance is created and reused for all dependencies you can add the following annotation:

bc.. @SingletonBinding
public Class<? extends IFooService> bindIFooService() {
     return MyFooServiceImpl.class;
}

p. In addition if the creation of the type causes any needed side effects, so you want it to be instantiated eagerly, you can set the @eager@ property to true. Like shown in the following snippet:

bc.. @SingletonBinding(eager=true)
public Class<? extends IFooService> bindIFooService() {
     return MyFooServiceImpl.class;
}

p. One more way of specify a binding is currently supported: If you need to control the way, the instance is created, you can have a type to object mapping:

bc.. public IFooService bindIFooService() {
     return new MyFooServiceImpl();
}

p. __Note that, although this is a convenient and simple way, you have of course also the full power of Guice, i.e. you can override the Guice method @void configure(Binder)@ and use the afore mentioned fluent API to do whatever you want.__
