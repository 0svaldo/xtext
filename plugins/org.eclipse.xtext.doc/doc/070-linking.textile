
h2(#linking). Linking

The linking feature allows for specification of cross references within an Xtext grammar.
The following things are needed for the linking:

# declaration of a crosslink in the grammar (at least in the Ecore model)
# specification of linking semantics (usually provided via the "scoping API":#scoping)

h3. Declaration of crosslinks

In the grammar a cross reference is specified using square brackets.

bc.. CrossReference :
  '[' ReferencedEClass ('|' terminal=AbstractTerminal)? ']'
;

p. Example:
  
bc.. ReferringType :
  'ref' referencedObject=[Entity|(ID|STRING)]
;

p. The "Ecore model inference":#metamodelInference would create an @EClass@ 'ReferringType' with an @EReference@ 'referencedObject' of type 'Entity' (containment=false). The referenced object would be identified either by an ID or a STRING and the surrounding information in the current context (see "scoping":#scoping). If you do not use "generate" but "import" an existing ecore model, the class @ReferringType@ (or one of its super types) would need to have an EReference of type Entity (or one of its super types) declared. Also the EReference's containment property needs to be set to @false@. 


h3. Default runtime behavior / lazy linking

Xtext uses lazy linking by default and we encourage users to stick to this, because it provides a lot of advantages. One is improved performance in all scenarios where you don't have to load the whole closure of all transitively referenced resources. Also it automatically solves situation where one link relies on other links. Though cyclic linking dependencies are not supported by Xtext at all. 

When parsing a given input string, say

bc. ref Entity01

The ${org.eclipse.xtext/src/org.eclipse.xtext.linking.lazy.LazyLinker} first creates an EMF proxy and sets on the corresponding EReference. In EMF a proxy is described by a URI, which points to the real EObject. In the case of lazy linking the stored URI comprises of the context information given at parse time, which is the EObject containing the cross reference, the actual EReference, the index (in case it's a multi-valued cross reference) and the string which represented the cross link in the concrete syntax. The latter usually corresponds to the name of the referenced EObject. 
In EMF a URI consists of information about the resource the EObject is contained in as well as a so called fragment part, which is used to find the EObject within that resource. When an  EMF proxy is resolved, the current ResourceSet is asked. The resource set uses the first part to obtain (i.e. load if it is not already loaded) the resource. Then the resource is asked to return the EObject based on the fragment in the URI. The actual cross reference resolution is done by @LazyLinkingResource.getEObject(String)@ which receives the fragment and delegates to the implementation of the @ILinkingService@.  The default implementation in turn delegates to the "scopes API"#scoping.

A simple implementation of the linking service (the ${org.eclipse.xtext/src/org.eclipse.xtext.linking.impl.DefaultLinkingService}) is shipped with Xtext and used for any grammar per default. Usually any necessary customization of the linking behavior can best be described using the "scopes API"#scoping.

