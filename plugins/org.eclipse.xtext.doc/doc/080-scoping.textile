
h2(#scoping). Scoping

Using the scoping API one defines which elements are referable from a certain reference. For instance, using the introductory example (fowler's state machine language)
a transition contains two cross reference one to a declared event and one to a declared state.

Example:

bc.. events
  nothingImportant  MYEV
end
 
state idle
  nothingImportant => idle
end
  
p. The grammar rule for transitions looks like this:

bc.. Transition :
  event=[Event] '=>' state=[State];

p. The grammar only states that for the reference @event@ only instances of the type @Event@ are allowed and that for the EReference @state@ only instances of type @State@ can be referenced. However, this simple declaration doesn't say anything about where to find the states or events. That is the duty of scopes.  

An @IScopeProvider@ is responsible for providing an @IScope@ for a given context @EObject@ and @EReference@. The returned @IScope@ should contain all target candidates for the given object and cross reference.

bc.. public interface IScopeProvider {

	/**
	 * Returns a scope for the given context. The scope provides access to the compatible
	 * visible EObjects for a given reference.
	 *
	 * @param context the element from which an element shall be referenced
	 * @param reference the reference to be used to filter the elements.
	 * @return {@link IScope} representing the inner most {@link IScope} for the
	 *         passed context and reference. Note for implementors: The result may not be <code>null</code>.
	 *         Return <code>IScope.NULLSCOPE</code> instead.
	 */
	IScope getScope(EObject context, EReference reference);

}

p. A single @IScope@ represents an element of a linked list of scopes. That means that a scope can be nested within an outer scope. Each scope works like a symbol table or a map where the keys are strings and the values are so called IEObjectDescription, which is effectively an abstract description of a real EObject. 

h3(#global_scopes). Global Scopes and IResourceDescriptions

In the state machine example we don't have cross file references. Also there is no such thing as name spaces or other concepts which make scoping a bit more complicated. Basically every @State@ and every @Event@ declared in the same resource is visible by their name. However in the real world things are most likely not that simple. What if you want to reuse certain declared states and events across different state machines and you want to share those as library between different users? You would want to introduce some kind of cross resource reference. Defining what is visible from outside the current resource is the responsibility of global scopes. Defining what things of the current resource can be seen from outside (i.e. is publicly referenceable) is the duty of the so called @IResourceDescriptions.Manager@. 

h4(#resourcedescriptions). @Resource@ and @EObject@ Descriptions (@IResourceDescription@, @IEObjectDescription@)

In order to make states and events of one file referenceable from another file you need to export them as part of a so called ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IResourceDescription}. Such a description can be obtained by an implementation of @IResourceDescription.Manager@ which is provided by the ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IResourceServiceProvider} for your language. 

A @IResourceDescription@ contains information about the resource itself (primarily a @URI@), a list of exported @EObjects@ (in the form of ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IEObjectDescription}) as well as information about outgoing cross references and qualified names it references. The cross references contain only resolved references, while the list of imported qualified names also contain those names, which couldn't be resolved. This information is important in order to compute the transitive hull of dependent resources, which the shipped index infrastructure automatically does for you.

For users and especially in the context of scoping the most important information is the list of exported @EObjects@. An @IEObjectDescription@ contains information about the @URI@ to the actual @EObject@ and the qualified name of that element as well as the corresponding @EClass@. In addition one can export arbitrary information using the so called user data map.

A language is configured with a default implementation of @IResourceDescription.Manager@ which computes the list of exported @IEObjectDescription@ s by iterating the whole EMF model and applying the @getQualifiedName(EObject obj)@ from ${org.eclipse.xtext/src/org.eclipse.xtext.naming.IQualifiedNameProvider} on each @EObject@. If it returns a name an @IEObjectDescription@ is created and exported (i.e. added to the list). If an @EObject@ doesn't have a qualified name, the element is considered to be not referenceable from outside the resource. 

There are also two different implementations of @IQualifiedNameProvider@. Both work by looking up an @EAttribute@ with the name 'name'. The ${org.eclipse.xtext/src/org.eclipse.xtext.naming.SimpleNameProvider} just returns the plain value, while the ${org.eclipse.xtext/src/org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider} concats the simple name with the qualified name of its parent exported @EObject@. This effectively simulates the qualified name computation of most name space based languages (like e.g. Java). 

As mentioned above, in order to obtain an @IResourceDescription@ for a resource you need to ask the @IResourceDescription.Manager@. Here's some Java code showing how to do that:

bc..   Manager manager = // obtain an instance of IResourceDescription.Manager.class
  IResourceDescription description = manager.getResourceDescription(resource);
  for (IEObjectDescription eObjDescription : description.getExportedObjects()) {
    System.out.println(eObjDescription.getQualifiedName());
  } 
  
p. In order to obtain an @IResourceDescription.Manager@ it is best to ask the corresponding ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IResourceServiceProvider}. That is because each language might have a totally different implementation and as you might refer to from your language to a different language you can't reuse your language's @IResourceDescription.Manager@. One basically asks the @IResourceServiceProvider.Registry@ (there is usually one global instance) for an @IResourceServiceProvider@, which in turn provides an @IResourceDescription.Manager@ along other useful services.

If you're running in a Guice enabled scenario, the code looks like this:

bc..   @Inject private IResourceServiceProvider.Registry resourceServiceProviderRegistry;
	
  private IResourceDescription.Manager getManager(Resource res) {
		IResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry.getResourceServiceProvider(res.getURI());
		return resourceServiceProvider.getResourceDescriptionManager();
	}

p. If you don't run in a Guice enabled context you will likely have to directly access the singleton:

bc..   private IResourceServiceProvider.Registry resourceServiceProviderRegistry = IResourceServiceProvider.Registry.INSTANCE;

p. However, we strongly encourage you to use dependency injection.
Now, that we know how to export elements to be referenceable from other resources, we need to learn how those exported @IEObjectDescriptions@ can be made available to the referencing resources. That is the responsibility of global scoping (i.e. ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.IGlobalScopeProvider}) which is described in the following.

h4(#import_uri). Global Scopes based on explicit imports (ImportURI mechanism)

A simple and straight forward solution is to have explicit references to other resources in your file by explicitly listing pathes (or @URIs@) to all referenced resources in your model file. That is for instance what most include mechanisms use. In Xtext we provide a handy implementation of an @IGlobalScopeProvider@ which is based on naming convention and makes this semantics very easy to use. Talking of the introductory example and given you would want to add support for referencing external @States@ and @Events@ from within your state machine, all you'ld had to do is add something like the following to the grammar definition:

bc.. Statemachine :
  (imports+=Import)* // allow imports
  'events'
     (events+=Event)+
  'end'
  ('resetEvents'
     (resetEvents+=[Event])+
  'end')?
  'commands'
     (commands+=Command)+
  'end'
  (states+=State)+;

Import : 
  'import' importURI=STRING;

p.  This effectively allows import statements to be declared before the events section. In addition you'll have to make sure that you have bound the ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.ImportUriGlobalScopeProvider} for the type @IGlobalScopeProvider@ by the means of Guice:#dependencyInjection. That implementation looks up any @EAttributes@ named 'importURI' in your model and interprets their values as imports. That is it adds the corresponding resources to the current resource's resource set. In addition the scope provider uses the @IResourceDescription.Manager@#resource_descriptions of that imported resource to compute all the @IEObjectDescriptions@ returned by the @IScope@.  

h4(#index_based). Global Scopes based on external configuration (e.g. classpath-based)

The other possibility is to have some kind of external configuration in order to define what is visible outside a resource. Java for instances uses the notion of classpaths to define containers (jars and class folders) which contain any referenceable elements. In the case of Java also the order of such entries is important. 
Since version 1.0.0 Xtext provides support for this kind of global scoping. Actually by default Xtext leverages the classpath mechanism since it is well designed and already understood by most of our users. Also the available tooling provided by JDT and PDE to configure the classpath is of high value. However it is just a default you can reuse the infrastructure without reusing Java and therefore depending on JDT.

In order to know what is available in the "world" a global scope provider which relies on external configuration needs to read that configuration in and be able to find all candidates for a certain EReference in those containers. If you don't want to force users to have a folder and file name structure reflecting the actual qualified names of the referenceable @EObjects@, you'll have to load all resources up front and either keep holding them in memory or remembering all information which is needed for reference resolution. In Xtext that information is provided by a so called @IEObjectDescription@#resource_descriptions. 

Xtext ships with an index which remembers all @IResourceDescriptions@ and its @IEObjectDescriptions@. In the IDE-context (i.e. when running the editor, etc.) the index is updated incrementally by an incremental project builder. At runtime however, you typically do not have to deal with changes so that the infrastructure can be much simpler. In both situations the global index state is hold by an implementation of${org.eclipse.xtext/src/org.eclipse.xtext.resource.IResourceDescriptions} (Note the plural form!). 

h5(#containers). Of containers and its manager 

p. As mentioned above all this stuff is best explained along Java's class path mechanism, because we assume that you have an idea of its concepts and how it works. At least if not and we haven't written enough information down, there are other resources you could consult. The index is just a flat list of instances of @IResourceDescription@ the index itself doesn't know about containers. That is because we think the notion of containers is something which is defined by the referencing language. The very same resource could be loaded from Java by the means of ClassLoader.loadResource() (i.e. using the classpath mechanism) but could be loaded from some other language by using the file system paths. 
 
p. This means that the information about to what container a resource belongs depends on the context. Therefore an @IResourceServiceProvider@ provides another interesting service, which is called @IContainer.Manager@. An @IContainer.Manager@ provides you with the ${org.eclipse.xtext/src/org.eclipse.xtext.resource.IContainer} a certain @IResourceDescripition@ belongs to as well as with a list of all @IContainers@ which are visible from a certain @IResourceDescription@. Note that while the index (@IResourceDesciptions@) is globally shared (between all languages) the @IContainer.Manager@ adds the semantic of containers and its implementation can be very different depending on the language.

p. By default Xtext provides either leveraging the Java class path mechanism, which allows to reuse a lot of nice Java things (jars, OSGi, maven, etc.) or define containers based on Eclipse projects. At runtime the only alternative is configured with a list of pathes to scan. Such pathes can either point to folders or archives.

h5(#java_based_containers). Java based container manager 

TODO Explain how to setup Java and project based container state in the ui. 
TODO Explain how to setup a resourcesetbased IResourceDescriptions for runtime.

h3(#local_scoping). Local Scoping

TODO TODO TODO
We now know how the outer world of referenceable elements can be defined in Xtext. 

For instance Java has multiple kinds of scopes (object scope, type scope, etc.).

For Java one would create the scope hierarchy as commented in the following example:

bc.. // file contents scope
import static my.Constants.STATIC;

public class ScopeExample { // class body scope
  private Object field = STATIC;

  private void method(String param) { // method body scope
    String localVar = "bar";
    innerBlock: { // block scope
      String innerScopeVar = "foo";
      Object field = innerScopeVar;
      // the scope hierarchy at this point would look like this:
      //  blockScope{field,innerScopeVar}->
      //  methodScope{localVar, param}->
      //  classScope{field}-> ('field' is overlayed)
      //  fileScope{STATIC}->
      //  classpathScope{'all qualified names of accessible static fields'} ->
      //  NULLSCOPE{}
      //
    }
    field.add(localVar);
  }
}

p. In fact the class path scope should also reflect the order of class path entries.
For instance:

bc.. classpathScope{stuff from bin/}
-> classpathScope{stuff from foo.jar/}
-> ...
-> classpathScope{stuff from JRE System Library}
-> NULLSCOPE{}

p. Please find the motivation behind this and some additional details in "this blog post":http://blog.efftinge.de/2009/01/xtext-scopes-and-emf-index.html .

The default implementation would produce this hierarchy of scopes for the model from the last example in the "previous chapter":#defaultImports:

bc.. //file model.dsl
import "model1.dsl";
import "model2.dsl";
 
ref Foo;
entity Bar;

bc.. //file model1.dsl 
entity Stuff;

bc.. //file model2.dsl
entity Foo;

bc.. Scope (model.dsl) {
  parent : Scope (model1.dsl) {
    parent : Scope (model2.dsl) {}
  }
}

p. When enumerating the scope's content, the first, most specialized scope would return @Bar@, its parent would provide @Stuff@ and the outermost scope adds @Foo@. The linker will iterate the scope in that order and abort when it finds a matching @ScopedElement@. 

h3. Default linking semantics

The default implementation for all languages looks within the current file for an EObject of the respective type. In the example above this would be an "Entity" which by convention has a @name@ attribute set to 'Entity01'. 

Given the grammar :

bc.. Model : 
  (stuff+=(Ref|Entity))*
;

Ref : 
  'ref' referencedObject=[Entity|ID] ';'
;

Entity : 
  'entity' name=ID ';'
;

p. In the following model:

bc.. ref Entity01;
entity Entity01;

p. the @ref@ would be linked to the declared entity (@entity Entity01;@). Nearly any aspect is configurable, especially the name of the identifying attribute may be overridden for a particular type.

h4(#defaultImports). Default Imports

There is a default implementation for inter-resource references, which as well uses convention.
Each string in a model which is assigned to an EAttribute with the name @importURI@, will be interpreted as an URI and used to be loaded using the @ResourceSet@ of the current resource.

For example, given the following grammar :

bc.. Model : 
  (imports+=Import)*
  (stuff+=(Ref|Entity))*
;

Import :
  'import' importURI=STRING ';'
;

Ref : 
  'ref' referencedObject=[Entity|ID] ';'
;

Entity : 
  'entity' name=ID ';'
;

p. It would be possible to write three files in that language where the first references the other two, like this:

bc.. //file model.dsl
import "model1.dsl";
import "model2.dsl";
 
ref Foo;
entity Bar;

bc.. //file model1.dsl 
entity Stuff;

bc.. //file model2.dsl
entity Foo;

p. The linking candidates for the reference @Foo@ will be @Bar@, @Stuff@ and @Foo@ in that order. They will be computed by the "ScopeProvider":#scoping. 

h3. ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.DeclarativeScopeProvider}

As always there is an implementation that allows to specify scoping in a declarative way. It looks up methods which have either of the following two signatures:

bc. IScope scope_<RefDeclaringEClass>_<Reference>(<ContextType> ctx, EReference ref)

bc. IScope scope_<TypeToReturn>(<ContextType> ctx, EReference ref)

The former is used when evaluating the scope for a specific cross reference and here @<ContextReference>@ corresponds to the name of this reference (prefixed with the name of the reference's declaring type and separated by an underscore). The @ref@ parameter represents this cross reference.

The latter method signature is used when computing the scope for a given element type and is applicable to all cross references of that type. Here @<TypeToReturn>@ is the name of that type which also corresponds to the @type@ parameter. 

So if you for example have a state machine with a  _Transition_ object owned by its source _State_ and you want to compute all reachable states (i.e. potential target states), the corresponding method could be declared as follows (assuming the cross reference is declared by the _Transition_ type and is called _target_):

bc. IScope scope_Transition_target(Transition this, EReference ref)

If such a method does not exist, the implementation will try to find one for the context object's container. Thus in the example this would match a method with the same name but _State_ as the type of the first parameter. It will keep on walking the containment hierarchy until a matching method is found. This container delegation allows to reuse the same scope definition for elements in different places of the containment hierarchy. Also it may make the method easier to implement as the elements comprising the scope are quite often owned or referenced by a container of the context object. In the example the _State_ objects could for instance be owned by a containing _StateMachine_ object.

If no method specific to the cross reference in question was found for any of the objects in the containment hierarchy, the implementation will start looking for methods matching the other signature (with the _EClass_ parameter). Again it will first attempt to match the context object. Thus in the example the signature first matched would be:

bc. IScope scope_State(Transition this, EReference ref)

If no such method exists, the implementation will again try to find a method matching the context object's container objects. In the case of the state machine example you might want to declare the scope with available states at the state machine level:

bc. IScope scope_State(StateMachine this, EReference ref)

This scope can now be used for any cross references of type _State_ for context objects owned by the state machine.

There are currently two different scope provider implmentations available which support these semantics:

#  ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider} 
#  ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.AbstractDeclarativeQualifiedNameScopeProvider}

h3. ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.QualifiedNameScopeProvider}

The qualified name scoping is based on qualified names and name spaces. It adds name space support to your language, which is comparable and similar to the one in Scala and C#. Scala and C# both allow to have multiple nested packages within one file and you can put imports per namespace, so that imported names are only visible within that namespace. See the domain model example its scope provider extends  ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.AbstractDeclarativeQualifiedNameScopeProvider}.

h4. ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.IQualifiedNameProvider}

The ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.QualifiedNameScopeProvider} makes use of the so called ${org.eclipse.xtext/src/org.eclipse.xtext.scoping.IQualifiedNameProvider} service. It computes qualified names for EObjects. The default implementation (${org.eclipse.xtext/src/org.eclipse.xtext.scoping.impl.DefaultDeclarativeQualifiedNameProvider}) uses a simple name look up and concats the result to the qualified name of its parent object. See its JavaDoc and the code for more details.

h4. Importing name spaces

The QualifiedNameScopeProvider looks up EAttributes with name 'importNamespace' and interprets such as import statements.
By default qualified names with or without a wildcard at the end are supported. For an import of a qualified name the simple name is made available as we know from e.g. Java, where

bc. import java.util.Set;

makes it possible to refer to 'java.util.Set' by its simple name 'Set'.
Contrary to Java the import is not active for the whole file but only for the namespace it is declared in and its child namespaces. That is why you can write the following in the example DSL:

bc.. 
package foo {
  import bar.Foo
  entity Bar extends Foo {
  }
}

package bar {
  entity Foo {}
}

p. Of course the declared elements within a package are as well referable by their simple name:

bc.. 
package bar {
  entity Bar extends Foo {}
  entity Foo {}
}

p. Of course the following would as well be ok:

bc.. 
package bar {
  entity Bar extends bar.Foo {}
  entity Foo {}
}

p. As the name suggests it uses the EMF index to find any EObjects which are not located in the current resource. 
The ${org.eclipse.xtext/src/org.eclipse.xtext.index.IndexBasedScopeProvider} supports nested namespaces (similar to C# and Scala) and is used in the Domainmodel example (project org.eclipse.xtext.example.domainmodel). There is support for declarative overwriting of the default semantics if you subclass ${org.eclipse.xtext/src/org.eclipse.xtext.index.AbstractDeclarativeIndexBasedScopeProvider}.

See the JavaDocs and "this blog post":http://blog.efftinge.de/2009/07/xtext-scopes-and-emf-index-in-action.html for details.

