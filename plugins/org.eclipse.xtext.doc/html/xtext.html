<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Xtext User Guide</title><link href="book.css" rel="stylesheet" type="text/css"><meta content="DocBook XSL Stylesheets V1.75.1" name="generator"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="Xtext User Guide"><div class="titlepage"><div><div><h1 class="title"><a name="N10001"></a>Xtext User Guide</h1></div></div><hr></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title"><a name="Overview"></a>Chapter&nbsp;1.&nbsp;Overview</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#WhatsXtext">What&rsquo;s Xtext?</a></span></dt><dt><span class="section"><a href="#concepts">Xtext concepts from a bird&rsquo;s eye view</a></span></dt><dt><span class="section"><a href="#grammarLanguage">The Grammar Language</a></span></dt><dd><dl><dt><span class="section"><a href="#Firstanexample">First an example</a></span></dt><dt><span class="section"><a href="#LanguageDeclaration">Language Declaration</a></span></dt><dt><span class="section"><a href="#EPackagedeclarations">EPackage declarations</a></span></dt><dt><span class="section"><a href="#Rules">Rules</a></span></dt><dt><span class="section"><a href="#ParserRules">Parser Rules</a></span></dt><dt><span class="section"><a href="#Hiddenterminalsymbols">Hidden terminal symbols</a></span></dt><dt><span class="section"><a href="#Datatyperules">Datatype rules</a></span></dt><dt><span class="section"><a href="#EnumRules">Enum Rules</a></span></dt></dl></dd><dt><span class="section"><a href="#metamodelInference">Meta-Model inference</a></span></dt><dd><dl><dt><span class="section"><a href="#TypeandPackageGeneration">Type and Package Generation</a></span></dt><dt><span class="section"><a href="#FeatureandTypeHierarchyGeneration">Feature and Type Hierarchy Generation</a></span></dt><dt><span class="section"><a href="#EnumLiteralGeneration">Enum Literal Generation</a></span></dt><dt><span class="section"><a href="#FeatureNormalization">Feature Normalization</a></span></dt><dt><span class="section"><a href="#CustomizedPostProcessing">Customized Post Processing</a></span></dt><dt><span class="section"><a href="#ErrorConditions">Error Conditions</a></span></dt></dl></dd><dt><span class="section"><a href="#ImportingexistingMetaModels">Importing existing Meta Models</a></span></dt><dt><span class="section"><a href="#GrammarMixins">Grammar Mixins</a></span></dt><dt><span class="section"><a href="#Defaulttokens">Default tokens</a></span></dt><dt><span class="section"><a href="#generator">The Generator</a></span></dt><dt><span class="section"><a href="#dependencyInjection">Dependency Injection in Xtext with Google Guice</a></span></dt><dd><dl><dt><span class="section"><a href="#Modules">Modules</a></span></dt></dl></dd></dl></div><div class="section" title="What&rsquo;s Xtext?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="WhatsXtext"></a>What&rsquo;s Xtext?</h2></div></div></div><p>The TMF Xtext project provides a domain-specific language (the grammar language) for description of textual programming languages and domain-specific languages. It is tightly integrated with the Eclipse Modeling Framework (EMF) and leverages the Eclipse Platform in order to provide language-specific tool support. </p><p>In contrast to common parser generators (like e.g. JavaCC or ANTLR), the grammar language is used to derive much more than just a parser and lexer (lexical analyzer). </p><p>From a grammar the following is derived:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>incremental, ANTLR 3 based parser and lexer</p></li><li class="listitem"><p>Ecore-based meta models (optional)</p></li><li class="listitem"><p>a serializer, used to serialize instances of such meta models back to a parseable textual representation</p></li><li class="listitem"><p>a linker</p></li><li class="listitem"><p>an implementation of the EMF Resource interface (based on the parser and the serializer)</p></li><li class="listitem"><p>a full-fledged integration of the language into Eclipse IDE</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>syntax coloring</p></li><li class="listitem"><p>navigation (F3, etc.) </p></li><li class="listitem"><p>code completion</p></li><li class="listitem"><p>outline views</p></li><li class="listitem"><p>code templates</p></li></ul></div></li></ul></div><p>The generated artifacts are wired up through 
				<a class="ulink" href="http://code.google.com/p/google-guice/" target="_new">Google Guice</a>, a dependency injection framework which makes it easy to exchange certain functionality in a non-invasive manner. For example if you don&rsquo;t like the default code assistant implementation, all you need to do is to come up with an alternative implementation of the corresponding service and configure it via 
				<a class="link" href="#dependencyInjection" title="Dependency Injection in Xtext with Google Guice">dependency injection</a>.
			</p></div><div class="section" title="Xtext concepts from a bird&rsquo;s eye view"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="concepts"></a>Xtext concepts from a bird&rsquo;s eye view</h2></div></div></div><p>text</p></div><div class="section" title="The Grammar Language"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="grammarLanguage"></a>The Grammar Language</h2></div></div></div><p>The 
				<a class="ulink" href="http://dev.eclipse.org/viewcvs/index.cgi/org.eclipse.tmf/org.eclipse.xtext/plugins/org.eclipse.xtext/src/org/eclipse/xtext/Xtext.xtext?root=Modeling_Project&view=markup" target="_new">grammar language</a> 
				is the corner stone of Xtext and is defined in itself &ndash; of course.
			</p><p>It is a DSL carefully designed for description of textual languages, based on 
				<a class="ulink" href="http://en.wikipedia.org/wiki/LL_parser" target="_new">LL(*)-Parsing</a> that is like 
				<a class="ulink" href="http://www.artima.com/lejava/articles/antlr_3.html" target="_new">Antlr3's parsing strategy</a> and supported by 
				<a class="ulink" href="http://pdos.csail.mit.edu/~baford/packrat/" target="_new">packrat parsers</a>.
				The main idea is to describe the concrete syntax and how an EMF-based in-memory model is created during parsing. 
			</p><div class="section" title="First an example"><div class="titlepage"><div><div><h3 class="title"><a name="Firstanexample"></a>First an example</h3></div></div></div><p>To get an idea of how it works we&rsquo;ll start by implementing a 
					<a class="ulink" href="http://martinfowler.com/dslwip/Intro.html" target="_new">simple example</a> introduced by Martin Fowler.
					It&rsquo;s mainly about describing state machines used as the (un)lock mechanism of secret compartments. 
					People who have secret compartments control their access in a very old-school way, e.g. by opening the door first and turning on the light afterwards.  
				</p><p>Then the secret compartment, for instance a panel, opens up.</p><p>One of those state machines could look like this:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;events<br>
&nbsp;&nbsp;doorClosed&nbsp;&nbsp;D1CL<br>
&nbsp;&nbsp;drawOpened&nbsp;&nbsp;D2OP<br>
&nbsp;&nbsp;lightOn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L1ON<br>
&nbsp;&nbsp;doorOpened&nbsp;&nbsp;D1OP<br>
&nbsp;&nbsp;panelClosed&nbsp;PNCL<br>
&nbsp;end<br>
&nbsp;<br>
&nbsp;resetEvents<br>
&nbsp;&nbsp;doorOpened<br>
&nbsp;end<br>
&nbsp;<br>
&nbsp;commands<br>
&nbsp;&nbsp;unlockPanel&nbsp;PNUL<br>
&nbsp;&nbsp;lockPanel&nbsp;&nbsp;&nbsp;PNLK<br>
&nbsp;&nbsp;lockDoor&nbsp;&nbsp;&nbsp;&nbsp;D1LK<br>
&nbsp;&nbsp;unlockDoor&nbsp;&nbsp;D1UL<br>
&nbsp;end<br>
&nbsp;<br>
&nbsp;state&nbsp;idle<br>
&nbsp;&nbsp;actions&nbsp;{unlockDoor&nbsp;lockPanel}<br>
&nbsp;&nbsp;doorClosed&nbsp;=&gt;&nbsp;active<br>
&nbsp;end<br>
&nbsp;<br>
&nbsp;state&nbsp;active<br>
&nbsp;&nbsp;drawOpened&nbsp;=&gt;&nbsp;waitingForLight<br>
&nbsp;&nbsp;lightOn&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;waitingForDraw<br>
&nbsp;end<br>
&nbsp;<br>
&nbsp;state&nbsp;waitingForLight<br>
&nbsp;&nbsp;lightOn&nbsp;=&gt;&nbsp;unlockedPanel<br>
&nbsp;end<br>
&nbsp;<br>
&nbsp;state&nbsp;waitingForDraw<br>
&nbsp;&nbsp;drawOpened&nbsp;=&gt;&nbsp;unlockedPanel<br>
&nbsp;end<br>
&nbsp;<br>
&nbsp;state&nbsp;unlockedPanel<br>
&nbsp;&nbsp;actions&nbsp;{unlockPanel&nbsp;lockDoor}<br>
&nbsp;&nbsp;panelClosed&nbsp;=&gt;&nbsp;idle<br>
&nbsp;end<br>
<br>
</code></p></div><p>So, we have a bunch of declared events, commands and states. Within states there are references to declared actions, which should be executed when entering such a state.
					Also there are transitions consisting of a reference to an event and a state. Please read 
					<a class="ulink" href="http://martinfowler.com/dslwip/Intro.html" target="_new">Martin's description</a>  if it is not clear enough.
				</p><p>In order to get a complete IDE for this little language from Xtext, you need to write the following grammar:</p><div class="literallayout"><p><code class="code">grammar&nbsp;my.pack.SecretCompartments&nbsp;<br>
&nbsp;&nbsp;&nbsp;with&nbsp;org.eclipse.xtext.common.Terminals<br>
&nbsp;generate&nbsp;secretcompartment&nbsp;"http://www.eclipse.org/secretcompartment"<br>
&nbsp;<br>
&nbsp;Statemachine&nbsp;:<br>
&nbsp;&nbsp;'events'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(events+=Event)+<br>
&nbsp;&nbsp;'end'<br>
&nbsp;&nbsp;('resetEvents'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(resetEvents+=[Event])+<br>
&nbsp;&nbsp;'end')?<br>
&nbsp;&nbsp;'commands'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(commands+=Command)+<br>
&nbsp;&nbsp;'end'<br>
&nbsp;&nbsp;(states+=State)+;<br>
&nbsp;<br>
&nbsp;Event&nbsp;:<br>
&nbsp;&nbsp;name=ID&nbsp;code=ID;<br>
&nbsp;<br>
&nbsp;Command&nbsp;:<br>
&nbsp;&nbsp;name=ID&nbsp;code=ID;<br>
&nbsp;<br>
&nbsp;State&nbsp;:<br>
&nbsp;&nbsp;'state'&nbsp;name=ID<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('actions'&nbsp;'{'&nbsp;(actions+=[Command])+&nbsp;'}')?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(transitions+=Transition)*<br>
&nbsp;&nbsp;'end';<br>
&nbsp;<br>
&nbsp;Transition&nbsp;:<br>
&nbsp;&nbsp;event=[Event]&nbsp;'=&gt;'&nbsp;state=[State];<br>
&nbsp;&nbsp;<br>
</code></p></div><p>In the following the different concepts of the grammar language are explained. We refer to this grammar when appropriate.</p></div><div class="section" title="Language Declaration"><div class="titlepage"><div><div><h3 class="title"><a name="LanguageDeclaration"></a>Language Declaration</h3></div></div></div><p>The first line  </p><div class="literallayout"><p><code class="code">grammar&nbsp;my.pack.SecretCompartments&nbsp;with&nbsp;org.eclipse.xtext.common.Terminals<br>
</code></p></div><p>declares the name of the grammar. Xtext leverages Java&rsquo;s classpath mechanism. This means that the name can be any valid Java qualifier. The file name needs to correspond and have the file extension '&lsquo;xtext&rsquo;'. This means that the name needs to be 
					<code class="code">SecretCompartments.xtext</code> and must be placed in package 
					<code class="code">my.pack</code> somewhere on your project&rsquo;s class path.
				</p><p>The first line is also used to declare any used language (for mechanism details cf. 
					<a class="link" href="#">Grammar Mixins</a> Mixins).
				</p></div><div class="section" title="EPackage declarations"><div class="titlepage"><div><div><h3 class="title"><a name="EPackagedeclarations"></a>EPackage declarations</h3></div></div></div><p>Xtext parsers instantiate Ecore models (aka meta model). An Ecore model basically consists of an EPackage containing EClasses, EDatatypes and EEnums.
					Xtext can infer Ecore models from a grammar (see 
					<a class="link" href="#metamodelInference" title="Meta-Model inference">Meta-Model Inference</a>) but it is also possible to instantiate existing Ecore models. You can even mix this, use multiple existing ECore models and infer some others from one grammar. 
				</p><div class="section" title="EPackage generation"><div class="titlepage"><div><div><h4 class="title"><a name="EPackagegeneration"></a>EPackage generation</h4></div></div></div><p>The easiest way to get started is to let Xtext infer the meta model from your grammar. This is what is done in the secret compartment example. To do so just state:</p><div class="literallayout"><p><code class="code">generate&nbsp;secretcompartment&nbsp;http://www.eclipse.org/secretcompartment<br>
</code></p></div><p>Which means: generate an EPackage with name 
						<code class="code">secretcompartment</code> and nsURI 
						<code class="code">http://www.eclipse.org/secretcompartment</code> (these are the properties needed to create an EPackage). See 
						<a class="link" href="#metamodelInference" title="Meta-Model inference">Meta-Model Inference</a> for details.
					</p></div><div class="section" title="EPackage import"><div class="titlepage"><div><div><h4 class="title"><a name="EPackageimport"></a>EPackage import</h4></div></div></div><p>If you already have created such an EPackage somehow, you can import it using either a namespace URI or a resource URI (URIs are an EMF concept).</p><div class="section" title="Using namespace URIs to import existing EPackages"><div class="titlepage"><div><div><h5 class="title"><a name="UsingnamespaceURIstoimportexistingEPackages"></a>Using namespace URIs to import existing EPackages</h5></div></div></div><p>You can import existing EPackages using the following syntax:</p><div class="literallayout"><p><code class="code">import&nbsp;"http://www.eclipse.org/secretcompartment"<br>
</code></p></div><p>Note that if you use a namespace URI, the corresponding EPackage needs to be installed into the workbench, so that the editor can find it.
							At runtime (i.e. when starting the generator) you need to make sure that the corresponding EPackage is registered in 
							<code class="code">EPackage.Registry.INSTANCE</code>. If you use MWE to drive your code generator, you need to add the following lines to your workflow file:
						</p><div class="literallayout"><p><code class="code">&lt;bean&nbsp;class="org.eclipse.emf.mwe.utils.StandaloneSetup"&nbsp;<br>
	platformUri="${runtimeProject}/.."&gt;<br>
	&lt;registerGeneratedEPackage&nbsp;value="foo.bar.MyPackage"/&gt;<br>
&lt;/bean&gt;<br>
<br>
</code></p></div></div><div class="section" title="Using classpath URIs to import existing EPackages"><div class="titlepage"><div><div><h5 class="title"><a name="UsingclasspathURIstoimportexistingEPackages"></a>Using classpath URIs to import existing EPackages</h5></div></div></div><p>Xtext provides a new resource URI scheme, which is backed by the Java classpath. If you want to refer to an ECore file 
							<code class="code">MyEcore.ecore</code>, provided in a package 
							<code class="code">foo.bar</code>, you could write 
						</p><div class="literallayout"><p><code class="code">import&nbsp;"classpath:/foo/bar/MyEcore.ecore"<br>
</code></p></div><p>Using the classpath scheme is considered the preferred way.</p></div></div><div class="section" title="Using multiple packages / meta model aliases"><div class="titlepage"><div><div><h4 class="title"><a name="Usingmultiplepackagesmetamodelaliases"></a>Using multiple packages / meta model aliases</h4></div></div></div><p>If you want to use multiple EPackages you need to specify aliases like so:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;generate&nbsp;secretcompartment&nbsp;http://www.eclipse.org/secretcompartment<br>
&nbsp;import&nbsp;http://www.eclipse.org/anotherPackage&nbsp;as&nbsp;another<br>
<br>
</code></p></div><p>When referring to a type somewhere in the grammar you need to qualify them using that alias (example '&lsquo;another::CoolType&rsquo;'). We&rsquo;ll see later where such type references occur.</p><p>It is also supported to put multiple EPackage imports into one alias. This is no problem as long as there are no two EClassifiers with the same name. In such cases none of them are referable. It is even possible to have multiple '&lsquo;import&rsquo;&lsquo;s and one &rsquo;&lsquo;generate&rsquo;' declared for the same alias. If you do so, for a reference to an EClassifier first the imported EPackages are scanned before it is assumed that a type needs to by generated into the to-be-generated package.</p><p>Example:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;generate&nbsp;toBeGenerated&nbsp;http://www.eclipse.org/toBeGenerated<br>
&nbsp;import&nbsp;http://www.eclipse.org/packContainingClassA<br>
&nbsp;import&nbsp;http://www.eclipse.org/packContainingClassB<br>
<br>
</code></p></div><p>With the declaration from above </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>a reference to type 
								<code class="code">ClassA</code> would be linked to the EClass contained in 
								<code class="code">http://www.eclipse.org/packContainingClassA</code>, 
							</p></li><li class="listitem"><p>a reference to type 
								<code class="code">ClassB</code> would be linked to the EClass contained in 
								<code class="code">http://www.eclipse.org/packContainingClassB</code>, 
							</p></li><li class="listitem"><p>a reference to type 
								<code class="code">NotYetDefined</code> would be linked to a newly created EClass in 
								<code class="code">http://www.eclipse.org/toBeGenerated</code>
							</p></li></ol></div><p>Note, that using this feature is not recommended, because it might cause problems, which are hard to tackle down.
						For instance, a reference to ''
						<code class="code">classA</code>'' would as well be linked to a newly created EClass, because the corresponding type in 
						<code class="code">http://www.eclipse.org/packContainingClassA</code> is spelled with a capital letter.
					</p></div></div><div class="section" title="Rules"><div class="titlepage"><div><div><h3 class="title"><a name="Rules"></a>Rules</h3></div></div></div><p>The default parsing is based on a homegrown packrat parser. It can be substituted by an Anltr parser through the Xtext service mechanism. Antlr is a sophisticated parser generator framework based on an LL(*) 
					<a class="ulink" href="http://bit.ly/ANTLR_LL_star_algorithm" target="_new">parsing algorithm</a>, that works quite well for Xtext. At the moment it is advised to download the plugin de.itemis.xtext.antlr (from update site 
					<code class="code">http://www.itemis.com/xtext/updatesite/milestones</code>) and use the Antlr Parser instead of the packrat parser (cf. 
					<a class="ulink" href="Xtext_Workspace_Setup" target="_new">Xtext Workspace Setup</a>).
				</p><p>Basically parsing can be separated in the following phases. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>lexing</p></li><li class="listitem"><p>parsing</p></li><li class="listitem"><p>linking</p></li><li class="listitem"><p>validation</p></li></ol></div><div class="section" title="Terminal Rules"><div class="titlepage"><div><div><h4 class="title"><a name="TerminalRules"></a>Terminal Rules</h4></div></div></div><p>In the first phase, i.e. lexing, a sequence of characters (the text input) is transformed into a sequence of so called tokens. 
						Each token consists of one or more characters and was matched by a particular terminal rule and represents an atomic symbol.
						In the secret compartments example there are no explicitly defined terminal rules, since it only uses the ID rule which is inherited from the grammar org.eclipse.xtext.common.Terminals (cf. 
						<a class="link" href="#">Grammar Mixins</a> Mixins).
						Terminal rules are also referred to as token rules or lexer rules. There is an informal naming convention that terminal-rule names are all uppercase.
					</p><p>Therein the ID rule is defined as follows:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;terminal&nbsp;ID&nbsp;:&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;('^')?('a'..'z'|'A'..'Z'|'_')&nbsp;('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
</code></p></div><p>It says that a Token ID starts with an optional &lsquo;^&rsquo; character, which is called caret, followed by a letter (&lsquo;a&rsquo;..&lsquo;z&rsquo;|&lsquo;A&rsquo;..&lsquo;Z&rsquo;) or underscore (&lsquo;_&rsquo;) followed by any number of letters, underscores and numbers (&lsquo;0&rsquo;..&lsquo;9&rsquo;). </p><p>The caret is used to escape an identifier for cases where there are conflicts with keywords. It is removed by the ID rule&rsquo;s [[Xtext/Documentation/ValueConverter|ValueConverter]]. </p><p>This is the formal definition of terminal rules:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;TerminalRule&nbsp;:<br>
&nbsp;&nbsp;&nbsp;'terminal'&nbsp;name=ID&nbsp;('returns'&nbsp;type=TypeRef)?&nbsp;':'&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alternatives=TerminalAlternatives&nbsp;';'<br>
&nbsp;;<br>
<br>
</code></p></div><p>Note, that the order of terminal rules is crucial for your grammar, as they may hide each other. This is especially important for newly introduced rules in connection with mixed rules from used grammars. </p><p>If you for instance want to add a rule to allow fully qualified names in addition to simple IDs, you should implement it as a 
						<a class="link" href="#">datatype rule</a>, instead of adding another terminal rule.
					</p><div class="section" title="Return types"><div class="titlepage"><div><div><h5 class="title"><a name="Returntypes"></a>Return types</h5></div></div></div><p>A terminal rule returns a value, which is a string (type ecore::EString) by default.
							However, if you want to have a different type you can specify it. For instance, the rule &lsquo;INT&rsquo; is defined as:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;terminal&nbsp;INT&nbsp;returns&nbsp;ecore::EInt&nbsp;:&nbsp;<br>
&nbsp;&nbsp;&nbsp;('0'..'9')+;<br>
<br>
</code></p></div><p>This means that the terminal rule INT returns instances of ecore::EInt. It is possible to define any kind of data type here, which just needs to be an instance of ecore::EDataType.
							In order to tell the parser how to convert the parsed string to a value of the declared data type, you need to provide your own implementation of &lsquo;IValueConverterService&rsquo; (cf. [[Xtext/Documentation/ValueConverter|value converters]]).</p><p>The implementation needs to be registered as a service (cf. 
							<a class="link" href="#">Service Framework</a>).
						</p><p>This is also the point where you can remove things like quotes form string literals or the caret (&lsquo;^&rsquo;) from identifiers.</p></div></div><div class="section" title="Extended Backus-Naur form expressions"><div class="titlepage"><div><div><h4 class="title"><a name="ExtendedBackusNaurformexpressions"></a>Extended Backus-Naur form expressions</h4></div></div></div><p>Token rules are described using &ldquo;Extended Backus-Naur Form&rdquo;-like (EBNF) expressions. The different expressions are described in the following.
						The one thing all of these expressions have in common is the quantifier operator.
						There are four different quantities</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>exactly one (the default no operator)</p></li><li class="listitem"><p>one or none (operator &ldquo;?&rdquo;)</p></li><li class="listitem"><p>any (operator &ldquo;*&rdquo;)</p></li><li class="listitem"><p>one or more (operator &ldquo;+&rdquo;)</p></li></ol></div><div class="section" title="Keywords / Characters"><div class="titlepage"><div><div><h5 class="title"><a name="KeywordsCharacters"></a>Keywords / Characters</h5></div></div></div><p>Keywords are a kind of token rule literals. 
							The ID rule in org.eclipse.xtext.common.Terminals for instance starts with a keyword :</p><div class="literallayout"><p><code class="code"><br>
&nbsp;terminal&nbsp;ID&nbsp;:&nbsp;'^'?&nbsp;....&nbsp;;<br>
</code></p></div><p>The question mark sets the cardinality to &ldquo;none or one&rdquo; (i.e. optional) like explained above.</p><p>Note that a keyword can have any length and contain arbitrary characters.</p></div><div class="section" title="Character Ranges"><div class="titlepage"><div><div><h5 class="title"><a name="CharacterRanges"></a>Character Ranges</h5></div></div></div><p>A character range can be declared using the &lsquo;..&rsquo; operator.</p><p>Example:</p><div class="literallayout"><p><code class="code">terminal&nbsp;INT&nbsp;returns&nbsp;ecore::EInt:&nbsp;('0'..'9')+&nbsp;;<br>
</code></p></div><p>In this case an INT is comprised of one or more (note the &lsquo;+&rsquo; operator) characters between (and including) &lsquo;0&rsquo; and &lsquo;9&rsquo;.</p></div><div class="section" title="Wildcard"><div class="titlepage"><div><div><h5 class="title"><a name="Wildcard"></a>Wildcard</h5></div></div></div><p>If you want to allow any character you can simple write a dot:
							Example:</p><div class="literallayout"><p><code class="code">FOO&nbsp;:&nbsp;'f'&nbsp;.&nbsp;'o';<br>
</code></p></div><p>The rule above would allow expressions like &lsquo;foo&rsquo;, &lsquo;f0o&rsquo; or even &lsquo;f\no&rsquo;.</p></div><div class="section" title="Until Token"><div class="titlepage"><div><div><h5 class="title"><a name="UntilToken"></a>Until Token</h5></div></div></div><p>With the until token it is possible to state that everything should be consumed until a certain token occurs.
							The multi line comment is implemented using it:</p><div class="literallayout"><p><code class="code">terminal&nbsp;ML_COMMENT	:&nbsp;'/*'&nbsp;-&gt;&nbsp;'*/'&nbsp;;<br>
</code></p></div><p>This is the rule for Java-style comments that begin with &lsquo;/*&rsquo; and end with &lsquo;*/&rsquo;.</p></div><div class="section" title="Negated Token"><div class="titlepage"><div><div><h5 class="title"><a name="NegatedToken"></a>Negated Token</h5></div></div></div><p>All the tokens explained above can be inverted using a preceding explanation mark:</p><div class="literallayout"><p><code class="code">terminal&nbsp;ML_COMMENT	:&nbsp;'/*'&nbsp;(!'*/')+&nbsp;;<br>
</code></p></div></div><div class="section" title="Rule Calls"><div class="titlepage"><div><div><h5 class="title"><a name="RuleCalls"></a>Rule Calls</h5></div></div></div><p>Rules can refer to other rules. This is done by writing the name of the rule to be called.
							We refer to this as rule calls. Rule calls in terminal rules can only point to terminal rules.</p><p>Example:</p><div class="literallayout"><p><code class="code">terminal&nbsp;QUALIFIED_NAME&nbsp;:&nbsp;ID&nbsp;('.'&nbsp;ID)*;<br>
</code></p></div></div><div class="section" title="Alternatives"><div class="titlepage"><div><div><h5 class="title"><a name="Alternatives"></a>Alternatives </h5></div></div></div><p>Using alternatives one can state multiple different alternatives.
							For instance, the whitespace rule uses alternatives like so:</p><div class="literallayout"><p><code class="code">terminal&nbsp;WS&nbsp;:&nbsp;('&nbsp;'|'\t'|'\r'|'\n')+&nbsp;;<br>
</code></p></div><p>That is a WS can be made of one or more whitespace characters (including &lsquo; &rsquo;,&lsquo;\t&rsquo;,&lsquo;\r&rsquo;,&lsquo;\n&rsquo;)</p></div><div class="section" title="Groups"><div class="titlepage"><div><div><h5 class="title"><a name="Groups"></a>Groups</h5></div></div></div><p>Finally, if you put tokens one after another, the whole sequence is referred to as a group.
							Example:</p><div class="literallayout"><p><code class="code">terminal&nbsp;FOO&nbsp;:&nbsp;'0x'&nbsp;('0'..'7')&nbsp;('0'..'9'|'A'..'F')&nbsp;;<br>
</code></p></div><p>That is the 4-digit hexadecimal code of ascii characters.</p></div></div></div><div class="section" title="Parser Rules"><div class="titlepage"><div><div><h3 class="title"><a name="ParserRules"></a>Parser Rules</h3></div></div></div><p>The parser reads in a sequence of terminals and walks through the parser rules. That&rsquo;s why a parser rule &ndash; contrary to a terminal rule &ndash; does not produce a single terminal token but a tree of non-terminal and terminal tokens that lead to a so called parse tree (in Xtext it is a.k.a node model). Furthermore, parser rules are handled as kind of a building plan to create EObjects that form the semantic model (the linked! AST). The different constructs like actions and assignments are used to derive types and initialize the semantic objects accordingly. </p><div class="section" title="Extended Backus-Naur Form expressions"><div class="titlepage"><div><div><h4 class="title"><a name="ExtendedBackusNaurFormexpressions"></a>Extended Backus-Naur Form expressions</h4></div></div></div><p>In parser rules (as well as in datatype rules) not all the expressions available for terminal rules can be used. Character ranges, wildcards, the until token and the negation are currently only available for terminal rules. 
						Available in parser rules as well as in terminal rules are</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
								<a class="link" href="#Groups" title="Groups">groups</a>, 
							</p></li><li class="listitem"><p>
								<a class="link" href="#Alternatives" title="Alternatives">alternatives</a>, 
							</p></li><li class="listitem"><p>
								<a class="link" href="#">keywords</a> and 
							</p></li><li class="listitem"><p>&ldquo;rule calls&rdquo;#RuleCalls.</p></li></ol></div><p>In addition to these elements, there are some expressions used to direct how the AST is constructed, which are listed and explained in the following.</p><div class="section" title="Assignments"><div class="titlepage"><div><div><h5 class="title"><a name="Assignments"></a>Assignments </h5></div></div></div><p>Assignments are used to assign parsed information to a feature of the current EClass. The current EClass is specified by the return type resp. if not explicitly stated it is implied that the type&rsquo;s name equals the rule&rsquo;s name.</p><p>Example:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;State&nbsp;:<br>
&nbsp;&nbsp;'state'&nbsp;name=ID<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;('actions'&nbsp;'{'&nbsp;(actions+=[Command])+&nbsp;'}')?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(transitions+=Transition)*<br>
&nbsp;&nbsp;'end';<br>
<br>
</code></p></div><p>The syntactic declaration for states in the state machine example starts with a keyword &lsquo;state&rsquo; followed by an assignment :</p><div class="literallayout"><p><code class="code">name=ID<br>
</code></p></div><p>Where the left hand side refers to a feature of the current EClass (in this case EClass &lsquo;State&rsquo;). 
							The right hand side can be a rule call, a keyword, a cross reference (explained later) or even an alternative comprised by the former.
							The type of the feature needs to be compatible to the type of the expression on the right. As ID returns an EString the feature name needs to be of type EString as well.</p></div></div><div class="section" title="Assignment Operators"><div class="titlepage"><div><div><h4 class="title"><a name="AssignmentOperators"></a>Assignment Operators</h4></div></div></div><p>There are three different assignment operators, each with different semantics</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>the simple equal sign &ldquo;=&rdquo; is the straight forward assignment, and used for features which take only one element</p></li><li class="listitem"><p>the &ldquo;+=&rdquo; sign (the add operator) awaits a multiple feature and adds the value on the right hand to that feature, which is, of course, a list feature</p></li><li class="listitem"><p>the &ldquo;?=&rdquo; sign (boolean add operator) awaits a feature if type EBoolean and sets it to true if the right hand side was consumed (no matter with what values)</p></li></ol></div><div class="section" title="Cross References"><div class="titlepage"><div><div><h5 class="title"><a name="CrossReferences"></a>Cross References </h5></div></div></div><p>A unique feature of Xtext is the ability to declare cross links in the grammar. In traditional compiler construction the cross links are not established during parsing but in a later linking phase. This is the same in Xtext, but we allow to specify cross link information in the grammar, which is used during the linking phase.
							The syntax for cross links is:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;CrossReference&nbsp;:<br>
&nbsp;&nbsp;&nbsp;'['&nbsp;type=TypeRef&nbsp;('|'&nbsp;^terminal=CrossReferenceableTerminal&nbsp;)?&nbsp;']'<br>
&nbsp;;<br>
<br>
</code></p></div><p>For example, the transition is made up of two cross references, pointing to an event and a state:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;Transition&nbsp;:<br>
&nbsp;&nbsp;event=[Event]&nbsp;'=&gt;'&nbsp;state=[State];<br>
<br>
</code></p></div><p>It is important to understand that the text between the square brackets does not refer to another rule, but to the type!
							This is sometimes confusing, because one usually uses the same name for the rules and the types.
							That is if we had named the type for events differently like in the following the cross references needs to be adapted as well:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;Transition&nbsp;:<br>
&nbsp;&nbsp;event=[MyEvent]&nbsp;'=&gt;'&nbsp;state=[State];<br>
&nbsp;<br>
&nbsp;Event&nbsp;returns&nbsp;MyEvent&nbsp;:&nbsp;....;<br>
<br>
</code></p></div><p>Looking at the syntax definition of cross references, there is an optional part starting with a vertical bar followed by &lsquo;CrossReferenceableTerminal&rsquo;. This is the part describing the concrete text, from which the crosslink later should be established.
							By default (that&rsquo;s why it&rsquo;s optional) it is &ldquo;|ID&rdquo;.</p><p>You may even use alternatives as the referencable terminal. This way, either an ID or a STRING may be used as the referencable terminal, as it is possible in many SQL dialects.</p><div class="literallayout"><p><code class="code">TableRef:&nbsp;table=[Table|(ID|STRING)];<br>
</code></p></div><p>Have a look at the 
							<a class="link" href="#">linking section</a> in order to understand how linking is done.
						</p></div><div class="section" title="Simple Actions"><div class="titlepage"><div><div><h5 class="title"><a name="SimpleActions"></a>Simple Actions </h5></div></div></div><p>By default the object to be returned by parser rule is created lazily on the first assignment. Then the type of the EObject to be created is determined from the specified return type (or the rule name if not explicit return type is specified).
							With Actions however, creation of EObject can be made explicit. Xtext supports two kinds of Actions:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>simple actions</p></li><li class="listitem"><p>assigned actions.</p></li></ol></div><p>If at some point you want to enforce creation of a specific type you can use alternatives or simple actions.
							In the following example TypeB must be a subtype of TypeA. An expression 
							<code class="code">A ident</code> should create an instance of TypeA, whereas 
							<code class="code">B ident</code> should instantiate TypeB.
						</p><p>Example with alternatives:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;MyRule&nbsp;returns&nbsp;TypeA&nbsp;:<br>
&nbsp;&nbsp;&nbsp;"A"&nbsp;name=ID&nbsp;|<br>
&nbsp;&nbsp;&nbsp;MyOtherRule;&nbsp;<br>
&nbsp;<br>
&nbsp;MyOtherRule&nbsp;returns&nbsp;TypeB&nbsp;:<br>
&nbsp;&nbsp;&nbsp;"B"&nbsp;name&nbsp;=&nbsp;ID;<br>
<br>
</code></p></div><p>Example with simple actions:  </p><div class="literallayout"><p><code class="code"><br>
&nbsp;MyRule&nbsp;returns&nbsp;TypeA&nbsp;:<br>
&nbsp;&nbsp;&nbsp;"A"&nbsp;name=ID&nbsp;|<br>
&nbsp;&nbsp;&nbsp;"B"&nbsp;{TypeB}&nbsp;name=ID;&nbsp;<br>
<br>
</code></p></div><p>Generally speaking, the instance is created as soon as the parser hits the first assignment. However, Actions allow to explicitly instantiate any EClass. The notation 
							<code class="code">{TypeB}</code> will create an instance of TypeB and assign it to the result of the parser rule. This allows parser rules without any assignment and object creation without the need to introduce stub-rules.
						</p></div><div class="section" title="Unassigned rule calls"><div class="titlepage"><div><div><h5 class="title"><a name="Unassignedrulecalls"></a>Unassigned rule calls </h5></div></div></div><p>We previously explained, that the EObject to be returned is created lazily when the first assignment occurs or when a simple action is evaluated. There is another way one can set the EObject to be returned, which we call an &ldquo;unassigned rule call&rdquo;.</p><p>Unassigned rule calls (the name suggests it) are rule calls to other parser rules, which are not used within an assignment. If there is no feature the returned value shall be assigned to, the value is assigned to the &ldquo;to-be-returned&rdquo; reference.</p><p>With unassigned rule calls one can, for instance, create rules which just dispatch between several other rules:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;AbstractToken&nbsp;:<br>
&nbsp;&nbsp;&nbsp;&nbsp;TokenA&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;TokenB&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;TokenC;<br>
<br>
</code></p></div><p>As 
							<code class="code">AbstractToken</code> could possibly return an instance of 
							<code class="code">TokenA</code>, 
							<code class="code">TokenB</code> or 
							<code class="code">TokenC</code> its type must by a super type to these types.
						</p><p>It is now for instance as well possible to further change the state of the AST element by assigning additional things.</p><p>Example:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;AbstractToken&nbsp;:<br>
&nbsp;&nbsp;&nbsp;(TokenA&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;TokenB&nbsp;|<br>
&nbsp;&nbsp;&nbsp;&nbsp;TokenC&nbsp;)&nbsp;(cardinality=('?'|'+'|'*'))?;<br>
<br>
</code></p></div><p>Thus, to state the cardinality is optional (last question mark) and can be represented by a question mark, a plus, or an asterisk.</p></div><div class="section" title="Tree Rewrite Actions"><div class="titlepage"><div><div><h5 class="title"><a name="TreeRewriteActions"></a>Tree Rewrite Actions </h5></div></div></div><p>LL parsing has some significant advantages over LR algorithms. The most important ones for Xtext are, that the generated code is much simpler to understand and debug and that it is easier to recover from errors and especially Antlr has a very nice generic error recovery mechanism. This allows to have AST constructed even if there are syntactic errors in the text. You wouldn&rsquo;t get any of the nice IDE features as soon as there is one little error, if we hadn&rsquo;t error recovery.</p><p>However, LL also has some drawbacks. The most important is, that it does not allow left recursive grammars.
							For instance, the following is not allowed in LL based grammars, because &ldquo;Expression '+' Expression&rdquo; is left recursive:</p><div class="literallayout"><p><code class="code">Expression&nbsp;:<br>
&nbsp;&nbsp;Expression&nbsp;'+'&nbsp;Expression&nbsp;|<br>
&nbsp;&nbsp;'('&nbsp;Expression&nbsp;')'<br>
&nbsp;&nbsp;INT;<br>
<br>
</code></p></div><p>Instead one has to rewrite such things by &ldquo;left-factoring&rdquo; it:</p><div class="literallayout"><p><code class="code">Expression&nbsp;:<br>
&nbsp;&nbsp;TerminalExpression&nbsp;('+'&nbsp;TerminalExpression)?;<br>
&nbsp;<br>
TerminalExpression&nbsp;:<br>
&nbsp;&nbsp;'('&nbsp;Expression&nbsp;')'&nbsp;|<br>
&nbsp;&nbsp;&nbsp;INT&nbsp;<br>
<br>
</code></p></div><p>In practice this is always the same pattern and therefore not that problematic. 
							However, by simply applying Xtext&rsquo;s AST construction we know so far like so ...</p><div class="literallayout"><p><code class="code">Expression&nbsp;:<br>
&nbsp;&nbsp;{Operation}&nbsp;left=TerminalExpression&nbsp;(op='+'&nbsp;right=TerminalExpression)?;<br>
&nbsp;<br>
TerminalExpression&nbsp;returns&nbsp;Expression:<br>
&nbsp;&nbsp;'('&nbsp;Expression&nbsp;')'&nbsp;|<br>
&nbsp;&nbsp;{IntLiteral}&nbsp;value=INT;<br>
<br>
</code></p></div><p>... one would get unwanted elements in the resulting AST.
							For instance the expression &ldquo; ( 42 ) &rdquo; would result in a tree like this:</p><div class="literallayout"><p><code class="code">Operation&nbsp;{<br>
&nbsp;&nbsp;left=Operation&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;left=IntLiteral&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value=42<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
}<br>
<br>
</code></p></div><p>Typically one would only want to have one instance of IntLiteral instead.</p><p>One can solve this problem using a combination of unassigned rule calls and actions:</p><div class="literallayout"><p><code class="code">Expression&nbsp;:<br>
&nbsp;&nbsp;TerminalExpression&nbsp;({Operation.left=current}&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;op='+'&nbsp;right=TerminalExpression)?;<br>
&nbsp;<br>
TerminalExpression&nbsp;returns&nbsp;Expression:<br>
&nbsp;&nbsp;'('&nbsp;Expression&nbsp;')'&nbsp;|<br>
&nbsp;&nbsp;{IntLiteral}&nbsp;value=INT;<br>
<br>
</code></p></div><p>In the example above 
							<code class="code">{Operation.left=current}</code> is a so called tree rewrite action, which creates a new instance of the stated EClass (Operation in this case) and assigns the element currently to-be-returned (current variable) to a feature of the newly created Object (in this case &lsquo;left&rsquo;).
							In Java the semantics could be expressed like so:
						</p><div class="literallayout"><p><code class="code">Operation&nbsp;temp&nbsp;=&nbsp;new&nbsp;Operation();<br>
temp.setLeft(current);<br>
current&nbsp;=&nbsp;temp;<br>
<br>
</code></p></div></div></div></div><div class="section" title="Hidden terminal symbols"><div class="titlepage"><div><div><h3 class="title"><a name="Hiddenterminalsymbols"></a>Hidden terminal symbols</h3></div></div></div><p>Because parser rules describe not a single token, but a sequence of patterns in the input, it is necessary to define the interesting parts of the input. Xtext introduces the concept of hidden tokens to handle semantically unimportant things like whitespaces, comments etc. in the input sequence gracefully. It is possible to define a set of terminal symbols, that are hidden from the parser rules and automatically skipped when they are recognized. Nevertheless, they are transparently woven into the node model, but not relevant for the semantic model. </p><p>Hidden terminals may (or may not) appear between any other terminals in any cardinality. They can be described per rule or for the whole grammar. When [[#Grammar_Mixins | reusing a single grammar]] its definition of hidden tokens is reused as well. The grammar org.eclipse.xtext.common.Terminals comes with a reasonable default and hides all comments and whitespace from the parser rules.</p><p>If a rule defines hidden symbols, you can think of a kind of scope that is automatically introduced. Any rule that is called from the declaring rule uses the same hidden terminals as the calling rule, unless it defines other hidden tokens itself.</p><div class="literallayout"><p><code class="code"><br>
&nbsp;Person&nbsp;hidden(WS,&nbsp;ML_COMMENT,&nbsp;SL_COMMENT):&nbsp;<br>
&nbsp;&nbsp;&nbsp;name=fullname&nbsp;age=INT&nbsp;';';<br>
<br>
&nbsp;Fullname:&nbsp;<br>
&nbsp;&nbsp;&nbsp;(firstname=ID)?&nbsp;lastname=ID;<br>
<br>
</code></p></div><p>The sample rule &ldquo;Person&rdquo; defines multiple-line comments (ML_COMMENT), single-line comments (SL_COMMENT), and whitespaces (WS) to be allowed between the &lsquo;Fullname&rsquo; and the &lsquo;age&rsquo;. Because &lsquo;Fullname&rsquo; does not introduce another set of hidden terminals, it allows the same symbols to appear between &lsquo;firstname&rsquo; and &lsquo;lastname&rsquo; as the calling rule &lsquo;pPerson&rsquo;. Thus, the following input is perfectly valid for the given grammar snippet:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;John&nbsp;/*&nbsp;comment&nbsp;*/&nbsp;Smith&nbsp;//&nbsp;line&nbsp;comment<br>
&nbsp;&nbsp;&nbsp;/*&nbsp;comment&nbsp;*/<br>
&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br>
<br>
</code></p></div><p>A list of all default terminals like WS can be found in section 
					<a class="link" href="#">Grammar Mixins</a>.
				</p></div><div class="section" title="Datatype rules"><div class="titlepage"><div><div><h3 class="title"><a name="Datatyperules"></a>Datatype rules</h3></div></div></div><p>Datatype rules are parsing-phase rules, which create instances of EDatatype as terminal rules do.
					The nice thing about datatype rules is that they are actually parser rules and are therefore </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>context sensitive and </p></li><li class="listitem"><p>allow for use of hidden tokens</p></li></ol></div><p>If you, for instance, want to define a rule to consume Java-like qualified names (e.g. &ldquo;foo.bar.Baz&rdquo;)
					you could write:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;QualifiedName&nbsp;:<br>
&nbsp;&nbsp;&nbsp;ID&nbsp;('.'&nbsp;ID)*;<br>
<br>
</code></p></div><p>Which looks similar to the terminal rule we&rsquo;ve defined above in order to explain rule calls.
					However, the difference is that because it is a parser rule and therefore only valid in certain contexts, it won&rsquo;t conflict with the rule ID.
					If you had defined it as a terminal rule, it would hide the ID rule.</p><p>In addition having this defined as a datatype rule, it is allowed to use hidden tokens (e.g. "/* comment 
					<span class="bold"><strong>/") between the IDs and dots (e.g. @foo/</strong></span> comment */. bar . Baz"@)
				</p><p>Return types can be specified like in terminal rules:</p><div class="literallayout"><p><code class="code">QualifiedName&nbsp;returns&nbsp;ecore::EString&nbsp;:&nbsp;ID&nbsp;('.'&nbsp;ID)*;<br>
</code></p></div><p>Note that if a rule does not call another parser rule and does not contain any actions nor assignments (see parser rules), it is considered a datatype rule and the datatype EString is implied if not explicitly declared differently.</p><p>For conversion again value converters are responsible (cf. 
					<a class="ulink" href="Xtext/Documentation/ValueConverter" target="_new">value converters</a>).
				</p></div><div class="section" title="Enum Rules"><div class="titlepage"><div><div><h3 class="title"><a name="EnumRules"></a>Enum Rules</h3></div></div></div><p>Enum rules return enumeration literals from strings. They can be seen as a shortcut for datatype rules with specific value converters.
					The main advantage of enum rules is their simplicity, typesafety and therefore nice validation. Furthermore it is possible to infere enums and their respective literals during the metamodel transformation.</p><p>If you want to define a ChangeKind [[http://help.eclipse.org/stable/index.jsp?topic=/org.eclipse.emf.doc/references/javadoc/org/eclipse/emf/ecore/change/impl/package-summary.html org.eclipse.emf.ecore.change/model/Change.ecore]] with &lsquo;ADD&rsquo;, &lsquo;MOVE&rsquo; and &lsquo;REMOVE&rsquo; you could write:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;enum&nbsp;ChangeKind&nbsp;:<br>
&nbsp;&nbsp;&nbsp;ADD&nbsp;|&nbsp;MOVE&nbsp;|&nbsp;REMOVE;<br>
<br>
</code></p></div><p>It is even possible to use alternative literals for your enums or reference an enum value twice:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;enum&nbsp;ChangeKind&nbsp;:<br>
&nbsp;&nbsp;&nbsp;ADD&nbsp;=&nbsp;'add'&nbsp;|&nbsp;ADD&nbsp;=&nbsp;'+'&nbsp;|&nbsp;<br>
&nbsp;&nbsp;&nbsp;MOVE&nbsp;=&nbsp;'move'&nbsp;|&nbsp;MOVE&nbsp;=&nbsp;'-&gt;'&nbsp;|&nbsp;<br>
&nbsp;&nbsp;&nbsp;REMOVE&nbsp;=&nbsp;'remove'&nbsp;|&nbsp;REMOVE&nbsp;=&nbsp;'-';<br>
<br>
</code></p></div><p>Please note, that Ecore does not support unset values for enums. If you formulate a grammar like</p><div class="literallayout"><p><code class="code"><br>
&nbsp;Element:&nbsp;"element"&nbsp;name=ID&nbsp;(value=SomeEnum)?;<br>
</code></p></div><p>with the input of</p><div class="literallayout"><p><code class="code"><br>
&nbsp;element&nbsp;Foo<br>
</code></p></div><p>the resulting value of the element 
					<code class="code">Foo</code> will hold the enum value with the internal representation of 0. When generating the EPackage from your grammar this will be the first literal you define. As a workaround you could introduce a dedicated none-value or order the enums accordingly. Note that it is not possible to define an enum literal with an empty textual representation.
				</p><div class="literallayout"><p><code class="code"><br>
&nbsp;enum&nbsp;Visibility:&nbsp;package&nbsp;|&nbsp;private&nbsp;|&nbsp;protected&nbsp;|&nbsp;public;<br>
</code></p></div></div></div><div class="section" title="Meta-Model inference"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metamodelInference"></a>Meta-Model inference</h2></div></div></div><p>The meta model of a textual language describes the structure of its abstract syntax trees (AST). </p><p>Xtext uses Ecore EPackages to define meta models. Meta models are declared to be either inferred (generated) from the grammar or imported. 
				By using the &lsquo;generate&rsquo; directive, one tells Xtext to derive an EPackage from the grammar. </p><div class="section" title="Type and Package Generation"><div class="titlepage"><div><div><h3 class="title"><a name="TypeandPackageGeneration"></a>Type and Package Generation</h3></div></div></div><p>Xtext creates</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>an EPackage</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>for each generated package declaration. After the directive '&lsquo;generate&rsquo;&lsquo; a list of parameters follows. The &rsquo;&lsquo;name&rsquo;&lsquo; of the EPackage will be set to the first parameter, its &rsquo;&lsquo;nsURI&rsquo;' to the second parameter. An optional alias as the third parameter allows to distinguish generated EPackages later. Only one generated package declaration per alias is allowed.</p></li></ul></div></li><li class="listitem"><p>an EClass</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>for each return type of a parser rule. If a parser rule does not define a return type, an implicit one with the same name is assumed. You can specify more than one rule that return the same type but only one EClass will be generated.</p></li><li class="listitem"><p>for each type defined in an action or a cross-reference.</p></li></ul></div></li><li class="listitem"><p>an EEnum</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>for each return type of an enum rule.</p></li></ul></div></li><li class="listitem"><p>an EDatatype</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>for each return type of a terminal rule or a datatype rule.</p></li></ul></div></li></ul></div><p>All EClasses, EEnums and EDatatypes are added to the EPackage referred to by the alias provided in the type reference they were created from.</p></div><div class="section" title="Feature and Type Hierarchy Generation"><div class="titlepage"><div><div><h3 class="title"><a name="FeatureandTypeHierarchyGeneration"></a>Feature and Type Hierarchy Generation</h3></div></div></div><p>While walking through the grammar, the algorithm keeps track of a set of the currently possible return types to add features to. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Entering a parser rule the set contains only the return type of the rule. </p></li><li class="listitem"><p>Entering a group in an alternative the set is reset to the same state it was in when entering the first group of this alternative. </p></li><li class="listitem"><p>Leaving an alternative the set contains the union of all types at the end of each of its groups.</p></li><li class="listitem"><p>After an optional element, the set is reset to the same state it was before entering it. </p></li><li class="listitem"><p>After a mandatory (non-optional) rule call or mandatory action the set contains only the return type of the called rule or action. </p></li><li class="listitem"><p>An optional rule call does not modify the set.</p></li><li class="listitem"><p>A rule call is optional, if its cardinality is &lsquo;?&rsquo; or &lsquo;*&rsquo;.</p></li></ul></div><p>While iterating the parser rules Xtext creates</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>an EAttribute in each current return type</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>of type EBoolean for each feature assignment using the &lsquo;?=&rsquo; operator. No further EReferences or EAttributes will be generated from this assignment.</p></li><li class="listitem"><p>for each assignment with the &lsquo;=&rsquo; or &lsquo;+=&rsquo; operator calling a terminal rule. Its type will be the return type of the called rule.</p></li></ul></div></li><li class="listitem"><p>an EReference in each current return type</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>for each assignment with the &lsquo;=&rsquo; or &lsquo;+=&rsquo; operator in a parser rule calling a parser rule. The EReference type will be the return type of the called parser rule.</p></li><li class="listitem"><p>for each action. The reference&rsquo;s type will be set to the return type of the current calling rule. </p></li></ul></div></li></ul></div><p>Each EAttribute or EReference takes its name from the assignment/action that caused it. Multiplicities will be 0...1 for assignments with the &lsquo;=&rsquo; operator and 0...* for assignments with the &lsquo;+=&rsquo; operator. </p><p>Furthermore, each type that is added to the currently possible return types automatically inherits from the current return type of the parser rule. You can specify additional common supertypes by means of &ldquo;artificial&rdquo; parser rules, that are never called, e.g.</p><div class="literallayout"><p><code class="code"><br>
&nbsp;CommonSuperType:<br>
&nbsp;&nbsp;&nbsp;SubTypeA&nbsp;|&nbsp;SubTypeB&nbsp;|&nbsp;SubTypeC;<br>
<br>
</code></p></div></div><div class="section" title="Enum Literal Generation"><div class="titlepage"><div><div><h3 class="title"><a name="EnumLiteralGeneration"></a>Enum Literal Generation</h3></div></div></div><p>For each alternative defined in an enum rule, the transformer creates an enum literal, when another with the same name cannot be found. The &lsquo;literal&rsquo; property of the generated enum literal is set to the right hand side of the declaration. If it is ommitted, you&rsquo;ll get an enum literal with equal &lsquo;name&rsquo; and &lsquo;literal&rsquo; attributes.</p><div class="literallayout"><p><code class="code"><br>
&nbsp;enum&nbsp;MyGeneratedEnum:<br>
&nbsp;&nbsp;&nbsp;NAME&nbsp;=&nbsp;'literal'&nbsp;|&nbsp;EQUAL_NAME_AND_LITERAL;<br>
<br>
</code></p></div></div><div class="section" title="Feature Normalization"><div class="titlepage"><div><div><h3 class="title"><a name="FeatureNormalization"></a>Feature Normalization</h3></div></div></div><p>Next the generator examines all generated EClasses and lifts up similar features to supertypes if there is more than one subtype and the feature is defined in every subtypes. This does even work for multiple supertypes.</p></div><div class="section" title="Customized Post Processing"><div class="titlepage"><div><div><h3 class="title"><a name="CustomizedPostProcessing"></a>Customized Post Processing</h3></div></div></div><p>As a last step, the generator invokes the post processor for every generated meta model. The post processor expects an Xtend file with name 
					<code class="code">MyDslPostProcessor.ext</code> (if the name of the grammar file is 
					<code class="code">MyDsl.xtext</code>) in the same folder as the grammar file. Further, for a successful invocation, the Xtend file must declare an extension with signature 
					<code class="code">process(xtext::GeneratedMetamodel)</code>. E.g.
				</p><div class="literallayout"><p><code class="code"><br>
&nbsp;process(xtext::GeneratedMetamodel&nbsp;this)&nbsp;:<br>
&nbsp;&nbsp;&nbsp;process(ePackage)<br>
&nbsp;;<br>
&nbsp;<br>
&nbsp;process(ecore::EPackage&nbsp;this)&nbsp;:<br>
&nbsp;&nbsp;&nbsp;...<br>
&nbsp;;<br>
<br>
</code></p></div><p>The invoked extension can then augment the generated Ecore model in place. Some typical use cases are to:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>set default values for attributes</p></li><li class="listitem"><p>add container references as opposites of existing containment references</p></li><li class="listitem"><p>add operations with implementation (using a body annotation)</p></li></ul></div><p>Great care must be taken not to modify the meta model in a way preventing the Xtext parser from working correctly (e.g. removing or renaming model elements).</p></div><div class="section" title="Error Conditions"><div class="titlepage"><div><div><h3 class="title"><a name="ErrorConditions"></a>Error Conditions</h3></div></div></div><p>The following conditions cause an error</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>An EAttribute or EReference has two different types or different cardinality.</p></li><li class="listitem"><p>There are an EAttribute and an EReference with the same name in the same EClass.</p></li><li class="listitem"><p>There is a cycle in the type hierarchy.</p></li><li class="listitem"><p>An new EAttribute, EReference or supertype is added to an imported type.</p></li><li class="listitem"><p>An EClass is added to an imported EPackage.</p></li><li class="listitem"><p>An undeclared alias is used. </p></li><li class="listitem"><p>An imported metamodel cannot be loaded.</p></li></ul></div></div></div><div class="section" title="Importing existing Meta Models"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ImportingexistingMetaModels"></a>Importing existing Meta Models</h2></div></div></div><p>With the import directive in Xtext you can refer to existing Ecore metamodels and reuse the types that are declared in an EPackage. Xtext uses this technique itself to leverage Ecore datatypes.</p><div class="literallayout"><p><code class="code">import&nbsp;"http://www.eclipse.org/emf/2002/Ecore"&nbsp;as&nbsp;ecore<br>
</code></p></div><p>Specify an explicit return type to reuse such imported types. Note that this even works for lexer rules.</p><div class="literallayout"><p><code class="code">terminal&nbsp;INT&nbsp;returns&nbsp;ecore::EInt&nbsp;:&nbsp;('0'..'9')+;<br>
</code></p></div></div><div class="section" title="Grammar Mixins"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="GrammarMixins"></a>Grammar Mixins</h2></div></div></div><p>Xtext supports the reuse of existing grammars. Grammars that are created via the Xtext wizard extend 
				<code class="code">org.eclipse.xtext.common.Terminals</code> by default. 
			</p><div class="literallayout"><p><code class="code"><br>
&nbsp;grammar&nbsp;org.xtext.example.MyDsl&nbsp;with&nbsp;org.eclipse.xtext.common.Terminals<br>
&nbsp;<br>
&nbsp;generate&nbsp;myDsl&nbsp;"http://www.xtext.org/example/MyDsl"<br>
&nbsp;<br>
&nbsp;....<br>
<br>
</code></p></div><p>Inheriting from another grammar makes the rules defined in that grammar referable. It is also possible to overwrite rules from the super grammar. </p><p>Example :</p><div class="literallayout"><p><code class="code"><br>
&nbsp;grammar&nbsp;my.SuperGrammar<br>
&nbsp;...<br>
&nbsp;RuleA&nbsp;:&nbsp;"a"&nbsp;stuff=RuleB;<br>
&nbsp;RuleB&nbsp;:&nbsp;"{"&nbsp;name=ID&nbsp;"}";<br>
<br>
&nbsp;grammar&nbsp;my.SubGrammar&nbsp;with&nbsp;my.SuperGrammar<br>
<br>
&nbsp;Model&nbsp;:&nbsp;(ruleAs+=RuleA)*;<br>
<br>
&nbsp;//&nbsp;overwrites&nbsp;my.SuperGrammar.RuleB<br>
&nbsp;RuleB&nbsp;:&nbsp;'['&nbsp;name=ID&nbsp;']';<br>
<br>
</code></p></div><p>Note that declared terminal rules always come before any imported / mixed-in terminal rules.</p></div><div class="section" title="Default tokens"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Defaulttokens"></a>Default tokens</h2></div></div></div><p>Xtext is shipped with a default set of predefined, reasonable and often required terminal rules. This grammar is defined as follows:</p><div class="literallayout"><p><code class="code">grammar&nbsp;org.eclipse.xtext.common.Terminals&nbsp;<br>
&nbsp;&nbsp;&nbsp;hidden(WS,&nbsp;ML_COMMENT,&nbsp;SL_COMMENT)<br>
<br>
&nbsp;import&nbsp;"http://www.eclipse.org/emf/2002/Ecore"&nbsp;as&nbsp;ecore<br>
<br>
&nbsp;terminal&nbsp;ID&nbsp;:&nbsp;<br>
&nbsp;&nbsp;&nbsp;'^'?('a'..'z'|'A'..'Z'|'_')&nbsp;('a'..'z'|'A'..'Z'|'_'|'0'..'9')*&nbsp;;<br>
&nbsp;terminal&nbsp;INT&nbsp;returns&nbsp;ecore::EInt:&nbsp;('0'..'9')+&nbsp;;<br>
&nbsp;terminal&nbsp;STRING	:&nbsp;<br>
&nbsp;&nbsp;&nbsp;'"'&nbsp;(&nbsp;'\\'&nbsp;('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\')&nbsp;|&nbsp;!('\\'|'"')&nbsp;)*&nbsp;'"'&nbsp;|<br>
&nbsp;&nbsp;&nbsp;"'"&nbsp;(&nbsp;'\\'&nbsp;('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\')&nbsp;|&nbsp;!('\\'|"'")&nbsp;)*&nbsp;"'"<br>
&nbsp;&nbsp;&nbsp;;&nbsp;<br>
&nbsp;terminal&nbsp;ML_COMMENT	:&nbsp;'/*'&nbsp;-&gt;&nbsp;'*/'&nbsp;;<br>
&nbsp;terminal&nbsp;SL_COMMENT&nbsp;	:&nbsp;'//'&nbsp;!('\n'|'\r')*&nbsp;('\r'?&nbsp;'\n')?&nbsp;;<br>
<br>
&nbsp;terminal&nbsp;WS		:&nbsp;('&nbsp;'|'\t'|'\r'|'\n')+&nbsp;;<br>
<br>
&nbsp;terminal&nbsp;ANY_OTHER:	.&nbsp;;<br>
<br>
&nbsp;<br>
<br>
</code></p></div></div><div class="section" title="The Generator"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="generator"></a>The Generator</h2></div></div></div><p>Text</p></div><div class="section" title="Dependency Injection in Xtext with Google Guice"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dependencyInjection"></a>Dependency Injection in Xtext with Google Guice</h2></div></div></div><div class="section" title="Modules"><div class="titlepage"><div><div><h3 class="title"><a name="Modules"></a>Modules</h3></div></div></div><p>The Guice Injector configuration is done through the use of Modules (also a Guice concept).
					The generator provides two modules when first called, one for runtime ([MyLanguage]RuntimeModule) and one for UI ([MyLanguage]UIModule).
					These modules are initially empty and intended to be manually edited when needed. These are also the modules used directly by the setup methods. 
					By default these modules extend a fully generated module.</p><div class="section" title="Generated Modules"><div class="titlepage"><div><div><h4 class="title"><a name="GeneratedModules"></a>Generated Modules</h4></div></div></div><p>The fully generated modules (never touch them!) are called Abstract[MyLanguage]RuntimeModule and Abstract[MyLanguage]UiModule respectively. 
						They contain all components which have been generated specifically for the language at hand.
						Examples are: the generated parsers, serializer or for UI a proposal provider for content assist is generated.
						What goes into these modules depends on how your generator is configured.</p></div><div class="section" title="Default Modules"><div class="titlepage"><div><div><h4 class="title"><a name="DefaultModules"></a>Default Modules</h4></div></div></div><p>Finally the fully generated modules extend the 
						<code class="code">DefaultRuntimeModule</code> (resp. 
						<code class="code">DefaultUiModule</code>), which contains all the default configuration. The default configuration consists of all components for which we have generic default implementations (interpreting as opposed to generated). 
						Examples are all the components used in linking, the outline view, hyperlinking and navigation. 
					</p></div><div class="section" title="Changing Configuration"><div class="titlepage"><div><div><h4 class="title"><a name="ChangingConfiguration"></a>Changing Configuration</h4></div></div></div><p>We use the primary modules ([MyLanguage]RuntimeModule and [MyLanguage]UiModule) in order to change the configuration. 
						The class is initially empty and has been generated only to allow for arbitrary customization.</p><p>In order to provide a simple and convenient way, in TMF Xtext every module extends AbstractXtextModule. 
						This class allows to write bindings like so:</p><div class="literallayout"><p><code class="code">public&nbsp;Class&lt;?&nbsp;extends&nbsp;MyInterface&gt;&nbsp;bind[anyname]()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;MyInterfaceImpl.class;<br>
&nbsp;}<br>
</code></p></div><p>Such a method will be interpreted as a binding from 
						<code class="code">MyInterface</code> to 
						<code class="code">MyInterfaceImpl</code>. Note that you simply have to override a method from a super class (e.g. from the generated or default module) in order to change the respective binding.
						Although this is a convenient and simple way, you have of course also the full power of Guice, i.e. you can override the Guice method 
						<code class="code">void bind(Binding)</code> and do what every you want.
					</p></div></div></div></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;Runtime Concepts"><div class="titlepage"><div><div><h2 class="title"><a name="RuntimeConcepts"></a>Chapter&nbsp;2.&nbsp;Runtime Concepts</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#RuntimesetupISetup">Runtime setup (ISetup)</a></span></dt><dt><span class="section"><a href="#SetupwithinEclipseEquinox">Setup within Eclipse / Equinox</a></span></dt><dt><span class="section"><a href="#validation">Validation</a></span></dt><dd><dl><dt><span class="section"><a href="#syntactical_validation">Syntactical Validation</a></span></dt><dt><span class="section"><a href="#linking_validation">Cross-link Validation</a></span></dt><dt><span class="section"><a href="#custom_validation">Custom Validation</a></span></dt></dl></dd><dt><span class="section"><a href="#linking">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="#Declarationofcrosslinks">Declaration of cross links</a></span></dt><dt><span class="section"><a href="#Specificationoflinkingsemantics">Specification of linking semantics</a></span></dt><dt><span class="section"><a href="#Defaultlinkingsemantics">Default linking semantics</a></span></dt></dl></dd><dt><span class="section"><a href="#scoping">Scoping</a></span></dt><dd><dl><dt><span class="section"><a href="#DeclarativeScopeProvider">Declarative Scope Provider</a></span></dt></dl></dd><dt><span class="section"><a href="#valueconverter">Value Converter</a></span></dt><dd><dl><dt><span class="section"><a href="#Annotationbasedvalueconverters">Annotation based value converters</a></span></dt></dl></dd><dt><span class="section"><a href="#transientvalues">Transient Values</a></span></dt><dt><span class="section"><a href="#fragmentProvider">Fragment Provider (referencing Xtext models from other EMF artifacts)</a></span></dt></dl></div><p>TMF Xtext itself and every language infrastructure developed with TMF Xtext is configured and wired-up using dependency injection (DI).</p><p>We use Google Guice as the underlying framework, and haven&rsquo;t built much on top of it as it pretty much does what we need.
			So instead of describing how google guice works, we refer to the website, where additional information can be found: 
			<a class="ulink" href="http://code.google.com/p/google-guice/" target="_new">http://code.google.com/p/google-guice/</a>. 
		</p><p>Using DI allows everyone to set up and change all components. This does not mean that everything which gets configured using DI (we use it a lot) is automatically public API. But we don&rsquo;t forbid use of non-public API, as we think you should decide, if you want to rely on stable API only or use things which might be changed (further enhanced ;-)) in future. See 
			<a class="link" href="#">Xtext API Documentation</a>.
		</p><div class="section" title="Runtime setup (ISetup)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RuntimesetupISetup"></a>Runtime setup (ISetup)</h2></div></div></div><p>For each language there is an implementation of 
				<code class="code">ISetup</code> generated. It implements a method called 
				<code class="code">doSetup()</code>, which can be called to do the initialization of the language infrastructure.
			</p><p>This class is intended to be used for runtime and unit testing, only.</p><p>The setup method returns an Injector, which can further be used to obtain a parser, etc.</p><p>The setup method also registers the ResourceFactory and generated EPackage with the respective global registries provided by EMF.</p><p>So basically you can just run the setup and start using EMF API to load and store models of your language.</p></div><div class="section" title="Setup within Eclipse / Equinox"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SetupwithinEclipseEquinox"></a>Setup within Eclipse / Equinox</h2></div></div></div><p>Within Eclipse we have a generated Activator, which creates a guice injector using the modules.
				In addition an IExecutableExtensionFactory is generated for each language, which is used to create ExecutableExtensions.
				This means that everything which is created via extension points is managed by guice as well, i.e. you can declare dependencies and get them injected upon creation. </p><p>The only thing you have to do in order to use this factory is to prefix the class with the factory ([MyLanguageName]ExecutableExtensionFactory) name followed by a colon.</p><div class="literallayout"><p><code class="code"><br>
&lt;extension<br>
&nbsp;&nbsp;point="org.eclipse.ui.editors"&gt;<br>
&nbsp;&nbsp;&lt;editor<br>
&nbsp;&nbsp;&nbsp;&nbsp;class="&lt;MyLanguageName&gt;ExecutableExtensionFactory:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;org.eclipse.xtext.ui.core.editor.XtextEditor"<br>
&nbsp;&nbsp;&nbsp;&nbsp;contributorClass=<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"org.eclipse.ui.editors.text.TextEditorActionContributor"<br>
&nbsp;&nbsp;&nbsp;&nbsp;default="true"<br>
&nbsp;&nbsp;&nbsp;&nbsp;extensions="ecoredsl"<br>
&nbsp;&nbsp;&nbsp;&nbsp;id="org.eclipse.xtext.example.EcoreDsl"<br>
&nbsp;&nbsp;&nbsp;&nbsp;name="EcoreDsl&nbsp;Editor"&gt;<br>
&nbsp;&nbsp;&lt;/editor&gt;<br>
&lt;/extension&gt;<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;<br>
<br>
</code></p></div></div><div class="section" title="Validation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation"></a>Validation</h2></div></div></div><p>Validation (a.k.a Static Analysis) is one of the most interesting aspects when developing a programming language. The users of your languages will be grateful
				if they get informative feedback as they type. 
				In Xtext there are basically three different kinds of validation</p><div class="section" title="Syntactical Validation"><div class="titlepage"><div><div><h3 class="title"><a name="syntactical_validation"></a>Syntactical Validation</h3></div></div></div><p>The syntactical correctness of any textual input is validated automatically by the parser. The error messages are generated by the underlying parser technology and cannot be customized using a general hook.
					Any syntax errors can be retrieved from the Resource using the common EMF API:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
							<code class="code">org.eclipse.emf.ecore.resource.Resource.getErrors()</code>
						</p></li><li class="listitem"><p>
							<code class="code">org.eclipse.emf.ecore.resource.Resource.getWarnings()</code>
						</p></li></ul></div></div><div class="section" title="Cross-link Validation"><div class="titlepage"><div><div><h3 class="title"><a name="linking_validation"></a>Cross-link Validation</h3></div></div></div><p>Any broken cross-links can be checked generically. As cross-link resolution is done lazily (see linking), any broken links are resolved lazy as well.
					If you want to validate whether all links are valid, you&rsquo;ll have to navigate through the model so that all proxies get resolved. This is done automatically in the editor.</p><p>Any unresolvable cross-links will be reported through:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
							<code class="code">org.eclipse.emf.ecore.resource.Resource.getErrors()</code>
						</p></li><li class="listitem"><p>
							<code class="code">org.eclipse.emf.ecore.resource.Resource.getWarnings()</code>
						</p></li></ul></div></div><div class="section" title="Custom Validation"><div class="titlepage"><div><div><h3 class="title"><a name="custom_validation"></a>Custom Validation</h3></div></div></div><p>In addition to the afore mentioned kinds of validations, which are more or less done automatically, you can specify additional constraints specific for your ecore model.
					We leverage existing EMF API (mainly EValidator) and have put some convenience stuff on top. 
					Basically all you need to do is to make sure that an EValidator is registered for your EPackage. The registry for 
					<code class="code">EValidators</code> (
					<code class="code">org.eclipse.emf.ecore.EValidator.Registry.INSTANCE</code>) can only be filled programatically,
					that means that there&rsquo;s no equinox extension point similar to the EPackage- and ResourceFactory registries.
				</p><p>For Xtext we provide a generator fragment for the convenient java-based EValidator API. Just add the following fragment to your generator configuration and you&rsquo;re good to go:</p><code class="code">&lt;fragment class="org.eclipse.xtext.generator.validation.JavaValidatorFragment"/&gt;</code><p>The generator will provide you with two Java classes. An abstract class generated to src-gen/ which extends the library class AbstractDeclarativeValidator. This one just registers the EPackages for which this validator contains constraints.
					The other class is a subclass of that abstract class and is generated to the src/ folder in order to be edited by you. That&rsquo;s where you put the constraints in.</p><p>The purpose of the AbstractDeclarativeValidator is to allow you to write constraints in a (the name says it) declarative way. That is instead of writing exhaustive if else constructs or extending the generated EMF switch you just have to add the @Check annotation to any method and it will be invoked automatically when validation takes place.
					Moreover you can state for what type the respective constraints method is, just by declaring a typed parameter. This also let&rsquo;s you avoid any castings.  
					In addition to the reflective invocation of test methods  the AbstractDeclarative provides a couple of convenience assertions.</p><p>All in all this is very similar to how Junit work. Example:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;&nbsp;public&nbsp;class&nbsp;DomainmodelJavaValidator&nbsp;extends&nbsp;AbstractDomainmodelJavaValidator&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;@Check<br>
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;checkTypeNameStartsWithCapital(Type&nbsp;type)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!Character.isUpperCase(type.getName().charAt(0)))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;warning("Name&nbsp;should&nbsp;start&nbsp;with&nbsp;a&nbsp;capital",&nbsp;DomainmodelPackage.TYPE__NAME);<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
<br>
<br>
</code></p></div></div></div><div class="section" title="Linking"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="linking"></a>Linking</h2></div></div></div><p>The linking feature allows for specification of cross references within an Xtext grammar.
				The following things are needed for the linking:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>declaration of a cross link in the grammar (at least in the meta model)</p></li><li class="listitem"><p>specification of linking semantics</p></li></ol></div><div class="section" title="Declaration of cross links"><div class="titlepage"><div><div><h3 class="title"><a name="Declarationofcrosslinks"></a>Declaration of cross links</h3></div></div></div><p>In the grammar a cross reference is specified using square brackets.</p><div class="literallayout"><p><code class="code">CrossReference&nbsp;:<br>
&nbsp;&nbsp;&nbsp;'['&nbsp;ReferencedEClass&nbsp;('|'&nbsp;terminal=AbstractTerminal)?&nbsp;']'<br>
</code></p></div><p>Example:</p><div class="literallayout"><p><code class="code">ReferringType&nbsp;:<br>
&nbsp;&nbsp;&nbsp;'ref'&nbsp;referencedObject=[Entity|(ID|STRING)];<br>
</code></p></div><p>The meta model derivation would create an 
					<code class="code">EClass</code> &lsquo;ReferringType&rsquo; with an 
					<code class="code">EReference</code> &lsquo;referencedObject&rsquo; of type &lsquo;Entity&rsquo; (containment=false). The referenced object would be identified either by an ID or a STRING and the surrounding information (see scoping).
				</p><p>Example: While parsing a given input string, say</p><div class="literallayout"><p><code class="code">ref&nbsp;Entity01<br>
</code></p></div><p>Xtext produces an instance of &lsquo;ReferringType&rsquo;. After this parsing step it enters the linking phase and tries to find an instance of '&lsquo;Entity&rsquo;' using the parsed text &lsquo;Entity01&rsquo;. The input </p><div class="literallayout"><p><code class="code">ref&nbsp;"EntityWith&Auml;&Ouml;&Uuml;"<br>
</code></p></div><p>would work analogously. This is not an ID (umlauts are not allowed), but a STRING (as it is apparent from the quotation marks).</p></div><div class="section" title="Specification of linking semantics"><div class="titlepage"><div><div><h3 class="title"><a name="Specificationoflinkingsemantics"></a>Specification of linking semantics</h3></div></div></div><p>The default 
					<code class="code">ILinker</code> implementation installs 
					<code class="code">EObject</code> proxies for all crosslinks, which are then resolved on demand.
					The actual cross ref resolution is done in 
					<code class="code">LazyLinkingResource.getEObject(String)</code> and delegates to 
					<code class="code">ILinkingService</code>.
					Although the default linking behavior is appropriate in many cases there might be scenarios where this is not sufficient. For each grammar a linking service can be implemented/configured, which implements the following interface:
				</p><div class="literallayout"><p><code class="code">@Stable(since&nbsp;=&nbsp;"0.7.0",&nbsp;subClass&nbsp;=&nbsp;AbstractLinkingService.class)<br>
public&nbsp;interface&nbsp;ILinkingService&nbsp;{<br>
<br>
&nbsp;&nbsp;/**<br>
&nbsp;&nbsp;&nbsp;*&nbsp;Returns&nbsp;all&nbsp;{@link&nbsp;EObject}s&nbsp;referenced&nbsp;by&nbsp;the&nbsp;given&nbsp;link&nbsp;text&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;*&nbsp;given&nbsp;context.&nbsp;But&nbsp;does&nbsp;not&nbsp;set&nbsp;the&nbsp;references&nbsp;or&nbsp;modifies&nbsp;the&nbsp;passed<br>
&nbsp;&nbsp;&nbsp;*&nbsp;information&nbsp;somehow<br>
&nbsp;&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;List&lt;EObject&gt;&nbsp;getLinkedObjects(<br>
&nbsp;&nbsp;&nbsp;&nbsp;EObject&nbsp;context,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;EReference&nbsp;reference,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;AbstractNode&nbsp;node)<br>
		throws&nbsp;IllegalNodeException;<br>
<br>
&nbsp;&nbsp;/**<br>
&nbsp;&nbsp;&nbsp;*&nbsp;Returns&nbsp;the&nbsp;textual&nbsp;representation&nbsp;of&nbsp;a&nbsp;given&nbsp;object&nbsp;as&nbsp;it&nbsp;would&nbsp;be<br>
&nbsp;&nbsp;&nbsp;*&nbsp;serialized&nbsp;in&nbsp;the&nbsp;given&nbsp;context.<br>
&nbsp;&nbsp;&nbsp;*&nbsp;<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;object<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;reference<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;context<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;the&nbsp;text&nbsp;representation.<br>
&nbsp;&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;String&nbsp;getLinkText(<br>
&nbsp;&nbsp;&nbsp;&nbsp;EObject&nbsp;object,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;EReference&nbsp;reference,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;EObject&nbsp;context);<br>
}<br>
<br>
</code></p></div><p>The method 
					<code class="code">getLinkedObjects</code> is directly related to this topic whereas 
					<code class="code">getLinkText</code> adresses complementary functionality: it is used for Serialization.
				</p><p>A simple implementation of the linking service (
					<code class="code">DefaultLinkingService</code>) is shipped with Xtext and is used for any grammar per default. It uses the default implementation of 
					<code class="code">IScopeProvider</code>. 
				</p></div><div class="section" title="Default linking semantics"><div class="titlepage"><div><div><h3 class="title"><a name="Defaultlinkingsemantics"></a>Default linking semantics</h3></div></div></div><p>The default implementation for all languages, looks within the current file for an EObject of the respective type (&lsquo;Entity&rsquo;) which has a name attribute set to &lsquo;Entity01&rsquo;. </p><p>Given the grammar :</p><div class="literallayout"><p><code class="code">Model&nbsp;:&nbsp;(stuff+=(Ref|Entity))*;<br>
&nbsp;Ref&nbsp;:&nbsp;'ref'&nbsp;referencedObject=[Entity|ID]&nbsp;';';<br>
&nbsp;Entity&nbsp;:&nbsp;'entity'&nbsp;name=ID&nbsp;';';<br>
<br>
</code></p></div><p>In the following model :</p><div class="literallayout"><p><code class="code">ref&nbsp;Entity01;<br>
&nbsp;entity&nbsp;Entity01;<br>
</code></p></div><p>the 
					<code class="code">ref</code> would be linked to the declared entity (
					<code class="code">entity Entity01;</code>).
				</p><div class="section" title="Default Imports"><div class="titlepage"><div><div><h4 class="title"><a name="DefaultImports"></a>Default Imports</h4></div></div></div><p>There is a default implementation for inter-resource referencing, which as well uses convention:</p><p>Given the grammar :</p><div class="literallayout"><p><code class="code">Model&nbsp;:&nbsp;(imports+=Import)*&nbsp;(stuff+=(Ref|Entity))*;<br>
&nbsp;Import&nbsp;:&nbsp;'import'&nbsp;importURI=STRING&nbsp;';';<br>
&nbsp;Ref&nbsp;:&nbsp;'ref'&nbsp;referencedObject=[Entity|ID]&nbsp;';';<br>
&nbsp;Entity&nbsp;:&nbsp;'entity'&nbsp;name=ID&nbsp;';';<br>
<br>
</code></p></div><p>With this grammar in place it would be possible to write three files in the new DSL where the first references the other two, like this:</p><div class="literallayout"><p><code class="code">--file&nbsp;model.dsl<br>
&nbsp;import&nbsp;"model1.dsl";<br>
&nbsp;import&nbsp;"model2.dsl";<br>
&nbsp;<br>
&nbsp;ref&nbsp;Foo;<br>
&nbsp;entity&nbsp;Bar;<br>
<br>
</code></p></div><div class="literallayout"><p><code class="code">--file&nbsp;model1.dsl&nbsp;<br>
&nbsp;entity&nbsp;Stuff;<br>
<br>
</code></p></div><div class="literallayout"><p><code class="code">--file&nbsp;model2.dsl<br>
&nbsp;entity&nbsp;Foo;<br>
<br>
</code></p></div><p>The resulting default scope list is as follows:</p><div class="literallayout"><p><code class="code">Scope&nbsp;(model.dsl)&nbsp;{<br>
&nbsp;&nbsp;parent&nbsp;:&nbsp;Scope&nbsp;(model1.dsl)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;parent&nbsp;:&nbsp;Scope&nbsp;(model2.dsl)&nbsp;{}<br>
&nbsp;&nbsp;}<br>
&nbsp;}<br>
<br>
</code></p></div><p>So, the outer scope is asked for an Entity named 
						<code class="code">Foo</code>, as it does not contain such a declaration itself its parent is asked and so on.
						The default implementation of 
						<code class="code">IScopeProvider</code> creates this kind of scope chain.
					</p></div></div></div><div class="section" title="Scoping"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scoping"></a>Scoping</h2></div></div></div><p>An 
				<code class="code">IScopeProvider</code> is responsible for providing an 
				<code class="code">IScope</code> for a given 
				<code class="code">EObject</code> and its 
				<code class="code">EReference</code>, for which all candidates shall be returned. 
			</p><div class="literallayout"><p><code class="code"><br>
@Stable(since&nbsp;=&nbsp;"0.7.0",&nbsp;subClass&nbsp;=&nbsp;AbstractScopeProvider.class)<br>
public&nbsp;interface&nbsp;IScopeProvider&nbsp;{<br>
<br>
&nbsp;&nbsp;/**<br>
&nbsp;&nbsp;&nbsp;*&nbsp;Returns&nbsp;a&nbsp;scope&nbsp;for&nbsp;the&nbsp;given&nbsp;context.&nbsp;The&nbsp;scope&nbsp;provides&nbsp;access&nbsp;to&nbsp;<br>
&nbsp;&nbsp;&nbsp;*&nbsp;the&nbsp;compatible&nbsp;visible&nbsp;EObjects&nbsp;for&nbsp;a&nbsp;given&nbsp;reference.<br>
&nbsp;&nbsp;&nbsp;*<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;context&nbsp;the&nbsp;element&nbsp;from&nbsp;which&nbsp;an&nbsp;element&nbsp;shall&nbsp;be&nbsp;referenced<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;reference&nbsp;the&nbsp;reference&nbsp;to&nbsp;be&nbsp;used&nbsp;to&nbsp;filter&nbsp;the&nbsp;elements.<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;{@link&nbsp;IScope}&nbsp;representing&nbsp;the&nbsp;inner&nbsp;most&nbsp;{@link&nbsp;IScope}&nbsp;for&nbsp;<br>
&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;passed&nbsp;context&nbsp;and&nbsp;reference.<br>
&nbsp;&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;public&nbsp;IScope&nbsp;getScope(EObject&nbsp;context,&nbsp;EReference&nbsp;reference);<br>
<br>
&nbsp;&nbsp;/**<br>
&nbsp;&nbsp;&nbsp;*&nbsp;Returns&nbsp;a&nbsp;scope&nbsp;for&nbsp;a&nbsp;given&nbsp;context.&nbsp;The&nbsp;scope&nbsp;contains&nbsp;any&nbsp;visible,&nbsp;<br>
&nbsp;&nbsp;&nbsp;*&nbsp;type-compatible&nbsp;element.<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;context&nbsp;the&nbsp;element&nbsp;from&nbsp;which&nbsp;an&nbsp;element&nbsp;shall&nbsp;be&nbsp;referenced<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;type&nbsp;the&nbsp;(super)type&nbsp;of&nbsp;the&nbsp;elements.<br>
&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;{@link&nbsp;IScope}&nbsp;representing&nbsp;the&nbsp;inner&nbsp;most&nbsp;{@link&nbsp;IScope}&nbsp;for<br>
&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;passed&nbsp;context&nbsp;and&nbsp;type.<br>
&nbsp;&nbsp;&nbsp;*/<br>
&nbsp;&nbsp;public&nbsp;IScope&nbsp;getScope(EObject&nbsp;context,&nbsp;EClass&nbsp;type);<br>
}<br>
<br>
</code></p></div><p>An 
				<code class="code">IScope</code> represents an element of a linked list of scopes. That means that a scope can be nested within an outer scope.
				For instance Java has multiple kinds of scopes (object scope, type scope, etc.).
			</p><p>For Java one would create the scope hierarchy as commented in the following example:</p><div class="literallayout"><p><code class="code"><br>
//&nbsp;file&nbsp;contents&nbsp;scope<br>
import&nbsp;static&nbsp;my.Constants.STATIC;<br>
<br>
public&nbsp;class&nbsp;ScopeExample&nbsp;{&nbsp;//&nbsp;class&nbsp;body&nbsp;scope<br>
	private&nbsp;Object&nbsp;field&nbsp;=&nbsp;STATIC;<br>
	<br>
	private&nbsp;void&nbsp;method(String&nbsp;param)&nbsp;{&nbsp;//&nbsp;method&nbsp;body&nbsp;scope<br>
		String&nbsp;localVar&nbsp;=&nbsp;"bar";<br>
		innerBlock:&nbsp;{&nbsp;//&nbsp;block&nbsp;scope<br>
			String&nbsp;innerScopeVar&nbsp;=&nbsp;"foo";<br>
			Object&nbsp;field&nbsp;=&nbsp;innerScopeVar;<br>
			//&nbsp;the&nbsp;scope&nbsp;hierarchy&nbsp;at&nbsp;this&nbsp;point&nbsp;would&nbsp;look&nbsp;like&nbsp;so:<br>
			//blockScope{field,innerScopeVar}-&gt;<br>
			//methodScope{localVar,param}-&gt;<br>
			//classScope{field}-&gt;&nbsp;('field'&nbsp;is&nbsp;overlayed)<br>
			//fileScope{STATIC}-&gt;<br>
			//classpathScope{'all&nbsp;qualified&nbsp;names&nbsp;of&nbsp;accessible&nbsp;static&nbsp;fields'}&nbsp;-&gt;<br>
			//NULLSCOPE{}<br>
			//<br>
		}<br>
		field.add(localVar);<br>
	}<br>
}<br>
<br>
</code></p></div><p>In fact the class path scope should also reflect the order of class path entries.
				For instance:</p><div class="literallayout"><p><code class="code">classpathScope{stuff&nbsp;from&nbsp;bin/}<br>
-&gt;&nbsp;classpathScope{stuff&nbsp;from&nbsp;foo.jar/}<br>
-&gt;&nbsp;...<br>
-&gt;&nbsp;classpathScope{stuff&nbsp;from&nbsp;JRE&nbsp;System&nbsp;Library}<br>
-&gt;&nbsp;NULLSCOPE{}<br>
</code></p></div><p>Please find the motivation behind this and some additional details in 
				<a class="ulink" href="http://blog.efftinge.de/2009/01/xtext-scopes-and-emf-index.html" target="_new">this blog post</a> .
			</p><div class="section" title="Declarative Scope Provider"><div class="titlepage"><div><div><h3 class="title"><a name="DeclarativeScopeProvider"></a>Declarative Scope Provider</h3></div></div></div><p>As always there is an implementation allowing to specify scoping in a declarative way (
					<code class="code">org.eclipse.xtext.crossref.impl.AbstractDeclarativeScopeProvider</code>).
					It looks up methods which have the following signature:
				</p><div class="literallayout"><p><code class="code">IScope&nbsp;scope_&lt;TypeToReturn&gt;(&lt;TypeOfContext&gt;&nbsp;ctx,&nbsp;EReference&nbsp;ref)<br>
</code></p></div><p>For example if you have a transition contained in a scope and you want to compute all reachable states the corresponding method could be declared as follows:</p><div class="literallayout"><p><code class="code">IScope&nbsp;scope_State(Transition&nbsp;this,&nbsp;EReference&nbsp;ref)<br>
</code></p></div><p>If such a method does not exist, the implementation will try to find one for the context&rsquo;s container. This allows to reuse the same scope for different elements and references. In the case of a state machine you might want to declare the scope with available states per state machine.
					This can simply be done using the following signature:</p><div class="literallayout"><p><code class="code">IScope&nbsp;scope_State(StateMachine&nbsp;this,&nbsp;EReference&nbsp;ref)<br>
</code></p></div><p>For a transition looking for possible states to link to, the implementation would first look for 
					<code class="code">scope_State(Transition,EReference)</code>, then for the container of the transition. Assuming that is a State the implementation would look for 
					<code class="code">scope_State(State,EReference)</code> and so on.
					Until it finds a matching method (e.g. 
					<code class="code">scope_State(StateMachine,EReference)</code>)
				</p></div></div><div class="section" title="Value Converter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="valueconverter"></a>Value Converter</h2></div></div></div><p>Value converters are registered to convert parsed text into a certain data type instance and back.
				The primary hook is called org.eclipse.xtext.conversion.IValueConverterService and the concrete implementation can be registered via the runtime Guice module (TODO reference to framework description).</p><div class="section" title="Annotation based value converters"><div class="titlepage"><div><div><h3 class="title"><a name="Annotationbasedvalueconverters"></a>Annotation based value converters</h3></div></div></div><p>The most simple way to register additional value converters is to make use of 
					<code class="code">org.eclipse.xtext.conversion.impl.AbstractAnnotationBasedValueConverterService</code>, which allows to
					declaratively register 
					<code class="code">IValueConverter</code> via annotated methods. 
				</p><p>The implementation for the default token grammar looks like </p><div class="literallayout"><p><code class="code">public&nbsp;class&nbsp;DefaultTerminalConverters&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;extends&nbsp;AbstractAnnotationBasedValueConverterService&nbsp;{<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;private&nbsp;Grammar&nbsp;grammar;<br>
&nbsp;&nbsp;	<br>
&nbsp;&nbsp;@Inject<br>
&nbsp;&nbsp;public&nbsp;void&nbsp;setGrammar(IGrammarAccess&nbsp;grammarAccess)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;this.grammar&nbsp;=&nbsp;grammarAccess.getGrammar();<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;	<br>
&nbsp;&nbsp;protected&nbsp;Grammar&nbsp;getGrammar()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;grammar;<br>
&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;@ValueConverter(rule&nbsp;=&nbsp;"ID")<br>
&nbsp;&nbsp;public&nbsp;IValueConverter&lt;String&gt;&nbsp;ID()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;AbstractNullSafeConverter&lt;String&gt;()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;String&nbsp;internalToValue(String&nbsp;string,&nbsp;AbstractNode&nbsp;node)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;string.startsWith("^")&nbsp;?&nbsp;string.substring(1)&nbsp;:&nbsp;string;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;String&nbsp;internalToString(String&nbsp;value)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(GrammarUtil.getAllKeywords(getGrammar()).contains(value))&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;"^"+value;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;value;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;};<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;some&nbsp;other&nbsp;value&nbsp;converter<br>
<br>
</code></p></div><p>If you use the common terminals grammar (
					<code class="code">org.eclipse.xtext.common.Terminals</code>) you should subclass 
					<code class="code">DefaultTerminalConverters</code> and overwrite or add addition value converter by adding the respective methods.
				</p><p>Imagine, you would want to add a rule creating BigDecimals:</p><div class="literallayout"><p><code class="code">@ValueConverter(rule&nbsp;=&nbsp;"BIG_DECIMAL")<br>
&nbsp;&nbsp;public&nbsp;IValueConverter&lt;String&gt;&nbsp;BIG_DECIMAL()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;AbstractToStringConverter&lt;BigDecimal&gt;()&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;BigDecimal&nbsp;internalToValue(String&nbsp;string,&nbsp;AbstractNode&nbsp;node)&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;BigDecimal.valueOf(string);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;};<br>
&nbsp;&nbsp;}<br>
<br>
</code></p></div></div></div><div class="section" title="Transient Values"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transientvalues"></a>Transient Values</h2></div></div></div><p>text</p></div><div class="section" title="Fragment Provider (referencing Xtext models from other EMF artifacts)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="fragmentProvider"></a>Fragment Provider (referencing Xtext models from other EMF artifacts)</h2></div></div></div><p>Although inter-Xtext linking is not done by URIs, you may want to be able to reference your 
				<code class="code">EObject</code> from non-Xtext models.
				In those cases URIs are used, which are made up of a part identifying the resource. Each 
				<code class="code">EObject</code> contained in a resource can be identified by a so called 
				<span class="emphasis"><em>fragment</em></span>.
			</p><p>A fragment is a part of an EMF URI and needs to be unique per resource.</p><p>The generic XMI resource shipped with EMF provides a generic path-like computation of fragments. With an XMI or other binary-like serialization it is also common and possible to use UUIDs.</p><p>However with a textual concrete syntax we want to be able to compute fragments out of the given information. We don&rsquo;t want to force people to use UUIDs (i.e. synthetic identifiers) or relative generic paths (very fragile), in order to refer to 
				<code class="code">EObjects</code>.
			</p><p>Therefore one can contribute a so called 
				<code class="code">IFragmentProvider</code> per language.
			</p><div class="literallayout"><p><code class="code">public&nbsp;interface&nbsp;IFragmentProvider&nbsp;extends&nbsp;ILanguageService&nbsp;{<br>
&nbsp;<br>
	/**<br>
	&nbsp;*&nbsp;Computes&nbsp;the&nbsp;local&nbsp;ID&nbsp;of&nbsp;the&nbsp;given&nbsp;object.&nbsp;<br>
	&nbsp;*&nbsp;@param&nbsp;obj<br>
	&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;EObject&nbsp;to&nbsp;compute&nbsp;the&nbsp;fragment&nbsp;for<br>
	&nbsp;*&nbsp;@return&nbsp;the&nbsp;fragment,&nbsp;which&nbsp;can&nbsp;be&nbsp;an&nbsp;arbitrary&nbsp;string&nbsp;but&nbsp;must&nbsp;be&nbsp;<br>
	&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unique&nbsp;within&nbsp;a&nbsp;resource.&nbsp;Return&nbsp;null&nbsp;to&nbsp;use&nbsp;default&nbsp;<br>
	&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implementation<br>
	&nbsp;*/<br>
	String&nbsp;getFragment(EObject&nbsp;obj);<br>
	<br>
	/**<br>
	&nbsp;*&nbsp;Locates&nbsp;an&nbsp;EObject&nbsp;in&nbsp;a&nbsp;resource&nbsp;by&nbsp;its&nbsp;fragment.&nbsp;<br>
	&nbsp;*&nbsp;@param&nbsp;resource<br>
	&nbsp;*&nbsp;@param&nbsp;fragment<br>
	&nbsp;*&nbsp;@return&nbsp;the&nbsp;EObject&nbsp;<br>
	&nbsp;*/<br>
	EObject&nbsp;getEObject(Resource&nbsp;resource,&nbsp;String&nbsp;fragment);<br>
&nbsp;}<br>
<br>
</code></p></div><p>However, the currently available default fragment provider does nothing.</p></div></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;IDE concepts"><div class="titlepage"><div><div><h2 class="title"><a name="IDEconcepts"></a>Chapter&nbsp;3.&nbsp;IDE concepts</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#concurrency">Managing Concurrency</a></span></dt><dt><span class="section"><a href="#labelProvider">Label Provider</a></span></dt><dt><span class="section"><a href="#contentAssist">Content Assist</a></span></dt><dd><dl><dt><span class="section"><a href="#ProposalProvider">ProposalProvider</a></span></dt><dt><span class="section"><a href="#SampleImplementation">Sample Implementation</a></span></dt></dl></dd><dt><span class="section"><a href="#templates">Template Proposals</a></span></dt><dd><dl><dt><span class="section"><a href="#CrossReferenceResolver">CrossReference Resolver</a></span></dt></dl></dd><dt><span class="section"><a href="#outline">Outline View</a></span></dt><dt><span class="section"><a href="#navigation">Navigation and Hyperlinking</a></span></dt><dt><span class="section"><a href="#formatting">Formatting (Pretty Printing)</a></span></dt></dl></div><p>For the following part we will refer to a concrete example grammar in order to explain certain aspect of the UI more clearly. The used example grammar is as follows:</p><div class="literallayout"><p><code class="code">grammar&nbsp;org.eclipse.text.documentation.Sample&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;org.eclipse.xtext.common.Terminals<br>
<br>
generate&nbsp;gen&nbsp;'http://www.eclipse.org/xtext/documentation/Sample'&nbsp;as&nbsp;gen<br>
<br>
Model&nbsp;:<br>
&nbsp;&nbsp;"model"&nbsp;intAttribute=INT&nbsp;(stringDescription=STRING)?&nbsp;"{"&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rules&nbsp;+=&nbsp;AbstractRule)*&nbsp;<br>
&nbsp;&nbsp;"}"&nbsp;<br>
;<br>
<br>
AbstractRule:<br>
&nbsp;&nbsp;RuleA&nbsp;|&nbsp;RuleB<br>
;<br>
	&nbsp;<br>
RuleA&nbsp;:<br>
	&nbsp;"RuleA"&nbsp;"("&nbsp;name&nbsp;=&nbsp;ID&nbsp;")"&nbsp;;<br>
	&nbsp;<br>
RuleB&nbsp;return&nbsp;gen::CustomType:<br>
	&nbsp;"RuleB"&nbsp;"("&nbsp;ruleA&nbsp;=&nbsp;[RuleA]&nbsp;")"&nbsp;;<br>
<br>
</code></p></div><p></p><div class="section" title="Managing Concurrency"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="concurrency"></a>Managing Concurrency</h2></div></div></div><p>text</p></div><div class="section" title="Label Provider"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="labelProvider"></a>Label Provider</h2></div></div></div><p>text</p></div><div class="section" title="Content Assist"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="contentAssist"></a>Content Assist</h2></div></div></div><p>The Xtext generator, amongst other things, generates the following two content assist (CA) related artifacts:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>an abstract proposal provider class named '
						<code class="code">Abstract[Language]ProposalProvider'</code> generated into the 
						<code class="code">src-gen</code> folder within the 
						<code class="code">ui</code> project
					</p></li><li class="listitem"><p>a concrete descendent in the 
						<code class="code">src</code>-folder of the 
						<code class="code">ui</code> project 
						<code class="code">ProposalProvider</code>
					</p></li></ul></div><p>First we will investigate the generated 
				<code class="code">Abstract[Language]ProposalProvider</code> with methods that look like this:
			</p><div class="section" title="ProposalProvider"><div class="titlepage"><div><div><h3 class="title"><a name="ProposalProvider"></a>ProposalProvider</h3></div></div></div><div class="literallayout"><p><code class="code">public&nbsp;void&nbsp;complete[TypeName]_[FeatureName](<br>
&nbsp;&nbsp;EObject&nbsp;model,&nbsp;<br>
&nbsp;&nbsp;Assignment&nbsp;assignment,&nbsp;<br>
&nbsp;&nbsp;ContentAssistContext&nbsp;context,&nbsp;<br>
&nbsp;&nbsp;ICompletionProposalAcceptor&nbsp;acceptor)&nbsp;{<br>
&nbsp;&nbsp;//&nbsp;clients&nbsp;may&nbsp;override<br>
}<br>
<br>
public&nbsp;void&nbsp;complete_[RuleName](<br>
&nbsp;&nbsp;EObject&nbsp;model,&nbsp;<br>
&nbsp;&nbsp;RuleCall&nbsp;ruleCall,&nbsp;<br>
&nbsp;&nbsp;ContentAssistContext&nbsp;context,&nbsp;<br>
&nbsp;&nbsp;ICompletionProposalAcceptor&nbsp;acceptor)&nbsp;{<br>
&nbsp;&nbsp;//&nbsp;clients&nbsp;may&nbsp;override<br>
}<br>
<br>
</code></p></div><p>The snippet above indicates that the generated ProposalProvider class contains a 
					<code class="code">complete*</code>-method for each assigned feature in the grammar and for each rule. The brackets are placeholders that should give a clue about the naming scheme, that is used to create the various entry points for clients. The generated proposal provider falls back to some default behavior for cross references. Furthermore it inherits the logic that was introduced in reused grammars. 
				</p><p>Clients who want to customize the behavior may override the methods from the 
					<code class="code">AbstractProposalProvider</code> or in turn introduce new methods with specialized parameters. The framework dispatches method calls according to the current context to the most concrete implementation, that can be found.
				</p><p>It is important to know, that for a given offset in a model file, many possible grammar elements exist. The framework dispatches to the method declarations for any valid element. That means, that a bunch of '&lsquo;complete.*&rsquo;' may be called.</p></div><div class="section" title="Sample Implementation"><div class="titlepage"><div><div><h3 class="title"><a name="SampleImplementation"></a>Sample Implementation</h3></div></div></div><p>To provide a dummy proposal for the description of a model object, you may introduce a specialization of the generated method and implement it as follows. This will give &lsquo;Description for model #7&rsquo; for a model with the intAttribute '7'</p><div class="literallayout"><p><code class="code">public&nbsp;void&nbsp;completeModel_StringDescription&nbsp;(<br>
&nbsp;&nbsp;Model&nbsp;model,&nbsp;<br>
&nbsp;&nbsp;Assignment&nbsp;assignment,&nbsp;<br>
&nbsp;&nbsp;ContentAssistContext&nbsp;context,&nbsp;<br>
&nbsp;&nbsp;ICompletionProposalAcceptor&nbsp;acceptor)&nbsp;{<br>
&nbsp;&nbsp;//&nbsp;call&nbsp;implementation&nbsp;in&nbsp;superclass<br>
&nbsp;&nbsp;super.completeModel_StringDescription(<br>
&nbsp;&nbsp;&nbsp;&nbsp;model,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;assignment,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;context,&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;acceptor);<br>
<br>
&nbsp;&nbsp;//&nbsp;compute&nbsp;the&nbsp;plain&nbsp;proposal<br>
&nbsp;&nbsp;String&nbsp;proposal&nbsp;=&nbsp;"Description&nbsp;for&nbsp;model&nbsp;#"&nbsp;+&nbsp;model.getIntAttribute();<br>
<br>
&nbsp;&nbsp;//&nbsp;convert&nbsp;it&nbsp;to&nbsp;a&nbsp;valid&nbsp;STRING-terminal<br>
&nbsp;&nbsp;proposal&nbsp;=&nbsp;getValueConverter().toString(proposal,&nbsp;"STRING");<br>
<br>
&nbsp;&nbsp;//&nbsp;create&nbsp;the&nbsp;completion&nbsp;proposal<br>
&nbsp;&nbsp;//&nbsp;the&nbsp;result&nbsp;may&nbsp;be&nbsp;null&nbsp;as&nbsp;the&nbsp;createCompletionProposal(..)&nbsp;methods&nbsp;<br>
&nbsp;&nbsp;//&nbsp;check&nbsp;for&nbsp;valid&nbsp;prefixes<br>
&nbsp;&nbsp;//&nbsp;and&nbsp;terminal&nbsp;token&nbsp;conflicts<br>
&nbsp;&nbsp;ICompletionProposal&nbsp;completionProposal&nbsp;=&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;createCompletionProposal(proposal,&nbsp;contentAssistContext);<br>
<br>
&nbsp;&nbsp;//&nbsp;register&nbsp;the&nbsp;proposal,&nbsp;the&nbsp;acceptor&nbsp;handles&nbsp;null-values&nbsp;gracefully<br>
&nbsp;&nbsp;acceptor.accept(completionProposal);<br>
}<br>
<br>
</code></p></div></div></div><div class="section" title="Template Proposals"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="templates"></a>Template Proposals</h2></div></div></div><p>Xtext-based editors automatically support code templates. That means that you get the corresponding preference page where users can add and change template proposals. If you want to ship a couple of default templates, you have to put a file under 
				<code class="code">templates/templates.xml</code> containing templates in a format described in the 
				<a class="ulink" href="http://help.eclipse.org/ganymede/topic/org.eclipse.cdt.doc.user/tasks/cdt_t_imp_code_temp.htm" target="_new">eclipse help</a>  .
			</p><p>By default Xtext registers ContextTypes for each Rule (
				<code class="code">.[RuleName]</code>) and for each keyword (
				<code class="code">.kw_[keyword]</code>), as long as the keywords are valid identifiers.
			</p><p>If you don&rsquo;t like these defaults you&rsquo;ll have to subclass 
				<code class="code">org.eclipse.xtext.ui.common.editor.templates.XtextTemplateContextTypeRegistry</code> and configure it via Guice.
			</p><div class="section" title="CrossReference Resolver"><div class="titlepage"><div><div><h3 class="title"><a name="CrossReferenceResolver"></a>CrossReference Resolver</h3></div></div></div><p>Xtext comes with a specific template variable resolver (
					<code class="code">org.eclipse.jface.text.templates.TemplateVariableResolver</code>) called 
					<code class="code">CrossReferenceResolver</code>, which can be used to place cross refs within a template.
				</p><p>The syntax is as follows:</p><div class="literallayout"><p><code class="code">${someText:CrossReference('MyType.myRef')}<br>
</code></p></div><p>For example the following template:</p><div class="literallayout"><p><code class="code">&lt;template&nbsp;name="transition"&nbsp;description="event&nbsp;transition"<br>
&nbsp;&nbsp;&nbsp;&nbsp;id="transition"<br>
&nbsp;&nbsp;&nbsp;&nbsp;context="org.eclipse.xtext.example.FowlerDsl.Transition"&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;enabled="true"<br>
&nbsp;&nbsp;&gt;${event:CrossReference('Transition.event')}&nbsp;=&gt;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;${state:CrossReference('Transition.state')&lt;/<br>
&nbsp;&nbsp;template&gt;<br>
</code></p></div><p>yields the text

					<code class="code">event =&gt; state</code> and allows selecting any events and states using a drop down.
				</p></div></div><div class="section" title="Outline View"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="outline"></a>Outline View</h2></div></div></div><p>text</p></div><div class="section" title="Navigation and Hyperlinking"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="navigation"></a>Navigation and Hyperlinking</h2></div></div></div><p>text</p></div><div class="section" title="Formatting (Pretty Printing)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="formatting"></a>Formatting (Pretty Printing)</h2></div></div></div><p>text</p></div></div><div class="chapter" title="Chapter&nbsp;4.&nbsp;From oAW to TMF"><div class="titlepage"><div><div><h2 class="title"><a name="from_oaw_to_tmf"></a>Chapter&nbsp;4.&nbsp;From oAW to TMF</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#why_rewrite">Why a rewrite</a></span></dt><dt><span class="section"><a href="#Xtend_based_apis">Xtend-based APIs</a></span></dt><dd><dl><dt><span class="section"><a href="#Xtend_is_hard_to_debug">Xtend is hard to debug</a></span></dt><dt><span class="section"><a href="#Xtend_is_slow">Xtend is slow</a></span></dt><dt><span class="section"><a href="#Declarative_Java">Declarative Java</a></span></dt><dt><span class="section"><a href="#conclusion">Conclusion</a></span></dt></dl></dd><dt><span class="section"><a href="#differences">Differences</a></span></dt><dd><dl><dt><span class="section"><a href="#differenced_grammar_language">Differences in the grammar language</a></span></dt></dl></dd></dl></div><p>TMF Xtext is a complete rewrite of the Xtext framework previously released with openArchitectureWare 4.3.1 (oAW). We refer to the version from oAW as oAW Xtext.
			oAW Xtext has been around for about 2 years before TMF Xtext was released in June 2009 and has been used by many people to develop little languages and corresponding Eclipse-based IDE support.</p><p>This document describes the differences between oAW Xtext and TMF Xtext and is intended to be used as a guide to migrate from oAW Xtext to TMF Xtext.
			For people already familiar with the concepts of oAW Xtext it should also serves as a shortcut to learn TMF Xtext.  </p><div class="section" title="Why a rewrite"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="why_rewrite"></a>Why a rewrite</h2></div></div></div><p>The first thing you might wonder about is why we decided to reimplement the framework from scratch as opposed to use the existing code base and enhance it further on. 
				We decided so because we had learned a lot of lessons from oAW Xtext and wanted to stick with many proven concepts 
				but found the implementation to lack a solid foundation (the author of these lines is the original author of that non-solid code btw. :-)). The first version of oAW Xtext was just a proof of concept
				and was so well received that it had been extended with all kinds of features (some were good, some were bad). Unfortunately code quality, clean and orthogonal concepts and test coverage had not the needed focus.</p><p>In addition to this general lack of code quality, oAW Xtext suffers from some severe performance problems. The naive use of Xtend (see next section) made use of bigger models in Xtext editors unusable.</p></div><div class="section" title="Xtend-based APIs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Xtend_based_apis"></a>Xtend-based APIs</h2></div></div></div><p>One of the nice things with oAW Xtext was the use of Xtend to allow customizing different aspects of the generated language infrastructure. 
				Xtend is a part of the template language Xpand, which is shipped with oAW (and now is included in M2T Xpand).  It provides nicer expression syntax than Java
				especially the existence of higher-order functions for collections are extremely handy when working with models.
				In addition to the nice syntax it provides dynamic polymorphic dispatch, which means that declaring e.g. label computation for a meta model is very convenient and type safe.
				In contrast using Java one usually has to write instanceof and cast orgies. </p><div class="section" title="Xtend is hard to debug"><div class="titlepage"><div><div><h3 class="title"><a name="Xtend_is_hard_to_debug"></a>Xtend is hard to debug</h3></div></div></div><p>While the aforementioned things allow for convenient specification of label and icon providers, outline views, content assist and linking. Xtend is interpreted and therefore hard to debug.
					Because of that Xpand is shipped with a special debugger facility, however using the shipped debugger implies that the Xtend functions are called from a workflow. This is not and cannot be the case in Xtext.
					As a result one has to debug his way through the interpreter, which is hard and inconvenient even for us, who have written that interpreter.</p></div><div class="section" title="Xtend is slow"><div class="titlepage"><div><div><h3 class="title"><a name="Xtend_is_slow"></a>Xtend is slow</h3></div></div></div><p>But the problematic debugging was not the main reason why there are no Xtend-based APIs in TMF Xtext. The main reason is that Xtend is too slow to be evaluated &ldquo;live in the editor&rdquo;, that is evaluating lots of Xtend code while you type. 
					While Xtend&rsquo;s performance is sufficiently good when run in a code generator, it is just too slow to be executed on keystroke (or 500ms after the last keystroke, which is when the reconciler reparses, links and validates the model).
					Xtend is relatively slow, because it supports polymorphic dispatch (the cool feature mentioned above), which means that for each invocation it matches at runtime wich function is the best match and it has to do so on each call.
					Also Xtend supports a plggable typesystem, where you can adapt to other existing type systems such as JavaBeans or Ecore. Last but not least the code is interpreted and not compiled once. The price we pay for all these nice features reduced performance.</p><p>In addition to these scalability problems we have designed seom core concepts around the idea of Iterables, which allows for lazy resolution of things. As Xtend does not know the concept of Iterators you&rsquo;ld have work with lists all the time. This is far more expensive than chaining Iterables through filters and transformers like we do with Google Collections in TMF Xtext.</p></div><div class="section" title="Declarative Java"><div class="titlepage"><div><div><h3 class="title"><a name="Declarative_Java"></a>Declarative Java</h3></div></div></div><p>To summarize this we had to find a way to allow for convenient, scalable and debuggable APIs. Ultimately we wanted to provide neat DSLs for every view point, which provide all these things. However, we had to prioritize our efforts with the available resources in mind. 
					As a result we found ways and means to tweak Javaas good as possible to allow for relatively convenient, high performing implementations. </p><p>To allow convenience in Java we tried to mimic the nice things of Xtend in Java. This is done through two things</p><div class="section" title="Polymorphic Dispatcher"><div class="titlepage"><div><div><h4 class="title"><a name="polymorphic_dispatching"></a>Polymorphic Dispatcher</h4></div></div></div><p>Most of the APIs in TMF Xtext use polymorphic dispatching, which mimics the polymorphic dispatch know from Xtend. A ILabelProvider to be used in any Eclipse view can be writte like so for instance:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;&nbsp;public&nbsp;class&nbsp;XtextLabelProvider&nbsp;extends&nbsp;DefaultLabelProvider&nbsp;{<br>
<br>
	&nbsp;&nbsp;String&nbsp;text(Grammar&nbsp;grammar)&nbsp;{<br>
		&nbsp;&nbsp;return&nbsp;GrammarUtil.getName(grammar);<br>
	&nbsp;&nbsp;}<br>
	<br>
	&nbsp;&nbsp;String&nbsp;image(Grammar&nbsp;grammar)&nbsp;{<br>
		&nbsp;&nbsp;return&nbsp;"language.gif";<br>
	&nbsp;&nbsp;}<br>
	<br>
	&nbsp;&nbsp;String&nbsp;image(GeneratedMetamodel&nbsp;metamodel)&nbsp;{<br>
		&nbsp;&nbsp;return&nbsp;"export.gif";<br>
	&nbsp;&nbsp;}<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;<br>
</code></p></div><p>As you can see this is very similar to the way one describes labels and icons in oAW Xtext, but has the advantage that it is easier to test and to debug, faster and can be used everywhere an ILabelProvider is expected.</p></div><div class="section" title="Google Collections"><div class="titlepage"><div><div><h4 class="title"><a name="google_collections"></a>Google Collections</h4></div></div></div><p>The other thing we love about Xtend is its convenient way to navigate a model. This is something which can&rsquo;t be done with Java, as it lacks closures and in general requires to write lots of boilerplate such as superfluos type information, etc. So this is where you have to make compromises.
						Anyway, we think this could be improved a bit by using Google Collections which is (the name suggests it) a collections framewokr written by google. It&rsquo;s open-source and there&rsquo;s a JSR proposing to add the framework to the JDK, which would IMHO be a very good addition.</p><p>It provides lots of nice static factory methods similar to what we have in java.util.Collections and java.util.Arrays, contains higher-order functions based on a function type included in the library and a couple of very good collection implementations such as multi maps and immutable implementations of the various collection types. With this it is possible to  write a chain of filters and transformers like so.</p><div class="literallayout"><p><code class="code"><br>
&nbsp;&nbsp;&nbsp;	ArrayList&lt;String&gt;&nbsp;names&nbsp;=&nbsp;newArrayList("foo",&nbsp;"bar",&nbsp;"honk");<br>
		Iterable&lt;String&gt;&nbsp;filtered&nbsp;=&nbsp;filter(names,&nbsp;not(isEqualTo("bar")));<br>
		Iterable&lt;Integer&gt;&nbsp;lengths&nbsp;=&nbsp;transform(filtered,new&nbsp;Function&lt;String,&nbsp;Integer&gt;()&nbsp;{<br>
			public&nbsp;Integer&nbsp;apply(String&nbsp;from)&nbsp;{<br>
				return&nbsp;from.length();<br>
			}<br>
		});<br>
<br>
</code></p></div><p>or in a more functional way :</p><div class="literallayout"><p><code class="code"><br>
	&nbsp;transform(<br>
			filter(<br>
				newArrayList("foo",&nbsp;"bar",&nbsp;"honk"),&nbsp;<br>
				not(isEqualTo("bar"))<br>
			),<br>
			new&nbsp;Function&lt;String,&nbsp;Integer&gt;()&nbsp;{<br>
				public&nbsp;Integer&nbsp;apply(String&nbsp;from)&nbsp;{<br>
					return&nbsp;from.length();<br>
				}<br>
			}<br>
		);<br>
<br>
</code></p></div><p>From a syntactical point of view Google Collections is in no way a replacement for real closures and a non-verbose expression language like we have in Xtend, but it&rsquo;s a big improvement over traditional Java programming with java.util.* and it performs much better than Xtend.</p></div></div><div class="section" title="Conclusion"><div class="titlepage"><div><div><h3 class="title"><a name="conclusion"></a>Conclusion</h3></div></div></div><p>Just to get it right, Xtend is a very nice language and we still use it for it&rsquo;s main purpose: code generation and model transformation. The whole generator in TMF Xtext is written in Xpand and Xtend and it&rsquo;s performance is at least in our experience sufficient for that use case. Actually we were able to increase runtime performance of Xpand by about 60% for the Galileo release of M2T Xpand. But still live execution in the IDE and on typing is very critical and one has to think about every millisecond in this area. </p></div></div><div class="section" title="Differences"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="differences"></a>Differences</h2></div></div></div><p>In this section differences between oAW Xtext and TMF Xtext are outlined and explained. We&rsquo;ll start from the primary APIs such as the grammar language and the validation hook and finish with the different secondary hooks for customizing linking and several UI apsects, such as outline view and content assist.</p><div class="section" title="Differences in the grammar language"><div class="titlepage"><div><div><h3 class="title"><a name="differenced_grammar_language"></a>Differences in the grammar language</h3></div></div></div><p>When looking at a TMF Xtext gramar the first time it looks like one has to provide additional information which was not necessary in oAW Xtext. In oAW Xtext *.xtxt files started with the first production rule where in TMF Xtext one has to declare the name of the language followed by declaration of one or more used/generated meta models.
					In oAW Xtext this information was provided through the generator (actually it is contained in the *.properties file) but we found that these things are very important for a complete description of a grammar and had therefore be part of the grammar in order to have self-describing grammars and allow for sophisticated static analysis, etc.. </p><p>Apart from the first three lines the grammar languages are more or less compatible. The syntax for all the different EBNF concepts (alternatives, groups, cardinatlities) is similar.
					Also assignments are syntactically and semantically identical in both versions. 
					However in TMF Xtext some concepts have been generalized and improved:</p><div class="section" title="String rules become Datatype rules"><div class="titlepage"><div><div><h4 class="title"><a name="differences_datatype_rules"></a>String rules become Datatype rules</h4></div></div></div><p>The very handy String rules are still present in TMF Xtext but we generalized them so that you don&rsquo;t need to write the &lsquo;String&rsquo; keyword in front of them and at the same time these rules can not only produce EStrings but (as the name suggests) any kind of EDatatype. The return type is inferred and if not specified EString is assumed, however you can now simply create a parser rule returning other EDatatypes.</p></div><div class="section" title="Enum rules"><div class="titlepage"><div><div><h4 class="title"><a name="differences_enum_rules"></a>Enum rules</h4></div></div></div><p>Enum rules have not changed significantly. The keyword has changed to be all lower case (&lsquo;enum&rsquo; instead of &lsquo;Enum&rsquo;).
						Also the right handside of the assignment is now optional. That is in oAW Xtext:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;&nbsp;Enum&nbsp;MyEnum&nbsp;:&nbsp;foo='foo'&nbsp;|&nbsp;bar='bar';<br>
&nbsp;&nbsp;<br>
</code></p></div><p>becomes</p><div class="literallayout"><p><code class="code"><br>
&nbsp;&nbsp;&nbsp;enum&nbsp;MyEnum&nbsp;:&nbsp;foo='foo'&nbsp;|&nbsp;bar='bar';<br>
&nbsp;&nbsp;&nbsp;<br>
</code></p></div><p>and because the name of the literal equals the literal value one can ommit the right handside in this case and write:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;&nbsp;enum&nbsp;MyEnum&nbsp;:&nbsp;foo&nbsp;|&nbsp;bar;<br>
<br>
</code></p></div></div><div class="section" title="Native rules"><div class="titlepage"><div><div><h4 class="title"><a name="differences_native_rules"></a>Native rules</h4></div></div></div><p>The most significant improvement to oAW Xtext is that we could replace the blackbox native rules with full-blown EBNF syntax. 
						That is native rules become terminal rules and or no longer written as a string literal containing ANTLR syntax but are a part of the language.</p><p>Example :</p><div class="literallayout"><p><code class="code">Native&nbsp;FOO&nbsp;:&nbsp;"'f'&nbsp;'o'&nbsp;'o'";<br>
<br>
</code></p></div><p>becomes</p><div class="literallayout"><p><code class="code">terminal&nbsp;FOO&nbsp;:&nbsp;'f'&nbsp;'o'&nbsp;'o';<br>
<br>
</code></p></div><p>See the reference documentation for all the different expressions possible in terminal rules.</p></div><div class="section" title="No built-in terminals"><div class="titlepage"><div><div><h4 class="title"><a name="differences_no_builtin_terminals"></a>No built-in terminals</h4></div></div></div><p>In oAW Xtext common terminals lie ID, INT, STRING, ML_COMMENT, SL_SOMMENT and WS (whitespace) were hard coded into the grammar language and couldn&rsquo;t be removed.
						Also overriding was error-prone and challenged. In TMF Xtext these terminals are important through the newly introduced grammar mixin mechanism. This means that they are still there but they are now libraries. You don&rsquo;t have to use them and you can come up with your own reusable rules. </p></div><div class="section" title="No URI terminal rule anymore"><div class="titlepage"><div><div><h4 class="title"><a name="differences_no_URI_token"></a>No URI terminal rule anymore</h4></div></div></div><p>Although with grammar-mixins we would have been able to implement the URI terminal rule again, we decided to remove it as we only wanted to mark the model some how to identify what information to use in orde to load referenced models. Instead we decided to solve this similar to how we do resolution by name: We use convention.
						That is if you&rsquo;ve used the URI token like so:</p><div class="literallayout"><p><code class="code"><br>
&nbsp;Import&nbsp;:&nbsp;'import'&nbsp;myReference=URI;<br>
&nbsp;<br>
</code></p></div><p>you&rsquo;ll have to rewrite it like so</p><div class="literallayout"><p><code class="code"><br>
&nbsp;Import&nbsp;:&nbsp;'import'&nbsp;importedURI=STRING;<br>
&nbsp;<br>
</code></p></div><p>Although this changes your meta model, one usually never used this reference explicititely as it was only there to be used by Xtext&rsquo;s simple import mechanism. So we assume and hope  that changing the reference is not a big deal for you. </p></div></div></div></div></div></body></html>