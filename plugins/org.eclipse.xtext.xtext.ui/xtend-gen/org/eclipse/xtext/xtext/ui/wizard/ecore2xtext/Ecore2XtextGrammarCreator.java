package org.eclipse.xtext.xtext.ui.wizard.ecore2xtext;

import com.google.common.base.Objects;
import java.util.Collection;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xtext.ui.wizard.ecore2xtext.EPackageInfo;
import org.eclipse.xtext.xtext.ui.wizard.ecore2xtext.Ecore2XtextExtensions;
import org.eclipse.xtext.xtext.ui.wizard.ecore2xtext.Ecore2XtextProjectInfo;
import org.eclipse.xtext.xtext.ui.wizard.ecore2xtext.UniqueNameUtil;

@SuppressWarnings("all")
public class Ecore2XtextGrammarCreator {
  public CharSequence grammar(final Ecore2XtextProjectInfo it) {
    CharSequence _xblockexpression = null;
    {
      EPackageInfo _defaultEPackageInfo = it.getDefaultEPackageInfo();
      UniqueNameUtil.clearUniqueNames(_defaultEPackageInfo);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("// automatically generated by Xtext");
      _builder.newLine();
      _builder.append("grammar ");
      String _languageName = it.getLanguageName();
      _builder.append(_languageName, "");
      _builder.append(" with org.eclipse.xtext.common.Terminals ");
      _builder.newLineIfNotEmpty();
      {
        Collection<EPackage> _allReferencedEPackages = Ecore2XtextExtensions.allReferencedEPackages(it);
        for(final EPackage it_1 : _allReferencedEPackages) {
          _builder.append("import \"");
          String _importURI = UniqueNameUtil.importURI(it_1);
          _builder.append(_importURI, "");
          _builder.append("\" ");
          {
            boolean _and = false;
            String _uniqueName = UniqueNameUtil.uniqueName(it_1);
            boolean _notEquals = (!Objects.equal(_uniqueName, null));
            if (!_notEquals) {
              _and = false;
            } else {
              String _uniqueName_1 = UniqueNameUtil.uniqueName(it_1);
              boolean _notEquals_1 = (!Objects.equal(_uniqueName_1, ""));
              _and = (_notEquals && _notEquals_1);
            }
            if (_and) {
              _builder.append("as ");
              String _uniqueName_2 = UniqueNameUtil.uniqueName(it_1);
              _builder.append(_uniqueName_2, "");
            }
          }
          _builder.newLineIfNotEmpty();
        }
      }
      EClass _rootElementClass = it.getRootElementClass();
      CharSequence _rules = this.rules(_rootElementClass);
      _builder.append(_rules, "");
      _builder.newLineIfNotEmpty();
      _xblockexpression = (_builder);
    }
    return _xblockexpression;
  }
  
  /**
   * «DEFINE rule FOR EClass»
   * «concreteRuleName()» returns «fqn()»:
   * «	IF onlyOptionalFeatures()
   * »	{«fqn()»}
   * «	ENDIF»«
   * FOREACH prefixFeatures() AS prefixFeature
   * »	«EXPAND assignment FOR prefixFeature»«
   * ENDFOREACH
   * »	'«name»'
   * «	EXPAND idAssignment»«
   * IF !inlinedFeatures().isEmpty
   * »	'{'
   * «
   * FOREACH allAttributes() AS attribute
   * »		«EXPAND assignment FOR attribute»«
   * ENDFOREACH»«
   * FOREACH allCrossReferences() AS crossReference
   * »		«EXPAND assignment FOR crossReference»«
   * ENDFOREACH»«
   * FOREACH allContainmentReferences() AS containmentReference
   * »		«EXPAND assignment FOR containmentReference»«
   * ENDFOREACH
   * »    '}'«
   * ENDIF»;
   * «ENDDEFINE»
   */
  public Object rule(final EClass eClazz) {
    throw new UnsupportedOperationException("ruleis not implemented");
  }
  
  /**
   * «DEFINE subClassDispatcherRule FOR EClass-»
   * «	IF needsDispatcherRule()»
   * «uniqueName()» returns «fqn()»:
   * «	EXPAND subClassAlternatives»;
   * «	ENDIF-»
   * «ENDDEFINE»
   * 
   * «DEFINE subClassAlternatives FOR EClass»«
   * FOREACH {this}.union(subClasses()).select(c|c.needsConcreteRule()) AS subClass SEPARATOR " | "»«
   * subClass.concreteRuleName()»«
   * ENDFOREACH»«
   * ENDDEFINE»
   * 
   * «DEFINE idAssignment FOR EClass-»
   * «IF idAttribute() != null»	«idAttribute().name»=«assignedRuleCall(idAttribute())»
   * «ENDIF-»
   * «ENDDEFINE»
   * 
   * «DEFINE assignment FOR EStructuralFeature»«
   * IF !required
   * »(«
   * ENDIF»«
   * assignmentKeyword()»«
   * IF many»«
   * IF isContainment()
   * »'{' «
   * ELSE
   * »'(' «
   * ENDIF»«
   * ENDIF»«
   * name.quoteIfNeccesary()»«
   * EXPAND assignmentOperator»«
   * EXPAND assignedTerminal»«
   * IF many
   * » ( "," «
   * name.quoteIfNeccesary()»«
   * EXPAND assignmentOperator»«
   * EXPAND assignedTerminal
   * »)* «
   * IF isContainment()
   * »'}' «
   * ELSE
   * »')' «
   * ENDIF»«
   * ENDIF»«
   * IF !required
   * »)?«
   * ENDIF»
   * «ENDDEFINE»
   * 
   * «DEFINE assignedTerminal FOR EAttribute»«
   * assignedRuleCall()»«
   * ENDDEFINE»
   * 
   * «DEFINE assignedTerminal FOR EReference»«
   * IF containment»«
   * EReferenceType.uniqueName()»«
   * ELSE
   * »[«EReferenceType.fqn()»|EString]«
   * ENDIF»«
   * ENDDEFINE»
   * 
   * «DEFINE assignedTerminal FOR EStructuralFeature»«ENDDEFINE»
   * 
   * «DEFINE assignmentOperator FOR EStructuralFeature-»
   * «IF	many»+=«ELSEIF EType.isBoolean() && isPrefixBooleanFeature()»?=«ELSE»=«ENDIF-»
   * «ENDDEFINE»
   * 
   * «DEFINE rule FOR EEnum»
   * enum «name.quoteIfNeccesary()» returns «fqn()»:
   * «EXPAND enumAssignment FOREACH ELiterals SEPARATOR " | "»;
   * «ENDDEFINE»
   * 
   * «DEFINE enumAssignment FOR EEnumLiteral»«name» = '«name»'«ENDDEFINE»
   */
  public CharSequence rules(final EClassifier eClassifier) {
    boolean _needsConcreteRule = Ecore2XtextExtensions.needsConcreteRule(eClassifier);
    if (_needsConcreteRule) {
      this.rule(eClassifier);
    }
    StringConcatenation _builder = new StringConcatenation();
    return _builder;
  }
  
  /**
   * «DEFINE rule FOR EDataType»«
   * IF serializable»
   * «uniqueName()» returns «fqn()»:
   * «dataTypeRuleBody()»;
   * «	ENDIF»«
   * ENDDEFINE»
   * 
   * «DEFINE rule FOR EClassifier»
   * «ERROR "No rule template for " + this.metaType.name»
   * «ENDDEFINE»
   */
  public CharSequence rule(final EDataType it) {
    CharSequence _xifexpression = null;
    boolean _isSerializable = it.isSerializable();
    if (_isSerializable) {
      StringConcatenation _builder = new StringConcatenation();
      String _uniqueName = UniqueNameUtil.uniqueName(it);
      _builder.append(_uniqueName, "");
      _builder.append(" returns ");
      String _fqn = Ecore2XtextExtensions.fqn(it);
      _builder.append(_fqn, "");
      _builder.append(":");
      _builder.newLineIfNotEmpty();
      _builder.append("\t");
      String _dataTypeRuleBody = Ecore2XtextExtensions.dataTypeRuleBody(it);
      _builder.append(_dataTypeRuleBody, "	");
      _builder.append(";");
      _builder.newLineIfNotEmpty();
      _xifexpression = _builder;
    }
    return _xifexpression;
  }
  
  public void rule(final EClassifier eClassifier) {
    String _name = eClassifier.getName();
    String _plus = ("No rule template for " + _name);
    IllegalStateException _illegalStateException = new IllegalStateException(_plus);
    throw _illegalStateException;
  }
}
