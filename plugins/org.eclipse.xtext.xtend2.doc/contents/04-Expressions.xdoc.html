<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Expressions</title>
<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="index.html" title="">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<a name="Expressions"></a>
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Expressions</h1>

<p>
Expressions are the main language constructs which are used to express behavior and computation of values. Xbase does not support the concept of a statement, but instead comes with powerful 
expressions to handle situations in which the imperative nature of statements are a better fit. An expression always results in a value (might be the value &apos;null&apos; though). In addition expressions can
be statically typed. By default it is assumed that languages making use of Xbase provide enough static context information for static type analysis, which is the basis of a lot of
IDE features coming with Xbase. However, the static typing is not mandatory and might be completely skipped if not wished. The openness of the compiler even allows to change the generation of 
concrete feature invocations to reflective calls, such that the language can be fully dynamically typed.
</p>


<a name="Literals"></a>

<a name="Literals"></a>
<div class="section" title="Literals">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Literals
</h2>
</div>
</div>
</div>



<p>
A literal denotes a fixed unchangeable value. Xbase comes with the following literals
</p>


<a name="ExpressionsStringLiterals"></a>

<a name="ExpressionsStringLiterals"></a>
<div class="section" title="String Literals">
<div class="titlepage">
<div>
<div>
<h3 class="title">
String Literals
</h3>
</div>
</div>
</div>



<p>
A string literal as defined in 
<a href="02-Lexical%20Structure.xdoc.html#StringLiterals">section StringLiterals</a> is a valid expression and returns an instance of <span class="inlinecode">java.lang.String</span>
 of the given value.
</p>


</div>



<a name="Literals-3"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XStringLiteral:<br />&nbsp;&nbsp;&nbsp;&nbsp;STRING;<br />
</p>
</div>
</div>


</p>


</div>

<a name="ExpressionsIntegerLiterals"></a>

<a name="ExpressionsIntegerLiterals"></a>
<div class="section" title="Integer Literals">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Integer Literals
</h3>
</div>
</div>
</div>



<p>
An integer literal as defined in 
<a href="02-Lexical%20Structure.xdoc.html#IntegerLiterals">section IntegerLiterals</a> creates an instance of <span class="inlinecode">Integer</span>
.
</p>


</div>



<a name="Literals-5"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XIntegerLiteral:<br />&nbsp;&nbsp;&nbsp;&nbsp;INT;<br />
</p>
</div>
</div>


</p>


</div>

<a name="BooleanLiteral"></a>

<a name="BooleanLiteral"></a>
<div class="section" title="Boolean Literals">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Boolean Literals
</h3>
</div>
</div>
</div>



<p>
There are two boolean literals, <span class="inlinecode">true</span>
 and <span class="inlinecode">false</span>
 which correspond to their Java counterpart of type <em>java.lang.Boolean</em>. 
</p>


</div>



<a name="Literals-7"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XBooleanLiteral:<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;false&apos;&nbsp;|&nbsp;&apos;true&apos;;<br />
</p>
</div>
</div>


</p>


</div>

<a name="NullLiteral"></a>

<a name="NullLiteral"></a>
<div class="section" title="Null Literal">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Null Literal
</h3>
</div>
</div>
</div>



<p>
The null pointer literal is, like in Java, <span class="inlinecode">null</span>
. 
It is the only value of the type <em>java.lang.Void</em> which has a special meaning in Xbase (see 
<a href="03-Types.xdoc.html#VoidType">section VoidType</a>).
</p>


</div>



<a name="Literals-9"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XNullLiteral:<br />&nbsp;&nbsp;&nbsp;&nbsp;{XNullLiteral}&nbsp;&apos;null&apos;;<br />
</p>
</div>
</div>


</p>


</div>

<a name="TypeLiteral"></a>

<a name="TypeLiteral"></a>
<div class="section" title="Type Literals">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Type Literals
</h3>
</div>
</div>
</div>



<p>
Type literals are written like in Java. They consist of a reference to a raw type suffixed with a dot and the keyword <span class="inlinecode">class</span>
.
</p>


</div>



<a name="Literals-11"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XTypeLiteral:<br />&nbsp;&nbsp;&nbsp;&nbsp;QualifiedName&nbsp;&apos;.&apos;&nbsp;&apos;class&apos;;<br />
</p>
</div>
</div>


</p>


</div>

</div>

<a name="Operators"></a>

<a name="Operators"></a>
<div class="section" title="Infix Operators">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Infix Operators
</h2>
</div>
</div>
</div>



<p>
Xbase supports a couple of predefined infix operators. In contrast to Java, the operators are not fixed
to operations on certain types. Instead Xbase comes with an operator to method mapping, which allows users to redefine the 
operators for any type just by implementing the corresponding method signature.
The following defines the operators and the corresponding Java method signatures / expressions.
</p>

<p>


		
The table above also defines the operator precedence in ascending order. The blank lines separate precedence levels. 
The two assignment operators <span class="inlinecode">=</span>
 and <span class="inlinecode">+=</span>
 are right-to-left associative, that is a = b = c is executed as a = (b = c), all other
operators are left-to-right associative. Parenthesis can be used to adjust the default precedence and associativity. 
</p>


<a name="propertyAssignment"></a>

<a name="propertyAssignment"></a>
<div class="section" title="Property Assignment">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Property Assignment
</h3>
</div>
</div>
</div>



<p>
The translation rule for the simple assignment operator <span class="inlinecode">=</span>
 is a bit more complicated.
Given the expression 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty&nbsp;=&nbsp;&quot;foo&quot;<br />
</p>
</div>
</div>


</p>

<p>
The compiler first looks up whether there is an accessible Java Field called <span class="inlinecode">myProperty</span>
 on the type of <span class="inlinecode">myObj</span>
. If there is one it translates to
the following Java expression :
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty&nbsp;=&nbsp;&quot;foo&quot;;<br />
</p>
</div>
</div>


</p>

<p>
Remember in Xbase everything is an expression and has to return something. In the case of simple assignments the return value is the value returned from the corresponding
Java expression, which is the assigned value.
</p>

<p>
If there is no accessible field on the left operand&apos;s type, first a method called <span class="inlinecode">myProperty(OneArg)</span>
 and then <span class="inlinecode">setMyProperty(OneArg)</span>
 is looked up. It has to take 
one argument of the type (or a super type) of the right hand operand. The return value will be whatever the setter method returns (which usually is <span class="inlinecode">null</span>
). 
As a result the compiler translates to :
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myObj.setMyProperty(&quot;foo&quot;)<br />
</p>
</div>
</div>


</p>


</div>

<a name="addAssignment"></a>

<a name="addAssignment"></a>
<div class="section" title="Add Assignment">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Add Assignment
</h3>
</div>
</div>
</div>



<p>
The translation rule for the add assignment operator <span class="inlinecode">+=</span>
 is as follows:
Given the expression 
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty&nbsp;+=&nbsp;&quot;foo&quot;<br />
</p>
</div>
</div>


</p>

<p>
The compiler first looks up whether, the left hand side operand is of some type providing a method <span class="inlinecode">add(StringOrSuperType)</span>
. 
In that case the expression translates to the following Java expression :
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty.add(&quot;foo&quot;);<br />
</p>
</div>
</div>


</p>

<p>
If there is no such method, the compiler looks for a method called <span class="inlinecode">addMyProperty(OneArg)</span>
 on the type of the target expression
of the feature call. That is it looks whether the type of <span class="inlinecode">myObj</span>
 provides a method called <span class="inlinecode">addMyProperty(StringOrSuperType)</span>
.
</p>

<p>
The return value and compile-time type will be whatever the invoked Java method returns.
</p>


</div>



<a name="Operators-5"></a>
<div class="section" title="Short-Circuit Boolean Operators">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Short-Circuit Boolean Operators
</h3>
</div>
</div>
</div>



<p>
If the operators <span class="inlinecode">||</span>
 and <span class="inlinecode">&amp;&amp;</span>
 are used in a context where the left hand operand is of type boolean, the operation is evaluated
in short circuit mode, which means that the right hand operand might not be evaluated at all in the following cases: 

<ol>

<li>

<p>
in the case of <span class="inlinecode">||</span>
 the operand on the right hand side is not evaluated if the left operand evaluates to <span class="inlinecode">true</span>
.
</p>

</li>

<li>

<p>
in the case of <span class="inlinecode">&amp;&amp;</span>
 the operand on the right hand side is not evaluated if the left operand evaluates to <span class="inlinecode">false</span>
.
</p>

</li>

</ol>


</p>


</div>



<a name="Operators-6"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>
<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">myList&nbsp;+=&nbsp;23</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">x&nbsp;&gt;&nbsp;23&nbsp;&amp;&amp;&nbsp;y&nbsp;&lt;&nbsp;23</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">x&nbsp;&amp;&amp;&nbsp;y&nbsp;||&nbsp;z</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">1&nbsp;+&nbsp;3&nbsp;*&nbsp;5&nbsp;*&nbsp;(-&nbsp;23)</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">!(x)</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">my.foo&nbsp;=&nbsp;23</span>

</p>

</li>

</ul>

</p>


</div>

</div>

<a name="FeatureCalls"></a>

<a name="FeatureCalls"></a>
<div class="section" title="Feature Calls">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Feature Calls
</h2>
</div>
</div>
</div>



<p>
A feature call is used to invoke members of objects, such as fields and methods, but also can refer to local variables and parameters, 
which are made available for the current expression&apos;s scope (TODO define how scopes are declared around expressions). 
</p>




<a name="FeatureCalls-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>
The following snippet is a simplification of the real Xtext rules, which cover more than the concrete syntax.

<div class="literallayout">
<div class="incode">
<p class="code">
FeatureCall&nbsp;:<br />&nbsp;&nbsp;&nbsp;&nbsp;ID&nbsp;|<br />&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;(&apos;.&apos;&nbsp;ID&nbsp;(&apos;(&apos;&nbsp;Expression&nbsp;(&apos;,&apos;&nbsp;Expression)*&nbsp;&apos;)&apos;)?)*<br />
</p>
</div>
</div>


</p>


</div>

<a name="PropertyAccess"></a>

<a name="PropertyAccess"></a>
<div class="section" title="Property Access">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Property Access
</h3>
</div>
</div>
</div>



<p>
Feature calls are directly translated to their Java equivalent with the exception, that for calls to properties an equivalent rule as 
described in 
<a href="04-Expressions.xdoc.html#propertyAssignment">section propertyAssignment</a> applies. 
That is, for the following expression
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
myObj.myProperty<br />
</p>
</div>
</div>


</p>

<p>
the compiler first looks for an accessible field in the type of <span class="inlinecode">myObj</span>
. If no such field exists it looks for a method called <span class="inlinecode">myProperty()</span>
 before it looks 
for the getter methods <span class="inlinecode">getMyProperty()</span>
. If none of these members can be found the expression is unbound and a compiliation error is thrown.
</p>


</div>

<a name="ImplicitThis"></a>

<a name="ImplicitThis"></a>
<div class="section" title="Implicit 'this' variable">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Implicit &apos;this&apos; variable
</h3>
</div>
</div>
</div>



<p>
If the current scope contains a variable named <span class="inlinecode">this</span>
, the compiler will make all its members available to the scope. 
That is if 

<div class="literallayout">
<div class="incode">
<p class="code">
this.myProperty<br />
</p>
</div>
</div>


if a valid expression

<div class="literallayout">
<div class="incode">
<p class="code">
myProperty<br />
</p>
</div>
</div>


is valid as well and is equivalent. 
</p>


</div>



<a name="FeatureCalls-5"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>
<span class="inlinecode">foo</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">my.foo</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">my.foo(x)</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">oh.my.foo(bar)</span>

</p>

</li>

</ul>

</p>


</div>

</div>

<a name="Closures"></a>

<a name="Closures"></a>
<div class="section" title="Closures">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Closures
</h2>
</div>
</div>
</div>



<p>
A closure is a literal that defines an anonymous function. A closure also captures the current scope, so that any final variables and parameters visible at construction time 
can be referred to in the closure&apos;s expression. 
</p>




<a name="Closures-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XClosure:<br />&nbsp;&nbsp;&nbsp;&nbsp;(JvmFormalParameter&nbsp;(&apos;,&apos;&nbsp;JvmFormalParameter)*)?&nbsp;&apos;|&apos;&nbsp;XExpression;<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />JvmFormalParameter:<br />&nbsp;&nbsp;&nbsp;&nbsp;JvmTypeReference?&nbsp;ID;<br />
</p>
</div>
</div>


</p>


</div>

<a name="FunctionMapping"></a>

<a name="FunctionMapping"></a>
<div class="section" title="Function Mapping">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Function Mapping
</h3>
</div>
</div>
</div>



<p>
An Xbase closure is a Java object of one of the <em>Function</em> interfaces shipped with the runtime library of Xbase. There is an interface for each number of parameters.
The names of the interfaces are 

<ul>

<li>

<p>
<em>Function0&lt;ReturnType&gt;</em> for zero parameters, 
</p>

</li>

<li>

<p>
<em>Function1&lt;Param1Type, ReturnType&gt;</em> for one parameters, 
</p>

</li>

<li>

<p>
<em>Function2&lt;Param1Type, Param2Type, ReturnType&gt;</em> for two parameters, 
</p>

</li>

<li>

<p>
... 
</p>

</li>

<li>

<p>
<em>Function6&lt;Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type, ReturnType&gt;</em> for six parameters, 
</p>

</li>

</ul>

</p>

<p>
In order to allow seamless integration with Google Guava (formerly known as Google Collect) the type <span class="inlinecode">Function1</span>
 
extends <span class="inlinecode">com.google.common.base.Function&lt;F,&nbsp;T&gt;</span>
 and the type <em>Function0</em> extends <span class="inlinecode">com.google.common.base.Supplier&lt;T&gt;</span>
. 
There is also an auto-coercion for any <span class="inlinecode">Function1&lt;T,Boolean&gt;</span>
 to <span class="inlinecode">com.google.common.base.Predicate&lt;T&gt;</span>
.
</p>

<p>
<em>TODO: Discuss, whether we want to go a step further and do auto conversion to any type declaring only one method. That would allow to pass
closures also to methods expecting other such types like e.g. <span class="inlinecode">Iterable</span>
. This would avoid a fixed dependency to Google Guava, too.</em>
</p>


</div>

<a name="ClosuresTypeInference"></a>

<a name="ClosuresTypeInference"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Typing
</h3>
</div>
</div>
</div>



<p>
Closures are expressions which produce function objects. The type is a 
<a href="03-Types.xdoc.html#FunctionTypes">function type</a>, consisting of the types of the 
parameters as well as the return type. The return type is never specified explicitly but is always inferred from the expression. 
The parameter types can be inferred if the closure is used in a context where this is possible.
</p>

<p>
For instance, given the following Java method signature:

<div class="literallayout">
<div class="incode">
<p class="code">
public&nbsp;T&nbsp;&lt;T&gt;getFirst(List&lt;T&gt;&nbsp;list,&nbsp;Function0&lt;T,Boolean&gt;&nbsp;predicate)&nbsp;<br />
</p>
</div>
</div>


</p>

<p>
the type of the parameter can be inferred. Which allows users to write:

<div class="literallayout">
<div class="incode">
<p class="code">
getFirst(arrayList(&quot;Foo&quot;,&quot;Bar&quot;),&nbsp;e|e==&quot;Bar&quot;)<br />
</p>
</div>
</div>


instead of 

<div class="literallayout">
<div class="incode">
<p class="code">
getFirst(arrayList(&quot;Foo&quot;,&quot;Bar&quot;),&nbsp;String&nbsp;e|e==&quot;Bar&quot;)<br />
</p>
</div>
</div>


</p>


</div>



<a name="Closures-5"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>
<span class="inlinecode">|&nbsp;&quot;foo&quot;&nbsp;&nbsp;&nbsp;//&nbsp;closure&nbsp;without&nbsp;parameters</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">String&nbsp;s&nbsp;|&nbsp;s.toUpperCase()&nbsp;//&nbsp;explicit&nbsp;argument&nbsp;type</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">a,b,a&nbsp;|&nbsp;a+b+c&nbsp;&nbsp;//&nbsp;inferred&nbsp;argument&nbsp;types</span>

</p>

</li>

</ul>

</p>


</div>

</div>

<a name="IfExpression"></a>

<a name="IfExpression"></a>
<div class="section" title="If Expression">
<div class="titlepage">
<div>
<div>
<h2 class="title">
If Expression
</h2>
</div>
</div>
</div>



<p>
An if expression is used to choose two different values based on a predicate. While it has the syntax of Java&apos;s if statement it behaves  
like Java&apos;s ternary operator (<span class="inlinecode">predicate&nbsp;?&nbsp;thenPart&nbsp;:&nbsp;elsePart</span>
), i.e. it is an expression that returns a value. Consequently, you can use 
if expressions deeply nested within expressions.
</p>




<a name="IfExpression-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XIfExpression:<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;if&apos;&nbsp;&apos;(&apos;&nbsp;XExpression&nbsp;&apos;)&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XExpression<br />&nbsp;&nbsp;&nbsp;&nbsp;(&apos;else&apos;&nbsp;XExpression)?;<br />
</p>
</div>
</div>


</p>

<p>
An expression <span class="inlinecode">if&nbsp;(p)&nbsp;e1&nbsp;else&nbsp;e2</span>
 results to either the value <span class="inlinecode">e1</span>
 or <span class="inlinecode">e2</span>
 depending on whether the predicate <span class="inlinecode">p</span>
 evaluates to <span class="inlinecode">true</span>
 or <span class="inlinecode">false</span>
. 
The else part is optional which is a shorthand for <span class="inlinecode">else&nbsp;null</span>
.
That is 

<div class="literallayout">
<div class="incode">
<p class="code">
if&nbsp;(foo)&nbsp;x&nbsp;//&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;&apos;if&nbsp;(foo)&nbsp;x&nbsp;else&nbsp;null&apos;<br />
</p>
</div>
</div>


</p>


</div>

<a name="IfTypeInference"></a>

<a name="IfTypeInference"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Typing
</h3>
</div>
</div>
</div>



<p>
The type of an if expression is calculated by the return types <span class="inlinecode">T1</span>
 and <span class="inlinecode">T2</span>
 of the two expression <span class="inlinecode">e1</span>
 and <span class="inlinecode">e2</span>
.
It uses the rules defined in 
<a href="03-Types.xdoc.html#CommonSuperType">section CommonSuperType</a>.
</p>


</div>



<a name="IfExpression-4"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>
<span class="inlinecode">if&nbsp;(isFoo)&nbsp;this&nbsp;else&nbsp;that</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">if&nbsp;(isFoo)&nbsp;this&nbsp;else&nbsp;if&nbsp;(thatFoo)&nbsp;that&nbsp;else&nbsp;other</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">if&nbsp;(isFoo)&nbsp;this</span>

</p>

</li>

</ul>

</p>


</div>

</div>

<a name="SwitchExpression"></a>

<a name="SwitchExpression"></a>
<div class="section" title="Switch Expression">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Switch Expression
</h2>
</div>
</div>
</div>






<a name="SwitchExpression-1"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XSwitchExpression:<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;switch&apos;&nbsp;XExpressionOrVariableDeclaration?&nbsp;&apos;{&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XCasePart+<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&apos;default&apos;&nbsp;&apos;:&apos;&nbsp;(XBlockExpression&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;XExpression&nbsp;&apos;;&apos;))?<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;}&apos;;<br /><br />XCasePart:<br />&nbsp;&nbsp;&nbsp;&nbsp;JvmTypeReference?&nbsp;(&apos;case&apos;&nbsp;XExpression)?&nbsp;&apos;:&apos;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(XBlockExpression&nbsp;|&nbsp;XExpression&nbsp;&apos;;&apos;);<br />
</p>
</div>
</div>


</p>

<p>
The switch statement is a bit different from the one in Java. First, there is no fall through which means only one case is evaluated at most.
Second, the use of switch is not limited to certain values but can be used for any object reference instead. 
For a switch expression 

<div class="literallayout">
<div class="incode">
<p class="code">
switch&nbsp;e&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;e1&nbsp;:&nbsp;er1<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;e2&nbsp;:&nbsp;er2<br />&nbsp;&nbsp;&nbsp;&nbsp;...<br />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;en&nbsp;:&nbsp;ern<br />&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;:&nbsp;er<br />}<br />
</p>
</div>
</div>


</p>

<p>
the main expression <span class="inlinecode">e</span>
 is evaluated first and then each case sequentially. The result of the main expression, further called the switch value, is bound (and possibly shadows) the implicit
<span class="inlinecode">this</span>
 variable. In order to avoid shadowing, a 
<a href="04-Expressions.xdoc.html#VariableDeclaration">variable declaration</a> can be used.
</p>

<p>
A case clause is taken if the switch value equals the result of the case&apos;s guard expression or if the case&apos;s guard expression evaluates to <span class="inlinecode">true</span>
.
</p>


</div>



<a name="SwitchExpression-2"></a>
<div class="section" title="Leaving out the main expression">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Leaving out the main expression
</h3>
</div>
</div>
</div>



<p>
It is possible to leave out the main expression. Then the first case clause for which its guard returns <span class="inlinecode">true</span>
 is taken and executed.
</p>


</div>



<a name="SwitchExpression-3"></a>
<div class="section" title="Type guards">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Type guards
</h3>
</div>
</div>
</div>



<p>
In addition to the case predicate one can add a so called <em>Type Guard</em> which is syntactically just 
<a href="03-Types.xdoc.html#TypeReferences">type reference</a> in front of the case keyword.  
The compiler will use that type for the switch expression in subsequent expressions.
Example:

<div class="literallayout">
<div class="incode">
<p class="code">
{<br />var&nbsp;Object&nbsp;x&nbsp;=&nbsp;...;<br />switch&nbsp;x&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;case&nbsp;x.length()&gt;0&nbsp;:&nbsp;x.length()<br />&nbsp;&nbsp;&nbsp;&nbsp;List&lt;?&gt;&nbsp;:&nbsp;x.size()<br />&nbsp;&nbsp;&nbsp;&nbsp;default&nbsp;:&nbsp;-1<br />}<br />
</p>
</div>
</div>


</p>

<p>
Only if the switch value passes a type guard, i.e. an instanceof operation returns <span class="inlinecode">true</span>
, the case&apos;s guard expression is executed using the same semantics explained in
previously. Statically the type guard acts like a cast, that is all references to the switch value will be of the type specified in the type guard.
</p>


</div>



<a name="SwitchExpression-4"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Typing
</h3>
</div>
</div>
</div>



<p>
The return type of a switch expression is computed using the rules defined in 
<a href="03-Types.xdoc.html#CommonSuperType">section CommonSuperType</a>. The set of types from which the common super type is 
computed corresponds to the types of each case&apos;s result expression. In case a switch expression&apos;s type is
computed using the expected type form the context, it is sufficient to return the expected type if all case branches types conform to the expected type.
</p>


</div>

</div>

<a name="VariableDeclaration"></a>

<a name="VariableDeclaration"></a>
<div class="section" title="Variable Declarations">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Variable Declarations
</h2>
</div>
</div>
</div>



<p>
Variable declarations are only allowed within 
<a href="04-Expressions.xdoc.html#Blocks">blocks</a> and 
<a href="04-Expressions.xdoc.html#SwitchExpression">switch expressions</a>. They are visible in any subsequent expressions in
the block.
</p>




<a name="VariableDeclaration-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XVariableDeclaration:<br />&nbsp;&nbsp;&nbsp;&nbsp;(&apos;val&apos;&nbsp;|&nbsp;&apos;var&apos;)&nbsp;JvmTypeReference&nbsp;ID&nbsp;&apos;=&apos;&nbsp;XExpression;<br />
</p>
</div>
</div>


</p>

<p>
Xbase resembles the keywords <span class="inlinecode">val</span>
 and <span class="inlinecode">var</span>
 known from Scala (<a href="http://www.scala-lang.org/docu/files/ScalaReference.pdf">The Scala Language Specification 2.8</a>).
A variable declaration starting with the keyword <span class="inlinecode">val</span>
 denotes a so called value, which is essentially a final (i.e. unsettable) variable. In rare cases, one
needs to update the value of a reference. In such situations the variable needs to be declared with the keyowrd <span class="inlinecode">var</span>
, which stands for &apos;variable&apos;.
</p>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
{<br />&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;i&nbsp;=&nbsp;0<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(i&gt;MAX)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Hi&nbsp;there!&quot;)<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />}<br />{<br />&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;myFoo&nbsp;=&nbsp;my.complex(expression)<br />&nbsp;&nbsp;&nbsp;&nbsp;myFoo.call(myFoo)<br />}<br />
</p>
</div>
</div>


</p>


</div>



<a name="VariableDeclaration-3"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Typing
</h3>
</div>
</div>
</div>



<p>
The return type of a variable declaration expression is always <span class="inlinecode">java.lang.Void</span>
. 
The type of the variable itself can either be explicitly declared or be inferred from the right hand side expression.
Here is an example for an explicitly declared type:

<div class="literallayout">
<div class="incode">
<p class="code">
var&nbsp;List&lt;String&gt;&nbsp;msg&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;();&nbsp;<br />
</p>
</div>
</div>


In such cases, the right hand expression&apos;s type must 
<a href="03-Types.xdoc.html#ConformanceRules">conform</a> to the type on the left hand side. 
</p>

<p>
Alternatively the type can be left out and will be inferred from the initialization expression:  

<div class="literallayout">
<div class="incode">
<p class="code">
var&nbsp;msg&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;();&nbsp;//&nbsp;-&gt;&nbsp;type&nbsp;ArrayList&lt;String&gt;&nbsp;&nbsp;<br />
</p>
</div>
</div>


</p>


</div>

</div>

<a name="Blocks"></a>

<a name="Blocks"></a>
<div class="section" title="Blocks">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Blocks
</h2>
</div>
</div>
</div>



<p>
The block expression allows to simulate imperative code sequences. It consists of a sequence of expressions, and returns the value of the last expression.
The return type of a block is also the type of the last expression. Empty blocks return <span class="inlinecode">null</span>
. 

<a href="04-Expressions.xdoc.html#VariableDeclaration">Variable declarations</a> are only allowed within blocks and cannot be used as a block&apos;s last expression.
</p>




<a name="Blocks-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XBlockExpression:<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;{&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(XExpressionInsideBlock&nbsp;&apos;;&apos;?)*<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;}&apos;;<br />
</p>
</div>
</div>


</p>

<p>
A block expression is surrounded by curly braces and contains at least one expression.
It can optionally be terminated by a semicolon.
</p>


</div>



<a name="Blocks-3"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>

	{
		doSideEffect(&quot;foo&quot;)
		result
	}

</p>

</li>

<li>

<p>

	{
		var x = greeting();
		if ((x.equals(&quot;Hello &quot;)) {
			x+&quot;World!&quot;; 
		} else {
			x;
		}
	}

</p>

</li>

</ul>

</p>


</div>

</div>

<a name="WhileExpression"></a>

<a name="WhileExpression"></a>
<div class="section" title="While Loop">
<div class="titlepage">
<div>
<div>
<h2 class="title">
While Loop
</h2>
</div>
</div>
</div>



<p>
A while loop <span class="inlinecode">while&nbsp;(predicate)&nbsp;expression</span>
 is used to execute a certain <span class="inlinecode">expression</span>
 unless the <span class="inlinecode">predicate</span>
 is evaluated to <span class="inlinecode">false</span>
.
The return type of a while loop is <span class="inlinecode">java.lang.Void</span>
 and the return value is <span class="inlinecode">null</span>
.
</p>




<a name="WhileExpression-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XWhileExpression:<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;while&apos;&nbsp;&apos;(&apos;&nbsp;predicate=XExpression&nbsp;&apos;)&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body=XExpression;<br />
</p>
</div>
</div>


</p>


</div>



<a name="WhileExpression-3"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
while&nbsp;(true)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(&quot;foo&quot;);<br />}<br />
</p>
</div>
</div>


</p>

</li>

<li>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
while&nbsp;((i=i+1)&lt;max)&nbsp;doSideEffect(&quot;foo&quot;)<br />
</p>
</div>
</div>


</p>

</li>

</ul>

</p>


</div>

</div>

<a name="DoWhileExpression"></a>

<a name="DoWhileExpression"></a>
<div class="section" title="Do-While Loop">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Do-While Loop
</h2>
</div>
</div>
</div>



<p>
A do-while loop <span class="inlinecode">do&nbsp;expression&nbsp;while&nbsp;(predicate)</span>
 is used to execute a certain <span class="inlinecode">expression</span>
 unless the <span class="inlinecode">predicate</span>
 is evaluated to <span class="inlinecode">false</span>
.
The difference to the 
<a href="04-Expressions.xdoc.html#WhileExpression">while loop</a> is that the execution starts by executing the block once before evaluating the predicate for the first time.
The return type of a do-while loop is <span class="inlinecode">java.lang.Void</span>
 and the return value is <span class="inlinecode">null</span>
.
</p>




<a name="DoWhileExpression-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XDoWhileExpression:<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;do&apos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body=XExpression<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;while&apos;&nbsp;&apos;(&apos;&nbsp;predicate=XExpression&nbsp;&apos;)&apos;;<br />
</p>
</div>
</div>


</p>


</div>



<a name="DoWhileExpression-3"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
do&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(&quot;foo&quot;);<br />}&nbsp;while&nbsp;(true)<br />
</p>
</div>
</div>


</p>

</li>

<li>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
do&nbsp;doSideEffect(&quot;foo&quot;)&nbsp;while&nbsp;((i=i+1)&lt;max)<br />
</p>
</div>
</div>


</p>

</li>

</ul>

</p>


</div>

</div>

<a name="ForLoop"></a>

<a name="ForLoop"></a>
<div class="section" title="For Loop">
<div class="titlepage">
<div>
<div>
<h2 class="title">
For Loop
</h2>
</div>
</div>
</div>



<p>
The for loop <span class="inlinecode">for&nbsp;(T1&nbsp;variable&nbsp;:&nbsp;iterableOfT1)&nbsp;expression</span>
 is used to execute a certain <span class="inlinecode">expression</span>
 for each element of an <span class="inlinecode">java.lang.Iterable</span>
.
The local <span class="inlinecode">variable</span>
 is final, hence canot be updated. 
</p>




<a name="ForLoop-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XForExpression:<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;for&apos;&nbsp;&apos;(&apos;&nbsp;JvmFormalParameter&nbsp;&apos;:&apos;&nbsp;XExpression&nbsp;&apos;)&apos;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XExpression<br />&nbsp;&nbsp;&nbsp;&nbsp;;<br />
</p>
</div>
</div>


</p>


</div>



<a name="ForLoop-3"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Typing
</h3>
</div>
</div>
</div>



<p>
The return type of a for loop is <span class="inlinecode">java.lang.Void</span>
 and the return value is <span class="inlinecode">null</span>
.
The type of the local variable can be left out. In that case it is inferred from the type of the <span class="inlinecode">java.lang.Iterable</span>
 returned by the iterable expression.
</p>


</div>



<a name="ForLoop-4"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>

<div class="literallayout">
<div class="incode">
<p class="code">
for&nbsp;(String&nbsp;s&nbsp;:&nbsp;myStrings)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(s);<br />}
</p>
</div>
</div>


</p>

</li>

<li>

<p>


<div class="literallayout">
<div class="incode">
<p class="code">
for&nbsp;(s&nbsp;:&nbsp;myStrings)<br />&nbsp;&nbsp;&nbsp;&nbsp;doSideEffect(s)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</p>
</div>
</div>



</p>

</li>

</ul>

</p>


</div>

</div>

<a name="ConstructorCall"></a>

<a name="ConstructorCall"></a>
<div class="section" title="Constructor Call">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Constructor Call
</h2>
</div>
</div>
</div>



<p>
Construction of objects is done by invoking Java constructors. Xbase uses the <span class="inlinecode">new</span>
 keyword and the syntax is like the one known from Java.
</p>




<a name="ConstructorCall-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XConstructorCall:<br />&nbsp;&nbsp;&apos;new&apos;&nbsp;(QualifiedName&nbsp;(&apos;&lt;&apos;&nbsp;JvmTypeArgument&nbsp;(&apos;,&apos;&nbsp;JvmTypeArgument)*&nbsp;&apos;&gt;&apos;)?&nbsp;&apos;(&apos;(XExpression&nbsp;(&apos;,&apos;&nbsp;XExpression)*)?&apos;)&apos;)?;<br />
</p>
</div>
</div>


</p>


</div>



<a name="ConstructorCall-3"></a>
<div class="section" title="Example">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Example
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
new&nbsp;Foo()<br />
</p>
</div>
</div>


</p>


</div>

</div>

<a name="Throw"></a>

<a name="Throw"></a>
<div class="section" title="Throwing Exceptions">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Throwing Exceptions
</h2>
</div>
</div>
</div>



<p>
Like in Java it is possible to throw <span class="inlinecode">java.lang.Throwable</span>
. The syntax is exactly the same as in Java.
</p>




<a name="Throw-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XThrow:<br />&nbsp;&nbsp;&apos;throw&apos;&nbsp;XExpression;<br />
</p>
</div>
</div>


</p>


</div>



<a name="Throw-3"></a>
<div class="section" title="Typing">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Typing
</h3>
</div>
</div>
</div>



<p>
The type of a throw expression is always <span class="inlinecode">java.lang.Void</span>
. 
The type of the expression after the <span class="inlinecode">throw</span>
 keyword needs to conform to <span class="inlinecode">java.lang.Throwable</span>
.
</p>


</div>



<a name="Throw-4"></a>
<div class="section" title="Example">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Example
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
throw&nbsp;new&nbsp;RuntimeException()<br />
</p>
</div>
</div>


</p>


</div>

</div>

<a name="TryCatch"></a>

<a name="TryCatch"></a>
<div class="section" title="Try, Catch, Finally">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Try, Catch, Finally
</h2>
</div>
</div>
</div>



<p>
The try-catch-finally expression is used to handle exceptional situations gracefully.
Xbase never forces you to catch exceptions, because there is no such concept like checked exceptions in Java. 
The syntax again is like the one known from Java.
</p>




<a name="TryCatch-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XTryCatchFinally:<br />&nbsp;&nbsp;&apos;try&apos;&nbsp;XBlockExpression<br />&nbsp;&nbsp;CatchClause*<br />&nbsp;&nbsp;FinallyClause?;<br />&nbsp;&nbsp;<br />CatchClause:<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;catch&apos;&nbsp;XDeclaredParameter&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XBlockExpression&nbsp;&nbsp;<br /><br />FinallyClause:<br />&nbsp;&nbsp;&nbsp;&nbsp;&apos;finally&apos;&nbsp;XBlockExpression&nbsp;&nbsp;<br />
</p>
</div>
</div>


</p>


</div>



<a name="TryCatch-3"></a>
<div class="section" title="Example">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Example
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
try&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException()<br />}&nbsp;catch&nbsp;(NullPointerException&nbsp;e)&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;handle&nbsp;e<br />}&nbsp;finally&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;stuff<br />}<br />
</p>
</div>
</div>


</p>


</div>

</div>

</body>
</html>
