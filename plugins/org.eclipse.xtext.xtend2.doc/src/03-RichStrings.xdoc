section2:RichStrings[Rich Strings]

Of course there is the template expression, which is used to write readable string concatenation, which
is the main thing you do when writing a code generator. Xtend2 reuses the syntax known from the well
known and widely used Xpand template language (in fact Xtend2 is considered the successor to Xpand and
Xtend). Let's have a look at an example of how a typical function with template expressions look like:

code[
toClass(Entity this) :»
	package «packageName»;
	
	«placeImports»
	
	public class «name» «IF extendedType!=null»extends «extendedType»«ENDIF»{
		«FOREACH members»
			«member.toMember»
		«ENDFOREACH»
	}
	«;
]

If you are familiar with Xpand, you'll notice that it is exactly the same syntax. The difference is, that
the template syntax is actually an expression, which means it can occur everywhere where an expression is
expected. For instance in conjunction the powerful switch expression from Xbase:

code[
toMember(Member this) :
	switch(this) {
		Field :»private «type» «name» ;«;
		Method case isAbstract :» abstract «...;
		Method:» ..... «;
	};
]

section3:RichStringIF[Conditions in Rich Strings]

There is a special code[IF] to be used within rich strings which is identical in syntax and meaning to the
old code[IF] from Xpand. Note that you could also use the if expression, but since it has not an explicit
terminal token, it is not as readable in that context.

section3:RichStringFOREACH[Loops in Rich Strings]

Also the code[FOREACH] statement is available and can only be used in the context of a rich string.
It also supports the code[SEPARATOR] and code[ITERATOR] declaration from Xpand.

todo[Think about whether we really want to stick to the verbose syntax form previous Xpand for SEPARATOR
and ITERATOR]

todo[It should be possible to use libraries to provide access to an iterator or to pass a separator by
means of closures]

section3:RichStringType[Typing]

The rich string is translated to an efficient string concatenation and the return type of a rich string
is codeRef[java.lang.CharSequence] which allows much room for efficient implementation.

section3:WhitespaceHandling[Whitespace Handling]

One of the key features of rich strings is the smart handling of whitespace in the template output. The
whitespace is not written into the output data structure as is but preprocessed. This allows for readable
templates as well as nicely formatted output. This can be achieved by applying three simple rules
when the rich string is evaluated.

ol[
	item[
		An evaluated rich string as part of another string will be prefixed with the current indentation
		of the caller before it is inserted into the result.
	]
	item[
		Indentation in the template that is relative to a control structure will not be propagated to
		the output string. A control structure is a code[FOREACH]-loop or a condition (code[IF]) as well
		as the opening and closing marks of the rich string itself.
		
		The indentation is considered to be relative to such a constrol structure if the previous line
		ends with a control structure followed by optional white space. The amount of whitespace is not
		taken into account but the delta to the other lines.
	]
	item[
		Lines that do not contain any static text which is not whitespace but do contain control structures
		or invocations of other templates which evaluate to an empty string, will not appear in the output.
	]		
]

The behavior is best described with a set of examples. The following table assumes a data structure of
nested nodes.

table[
	tr[
		td[
			code[
class Template {
	print(Node this) """
		node «name» {}
	"""
}
			]
		]
		td[
			code[
				node NodeName{}
			]
		]
	]
]

The indentation before code[node «name»] will be skipped as it is relative to the opening
mark of the rich string and thereby not considered to be relevant for the output but only
for readability of the template itself.

table[
	tr[
		td[
			code[
class Template {
	print(Node this) """
		node «name» {
			«IF hasChildren»
				«children*.print»
			«ENDIF»
		}
	"""
}
			]
		]
		td[
			code[
node Parent{
	node FirstChild {
	}
	node SecondChild {
		node Leaf {
		}
	}
}
			]
		]
	]
]

As in the previous example, there is no indentation on the root level for the same reason.
The first nesting level has only one indentation level in the output. This is derived from
the indentation of the code[IF hasChildren] condition in the template which is nested in
the node. The additional nesting of the recursive invocation code[children*.print] is not
visible in the output as it is relative the the surrounding control structure. The line with
code[IF] and code[ENDIF] contain only control structures thus they are skipped in the output.
Note the additional indentation of the node e[Leaf] which happens due to the first rule:
Indentation is propagated to called templates.
