chapter:Introduction[Introduction]

Xtend is a statically-typed programming language which translates to comprehensible Java source code. 
Syntactically and semantically Xtend has its roots in the Java programming language but improves on many aspects:   

ul[
  item[e[ref:extensionMethods[Extension methods]] - enhance closed types with new functionality]
  item[e[ref:lambdas[Lambda Expressions]] - concise syntax for anonymous function literals]
  item[e[ref:operators[Operator overloading]] - make your libraries even more expressive]
  item[e[ref:switchExpression[Powerful switch expressions]] - type based switching with implicit casts]
  item[e[ref:polymorphicDispatch[Multiple dispatch]] - a.k.a. polymorphic method invocation]
  item[e[ref:templates[Template expressions]] - with intelligent white space handling]
  item[e[ref:Xtend_Expressions[No statements]] - everything is an expression]
  item[e[ref:propertyAccess[Properties]] - shorthands for accessing and defining getters and setter]
  item[e[Local type inference] - you rarely need to write down type signatures anymore]
  item[e[Full support for Java Generics] - including all conformance and conversion rules]
  item[e[Translates to Java] not bytecode - understand what is going on and use your code for platforms 
    such as Android or GWT]
] 

The language is not aiming at replacing Java all together. Its ref:library[library] is just a thin layer on top of the 
Java Development Kit (JDK) and unlike other JVM languages there are ref:javaInteroperability[zero interoperability] issues:
Everything you write in Xtend interacts with Java exactly as if it were written in Java in the first place.
At the same time Xtend is just much more concise, readable and expressive. 

Of course, you can call Xtend methods from Java, too, in a completely transparent way. Furthermore, Xtend provides a modern 
Eclipse-based IDE closely integrated with Eclipse's Java Development Tools (JDT), including features like call-hierarchies, rename refactoring, 
debugging and many more.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
section:Installation[Installation]

Xtend requires Eclipse 3.5 or higher and a Java SDK 5 or higher. The easiest way to install the
SDK is via link[http://marketplace.eclipse.org/content/eclipse-xtend][Eclipse Marketplace]. 
But there is also a complete Eclipse distribution link[http://www.eclipse.org/xtend/index.html#download][available for download
at http://xtend-lang.org].

If you do not want to use the recommended Eclipse plug-in, you can compile Xtend code using the 
ref:MavenSupport[Maven plug-in].

section2:MavenSupport[Maven Support]

The ref:library[runtime library] as well as a plug-in to run the compiler in a Maven build can be be obtained from
the following Maven repository: link[http://build.eclipse.org/common/xtend/maven/][http://build.eclipse.org/common/xtend/maven/].

Here is the XML for the repository:
code[
<repositories>
  <repository>
    <id>xtend</id>
    <url>http://build.eclipse.org/common/xtend/maven/</url>
  </repository>
</repositories>
<pluginRepositories>
  <pluginRepository>
    <id>xtend</id>
    <url>http://build.eclipse.org/common/xtend/maven/</url>
  </pluginRepository>
</pluginRepositories>
]

Here is the XML for the dependency to the library:

code[
<dependency>
  <groupId>org.eclipse.xtend</groupId>
  <artifactId>org.eclipse.xtend.lib</artifactId>
  <version>2.3.0</version>
</dependency>
]

And this is the XML for the plug-in:

code[
<plugin>
  <groupId>org.eclipse.xtend</groupId>
  <artifactId>xtend-maven-plugin</artifactId>
  <version>2.3.0</version>
  <executions>
    <execution>
      <goals>
        <goal>compile</goal>
        <!-- <goal>testCompile</goal> -->
      </goals>
      <!-- optionally you can configure a different target folder -->
      <!--
      <configuration>
        <outputDirectory>xtend-gen</outputDirectory>
      </configuration>
      -->
    </execution>
  </executions>
</plugin>
]

As you see the e[outputDirectory] can be specified to match the default of the Eclipse plug-in (e[xtend-gen]). Of course you can also change the configuration
in Eclipse to match the Maven default (e[generated-sources]). To do so right-click on the project and select e[Properties] or if you prefer a global setting choose e[Eclipse->Preferences].
In the category e[Xtend/Compiler] enter the directory name (see screenshot). It is interpreted as a relative path to the parent of the source folder, which includes the to-be-compiled Xtend file.

img[images/configure-compiler-in-eclipse.png][Configuring the compiler in Eclipse][][]

section2:library[The Runtime Library]

The compiler requires a small runtime library on the classpath, which mainly provides useful extensions
to existing classes and interfaces from the JDK. The class codeRef[org.eclipse.xtext.xbase.lib.InputOutput]
providing the method code[<T> T println(T obj)] being one of them. 

The only surprising fact in the generated Java code may be the library class. Many 
features of Xtend are not built into the language itself but provided via the library
e[org.eclipse.xtend.lib]. The library is available from a ref:MavenSupport[Maven repository] and via p2
update site (in case you do Eclipse plug-in development).

The library provides means to create collections in a readable way:

code[Xtend][
  val myList = newArrayList(1, 2, 3)
  val mySet = newHashSet(4, 5, 6)
  val myMap = newHashMap(1 -> 'one', 2 -> 'two', 3 -> 'three')
] 

It also extends the collection types with a lot of very useful functions.
One example is the ubiquitous code[map] function:

code[Xtend][
  val listOfNames = listOfPersons.map\[ name \]
]

Many operators to concat collections or to do arithmetics with types like code[BigDecimal] are also available.

You might want to have a look at the link[http://xtend-lang.org/api/2.3.0/index.html][JavaDoc API] to see what is
available.

section:GettingStarted[Getting Started]

The first thing you want to see in any language is a "Hello World" example. 
In Xtend, that reads as
code[Xtend][
  class HelloWorld {
    def static void main(String\[\] args) {
      println("Hello World")
    }
  }
]

You see that Xtend looks a lot like Java. At a first glance the main difference seems to be the code[Xtend][def]
keyword for declaring a method. Also like in Java it is mandatory to define a class and a main method as the entry point for an application. 
Admittedly 'hello world' programs are not a particular strength of Xtend. The real expressiveness is unleashed when you do real stuff
as you will learn in a moment.

An Xtend class resides in a plain Java project. As soon as the SDK is installed, Eclipse will automatically 
translate it to Java code. By default you will find it in a source folder e[xtend-gen], which is of course configurable.
The hello world example is translated to the following Java code:
code[Java][
  // Generated Java Source Code
  import org.eclipse.xtext.xbase.lib.InputOutput;
  
  public class HelloWorld {
    public static void main(final String\[\] args) {
      InputOutput.<String>println("Hello World");
    }
  }
] 

You can put an Xtend class in source folders of any Java project within Eclipse (or any Maven project). Eclipse will complain
about the missing library if it is not on the classpath and provide a quick fix to add it.

The next thing you might want to do is materializing one of the example projects into your workspace.
To do so right click anywhere in the e[Navigator] view in Eclipse and select e[New -> Example...].

In the upcoming dialog you will find two examples for Xtend:

ul[
  item[e[Xtend Introductory Examples] contains a couple of example code snippets illustrating certain
  aspects and strengths of Xtend. 
  It for instance shows how to build an API which allows for writing code like this:
  code[Xtend][
    assertEquals(42.km/h, (40_000.m + 2.km) / 60.min)
  ]
  Also the ref:moviesExample[the movies example] explained in detail in ref:moviesExample[the next section]
  is included there.]
  item[e[Xtend Solutions For Euler] contains solutions to a lot of the problems you will find at link[http://projecteuler.net/][Project Euler's website].
   These examples are leveraging the whole expressive power of Xtend. For instance link[http://projecteuler.net/problem=1][Euler Problem 1] can be solved
   with the following expression :
   code[Xtend][
     (1..999).filter\[ i | i % 3 == 0 || i % 5 == 0\].reduce\[i1, i2 | i1 + i2\]
   ]
   ]
]

section2:moviesExample[The Movies Example (src/examples6/Movies.xtend)]

The movies example is included in the example project e[Xtend Introductory Examples] and is about reading
a file with data about movies in and doing some analysis on it.

section3[The Data]

The movie database is a plain text file (data.csv) with data sets describing movies.
Here is an example data set:
code[
Naked Lunch  1991  6.9  16578  Biography  Comedy  Drama  Fantasy
]

The values are separated by two spaces. The columns are :
ol[
  item[title]
  item[year]
  item[rating]
  item[numberOfVotes]
  item[categories]
]
 
Let us define a data type code[Movie] representing a data set:

code[Xtend][
@Data class Movie {
  String title
  int year
  double rating
  long numberOfVotes
  Set<String> categories 
}
]

It is a plain class with a typed field for each column in the data sets. The ref:dataAnnotation[@Data]
annotation will turn this class into a value object, that is it will get 
ul[
  item[a getter-method for each field,]
  item[a code[hashCode()]/code[equals()] implementation,]
  item[implementation of code[Object.toString(),]]
  item[a constructor accepting values for all fields in the declared order.]
]

section3[Parsing The Data]

Let us now add another class to the same file (any number of ref:Xtend_Classes_Members[classes] per file is allowed) and initialize a field
called movies with a list of movies. For the initialization we read in the text file and turn the data sets into code[Movie]s:

code[Xtend][
import java.io.FileReader
import java.util.Set
import static extension com.google.common.io.CharStreams.*

class Movies {
  
  val movies = new FileReader('data.csv').readLines.map\[ line |
    val segments = line.split('  ').iterator
    return new Movie(
      segments.next, 
      Integer::parseInt(segments.next), 
      Double::parseDouble(segments.next), 
      Long::parseLong(segments.next), 
      segments.toSet
    )
  \]
}
]

A ref:fields[field's type] can be inferred from the expression on the right hand-side. 
That is called local type inference and is supported everyhwere in Xtend.
We want the field to be final, so we declare it as a value using the keyword code[Xtend][val].

The initialization on the right hand side first creates a fresh instance of code[java.io.FileReader].
Then the method code[readLines()] is invoked on that instance. But if you have a look at code[FileReader] you will not find
such a method, because code[readLines()] is in fact a static method from Google Guava's code[CharStream] which was imported 
as an ref:extensionImports[extension] which allows us to use this readable syntax.

code[Xtend][
import static extension com.google.common.io.CharStreams.*
]

code[CharStream.readLines(Reader)] returns a code[List<String>] on which we call another extension method called code[map].
That one is defined in the ref:library[runtime library] (code[ListExtensions.map(...)] and is always imported and
therefore automatically available on all lists. The code[map] extension expects a function as a parameter.
Map basically invokes that function for each value in the list and returns another list containing the results of the function incovations.

Function objects are created using ref:lambdas[lambda expression] (the code in squared brackets).
Within the lambda we process a single line from the text file and turn it into a movie by splitting the string using the
separator (two whitespaces) and calling iterator on the result. As you might know code[java.lang.String.split(String)]
returns a string array (code[String\[\]]), which Xtend ref:conversionRules[auto-convertes to a list] when we 
call code[Iterable.iterator()] on it.

code[Xtend][
val segments = line.split('  ').iterator
]

Now we use the iterator to create an instance of code[Movie].
The data type conversion (e.g. code[String] to code[Xtend][int]) is done by calling ref:staticAccess[static methods] from the wrapper types. 
The rest of the iterable is turned into a set using the extension method code[Iterators.toSet(Iterator<T>)]
and contains all the categories the movie is associated with.

code[Xtend][
return new Movie (
  segments.next, 
  Integer::parseInt(segments.next), 
  Double::parseDouble(segments.next), 
  Long::parseLong(segments.next), 
  segments.toSet
)
]

section3[Answering some Questions]

Now that we have turned the text file into a code[List<Movie>], we are ready to execute some queries against it.
We use e[JUnit] to make the individual analysis executable.

section4[What Is The Number Of Action Movies?]

code[Xtend][
  @Test def numberOfActionMovies() {
    assertEquals(828, 
      movies.filter\[categories.contains('Action')\].size)
  }
]

First the movies are code[filter]ed. The lambda expression checks whether the current movie's categories contain 
the entry code[Xtend]['Action']. Note that unlike the lambda we used to turn the lines in the file into movies, we 
have not declared a parameter name this time. 
We could have written 
code[Xtend][
  movies.filter\[ movie | movie.categories.contains('Action')\].size
]
but since we left out the name and the vertical bar the variable is automatically named code[Xtend][it] which
(like code[Xtend][this]) is an ref:implicitVariables[implicit variable]. That is why we can write either

code[Xtend][
  movies.filter\[ it.categories.contains('Action')\].size
]
or 
code[Xtend][
  movies.filter\[categories.contains('Action')\].size
]

Eventually we call code[size] on the resulting iterable which also is an extension method defined in 
codeRef[org.eclipse.xtext.xbase.lib.IterableExtensions].

section4[Question 2: What Is The Year The Best Movie From The 80ies Was Released?]

code[Xtend][
  @Test def void yearOfBestMovieFrom80ies() {
    assertEquals(1989, 
      movies.filter\[(1980..1989).contains(year)\].sortBy\[rating\].last.year)
  }
]

Here we code[filter] for all movies whose year is included in the range from 1980 to 1989 (the 80ies).
The code[..] operator is again an extension defined in codeRef[org.eclipse.xtext.xbase.lib.IntegerExtensions] and returns an instance of codeRef[org.eclipse.xtext.xbase.lib.IntegerRange].
Operator overloading is explained in ref:operators[section].

The resulting iterable is sorted (codeRef[org.eclipse.xtext.xbase.lib.IterableExtensions]code[.sortBy]) by the code[rating] of the movies. 
Since it is sorted in ascending order, we take the last movie from the list and return its code[year]. 

We could have sorted descending and take the head of the list as well:
code[Xtend][
  movies.filter\[(1980..1989).contains(year)\].sortBy\[-rating\].head.year
]

Note that first sorting and then taking the last or first is slightly more expensive than needed. We could
have used the method code[reduce] instead to find the best movie which would be more efficient. Maybe
you want to try it on your own?

The calls to code[movie.year] as well as code[movie.categories] in the previous example in fact access the corresponding 
ref:propertyAccess[getter methods].

section4[Question 3: What Is The The Sum Of All Votes Of The Top Two Movies?]

code[Xtend][
  @Test def void sumOfVotesOfTop2() {
    val long sum = movies.sortBy\[-rating\].take(2).map\[numberOfVotes\].reduce\[a, b| a + b\]
    assertEquals(47_229L, sum)
  }
]

First the movies are sorted by rating, then we take the best two. Next the list of movies is turned into a list of their code[numberOfVotes] using the code[map] function. 
Now we have a code[List<Long>] which can be reduced to a single code[Integer] by adding the values.

You could also use code[reduce] instead of code[map] and code[reduce]. Do you know how?

