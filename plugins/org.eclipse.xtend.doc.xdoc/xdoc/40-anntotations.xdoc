chapter:activeAnnotations[Active Annotations]

e[Active Annotations] allow developers to participate in the translation process of Xtend source code to Java code. That's useful in cases where Java requires you to 
write a lot of boilerplate manually. For instance, many of the good old design patterns fall into this category. With e[Active Annotations] you no longer need to remember how the 
link[http://en.wikipedia.org/wiki/Visitor_pattern][Visitor] or the link[http://en.wikipedia.org/wiki/][Observer] pattern should be implemented. In Xtend you can implement the expansion 
of such patterns in a library and let the compiler do the heavy lifting for you. To give you an example, lets have a look at the e[@Data] annotation:>

code[Xtend][
	@Data class Address {
	  String street
	  String zip
	  String city
	}
]

The code[@Data] annotation is part of Xtend and will implement best practices for immutability for the annotated class. In particular it will

ul[
  item[mark all fields as final,]
  item[create a single constructor,]
  item[implement code[hashCode()] and code[equals()] using the fields, and]
  item[create a readable code[toString()] implementation.]
]

Though these idioms are often very useful, they may not always be exactly what you want. With e[Active Annotations] you are no longer tight to the provided defaults but 
can roll your own implementation out which better suits your needs. e[Active Annotations] are just library so they integrate easily with your existing development environment.

In this article we want to give you an overview of how e[Active Annotations] work. As always this is best shown by example, so in the following we will develop our own 
little properties annotations, which generates getter and setter methods for annotated fields.

section[Creating The Project]

An e[Active Annotation] is declared in its own project which will be processed by the compiler before the clients of the annotations are translated. This allows to use the 
annotation right within your development environment and implement it side by side with the client code. This clear separation allows to avoid any dependencies of the 
downstream project to the APIs for the annotation processor and solves a chicken-and-egg problem between the processor and the annotated elements. The annotation is usable without any further ado.

You can use any kind of Java project to get started. We use the maven archetype here:
code[
 mvn archetype:generate 
     -DarchetypeGroupId=org.eclipse.xtend 
     -DarchetypeArtifactId=xtend-archetype 
     -DarchetypeCatalog=http://build.eclipse.org/common/xtend/maven/
]

This command will create a fully configured maven project which runs the Xtend and Java compiler during the build. Eclipse would not be needed to compile, test and jar the project, but is recommended because of the good IDE support. 
Also if you have the Eclipse Maven plugin m2e installed you can use the archetype wizard within Eclipse to create the project instead of the command line.

section[Test First]

e[Active Annotations] are executed in your IDE, whenever an annotated Xtend element is compiled. This is impressive, since whenever you change an annotation all clients get recompiled on the 
fly and you get instant feedback.

However, it doesn't allow you to debug your processor implementation nor to test it. In order to do so you should write a test case.

The test will make use of the compiler, so we need to add a dependency to it:

code[
<dependency>
  <groupId>org.eclipse.xtend</groupId>
  <artifactId>org.eclipse.xtend.standalone</artifactId>
  <version>2.4.0</version>
  <scope>test</scope>
</dependency>
]

Note that we only need this dependency for testing, which is why we set the scope element to 'test'. Further more we need some test framework, we'll use Junit in this example since that is already configured for the project.

Let's start with a simple test case:

code[Xtend][
class MyPropertyTests {

  extension XtendCompilerTester compilerTester = XtendCompilerTester::newXtendCompilerTester(typeof(MyPropertyTests)) 
  
  @Test def void testMyProperty() {
    '''
      class MyClass {
        @MyProperty String myField
      }
    '''.assertCompilesTo('''
      @SupressWarnings("all")
      public class MyClass {
        @MyProperty
        private String myField
        
        public String getMyField() {
          return this.myField;
        }
        
        public void setMyField(String myField) {
          this.myField = myField;
        }
      }
    ''')
  }
}
]

We use the code[XtendCompilerTester] to validate the code which is emitted by the active annotation and the Xtend compiler. Since it is declared as an extension field it is possible to call its method code[assertCompilesTo()] as if they were defined on instances of code[java.lang.String]. This idiom makes the test case easy to read and write. Later-on you may want to explore the other methods that are provided by the compiler tester in order to directly execute the code that is produced from a given Xtend snippet.


section[Implementing The Active Annotation]

Next up we want to fix the failing test. For that matter a new Xtend file called 'src/main/java/org/eclipse/example/activeannotations/MyProperty.xtend' should be created where we declare two elements: the annotation and its processor:
code[Xtend][
@Active(typeof(MyPropertyProcessor))
annotation MyProperty { }

class MyPropertyProcessor implements TransformationParticipant<MutableFieldDeclaration> {
  
  override doTransform(List<? extends MutableFieldDeclaration> fields, extension TransformationContext context) {
    //TODO add getters and setters
  }
  
}
]
Active annotations are annotated with code[@Active]. Therein a single class implementing code[TransformationParticipant] must be referenced. We put that class right after the annotation and can now start implementing the method code[doTransform()] which gets called by the compiler during the translation to Java.

All the annotated fields are passed into the processor as the first argument code[fields] of the method code[doTransform()]. Within the processor, we want to generate a getter and a setter method for each field.
code[Xtend][
fields.forEach \[ field |
  // add the getter method
  field.declaringType.addMethod('get'+field.name.toFirstUpper) \[
    returnType = field.type
    body = \['''
      return &#xab;field.name&#xbb;;
    '''\]
  \]
  //TODO add the setter method
\]
]
To add a getter method we iterate the annotated fields and add a method to each field's code[declaringType]. The code[addMethod()] operation takes two arguments, the method's name and an initializer block where we can set further properties like the return type, parameters, modifiers, etc. The method body is set with another block that is executed later when the actual Java code is generated. Here, we can generate Java code directly.

As you can see, the translation is two-fold, the coarse grained constructs such as type declarations and its members are created and modified on an structural basis. It is very similar to a mutable variation of the code[java.lang.reflect]. API. On top of that, the finer grained elements such as statements and expressions are generated using Java's concrete syntax in plain text. Xtend's template expression helps to produce beautiful code.

The setter method is created in a similar way. We only want a setter if the field is not final, so we add a guard for that:

code[Xtend][
fields.forEach \[ field |
  // add the getter method
  ...
  // add the setter method if field is not final
  if (!field.isFinal) {
    field.declaringType.addMethod('set'+field.name.toFirstUpper) \[
      returnType = primitiveVoid
      addParameter(field.name, field.type)
      body = \['''
        this.&#xab;field.name&#xbb; = &#xab;field.name&#xbb;;
      '''\]
    \]
  }
\]
]

Many of the needed properties and methods are declared on the AST types itself, such as code[MutableMethodDeclaration] and the like. However some are added through extensions coming from code[TransformationContext], which is the second argument to code[doTransform()]. The context exposes a handy API, for instance it allows to add error or warning messages and get a some support for tracing as well as useful factories for creating type references. All these blend naturally into the interfaces that are provided on the AST level and allow to implement very advanced processors that validate project specific constraints or implement specific idioms.

As an excercise you might want to add support for observing changes to the properties or check if a getter or setter method has been explicitly implemented already. Users should be able to change the getter or setter semantic by explicitly implementing one or the other.

section[Wrap Up]

e[Active Annotations] are a powerful new concept which lets you solve a large class of problems that previously had to be solved in cumbersome ways, e.g. by IDE wizards, with code generation or simply by manually writing boilerplate code. It basically e[is] a means of code generation, but its simple integration with your existing project structure and the fast development turnarounds diminish the typical downsides of code generation. e[Note, that in version 2.4 the Active Annotation-API is provisional, and might be changed in later releases.]

section[Existing Active Annotations]

Xtend comes with ready-to-use active annotations for common code patterns. 
They reside in the code[org.eclipse.xtend.lib] plug-in/jar which must be on the class path of the project containing the Xtend files.

section:propertyAnnotation[@Property]

For fields that are annotated as codeRef[org.eclipse.xtend.lib.Property][code[Xtend][@Property]], the Xtend compiler will generate a Java field, a
getter and, if the field is non-final, a setter method. The name of the Java field will be prefixed with 
an code[_] and have the visibility of the Xtend field. The accessors methods are always code[Xtend][public]. 
Thus, an Xtend field

code[Xtend][
  @Property String name
]

will compile to the Java code

code[Java][
  private String _name;
  
  public String getName() {
    return this._name;
  }
  
  public void setName(final String name) {
    this._name = name;
  }
]

section:dataAnnotation[@Data]

The annotation codeRef[org.eclipse.xtend.lib.Data][code[Xtend][@Data]], will turn an annotated class into a value object class. A class annotated with code[Xtend][@Data] 
has the following effect:

ul[
  item[all fields are flagged final,]
  item[getter methods will be generated (if not existent),]
  item[a constructor taking parameters for all non-initialized fields will be generated (if not existent),]
  item[equals(Object) / hashCode() methods will be generated (if not existent),]
  item[a toString() method will be generated (if not existent).]
]

Example:

code[Xtend][
@Data class Person {
  String firstName
  String lastName
}
]


