«REM»
/*******************************************************************************
 * Copyright (c) 2008 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 *******************************************************************************/
«ENDREM»

«IMPORT org::eclipse::xtext»

«EXTENSION org::eclipse::xtext::ui::generator::contentAssist::ContentAssist»
«EXTENSION org::eclipse::xtext::GrammarUtil»
«EXTENSION org::eclipse::xtext::generator::Naming»

«DEFINE generate FOR Grammar»
«FILE getGenProposalProvider().asPath()+".java" SRC_GEN_UI -»
/*
«fileHeader()»
*/
package «getGenProposalProvider().toJavaPackage()»;

«IF !usedGrammars.containedAssignments().isEmpty-»
import java.util.ArrayList;
«ENDIF-»
import java.util.Collections;
import java.util.List;


import org.eclipse.emf.ecore.EObject;
import org.eclipse.jface.text.contentassist.ICompletionProposal;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.ui.common.editor.contentassist.impl.AbstractJavaProposalProvider;
import org.eclipse.xtext.ui.common.editor.contentassist.IProposalProvider;
import org.eclipse.xtext.ui.common.editor.contentassist.IContentAssistContext;

«IF !usedGrammars.containedAssignments().isEmpty-»
import com.google.inject.Inject;
import com.google.inject.name.Named;
«ENDIF-»
/**
 * Represents a generated, default implementation of interface {@link IProposalProvider}.
 * Mehtods are dynamically dispatched on the first parameter, i.e., you can override them 
 * with a more concrete subtype. 
 * 
 * @see org.eclipse.xtext.ui.common.editor.contentassist.IProposalProvider
 */
public class «getGenProposalProvider().toSimpleName()» extends AbstractJavaProposalProvider {
	«IF !usedGrammars.containedAssignments().isEmpty-»
	«FOREACH usedGrammars AS usedGrammar-»
    @Inject(optional=true)
    @Named("«usedGrammar.name»")
    protected IProposalProvider «usedGrammar.name.toSimpleName().toFirstLower()»IProposalProvider;  
    «ENDFOREACH-»

    protected List<IProposalProvider> getReferencedProposalProviders() {
       List<IProposalProvider> referencedProposalProviders = new ArrayList<IProposalProvider>();
    «FOREACH usedGrammars AS usedGrammar-»
        if («usedGrammar.name.toSimpleName().toFirstLower()»IProposalProvider instanceof AbstractJavaProposalProvider) {
            referencedProposalProviders.addAll(((AbstractJavaProposalProvider) this.«usedGrammar.name.toSimpleName().toFirstLower()»IProposalProvider).getAllProposalProviders());
        }    
    «ENDFOREACH-»
       return referencedProposalProviders;
    }
    «ENDIF-»	
	«LET {} AS processedFqnFeatureNames-»
		«FOREACH containedAssignments() AS assignment-»
			«LET getFqFeatureName(assignment) AS fqnFeatureName»
				«IF !processedFqnFeatureNames.contains(fqnFeatureName)-»
					«processedFqnFeatureNames.add(fqnFeatureName)->""-»	 
	public List<? extends ICompletionProposal> complete«fqnFeatureName»(EObject model, Assignment assignment, IContentAssistContext contentAssistContext) {
		if (logger.isDebugEnabled()) {
			logger.debug("complete«fqnFeatureName» feature '" + assignment.getFeature() + "' terminal '"
					+ assignment.getTerminal() + "' cardinality '" + assignment.getCardinality() + "' and prefix '"
					+ contentAssistContext.getMatchString().trim() + "'");
		}
					«IF CrossReference.isInstance(assignment.terminal)-»
		return lookupCrossReference(((CrossReference)assignment.getTerminal()), contentAssistContext);
					«ELSEIF RuleCall.isInstance(assignment.terminal) && ((RuleCall)assignment.terminal).rule.name=="ID" -»
		return Collections.singletonList(createCompletionProposal(assignment, "«fqnFeatureName»", contentAssistContext));
					«ELSEIF RuleCall.isInstance(assignment.terminal) && ((RuleCall)assignment.terminal).rule.name=="INT" -»
		return Collections.singletonList(createCompletionProposal(assignment, "1", contentAssistContext));		
					«ELSEIF RuleCall.isInstance(assignment.terminal) && ((RuleCall)assignment.terminal).rule.name=="STRING" -»
		return Collections.singletonList(createCompletionProposal(assignment, "\"«fqnFeatureName»\"", contentAssistContext));		
					«ELSE-»
		return Collections.emptyList();
					«ENDIF-»
	}
				«ENDIF-»
			«ENDLET-»
  	  «ENDFOREACH-»
    
  	  «FOREACH getParserRulesWithType() AS parserRule-»
			«LET getFqFeatureName(parserRule) AS fqnFeatureName-»
				«IF !processedFqnFeatureNames.contains(fqnFeatureName)-»
					«processedFqnFeatureNames.add(fqnFeatureName)->""-»	 	 
	public List<? extends ICompletionProposal> complete«fqnFeatureName»(EObject model, RuleCall ruleCall, IContentAssistContext contentAssistContext) {
		if (logger.isDebugEnabled()) {
			logger.debug("complete«fqnFeatureName» '" + ruleCall.getRule().getName() + "' cardinality '" + ruleCall.getCardinality()
					+ "' for model '" + contentAssistContext.getModel() + "' and prefix '" + contentAssistContext.getMatchString() + "'");
		}
		return Collections.emptyList();
	}
				«ENDIF-»
			«ENDLET-»
    	«ENDFOREACH-»
	«ENDLET-»
}
«ENDFILE»

«FILE getProposalProvider().asPath()+".java" SRC_UI»
package «getProposalProvider().toJavaPackage()»;

public class «getProposalProvider().toSimpleName()» extends «getGenProposalProvider()» {

}
«ENDFILE»
«ENDDEFINE»

«DEFINE addToPluginXmlRt FOR Grammar»«ENDDEFINE»

«DEFINE addToPluginXmlUi FOR Grammar»«ENDDEFINE»

«DEFINE addToStandaloneSetup FOR Grammar»«ENDDEFINE»