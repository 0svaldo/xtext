/**
 * Copyright (c) 2015 itemis AG (http://www.itemis.eu) and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package org.eclipse.xtext.generator.parser.antlr;

import com.google.common.base.Objects;
import com.google.common.base.Stopwatch;
import com.google.common.io.Files;
import com.google.inject.Inject;
import java.io.File;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.TimeUnit;
import org.apache.log4j.Logger;
import org.eclipse.xpand2.XpandExecutionContext;
import org.eclipse.xpand2.XpandExecutionContextImpl;
import org.eclipse.xpand2.XpandFacade;
import org.eclipse.xpand2.output.Outlet;
import org.eclipse.xpand2.output.Output;
import org.eclipse.xtend.lib.annotations.Accessors;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.generator.Generator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.Naming;
import org.eclipse.xtext.generator.adapter.FragmentAdapter;
import org.eclipse.xtext.generator.parser.antlr.AntlrGrammarComparator;
import org.eclipse.xtext.generator.parser.antlr.AntlrOptions;
import org.eclipse.xtext.generator.parser.antlr.XtextAntlrGeneratorFragment;
import org.eclipse.xtext.generator.parser.antlr.XtextAntlrUiGeneratorFragment;
import org.eclipse.xtext.util.internal.Log;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.Pure;
import org.eclipse.xtext.xtext.FlattenedGrammarAccess;
import org.eclipse.xtext.xtext.RuleFilter;
import org.eclipse.xtext.xtext.RuleNames;
import org.eclipse.xtext.xtext.generator.IBundleProjectConfig;
import org.eclipse.xtext.xtext.generator.IRuntimeProjectConfig;
import org.eclipse.xtext.xtext.generator.IXtextProjectConfig;
import org.eclipse.xtext.xtext.generator.Issues;
import org.eclipse.xtext.xtext.generator.model.IXtextGeneratorFileSystemAccess;
import org.eclipse.xtext.xtext.generator.parser.antlr.AntlrGrammar;
import org.eclipse.xtext.xtext.generator.parser.antlr.ContentAssistGrammarNaming;
import org.eclipse.xtext.xtext.generator.parser.antlr.GrammarNaming;

/**
 * Compares the ANTLR grammar generated by {@link
 * org.eclipse.xtext.xtext.generator.parser.antlr.XtextAntlrGeneratorFragment2
 * XtextAntlrGeneratorFragment2} with that of {@link XtextAntlrGeneratorFragment}
 * by running its grammar generation in a temporary folder and calling {@link
 * GrammarComparator} to compare them.
 * 
 * @author Christian Schneider - Initial contribution and API
 * @since 2.9
 */
@Log
@SuppressWarnings("all")
public class XtextAntlrGeneratorComparisonFragment extends FragmentAdapter {
  public static class ErrorHandler extends AntlrGrammarComparator.AbstractErrorHandler {
    private File tmpFolder;
    
    public ErrorHandler(final File tmpFolder) {
      this.tmpFolder = tmpFolder;
    }
    
    @Override
    public void handleInvalidGrammarFile(final String absoluteGrammarFileName, final int lineNo) {
      XtextAntlrGeneratorComparisonFragment.deleteDir(this.tmpFolder);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Noticed an unmatched character sequence in file ");
      _builder.append(absoluteGrammarFileName, "");
      _builder.append(" in/before line ");
      _builder.append(lineNo, "");
      _builder.append(".");
      throw new RuntimeException(_builder.toString());
    }
    
    @Override
    public void handleMismatch(final String match, final String matchReference) {
      String _absoluteGrammarFileNameReference = this.getAbsoluteGrammarFileNameReference();
      String _absoluteGrammarFileName = this.getAbsoluteGrammarFileName();
      XtextAntlrGeneratorComparisonFragment.copyFile(_absoluteGrammarFileNameReference, _absoluteGrammarFileName);
      XtextAntlrGeneratorComparisonFragment.deleteDir(this.tmpFolder);
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Generated grammar ");
      String _absoluteGrammarFileName_1 = this.getAbsoluteGrammarFileName();
      _builder.append(_absoluteGrammarFileName_1, "");
      _builder.append(" differs at token ");
      _builder.append(match, "");
      _builder.append(" (line ");
      int _lineNumber = this.getLineNumber();
      _builder.append(_lineNumber, "");
      _builder.append("), expected token ");
      _builder.append(matchReference, "");
      _builder.append(" (line ");
      int _lineNumberReference = this.getLineNumberReference();
      _builder.append(_lineNumberReference, "");
      _builder.append(").");
      throw new RuntimeException(_builder.toString());
    }
  }
  
  private final static String ENCODING = "ISO-8859-1";
  
  @Inject
  private GrammarNaming productionNaming;
  
  @Inject
  private ContentAssistGrammarNaming contentAssistNaming;
  
  @Inject
  private AntlrGrammarComparator comparator;
  
  @Accessors
  private AntlrOptions options;
  
  @Accessors
  private boolean partialParsing;
  
  @Accessors
  private boolean skipContentAssistGrammarComparison = false;
  
  private List<String> advices = CollectionLiterals.<String>newArrayList();
  
  public void addRegisterAdvice(final String advice) {
    this.advices.add(advice);
  }
  
  @Override
  public void checkConfiguration(final Issues issues) {
  }
  
  @Override
  public void generate() {
    Naming _naming = this.getNaming();
    boolean _tripleEquals = (_naming == null);
    if (_tripleEquals) {
      Naming _createNaming = this.createNaming();
      this.setNaming(_createNaming);
    }
    if ((this.options == null)) {
      AntlrOptions _antlrOptions = new AntlrOptions();
      this.options = _antlrOptions;
    }
    File _tmpFolder = this.getTmpFolder();
    final XtextAntlrGeneratorComparisonFragment.ErrorHandler errorHandler = new XtextAntlrGeneratorComparisonFragment.ErrorHandler(_tmpFolder);
    IXtextProjectConfig _projectConfig = this.getProjectConfig();
    IRuntimeProjectConfig _runtime = _projectConfig.getRuntime();
    IXtextGeneratorFileSystemAccess _srcGen = null;
    if (_runtime!=null) {
      _srcGen=_runtime.getSrcGen();
    }
    boolean _notEquals = (!Objects.equal(_srcGen, null));
    if (_notEquals) {
      IXtextProjectConfig _projectConfig_1 = this.getProjectConfig();
      IRuntimeProjectConfig _runtime_1 = _projectConfig_1.getRuntime();
      IXtextGeneratorFileSystemAccess _srcGen_1 = _runtime_1.getSrcGen();
      Grammar _grammar = this.getGrammar();
      AntlrGrammar _parserGrammar = this.productionNaming.getParserGrammar(_grammar);
      String _grammarFileName = _parserGrammar.getGrammarFileName();
      this.loadAndCompareGrammars(_srcGen_1, 
        Generator.SRC_GEN, _grammarFileName, errorHandler);
    }
    boolean _and = false;
    if (!(!this.skipContentAssistGrammarComparison)) {
      _and = false;
    } else {
      IXtextProjectConfig _projectConfig_2 = this.getProjectConfig();
      IBundleProjectConfig _genericIde = _projectConfig_2.getGenericIde();
      IXtextGeneratorFileSystemAccess _srcGen_2 = null;
      if (_genericIde!=null) {
        _srcGen_2=_genericIde.getSrcGen();
      }
      boolean _notEquals_1 = (!Objects.equal(_srcGen_2, null));
      _and = _notEquals_1;
    }
    if (_and) {
      IXtextProjectConfig _projectConfig_3 = this.getProjectConfig();
      IBundleProjectConfig _genericIde_1 = _projectConfig_3.getGenericIde();
      IXtextGeneratorFileSystemAccess _srcGen_3 = _genericIde_1.getSrcGen();
      Grammar _grammar_1 = this.getGrammar();
      AntlrGrammar _parserGrammar_1 = this.contentAssistNaming.getParserGrammar(_grammar_1);
      String _grammarFileName_1 = _parserGrammar_1.getGrammarFileName();
      this.loadAndCompareGrammars(_srcGen_3, 
        Generator.SRC_GEN_IDE, _grammarFileName_1, errorHandler);
    }
    File _tmpFolder_1 = this.getTmpFolder();
    XtextAntlrGeneratorComparisonFragment.deleteDir(_tmpFolder_1);
  }
  
  protected void loadAndCompareGrammars(final IFileSystemAccess2 fsa, final String outlet, final String grammarFileName, final XtextAntlrGeneratorComparisonFragment.ErrorHandler errorHandler) {
    try {
      final Stopwatch stopWatch = Stopwatch.createStarted();
      this.performXpandBasedGeneration(outlet);
      StringConcatenation _builder = new StringConcatenation();
      File _tmpFolder = this.getTmpFolder();
      String _absolutePath = _tmpFolder.getAbsolutePath();
      _builder.append(_absolutePath, "");
      _builder.append("/");
      _builder.append(grammarFileName, "");
      final String absoluteGrammarFileNameReference = _builder.toString();
      StringConcatenation _builder_1 = new StringConcatenation();
      String _path = this.getPath(fsa);
      _builder_1.append(_path, "");
      _builder_1.append("/");
      _builder_1.append(grammarFileName, "");
      errorHandler.setAbsoluteGrammarFileName(_builder_1.toString());
      errorHandler.setAbsoluteGrammarFileNameReference(absoluteGrammarFileNameReference);
      final CharSequence grammar = fsa.readTextFile(grammarFileName);
      File _file = new File(absoluteGrammarFileNameReference);
      Charset _forName = Charset.forName(XtextAntlrGeneratorComparisonFragment.ENCODING);
      final String grammarReference = Files.toString(_file, _forName);
      this.comparator.compareGrammars(grammar, grammarReference, errorHandler);
      final long time = stopWatch.elapsed(TimeUnit.MILLISECONDS);
      String _xifexpression = null;
      if ((outlet == Generator.SRC_GEN)) {
        _xifexpression = "parser";
      } else {
        _xifexpression = "content assist";
      }
      final String type = _xifexpression;
      StringConcatenation _builder_2 = new StringConcatenation();
      _builder_2.append("Generated ");
      _builder_2.append(type, "");
      _builder_2.append(" grammar of ");
      int _lineNumber = errorHandler.getLineNumber();
      _builder_2.append(_lineNumber, "");
      _builder_2.append(" lines matches expected one of ");
      int _lineNumberReference = errorHandler.getLineNumberReference();
      _builder_2.append(_lineNumberReference, "");
      _builder_2.append(" (");
      _builder_2.append(time, "");
      _builder_2.append(" ms).");
      XtextAntlrGeneratorComparisonFragment.LOG.info(_builder_2);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  protected void performXpandBasedGeneration(final String outlet) {
    final RuleFilter filter = new RuleFilter();
    boolean _isSkipUnusedRules = this.options.isSkipUnusedRules();
    filter.setDiscardUnreachableRules(_isSkipUnusedRules);
    Grammar _grammar = this.getGrammar();
    final RuleNames ruleNames = RuleNames.getRuleNames(_grammar, true);
    FlattenedGrammarAccess _flattenedGrammarAccess = new FlattenedGrammarAccess(ruleNames, filter);
    final Grammar flattened = _flattenedGrammarAccess.getFlattenedGrammar();
    XpandExecutionContext _createExecutionContext = this.createExecutionContext();
    final XpandExecutionContextImpl context = ((XpandExecutionContextImpl) _createExecutionContext);
    final Procedure1<String> _function = new Procedure1<String>() {
      @Override
      public void apply(final String it) {
        context.registerAdvices(it);
      }
    };
    IterableExtensions.<String>forEach(this.advices, _function);
    boolean _and = false;
    boolean _equals = Objects.equal(outlet, Generator.SRC_GEN);
    if (!_equals) {
      _and = false;
    } else {
      Output _output = context.getOutput();
      Outlet _outlet = _output.getOutlet(Generator.SRC_GEN);
      boolean _notEquals = (!Objects.equal(_outlet, null));
      _and = _notEquals;
    }
    if (_and) {
      String _name = XtextAntlrGeneratorFragment.class.getName();
      final String template = _name.replaceAll("\\.", "::");
      XpandFacade _create = XpandFacade.create(context);
      _create.evaluate2((template + "::generate"), flattened, Collections.<Object>unmodifiableList(CollectionLiterals.<Object>newArrayList(this.options)));
    } else {
      boolean _and_1 = false;
      boolean _equals_1 = Objects.equal(outlet, Generator.SRC_GEN_IDE);
      if (!_equals_1) {
        _and_1 = false;
      } else {
        Output _output_1 = context.getOutput();
        Outlet _outlet_1 = _output_1.getOutlet(Generator.SRC_GEN_IDE);
        boolean _notEquals_1 = (!Objects.equal(_outlet_1, null));
        _and_1 = _notEquals_1;
      }
      if (_and_1) {
        String _name_1 = XtextAntlrUiGeneratorFragment.class.getName();
        final String template_1 = _name_1.replaceAll("\\.", "::");
        XpandFacade _create_1 = XpandFacade.create(context);
        Naming _naming = this.getNaming();
        boolean _hasIde = _naming.hasIde();
        _create_1.evaluate2((template_1 + "::generate"), flattened, Collections.<Object>unmodifiableList(CollectionLiterals.<Object>newArrayList(this.options, Boolean.valueOf(this.partialParsing), Boolean.valueOf(_hasIde))));
      }
    }
  }
  
  protected static void copyFile(final String from, final String to) {
    try {
      File _file = new File(from);
      StringConcatenation _builder = new StringConcatenation();
      int _length = to.length();
      int _minus = (_length - 2);
      String _substring = to.substring(0, _minus);
      _builder.append(_substring, "");
      _builder.append("Expected.g");
      File _file_1 = new File(_builder.toString());
      Files.copy(_file, _file_1);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * offers a singleton temporary folder
   */
  private File getTmpFolder() {
    final ArrayList<?> _cacheKey = CollectionLiterals.newArrayList();
    final File _result;
    synchronized (_createCache_getTmpFolder) {
      if (_createCache_getTmpFolder.containsKey(_cacheKey)) {
        return _createCache_getTmpFolder.get(_cacheKey);
      }
      File _createTempDir = Files.createTempDir();
      _result = _createTempDir;
      _createCache_getTmpFolder.put(_cacheKey, _result);
    }
    _init_getTmpFolder(_result);
    return _result;
  }
  
  private final HashMap<ArrayList<?>, File> _createCache_getTmpFolder = CollectionLiterals.newHashMap();
  
  private void _init_getTmpFolder(final File path) {
  }
  
  /**
   * Tweaks the generation of the {@link Generator#SRC_GEN Generator.SRC_GEN} outlet
   * and injects the {@link #getTmpPath()}.
   */
  @Override
  protected Outlet createOutlet(final boolean append, final String encoding, final String name, final boolean overwrite, final String path) {
    Outlet _xifexpression = null;
    boolean _or = false;
    boolean _or_1 = false;
    boolean _equals = Objects.equal(name, Generator.SRC_GEN);
    if (_equals) {
      _or_1 = true;
    } else {
      boolean _equals_1 = Objects.equal(name, Generator.SRC_GEN_IDE);
      _or_1 = _equals_1;
    }
    if (_or_1) {
      _or = true;
    } else {
      boolean _equals_2 = Objects.equal(name, Generator.SRC_GEN_UI);
      _or = _equals_2;
    }
    if (_or) {
      File _tmpFolder = this.getTmpFolder();
      String _absolutePath = _tmpFolder.getAbsolutePath();
      _xifexpression = super.createOutlet(append, encoding, name, overwrite, _absolutePath);
    } else {
      _xifexpression = super.createOutlet(append, encoding, name, overwrite, path);
    }
    return _xifexpression;
  }
  
  /**
   * little helper for cleaning up the temporary stuff.
   */
  private static void deleteDir(final File dir) {
    try {
      boolean _exists = dir.exists();
      boolean _not = (!_exists);
      if (_not) {
        return;
      }
      org.eclipse.xtext.util.Files.sweepFolder(dir);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private final static Logger LOG = Logger.getLogger(XtextAntlrGeneratorComparisonFragment.class);
  
  @Pure
  public AntlrOptions getOptions() {
    return this.options;
  }
  
  public void setOptions(final AntlrOptions options) {
    this.options = options;
  }
  
  @Pure
  public boolean isPartialParsing() {
    return this.partialParsing;
  }
  
  public void setPartialParsing(final boolean partialParsing) {
    this.partialParsing = partialParsing;
  }
  
  @Pure
  public boolean isSkipContentAssistGrammarComparison() {
    return this.skipContentAssistGrammarComparison;
  }
  
  public void setSkipContentAssistGrammarComparison(final boolean skipContentAssistGrammarComparison) {
    this.skipContentAssistGrammarComparison = skipContentAssistGrammarComparison;
  }
}
