/*
* generated by Xtext
*/
package org.eclipse.xtext.xbase.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.xtext.xbase.services.XbaseGrammarAccess;

import com.google.inject.Inject;

public class XbaseParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private XbaseGrammarAccess grammarAccess;
	
	@Override	
	public XbaseGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new File_Group(this, this, 0, inst);
			case 1: return new Import_Group(this, this, 1, inst);
			case 2: return new Function_Group(this, this, 2, inst);
			case 3: return new Expression_ClosureParserRuleCall(this, this, 3, inst);
			case 4: return new Closure_Alternatives(this, this, 4, inst);
			case 5: return new CastedExpression_Alternatives(this, this, 5, inst);
			case 6: return new Assignment_Group(this, this, 6, inst);
			case 7: return new OrExpression_Group(this, this, 7, inst);
			case 8: return new AndExpression_Group(this, this, 8, inst);
			case 9: return new RelationalExpression_Group(this, this, 9, inst);
			case 10: return new AdditiveExpression_Group(this, this, 10, inst);
			case 11: return new MultiplicativeExpression_Group(this, this, 11, inst);
			case 12: return new OtherOperatorExpression_Group(this, this, 12, inst);
			case 13: return new UnaryOperation_Alternatives(this, this, 13, inst);
			case 14: return new FeatureCall_Group(this, this, 14, inst);
			case 15: return new PrimaryExpression_Alternatives(this, this, 15, inst);
			case 16: return new ParenthesizedExpression_Group(this, this, 16, inst);
			case 17: return new IfExpression_Group(this, this, 17, inst);
			case 18: return new SwitchExpression_Group(this, this, 18, inst);
			case 19: return new WhileExpression_Group(this, this, 19, inst);
			case 20: return new CasePart_Group(this, this, 20, inst);
			case 21: return new BlockExpression_Group(this, this, 21, inst);
			case 22: return new ExpressionInsideBlock_Alternatives(this, this, 22, inst);
			case 23: return new VariableDeclaration_Group(this, this, 23, inst);
			case 24: return new DeclaredParameter_Group(this, this, 24, inst);
			case 25: return new SimpleFeatureCall_Group(this, this, 25, inst);
			case 26: return new ConstructorCall_Group(this, this, 26, inst);
			case 27: return new BooleanLiteral_Alternatives(this, this, 27, inst);
			case 28: return new NullLiteral_Group(this, this, 28, inst);
			case 29: return new IntLiteral_ValueAssignment(this, this, 29, inst);
			case 30: return new StringLiteral_ValueAssignment(this, this, 30, inst);
			case 31: return new RichString_Group(this, this, 31, inst);
			case 32: return new RichStringLiteral_ValueAssignment(this, this, 32, inst);
			case 33: return new TypeRef_Alternatives(this, this, 33, inst);
			case 34: return new FunctionTypeRef_Group(this, this, 34, inst);
			case 35: return new SimpleTypeRef_Group(this, this, 35, inst);
			case 36: return new TypeParam_Alternatives(this, this, 36, inst);
			case 37: return new WildcardParam_Group(this, this, 37, inst);
			case 38: return new TypeParamDeclaration_Group(this, this, 38, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule File ****************
 *
 * File:
 *   imports+=Import* functions+=Function*;
 *
 **/

// imports+=Import* functions+=Function*
protected class File_Group extends GroupToken {
	
	public File_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFileAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new File_FunctionsAssignment_1(parent, this, 0, inst);
			case 1: return new File_ImportsAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFileRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// imports+=Import*
protected class File_ImportsAssignment_0 extends AssignmentToken  {
	
	public File_ImportsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFileAccess().getImportsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("imports",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("imports");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getImportRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFileAccess().getImportsImportParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new File_ImportsAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

// functions+=Function*
protected class File_FunctionsAssignment_1 extends AssignmentToken  {
	
	public File_FunctionsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFileAccess().getFunctionsAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFunctionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFileAccess().getFunctionsFunctionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new File_FunctionsAssignment_1(parent, next, actIndex, consumed);
			case 1: return new File_ImportsAssignment_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}


/************ end Rule File ****************/


/************ begin Rule Import ****************
 *
 * Import:
 *   "import" importedNamespace=QualifiedNameWithWildCard;
 *
 **/

// "import" importedNamespace=QualifiedNameWithWildCard
protected class Import_Group extends GroupToken {
	
	public Import_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getImportAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_ImportedNamespaceAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getImportRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "import"
protected class Import_ImportKeyword_0 extends KeywordToken  {
	
	public Import_ImportKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getImportAccess().getImportKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// importedNamespace=QualifiedNameWithWildCard
protected class Import_ImportedNamespaceAssignment_1 extends AssignmentToken  {
	
	public Import_ImportedNamespaceAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getImportAccess().getImportedNamespaceAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Import_ImportKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("importedNamespace",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("importedNamespace");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildCardParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Import ****************/



/************ begin Rule Function ****************
 *
 * Function:
 *   (private?="private"|final?="final")* ("<" typeParams+=TypeParamDeclaration (","
 *   typeParams+=TypeParamDeclaration)* ">")? returnType=TypeRef? name=ID "(" (
 *   declaredParams+=DeclaredParameter ("," declaredParams+=DeclaredParameter)*)? ")" (
 *   "if" guard=Expression)? (":" expression=Expression ";"|expression=BlockExpression);
 *
 **/

// (private?="private"|final?="final")* ("<" typeParams+=TypeParamDeclaration (","
// typeParams+=TypeParamDeclaration)* ">")? returnType=TypeRef? name=ID "(" (
// declaredParams+=DeclaredParameter ("," declaredParams+=DeclaredParameter)*)? ")" (
// "if" guard=Expression)? (":" expression=Expression ";"|expression=BlockExpression)
protected class Function_Group extends GroupToken {
	
	public Function_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Alternatives_8(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFunctionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// (private?="private"|final?="final")*
protected class Function_Alternatives_0 extends AlternativesToken {

	public Function_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFunctionAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_PrivateAssignment_0_0(parent, this, 0, inst);
			case 1: return new Function_FinalAssignment_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// private?="private"
protected class Function_PrivateAssignment_0_0 extends AssignmentToken  {
	
	public Function_PrivateAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getPrivateAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Alternatives_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("private",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("private");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFunctionAccess().getPrivatePrivateKeyword_0_0_0();
			return obj;
		}
		return null;
	}

}

// final?="final"
protected class Function_FinalAssignment_0_1 extends AssignmentToken  {
	
	public Function_FinalAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getFinalAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Alternatives_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("final",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("final");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getFunctionAccess().getFinalFinalKeyword_0_1_0();
			return obj;
		}
		return null;
	}

}


// ("<" typeParams+=TypeParamDeclaration ("," typeParams+=TypeParamDeclaration)* ">")?
protected class Function_Group_1 extends GroupToken {
	
	public Function_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_GreaterThanSignKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class Function_LessThanSignKeyword_1_0 extends KeywordToken  {
	
	public Function_LessThanSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getLessThanSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Alternatives_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// typeParams+=TypeParamDeclaration
protected class Function_TypeParamsAssignment_1_1 extends AssignmentToken  {
	
	public Function_TypeParamsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getTypeParamsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeParams",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeParams");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeParamDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getTypeParamsTypeParamDeclarationParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_LessThanSignKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," typeParams+=TypeParamDeclaration)*
protected class Function_Group_1_2 extends GroupToken {
	
	public Function_Group_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_TypeParamsAssignment_1_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Function_CommaKeyword_1_2_0 extends KeywordToken  {
	
	public Function_CommaKeyword_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getCommaKeyword_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_1_2(parent, this, 0, inst);
			case 1: return new Function_TypeParamsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// typeParams+=TypeParamDeclaration
protected class Function_TypeParamsAssignment_1_2_1 extends AssignmentToken  {
	
	public Function_TypeParamsAssignment_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getTypeParamsAssignment_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeParams",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeParams");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeParamDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getTypeParamsTypeParamDeclarationParserRuleCall_1_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_CommaKeyword_1_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ">"
protected class Function_GreaterThanSignKeyword_1_3 extends KeywordToken  {
	
	public Function_GreaterThanSignKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGreaterThanSignKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_1_2(parent, this, 0, inst);
			case 1: return new Function_TypeParamsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// returnType=TypeRef?
protected class Function_ReturnTypeAssignment_2 extends AssignmentToken  {
	
	public Function_ReturnTypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getReturnTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("returnType",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("returnType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getReturnTypeTypeRefParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_Group_1(parent, next, actIndex, consumed);
			case 1: return new Function_Alternatives_0(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 2, consumed);
		}	
	}	
}

// name=ID
protected class Function_NameAssignment_3 extends AssignmentToken  {
	
	public Function_NameAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getNameAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_ReturnTypeAssignment_2(parent, this, 0, inst);
			case 1: return new Function_Group_1(parent, this, 1, inst);
			case 2: return new Function_Alternatives_0(parent, this, 2, inst);
			default: return parent.createParentFollower(this, index, index - 3, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getFunctionAccess().getNameIDTerminalRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class Function_LeftParenthesisKeyword_4 extends KeywordToken  {
	
	public Function_LeftParenthesisKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getLeftParenthesisKeyword_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_NameAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (declaredParams+=DeclaredParameter ("," declaredParams+=DeclaredParameter)*)?
protected class Function_Group_5 extends GroupToken {
	
	public Function_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_5_1(parent, this, 0, inst);
			case 1: return new Function_DeclaredParamsAssignment_5_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// declaredParams+=DeclaredParameter
protected class Function_DeclaredParamsAssignment_5_0 extends AssignmentToken  {
	
	public Function_DeclaredParamsAssignment_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getDeclaredParamsAssignment_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredParameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("declaredParams",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("declaredParams");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaredParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getDeclaredParamsDeclaredParameterParserRuleCall_5_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_LeftParenthesisKeyword_4(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," declaredParams+=DeclaredParameter)*
protected class Function_Group_5_1 extends GroupToken {
	
	public Function_Group_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_DeclaredParamsAssignment_5_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Function_CommaKeyword_5_1_0 extends KeywordToken  {
	
	public Function_CommaKeyword_5_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getCommaKeyword_5_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_5_1(parent, this, 0, inst);
			case 1: return new Function_DeclaredParamsAssignment_5_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// declaredParams+=DeclaredParameter
protected class Function_DeclaredParamsAssignment_5_1_1 extends AssignmentToken  {
	
	public Function_DeclaredParamsAssignment_5_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getDeclaredParamsAssignment_5_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredParameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("declaredParams",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("declaredParams");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaredParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getDeclaredParamsDeclaredParameterParserRuleCall_5_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_CommaKeyword_5_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class Function_RightParenthesisKeyword_6 extends KeywordToken  {
	
	public Function_RightParenthesisKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getRightParenthesisKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_5(parent, this, 0, inst);
			case 1: return new Function_LeftParenthesisKeyword_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ("if" guard=Expression)?
protected class Function_Group_7 extends GroupToken {
	
	public Function_Group_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_GuardAssignment_7_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "if"
protected class Function_IfKeyword_7_0 extends KeywordToken  {
	
	public Function_IfKeyword_7_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getIfKeyword_7_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_RightParenthesisKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// guard=Expression
protected class Function_GuardAssignment_7_1 extends AssignmentToken  {
	
	public Function_GuardAssignment_7_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGuardAssignment_7_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("guard",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("guard");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getGuardExpressionParserRuleCall_7_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_IfKeyword_7_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ":" expression=Expression ";"|expression=BlockExpression
protected class Function_Alternatives_8 extends AlternativesToken {

	public Function_Alternatives_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getFunctionAccess().getAlternatives_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_8_0(parent, this, 0, inst);
			case 1: return new Function_ExpressionAssignment_8_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// ":" expression=Expression ";"
protected class Function_Group_8_0 extends GroupToken {
	
	public Function_Group_8_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionAccess().getGroup_8_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_SemicolonKeyword_8_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class Function_ColonKeyword_8_0_0 extends KeywordToken  {
	
	public Function_ColonKeyword_8_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getColonKeyword_8_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_Group_7(parent, this, 0, inst);
			case 1: return new Function_RightParenthesisKeyword_6(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// expression=Expression
protected class Function_ExpressionAssignment_8_0_1 extends AssignmentToken  {
	
	public Function_ExpressionAssignment_8_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getExpressionAssignment_8_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getExpressionExpressionParserRuleCall_8_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_ColonKeyword_8_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class Function_SemicolonKeyword_8_0_2 extends KeywordToken  {
	
	public Function_SemicolonKeyword_8_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionAccess().getSemicolonKeyword_8_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Function_ExpressionAssignment_8_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// expression=BlockExpression
protected class Function_ExpressionAssignment_8_1 extends AssignmentToken  {
	
	public Function_ExpressionAssignment_8_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionAccess().getExpressionAssignment_8_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionAccess().getExpressionBlockExpressionParserRuleCall_8_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Function_Group_7(parent, next, actIndex, consumed);
			case 1: return new Function_RightParenthesisKeyword_6(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Function ****************/


/************ begin Rule Expression ****************
 *
 * Expression:
 *   Closure;
 *
 **/

// Closure
protected class Expression_ClosureParserRuleCall extends RuleCallToken {
	
	public Expression_ClosureParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getClosureParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Closure_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getClosureRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule Expression ****************/


/************ begin Rule Closure ****************
 *
 * Closure returns Expression:
 *   {Closure} (params+=DeclaredParameter ("," params+=DeclaredParameter)*)? "|"
 *   expression=CastedExpression|CastedExpression;
 *
 **/

// {Closure} (params+=DeclaredParameter ("," params+=DeclaredParameter)*)? "|"
// expression=CastedExpression|CastedExpression
protected class Closure_Alternatives extends AlternativesToken {

	public Closure_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getClosureAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_Group_0(parent, this, 0, inst);
			case 1: return new Closure_CastedExpressionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getClosureRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Closure} (params+=DeclaredParameter ("," params+=DeclaredParameter)*)? "|"
// expression=CastedExpression
protected class Closure_Group_0 extends GroupToken {
	
	public Closure_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_ExpressionAssignment_0_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Closure}
protected class Closure_ClosureAction_0_0 extends ActionToken  {

	public Closure_ClosureAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getClosureAccess().getClosureAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getClosureAccess().getClosureAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// (params+=DeclaredParameter ("," params+=DeclaredParameter)*)?
protected class Closure_Group_0_1 extends GroupToken {
	
	public Closure_Group_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureAccess().getGroup_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_Group_0_1_1(parent, this, 0, inst);
			case 1: return new Closure_ParamsAssignment_0_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=DeclaredParameter
protected class Closure_ParamsAssignment_0_1_0 extends AssignmentToken  {
	
	public Closure_ParamsAssignment_0_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureAccess().getParamsAssignment_0_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredParameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaredParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureAccess().getParamsDeclaredParameterParserRuleCall_0_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Closure_ClosureAction_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," params+=DeclaredParameter)*
protected class Closure_Group_0_1_1 extends GroupToken {
	
	public Closure_Group_0_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureAccess().getGroup_0_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_ParamsAssignment_0_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Closure_CommaKeyword_0_1_1_0 extends KeywordToken  {
	
	public Closure_CommaKeyword_0_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureAccess().getCommaKeyword_0_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_Group_0_1_1(parent, this, 0, inst);
			case 1: return new Closure_ParamsAssignment_0_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=DeclaredParameter
protected class Closure_ParamsAssignment_0_1_1_1 extends AssignmentToken  {
	
	public Closure_ParamsAssignment_0_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureAccess().getParamsAssignment_0_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredParameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaredParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureAccess().getParamsDeclaredParameterParserRuleCall_0_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Closure_CommaKeyword_0_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "|"
protected class Closure_VerticalLineKeyword_0_2 extends KeywordToken  {
	
	public Closure_VerticalLineKeyword_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureAccess().getVerticalLineKeyword_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_Group_0_1(parent, this, 0, inst);
			case 1: return new Closure_ClosureAction_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// expression=CastedExpression
protected class Closure_ExpressionAssignment_0_3 extends AssignmentToken  {
	
	public Closure_ExpressionAssignment_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureAccess().getExpressionAssignment_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CastedExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCastedExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureAccess().getExpressionCastedExpressionParserRuleCall_0_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Closure_VerticalLineKeyword_0_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// CastedExpression
protected class Closure_CastedExpressionParserRuleCall_1 extends RuleCallToken {
	
	public Closure_CastedExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getClosureAccess().getCastedExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CastedExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CastedExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCastedExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Closure ****************/


/************ begin Rule CastedExpression ****************
 *
 * CastedExpression returns Expression:
 *   {CastedExpression} "(" type=TypeRef ")" target=Assignment|Assignment;
 *
 **/

// {CastedExpression} "(" type=TypeRef ")" target=Assignment|Assignment
protected class CastedExpression_Alternatives extends AlternativesToken {

	public CastedExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCastedExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CastedExpression_Group_0(parent, this, 0, inst);
			case 1: return new CastedExpression_AssignmentParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCastedExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {CastedExpression} "(" type=TypeRef ")" target=Assignment
protected class CastedExpression_Group_0 extends GroupToken {
	
	public CastedExpression_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCastedExpressionAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CastedExpression_TargetAssignment_0_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {CastedExpression}
protected class CastedExpression_CastedExpressionAction_0_0 extends ActionToken  {

	public CastedExpression_CastedExpressionAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCastedExpressionAccess().getCastedExpressionAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCastedExpressionAccess().getCastedExpressionAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "("
protected class CastedExpression_LeftParenthesisKeyword_0_1 extends KeywordToken  {
	
	public CastedExpression_LeftParenthesisKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCastedExpressionAccess().getLeftParenthesisKeyword_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CastedExpression_CastedExpressionAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=TypeRef
protected class CastedExpression_TypeAssignment_0_2 extends AssignmentToken  {
	
	public CastedExpression_TypeAssignment_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCastedExpressionAccess().getTypeAssignment_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCastedExpressionAccess().getTypeTypeRefParserRuleCall_0_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CastedExpression_LeftParenthesisKeyword_0_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class CastedExpression_RightParenthesisKeyword_0_3 extends KeywordToken  {
	
	public CastedExpression_RightParenthesisKeyword_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCastedExpressionAccess().getRightParenthesisKeyword_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CastedExpression_TypeAssignment_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// target=Assignment
protected class CastedExpression_TargetAssignment_0_4 extends AssignmentToken  {
	
	public CastedExpression_TargetAssignment_0_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCastedExpressionAccess().getTargetAssignment_0_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCastedExpressionAccess().getTargetAssignmentParserRuleCall_0_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CastedExpression_RightParenthesisKeyword_0_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// Assignment
protected class CastedExpression_AssignmentParserRuleCall_1 extends RuleCallToken {
	
	public CastedExpression_AssignmentParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCastedExpressionAccess().getAssignmentParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Assignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule CastedExpression ****************/


/************ begin Rule Assignment ****************
 *
 * Assignment returns Expression:
 *   OrExpression ({Assignment.left=current} "=" right=OrExpression)?;
 *
 **/

// OrExpression ({Assignment.left=current} "=" right=OrExpression)?
protected class Assignment_Group extends GroupToken {
	
	public Assignment_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_Group_1(parent, this, 0, inst);
			case 1: return new Assignment_OrExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// OrExpression
protected class Assignment_OrExpressionParserRuleCall_0 extends RuleCallToken {
	
	public Assignment_OrExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getOrExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OrExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Assignment.left=current} "=" right=OrExpression)?
protected class Assignment_Group_1 extends GroupToken {
	
	public Assignment_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Assignment.left=current}
protected class Assignment_AssignmentLeftAction_1_0 extends ActionToken  {

	public Assignment_AssignmentLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_OrExpressionParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// "="
protected class Assignment_EqualsSignKeyword_1_1 extends KeywordToken  {
	
	public Assignment_EqualsSignKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getEqualsSignKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_AssignmentLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// right=OrExpression
protected class Assignment_RightAssignment_1_2 extends AssignmentToken  {
	
	public Assignment_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAssignmentAccess().getRightOrExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Assignment_EqualsSignKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Assignment ****************/


/************ begin Rule OrExpression ****************
 *
 * OrExpression returns Expression:
 *   AndExpression ({BinaryOperation.left=current} operator="||" right=AndExpression)*;
 *
 **/

// AndExpression ({BinaryOperation.left=current} operator="||" right=AndExpression)*
protected class OrExpression_Group extends GroupToken {
	
	public OrExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group_1(parent, this, 0, inst);
			case 1: return new OrExpression_AndExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AndExpression
protected class OrExpression_AndExpressionParserRuleCall_0 extends RuleCallToken {
	
	public OrExpression_AndExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getAndExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AndExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator="||" right=AndExpression)*
protected class OrExpression_Group_1 extends GroupToken {
	
	public OrExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class OrExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public OrExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group_1(parent, this, 0, inst);
			case 1: return new OrExpression_AndExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOrExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator="||"
protected class OrExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public OrExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("||".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getOrExpressionAccess().getOperatorVerticalLineVerticalLineKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// right=AndExpression
protected class OrExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public OrExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OrExpression ****************/


/************ begin Rule AndExpression ****************
 *
 * AndExpression returns Expression:
 *   RelationalExpression ({BinaryOperation.left=current} operator="&&" right=
 *   RelationalExpression)*;
 *
 **/

// RelationalExpression ({BinaryOperation.left=current} operator="&&" right=
// RelationalExpression)*
protected class AndExpression_Group extends GroupToken {
	
	public AndExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group_1(parent, this, 0, inst);
			case 1: return new AndExpression_RelationalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// RelationalExpression
protected class AndExpression_RelationalExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AndExpression_RelationalExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getRelationalExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RelationalExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator="&&" right=RelationalExpression)*
protected class AndExpression_Group_1 extends GroupToken {
	
	public AndExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class AndExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public AndExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group_1(parent, this, 0, inst);
			case 1: return new AndExpression_RelationalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAndExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator="&&"
protected class AndExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public AndExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("&&".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAndExpressionAccess().getOperatorAmpersandAmpersandKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// right=RelationalExpression
protected class AndExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public AndExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndExpressionAccess().getRightRelationalExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AndExpression ****************/


/************ begin Rule RelationalExpression ****************
 *
 * RelationalExpression returns Expression:
 *   AdditiveExpression ({BinaryOperation.left=current} operator=( "==" | "!=" | ">=" | "<=" |
 *   ">" | "<" ) right=AdditiveExpression)*;
 *
 **/

// AdditiveExpression ({BinaryOperation.left=current} operator=( "==" | "!=" | ">=" | "<=" |
// ">" | "<" ) right=AdditiveExpression)*
protected class RelationalExpression_Group extends GroupToken {
	
	public RelationalExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group_1(parent, this, 0, inst);
			case 1: return new RelationalExpression_AdditiveExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AdditiveExpression
protected class RelationalExpression_AdditiveExpressionParserRuleCall_0 extends RuleCallToken {
	
	public RelationalExpression_AdditiveExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getAdditiveExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AdditiveExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator=( "==" | "!=" | ">=" | "<=" | ">" | "<" ) right=
// AdditiveExpression)*
protected class RelationalExpression_Group_1 extends GroupToken {
	
	public RelationalExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class RelationalExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public RelationalExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group_1(parent, this, 0, inst);
			case 1: return new RelationalExpression_AdditiveExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "==" | "!=" | ">=" | "<=" | ">" | "<" )
protected class RelationalExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public RelationalExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("==".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalExpressionAccess().getOperatorEqualsSignEqualsSignKeyword_1_1_0_0();
			return obj;
		}
		if("!=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalExpressionAccess().getOperatorExclamationMarkEqualsSignKeyword_1_1_0_1();
			return obj;
		}
		if(">=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalExpressionAccess().getOperatorGreaterThanSignEqualsSignKeyword_1_1_0_2();
			return obj;
		}
		if("<=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalExpressionAccess().getOperatorLessThanSignEqualsSignKeyword_1_1_0_3();
			return obj;
		}
		if(">".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalExpressionAccess().getOperatorGreaterThanSignKeyword_1_1_0_4();
			return obj;
		}
		if("<".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalExpressionAccess().getOperatorLessThanSignKeyword_1_1_0_5();
			return obj;
		}
		return null;
	}

}

// right=AdditiveExpression
protected class RelationalExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public RelationalExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalExpressionAccess().getRightAdditiveExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RelationalExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule RelationalExpression ****************/


/************ begin Rule AdditiveExpression ****************
 *
 * AdditiveExpression returns Expression:
 *   MultiplicativeExpression ({BinaryOperation.left=current} operator=( "+" | "-" ) right=
 *   MultiplicativeExpression)*;
 *
 **/

// MultiplicativeExpression ({BinaryOperation.left=current} operator=( "+" | "-" ) right=
// MultiplicativeExpression)*
protected class AdditiveExpression_Group extends GroupToken {
	
	public AdditiveExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveExpression_MultiplicativeExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// MultiplicativeExpression
protected class AdditiveExpression_MultiplicativeExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AdditiveExpression_MultiplicativeExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getMultiplicativeExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(MultiplicativeExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator=( "+" | "-" ) right=MultiplicativeExpression)
// *
protected class AdditiveExpression_Group_1 extends GroupToken {
	
	public AdditiveExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class AdditiveExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public AdditiveExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveExpression_MultiplicativeExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "+" | "-" )
protected class AdditiveExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public AdditiveExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("+".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAdditiveExpressionAccess().getOperatorPlusSignKeyword_1_1_0_0();
			return obj;
		}
		if("-".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAdditiveExpressionAccess().getOperatorHyphenMinusKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// right=MultiplicativeExpression
protected class AdditiveExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public AdditiveExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditiveExpressionAccess().getRightMultiplicativeExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AdditiveExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AdditiveExpression ****************/


/************ begin Rule MultiplicativeExpression ****************
 *
 * MultiplicativeExpression returns Expression:
 *   OtherOperatorExpression ({BinaryOperation.left=current} operator=( "*" | "/" ) right=
 *   OtherOperatorExpression)*;
 *
 **/

// OtherOperatorExpression ({BinaryOperation.left=current} operator=( "*" | "/" ) right=
// OtherOperatorExpression)*
protected class MultiplicativeExpression_Group extends GroupToken {
	
	public MultiplicativeExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group_1(parent, this, 0, inst);
			case 1: return new MultiplicativeExpression_OtherOperatorExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// OtherOperatorExpression
protected class MultiplicativeExpression_OtherOperatorExpressionParserRuleCall_0 extends RuleCallToken {
	
	public MultiplicativeExpression_OtherOperatorExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getOtherOperatorExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OtherOperatorExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOtherOperatorExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator=( "*" | "/" ) right=OtherOperatorExpression)*
protected class MultiplicativeExpression_Group_1 extends GroupToken {
	
	public MultiplicativeExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class MultiplicativeExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public MultiplicativeExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group_1(parent, this, 0, inst);
			case 1: return new MultiplicativeExpression_OtherOperatorExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "*" | "/" )
protected class MultiplicativeExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public MultiplicativeExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("*".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicativeExpressionAccess().getOperatorAsteriskKeyword_1_1_0_0();
			return obj;
		}
		if("/".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicativeExpressionAccess().getOperatorSolidusKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// right=OtherOperatorExpression
protected class MultiplicativeExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public MultiplicativeExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOtherOperatorExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMultiplicativeExpressionAccess().getRightOtherOperatorExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MultiplicativeExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule MultiplicativeExpression ****************/


/************ begin Rule OtherOperatorExpression ****************
 *
 * OtherOperatorExpression returns Expression:
 *   UnaryOperation ({BinaryOperation.left=current} operator=( "+=" | ".." ) right=
 *   UnaryOperation)*;
 *
 **/

// UnaryOperation ({BinaryOperation.left=current} operator=( "+=" | ".." ) right=
// UnaryOperation)*
protected class OtherOperatorExpression_Group extends GroupToken {
	
	public OtherOperatorExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_Group_1(parent, this, 0, inst);
			case 1: return new OtherOperatorExpression_UnaryOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOtherOperatorExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// UnaryOperation
protected class OtherOperatorExpression_UnaryOperationParserRuleCall_0 extends RuleCallToken {
	
	public OtherOperatorExpression_UnaryOperationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getUnaryOperationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UnaryOperation_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUnaryOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator=( "+=" | ".." ) right=UnaryOperation)*
protected class OtherOperatorExpression_Group_1 extends GroupToken {
	
	public OtherOperatorExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class OtherOperatorExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public OtherOperatorExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_Group_1(parent, this, 0, inst);
			case 1: return new OtherOperatorExpression_UnaryOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOtherOperatorExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "+=" | ".." )
protected class OtherOperatorExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public OtherOperatorExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("+=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getOtherOperatorExpressionAccess().getOperatorPlusSignEqualsSignKeyword_1_1_0_0();
			return obj;
		}
		if("..".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getOtherOperatorExpressionAccess().getOperatorFullStopFullStopKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// right=UnaryOperation
protected class OtherOperatorExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public OtherOperatorExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryOperationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOtherOperatorExpressionAccess().getRightUnaryOperationParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OtherOperatorExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OtherOperatorExpression ****************/


/************ begin Rule UnaryOperation ****************
 *
 * UnaryOperation returns Expression:
 *   FeatureCall|{UnaryOperation} operator=( "!" | "-" ) target=FeatureCall;
 *
 **/

// FeatureCall|{UnaryOperation} operator=( "!" | "-" ) target=FeatureCall
protected class UnaryOperation_Alternatives extends AlternativesToken {

	public UnaryOperation_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_FeatureCallParserRuleCall_0(parent, this, 0, inst);
			case 1: return new UnaryOperation_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnaryOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// FeatureCall
protected class UnaryOperation_FeatureCallParserRuleCall_0 extends RuleCallToken {
	
	public UnaryOperation_FeatureCallParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getFeatureCallParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FeatureCall_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFeatureCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// {UnaryOperation} operator=( "!" | "-" ) target=FeatureCall
protected class UnaryOperation_Group_1 extends GroupToken {
	
	public UnaryOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_TargetAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {UnaryOperation}
protected class UnaryOperation_UnaryOperationAction_1_0 extends ActionToken  {

	public UnaryOperation_UnaryOperationAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getUnaryOperationAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getUnaryOperationAccess().getUnaryOperationAction_1_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// operator=( "!" | "-" )
protected class UnaryOperation_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public UnaryOperation_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_UnaryOperationAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("!".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUnaryOperationAccess().getOperatorExclamationMarkKeyword_1_1_0_0();
			return obj;
		}
		if("-".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUnaryOperationAccess().getOperatorHyphenMinusKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// target=FeatureCall
protected class UnaryOperation_TargetAssignment_1_2 extends AssignmentToken  {
	
	public UnaryOperation_TargetAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getTargetAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFeatureCallRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnaryOperationAccess().getTargetFeatureCallParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryOperation_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule UnaryOperation ****************/


/************ begin Rule FeatureCall ****************
 *
 * FeatureCall returns Expression:
 *   PrimaryExpression ({FeatureCall.target=current} "." name=ID ("(" (params+=Expression (
 *   "," params+=Expression)*)? ")")?)*;
 *
 **/

// PrimaryExpression ({FeatureCall.target=current} "." name=ID ("(" (params+=Expression (
// "," params+=Expression)*)? ")")?)*
protected class FeatureCall_Group extends GroupToken {
	
	public FeatureCall_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1(parent, this, 0, inst);
			case 1: return new FeatureCall_PrimaryExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFeatureCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// PrimaryExpression
protected class FeatureCall_PrimaryExpressionParserRuleCall_0 extends RuleCallToken {
	
	public FeatureCall_PrimaryExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getPrimaryExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PrimaryExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({FeatureCall.target=current} "." name=ID ("(" (params+=Expression ("," params+=
// Expression)*)? ")")?)*
protected class FeatureCall_Group_1 extends GroupToken {
	
	public FeatureCall_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1_3(parent, this, 0, inst);
			case 1: return new FeatureCall_NameAssignment_1_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// {FeatureCall.target=current}
protected class FeatureCall_FeatureCallTargetAction_1_0 extends ActionToken  {

	public FeatureCall_FeatureCallTargetAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getFeatureCallTargetAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1(parent, this, 0, inst);
			case 1: return new FeatureCall_PrimaryExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getFeatureCallAccess().getFeatureCallTargetAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("target", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("target")) return null;
		return getDescr((EObject) val);
	}
}

// "."
protected class FeatureCall_FullStopKeyword_1_1 extends KeywordToken  {
	
	public FeatureCall_FullStopKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getFullStopKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_FeatureCallTargetAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class FeatureCall_NameAssignment_1_2 extends AssignmentToken  {
	
	public FeatureCall_NameAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getNameAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_FullStopKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getFeatureCallAccess().getNameIDTerminalRuleCall_1_2_0();
			return obj;
		}
		return null;
	}

}

// ("(" (params+=Expression ("," params+=Expression)*)? ")")?
protected class FeatureCall_Group_1_3 extends GroupToken {
	
	public FeatureCall_Group_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getGroup_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_RightParenthesisKeyword_1_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class FeatureCall_LeftParenthesisKeyword_1_3_0 extends KeywordToken  {
	
	public FeatureCall_LeftParenthesisKeyword_1_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getLeftParenthesisKeyword_1_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_NameAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (params+=Expression ("," params+=Expression)*)?
protected class FeatureCall_Group_1_3_1 extends GroupToken {
	
	public FeatureCall_Group_1_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getGroup_1_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1_3_1_1(parent, this, 0, inst);
			case 1: return new FeatureCall_ParamsAssignment_1_3_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class FeatureCall_ParamsAssignment_1_3_1_0 extends AssignmentToken  {
	
	public FeatureCall_ParamsAssignment_1_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getParamsAssignment_1_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFeatureCallAccess().getParamsExpressionParserRuleCall_1_3_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FeatureCall_LeftParenthesisKeyword_1_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," params+=Expression)*
protected class FeatureCall_Group_1_3_1_1 extends GroupToken {
	
	public FeatureCall_Group_1_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getGroup_1_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_ParamsAssignment_1_3_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class FeatureCall_CommaKeyword_1_3_1_1_0 extends KeywordToken  {
	
	public FeatureCall_CommaKeyword_1_3_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getCommaKeyword_1_3_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1_3_1_1(parent, this, 0, inst);
			case 1: return new FeatureCall_ParamsAssignment_1_3_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class FeatureCall_ParamsAssignment_1_3_1_1_1 extends AssignmentToken  {
	
	public FeatureCall_ParamsAssignment_1_3_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getParamsAssignment_1_3_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFeatureCallAccess().getParamsExpressionParserRuleCall_1_3_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FeatureCall_CommaKeyword_1_3_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class FeatureCall_RightParenthesisKeyword_1_3_2 extends KeywordToken  {
	
	public FeatureCall_RightParenthesisKeyword_1_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getRightParenthesisKeyword_1_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1_3_1(parent, this, 0, inst);
			case 1: return new FeatureCall_LeftParenthesisKeyword_1_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}




/************ end Rule FeatureCall ****************/


/************ begin Rule PrimaryExpression ****************
 *
 * PrimaryExpression returns Expression:
 *   BooleanLiteral|IntLiteral|NullLiteral|StringLiteral|ConstructorCall|
 *   BlockExpression|RichString|IfExpression|SwitchExpression|WhileExpression|
 *   SimpleFeatureCall|ParenthesizedExpression;
 *
 **/

// BooleanLiteral|IntLiteral|NullLiteral|StringLiteral|ConstructorCall|
// BlockExpression|RichString|IfExpression|SwitchExpression|WhileExpression|
// SimpleFeatureCall|ParenthesizedExpression
protected class PrimaryExpression_Alternatives extends AlternativesToken {

	public PrimaryExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_BooleanLiteralParserRuleCall_0(parent, this, 0, inst);
			case 1: return new PrimaryExpression_IntLiteralParserRuleCall_1(parent, this, 1, inst);
			case 2: return new PrimaryExpression_NullLiteralParserRuleCall_2(parent, this, 2, inst);
			case 3: return new PrimaryExpression_StringLiteralParserRuleCall_3(parent, this, 3, inst);
			case 4: return new PrimaryExpression_ConstructorCallParserRuleCall_4(parent, this, 4, inst);
			case 5: return new PrimaryExpression_BlockExpressionParserRuleCall_5(parent, this, 5, inst);
			case 6: return new PrimaryExpression_RichStringParserRuleCall_6(parent, this, 6, inst);
			case 7: return new PrimaryExpression_IfExpressionParserRuleCall_7(parent, this, 7, inst);
			case 8: return new PrimaryExpression_SwitchExpressionParserRuleCall_8(parent, this, 8, inst);
			case 9: return new PrimaryExpression_WhileExpressionParserRuleCall_9(parent, this, 9, inst);
			case 10: return new PrimaryExpression_SimpleFeatureCallParserRuleCall_10(parent, this, 10, inst);
			case 11: return new PrimaryExpression_ParenthesizedExpressionParserRuleCall_11(parent, this, 11, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// BooleanLiteral
protected class PrimaryExpression_BooleanLiteralParserRuleCall_0 extends RuleCallToken {
	
	public PrimaryExpression_BooleanLiteralParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getBooleanLiteralParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteral_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanLiteral_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// IntLiteral
protected class PrimaryExpression_IntLiteralParserRuleCall_1 extends RuleCallToken {
	
	public PrimaryExpression_IntLiteralParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getIntLiteralParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntLiteral_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// NullLiteral
protected class PrimaryExpression_NullLiteralParserRuleCall_2 extends RuleCallToken {
	
	public PrimaryExpression_NullLiteralParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getNullLiteralParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteral_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NullLiteral_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNullLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// StringLiteral
protected class PrimaryExpression_StringLiteralParserRuleCall_3 extends RuleCallToken {
	
	public PrimaryExpression_StringLiteralParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getStringLiteralParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StringLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StringLiteral_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStringLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ConstructorCall
protected class PrimaryExpression_ConstructorCallParserRuleCall_4 extends RuleCallToken {
	
	public PrimaryExpression_ConstructorCallParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getConstructorCallParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ConstructorCall_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getConstructorCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BlockExpression
protected class PrimaryExpression_BlockExpressionParserRuleCall_5 extends RuleCallToken {
	
	public PrimaryExpression_BlockExpressionParserRuleCall_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getBlockExpressionParserRuleCall_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BlockExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// RichString
protected class PrimaryExpression_RichStringParserRuleCall_6 extends RuleCallToken {
	
	public PrimaryExpression_RichStringParserRuleCall_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getRichStringParserRuleCall_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RichString_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RichString_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRichStringRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// IfExpression
protected class PrimaryExpression_IfExpressionParserRuleCall_7 extends RuleCallToken {
	
	public PrimaryExpression_IfExpressionParserRuleCall_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getIfExpressionParserRuleCall_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IfExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIfExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// SwitchExpression
protected class PrimaryExpression_SwitchExpressionParserRuleCall_8 extends RuleCallToken {
	
	public PrimaryExpression_SwitchExpressionParserRuleCall_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getSwitchExpressionParserRuleCall_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SwitchExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSwitchExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// WhileExpression
protected class PrimaryExpression_WhileExpressionParserRuleCall_9 extends RuleCallToken {
	
	public PrimaryExpression_WhileExpressionParserRuleCall_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getWhileExpressionParserRuleCall_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WhileExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(WhileExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getWhileExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// SimpleFeatureCall
protected class PrimaryExpression_SimpleFeatureCallParserRuleCall_10 extends RuleCallToken {
	
	public PrimaryExpression_SimpleFeatureCallParserRuleCall_10(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getSimpleFeatureCallParserRuleCall_10();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SimpleFeatureCall_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSimpleFeatureCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ParenthesizedExpression
protected class PrimaryExpression_ParenthesizedExpressionParserRuleCall_11 extends RuleCallToken {
	
	public PrimaryExpression_ParenthesizedExpressionParserRuleCall_11(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getParenthesizedExpressionParserRuleCall_11();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ParenthesizedExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParenthesizedExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule PrimaryExpression ****************/


/************ begin Rule ParenthesizedExpression ****************
 *
 * ParenthesizedExpression returns Expression:
 *   "(" Expression ")";
 *
 **/

// "(" Expression ")"
protected class ParenthesizedExpression_Group extends GroupToken {
	
	public ParenthesizedExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParenthesizedExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "("
protected class ParenthesizedExpression_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public ParenthesizedExpression_LeftParenthesisKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getLeftParenthesisKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// Expression
protected class ParenthesizedExpression_ExpressionParserRuleCall_1 extends RuleCallToken {
	
	public ParenthesizedExpression_ExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Expression_ClosureParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_LeftParenthesisKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParenthesizedExpression_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public ParenthesizedExpression_RightParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getRightParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_ExpressionParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ParenthesizedExpression ****************/


/************ begin Rule IfExpression ****************
 *
 * IfExpression:
 *   "if" "(" if=Expression ")" then=Expression ("else" else=Expression)?;
 *
 **/

// "if" "(" if=Expression ")" then=Expression ("else" else=Expression)?
protected class IfExpression_Group extends GroupToken {
	
	public IfExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_Group_5(parent, this, 0, inst);
			case 1: return new IfExpression_ThenAssignment_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIfExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "if"
protected class IfExpression_IfKeyword_0 extends KeywordToken  {
	
	public IfExpression_IfKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getIfKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "("
protected class IfExpression_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public IfExpression_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_IfKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// if=Expression
protected class IfExpression_IfAssignment_2 extends AssignmentToken  {
	
	public IfExpression_IfAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getIfAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("if",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("if");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpressionAccess().getIfExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpression_LeftParenthesisKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class IfExpression_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public IfExpression_RightParenthesisKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_IfAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// then=Expression
protected class IfExpression_ThenAssignment_4 extends AssignmentToken  {
	
	public IfExpression_ThenAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getThenAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("then",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("then");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpressionAccess().getThenExpressionParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpression_RightParenthesisKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("else" else=Expression)?
protected class IfExpression_Group_5 extends GroupToken {
	
	public IfExpression_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_ElseAssignment_5_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "else"
protected class IfExpression_ElseKeyword_5_0 extends KeywordToken  {
	
	public IfExpression_ElseKeyword_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getElseKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_ThenAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// else=Expression
protected class IfExpression_ElseAssignment_5_1 extends AssignmentToken  {
	
	public IfExpression_ElseAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getElseAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("else",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("else");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpressionAccess().getElseExpressionParserRuleCall_5_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpression_ElseKeyword_5_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule IfExpression ****************/


/************ begin Rule SwitchExpression ****************
 *
 * SwitchExpression:
 *   "switch" switch=Expression? "{" cases+=CasePart+ ("default" ":" default=Expression)?
 *   "}";
 *
 **/

// "switch" switch=Expression? "{" cases+=CasePart+ ("default" ":" default=Expression)?
// "}"
protected class SwitchExpression_Group extends GroupToken {
	
	public SwitchExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_RightCurlyBracketKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSwitchExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "switch"
protected class SwitchExpression_SwitchKeyword_0 extends KeywordToken  {
	
	public SwitchExpression_SwitchKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getSwitchKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// switch=Expression?
protected class SwitchExpression_SwitchAssignment_1 extends AssignmentToken  {
	
	public SwitchExpression_SwitchAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getSwitchAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("switch",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("switch");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSwitchExpressionAccess().getSwitchExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SwitchExpression_SwitchKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "{"
protected class SwitchExpression_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public SwitchExpression_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_SwitchAssignment_1(parent, this, 0, inst);
			case 1: return new SwitchExpression_SwitchKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// cases+=CasePart+
protected class SwitchExpression_CasesAssignment_3 extends AssignmentToken  {
	
	public SwitchExpression_CasesAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getCasesAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CasePart_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("cases",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("cases");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCasePartRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSwitchExpressionAccess().getCasesCasePartParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SwitchExpression_CasesAssignment_3(parent, next, actIndex, consumed);
			case 1: return new SwitchExpression_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("default" ":" default=Expression)?
protected class SwitchExpression_Group_4 extends GroupToken {
	
	public SwitchExpression_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_DefaultAssignment_4_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "default"
protected class SwitchExpression_DefaultKeyword_4_0 extends KeywordToken  {
	
	public SwitchExpression_DefaultKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getDefaultKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_CasesAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class SwitchExpression_ColonKeyword_4_1 extends KeywordToken  {
	
	public SwitchExpression_ColonKeyword_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getColonKeyword_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_DefaultKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// default=Expression
protected class SwitchExpression_DefaultAssignment_4_2 extends AssignmentToken  {
	
	public SwitchExpression_DefaultAssignment_4_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getDefaultAssignment_4_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("default",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("default");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSwitchExpressionAccess().getDefaultExpressionParserRuleCall_4_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SwitchExpression_ColonKeyword_4_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class SwitchExpression_RightCurlyBracketKeyword_5 extends KeywordToken  {
	
	public SwitchExpression_RightCurlyBracketKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getRightCurlyBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_Group_4(parent, this, 0, inst);
			case 1: return new SwitchExpression_CasesAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule SwitchExpression ****************/


/************ begin Rule WhileExpression ****************
 *
 * WhileExpression:
 *   "while" predicate=ParenthesizedExpression body=Expression;
 *
 **/

// "while" predicate=ParenthesizedExpression body=Expression
protected class WhileExpression_Group extends GroupToken {
	
	public WhileExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWhileExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WhileExpression_BodyAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWhileExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "while"
protected class WhileExpression_WhileKeyword_0 extends KeywordToken  {
	
	public WhileExpression_WhileKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWhileExpressionAccess().getWhileKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// predicate=ParenthesizedExpression
protected class WhileExpression_PredicateAssignment_1 extends AssignmentToken  {
	
	public WhileExpression_PredicateAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWhileExpressionAccess().getPredicateAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("predicate",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("predicate");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParenthesizedExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWhileExpressionAccess().getPredicateParenthesizedExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WhileExpression_WhileKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// body=Expression
protected class WhileExpression_BodyAssignment_2 extends AssignmentToken  {
	
	public WhileExpression_BodyAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWhileExpressionAccess().getBodyAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("body",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("body");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWhileExpressionAccess().getBodyExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WhileExpression_PredicateAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule WhileExpression ****************/


/************ begin Rule CasePart ****************
 *
 * CasePart:
 *   "case" case=Expression ":" then=Expression;
 *
 **/

// "case" case=Expression ":" then=Expression
protected class CasePart_Group extends GroupToken {
	
	public CasePart_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCasePartAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CasePart_ThenAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCasePartRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "case"
protected class CasePart_CaseKeyword_0 extends KeywordToken  {
	
	public CasePart_CaseKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCasePartAccess().getCaseKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// case=Expression
protected class CasePart_CaseAssignment_1 extends AssignmentToken  {
	
	public CasePart_CaseAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCasePartAccess().getCaseAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("case",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("case");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCasePartAccess().getCaseExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CasePart_CaseKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ":"
protected class CasePart_ColonKeyword_2 extends KeywordToken  {
	
	public CasePart_ColonKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCasePartAccess().getColonKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CasePart_CaseAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// then=Expression
protected class CasePart_ThenAssignment_3 extends AssignmentToken  {
	
	public CasePart_ThenAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCasePartAccess().getThenAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("then",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("then");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCasePartAccess().getThenExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CasePart_ColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule CasePart ****************/


/************ begin Rule BlockExpression ****************
 *
 * BlockExpression:
 *   "{" (expressions+=ExpressionInsideBlock ";")+ "}";
 *
 **/

// "{" (expressions+=ExpressionInsideBlock ";")+ "}"
protected class BlockExpression_Group extends GroupToken {
	
	public BlockExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_RightCurlyBracketKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "{"
protected class BlockExpression_LeftCurlyBracketKeyword_0 extends KeywordToken  {
	
	public BlockExpression_LeftCurlyBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getLeftCurlyBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// (expressions+=ExpressionInsideBlock ";")+
protected class BlockExpression_Group_1 extends GroupToken {
	
	public BlockExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_SemicolonKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expressions+=ExpressionInsideBlock
protected class BlockExpression_ExpressionsAssignment_1_0 extends AssignmentToken  {
	
	public BlockExpression_ExpressionsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getExpressionsAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExpressionInsideBlock_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionInsideBlockRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBlockExpressionAccess().getExpressionsExpressionInsideBlockParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BlockExpression_Group_1(parent, next, actIndex, consumed);
			case 1: return new BlockExpression_LeftCurlyBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BlockExpression_SemicolonKeyword_1_1 extends KeywordToken  {
	
	public BlockExpression_SemicolonKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getSemicolonKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_ExpressionsAssignment_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "}"
protected class BlockExpression_RightCurlyBracketKeyword_2 extends KeywordToken  {
	
	public BlockExpression_RightCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getRightCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule BlockExpression ****************/


/************ begin Rule ExpressionInsideBlock ****************
 *
 * ExpressionInsideBlock returns Expression:
 *   VariableDeclaration|Expression;
 *
 **/

// VariableDeclaration|Expression
protected class ExpressionInsideBlock_Alternatives extends AlternativesToken {

	public ExpressionInsideBlock_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getExpressionInsideBlockAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExpressionInsideBlock_VariableDeclarationParserRuleCall_0(parent, this, 0, inst);
			case 1: return new ExpressionInsideBlock_ExpressionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionInsideBlockRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// VariableDeclaration
protected class ExpressionInsideBlock_VariableDeclarationParserRuleCall_0 extends RuleCallToken {
	
	public ExpressionInsideBlock_VariableDeclarationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionInsideBlockAccess().getVariableDeclarationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VariableDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Expression
protected class ExpressionInsideBlock_ExpressionParserRuleCall_1 extends RuleCallToken {
	
	public ExpressionInsideBlock_ExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionInsideBlockAccess().getExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Expression_ClosureParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule ExpressionInsideBlock ****************/


/************ begin Rule VariableDeclaration ****************
 *
 * VariableDeclaration:
 *   ("def"|type=TypeRef) name=ID ":=" right=Expression;
 *
 **/

// ("def"|type=TypeRef) name=ID ":=" right=Expression
protected class VariableDeclaration_Group extends GroupToken {
	
	public VariableDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableDeclaration_RightAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "def"|type=TypeRef
protected class VariableDeclaration_Alternatives_0 extends AlternativesToken {

	public VariableDeclaration_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableDeclaration_DefKeyword_0_0(parent, this, 0, inst);
			case 1: return new VariableDeclaration_TypeAssignment_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "def"
protected class VariableDeclaration_DefKeyword_0_0 extends KeywordToken  {
	
	public VariableDeclaration_DefKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getDefKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// type=TypeRef
protected class VariableDeclaration_TypeAssignment_0_1 extends AssignmentToken  {
	
	public VariableDeclaration_TypeAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getTypeAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVariableDeclarationAccess().getTypeTypeRefParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}


// name=ID
protected class VariableDeclaration_NameAssignment_1 extends AssignmentToken  {
	
	public VariableDeclaration_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableDeclaration_Alternatives_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ":="
protected class VariableDeclaration_ColonEqualsSignKeyword_2 extends KeywordToken  {
	
	public VariableDeclaration_ColonEqualsSignKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getColonEqualsSignKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableDeclaration_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// right=Expression
protected class VariableDeclaration_RightAssignment_3 extends AssignmentToken  {
	
	public VariableDeclaration_RightAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getRightAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVariableDeclarationAccess().getRightExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VariableDeclaration_ColonEqualsSignKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule VariableDeclaration ****************/


/************ begin Rule DeclaredParameter ****************
 *
 * DeclaredParameter:
 *   type=TypeRef? name=ID;
 *
 **/

// type=TypeRef? name=ID
protected class DeclaredParameter_Group extends GroupToken {
	
	public DeclaredParameter_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaredParameterAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredParameter_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclaredParameterRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// type=TypeRef?
protected class DeclaredParameter_TypeAssignment_0 extends AssignmentToken  {
	
	public DeclaredParameter_TypeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaredParameterAccess().getTypeAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaredParameterAccess().getTypeTypeRefParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// name=ID
protected class DeclaredParameter_NameAssignment_1 extends AssignmentToken  {
	
	public DeclaredParameter_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaredParameterAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredParameter_TypeAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getDeclaredParameterAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule DeclaredParameter ****************/


/************ begin Rule SimpleFeatureCall ****************
 *
 * SimpleFeatureCall returns FeatureCall:
 *   name=ID ("(" (params+=Expression ("," params+=Expression)*)? ")")?;
 *
 **/

// name=ID ("(" (params+=Expression ("," params+=Expression)*)? ")")?
protected class SimpleFeatureCall_Group extends GroupToken {
	
	public SimpleFeatureCall_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_Group_1(parent, this, 0, inst);
			case 1: return new SimpleFeatureCall_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSimpleFeatureCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class SimpleFeatureCall_NameAssignment_0 extends AssignmentToken  {
	
	public SimpleFeatureCall_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSimpleFeatureCallAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("(" (params+=Expression ("," params+=Expression)*)? ")")?
protected class SimpleFeatureCall_Group_1 extends GroupToken {
	
	public SimpleFeatureCall_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_RightParenthesisKeyword_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class SimpleFeatureCall_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public SimpleFeatureCall_LeftParenthesisKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getLeftParenthesisKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (params+=Expression ("," params+=Expression)*)?
protected class SimpleFeatureCall_Group_1_1 extends GroupToken {
	
	public SimpleFeatureCall_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_Group_1_1_1(parent, this, 0, inst);
			case 1: return new SimpleFeatureCall_ParamsAssignment_1_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class SimpleFeatureCall_ParamsAssignment_1_1_0 extends AssignmentToken  {
	
	public SimpleFeatureCall_ParamsAssignment_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getParamsAssignment_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSimpleFeatureCallAccess().getParamsExpressionParserRuleCall_1_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SimpleFeatureCall_LeftParenthesisKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," params+=Expression)*
protected class SimpleFeatureCall_Group_1_1_1 extends GroupToken {
	
	public SimpleFeatureCall_Group_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getGroup_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_ParamsAssignment_1_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class SimpleFeatureCall_CommaKeyword_1_1_1_0 extends KeywordToken  {
	
	public SimpleFeatureCall_CommaKeyword_1_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getCommaKeyword_1_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_Group_1_1_1(parent, this, 0, inst);
			case 1: return new SimpleFeatureCall_ParamsAssignment_1_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class SimpleFeatureCall_ParamsAssignment_1_1_1_1 extends AssignmentToken  {
	
	public SimpleFeatureCall_ParamsAssignment_1_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getParamsAssignment_1_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSimpleFeatureCallAccess().getParamsExpressionParserRuleCall_1_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SimpleFeatureCall_CommaKeyword_1_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class SimpleFeatureCall_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public SimpleFeatureCall_RightParenthesisKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getRightParenthesisKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_Group_1_1(parent, this, 0, inst);
			case 1: return new SimpleFeatureCall_LeftParenthesisKeyword_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule SimpleFeatureCall ****************/


/************ begin Rule ConstructorCall ****************
 *
 * ConstructorCall:
 *   "new" type=TypeRef ("(" (params+=Expression ("," params+=Expression)*)? ")")?
 *   initializer=BlockExpression?;
 *
 **/

// "new" type=TypeRef ("(" (params+=Expression ("," params+=Expression)*)? ")")?
// initializer=BlockExpression?
protected class ConstructorCall_Group extends GroupToken {
	
	public ConstructorCall_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_InitializerAssignment_3(parent, this, 0, inst);
			case 1: return new ConstructorCall_Group_2(parent, this, 1, inst);
			case 2: return new ConstructorCall_TypeAssignment_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConstructorCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "new"
protected class ConstructorCall_NewKeyword_0 extends KeywordToken  {
	
	public ConstructorCall_NewKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getNewKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// type=TypeRef
protected class ConstructorCall_TypeAssignment_1 extends AssignmentToken  {
	
	public ConstructorCall_TypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConstructorCallAccess().getTypeTypeRefParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstructorCall_NewKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("(" (params+=Expression ("," params+=Expression)*)? ")")?
protected class ConstructorCall_Group_2 extends GroupToken {
	
	public ConstructorCall_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_RightParenthesisKeyword_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class ConstructorCall_LeftParenthesisKeyword_2_0 extends KeywordToken  {
	
	public ConstructorCall_LeftParenthesisKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getLeftParenthesisKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_TypeAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (params+=Expression ("," params+=Expression)*)?
protected class ConstructorCall_Group_2_1 extends GroupToken {
	
	public ConstructorCall_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_Group_2_1_1(parent, this, 0, inst);
			case 1: return new ConstructorCall_ParamsAssignment_2_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class ConstructorCall_ParamsAssignment_2_1_0 extends AssignmentToken  {
	
	public ConstructorCall_ParamsAssignment_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getParamsAssignment_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConstructorCallAccess().getParamsExpressionParserRuleCall_2_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstructorCall_LeftParenthesisKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," params+=Expression)*
protected class ConstructorCall_Group_2_1_1 extends GroupToken {
	
	public ConstructorCall_Group_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getGroup_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_ParamsAssignment_2_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ConstructorCall_CommaKeyword_2_1_1_0 extends KeywordToken  {
	
	public ConstructorCall_CommaKeyword_2_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getCommaKeyword_2_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_Group_2_1_1(parent, this, 0, inst);
			case 1: return new ConstructorCall_ParamsAssignment_2_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class ConstructorCall_ParamsAssignment_2_1_1_1 extends AssignmentToken  {
	
	public ConstructorCall_ParamsAssignment_2_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getParamsAssignment_2_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConstructorCallAccess().getParamsExpressionParserRuleCall_2_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstructorCall_CommaKeyword_2_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class ConstructorCall_RightParenthesisKeyword_2_2 extends KeywordToken  {
	
	public ConstructorCall_RightParenthesisKeyword_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getRightParenthesisKeyword_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_Group_2_1(parent, this, 0, inst);
			case 1: return new ConstructorCall_LeftParenthesisKeyword_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// initializer=BlockExpression?
protected class ConstructorCall_InitializerAssignment_3 extends AssignmentToken  {
	
	public ConstructorCall_InitializerAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getInitializerAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initializer",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initializer");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConstructorCallAccess().getInitializerBlockExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstructorCall_Group_2(parent, next, actIndex, consumed);
			case 1: return new ConstructorCall_TypeAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ConstructorCall ****************/


/************ begin Rule BooleanLiteral ****************
 *
 * BooleanLiteral:
 *   {BooleanLiteral} "false"|isTrue?="true";
 *
 **/

// {BooleanLiteral} "false"|isTrue?="true"
protected class BooleanLiteral_Alternatives extends AlternativesToken {

	public BooleanLiteral_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteral_Group_0(parent, this, 0, inst);
			case 1: return new BooleanLiteral_IsTrueAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {BooleanLiteral} "false"
protected class BooleanLiteral_Group_0 extends GroupToken {
	
	public BooleanLiteral_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteral_FalseKeyword_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BooleanLiteral}
protected class BooleanLiteral_BooleanLiteralAction_0_0 extends ActionToken  {

	public BooleanLiteral_BooleanLiteralAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getBooleanLiteralAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getBooleanLiteralAccess().getBooleanLiteralAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "false"
protected class BooleanLiteral_FalseKeyword_0_1 extends KeywordToken  {
	
	public BooleanLiteral_FalseKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getFalseKeyword_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteral_BooleanLiteralAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// isTrue?="true"
protected class BooleanLiteral_IsTrueAssignment_1 extends AssignmentToken  {
	
	public BooleanLiteral_IsTrueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getIsTrueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("isTrue",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("isTrue");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getBooleanLiteralAccess().getIsTrueTrueKeyword_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule BooleanLiteral ****************/


/************ begin Rule NullLiteral ****************
 *
 * NullLiteral:
 *   {NullLiteral} "null";
 *
 **/

// {NullLiteral} "null"
protected class NullLiteral_Group extends GroupToken {
	
	public NullLiteral_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNullLiteralAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteral_NullKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNullLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {NullLiteral}
protected class NullLiteral_NullLiteralAction_0 extends ActionToken  {

	public NullLiteral_NullLiteralAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getNullLiteralAccess().getNullLiteralAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getNullLiteralAccess().getNullLiteralAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "null"
protected class NullLiteral_NullKeyword_1 extends KeywordToken  {
	
	public NullLiteral_NullKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNullLiteralAccess().getNullKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteral_NullLiteralAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule NullLiteral ****************/


/************ begin Rule IntLiteral ****************
 *
 * IntLiteral:
 *   value=INT;
 *
 **/

// value=INT
protected class IntLiteral_ValueAssignment extends AssignmentToken  {
	
	public IntLiteral_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIntLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getIntLiteralAccess().getValueINTTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule IntLiteral ****************/


/************ begin Rule StringLiteral ****************
 *
 * StringLiteral:
 *   value=STRING;
 *
 **/

// value=STRING
protected class StringLiteral_ValueAssignment extends AssignmentToken  {
	
	public StringLiteral_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStringLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStringLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule StringLiteral ****************/


/************ begin Rule RichString ****************
 *
 * RichString:
 *   expressions+=RichStringLiteral (expressions+=Expression expressions+=
 *   RichStringLiteral)*;
 *
 **/

// expressions+=RichStringLiteral (expressions+=Expression expressions+=
// RichStringLiteral)*
protected class RichString_Group extends GroupToken {
	
	public RichString_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRichStringAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RichString_Group_1(parent, this, 0, inst);
			case 1: return new RichString_ExpressionsAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRichStringRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// expressions+=RichStringLiteral
protected class RichString_ExpressionsAssignment_0 extends AssignmentToken  {
	
	public RichString_ExpressionsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRichStringAccess().getExpressionsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RichStringLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRichStringLiteralRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRichStringAccess().getExpressionsRichStringLiteralParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (expressions+=Expression expressions+=RichStringLiteral)*
protected class RichString_Group_1 extends GroupToken {
	
	public RichString_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRichStringAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RichString_ExpressionsAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expressions+=Expression
protected class RichString_ExpressionsAssignment_1_0 extends AssignmentToken  {
	
	public RichString_ExpressionsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRichStringAccess().getExpressionsAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ClosureParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRichStringAccess().getExpressionsExpressionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RichString_Group_1(parent, next, actIndex, consumed);
			case 1: return new RichString_ExpressionsAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// expressions+=RichStringLiteral
protected class RichString_ExpressionsAssignment_1_1 extends AssignmentToken  {
	
	public RichString_ExpressionsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRichStringAccess().getExpressionsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RichStringLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRichStringLiteralRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRichStringAccess().getExpressionsRichStringLiteralParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RichString_ExpressionsAssignment_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule RichString ****************/


/************ begin Rule RichStringLiteral ****************
 *
 * RichStringLiteral:
 *   value=RICH_STRING;
 *
 **/

// value=RICH_STRING
protected class RichStringLiteral_ValueAssignment extends AssignmentToken  {
	
	public RichStringLiteral_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRichStringLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRichStringLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getRichStringLiteralAccess().getValueRICH_STRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule RichStringLiteral ****************/


/************ begin Rule TypeRef ****************
 *
 * TypeRef:
 *   SimpleTypeRef|FunctionTypeRef;
 *
 **/

// SimpleTypeRef|FunctionTypeRef
protected class TypeRef_Alternatives extends AlternativesToken {

	public TypeRef_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_SimpleTypeRefParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TypeRef_FunctionTypeRefParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// SimpleTypeRef
protected class TypeRef_SimpleTypeRefParserRuleCall_0 extends RuleCallToken {
	
	public TypeRef_SimpleTypeRefParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getSimpleTypeRefParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SimpleTypeRef_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSimpleTypeRefRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// FunctionTypeRef
protected class TypeRef_FunctionTypeRefParserRuleCall_1 extends RuleCallToken {
	
	public TypeRef_FunctionTypeRefParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getFunctionTypeRefParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FunctionTypeRef_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFunctionTypeRefRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule TypeRef ****************/


/************ begin Rule FunctionTypeRef ****************
 *
 * FunctionTypeRef:
 *   ("(" paramTypes+=TypeRef ("," paramTypes+=TypeRef)* ")")? "=>" returnType=TypeRef;
 *
 **/

// ("(" paramTypes+=TypeRef ("," paramTypes+=TypeRef)* ")")? "=>" returnType=TypeRef
protected class FunctionTypeRef_Group extends GroupToken {
	
	public FunctionTypeRef_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_ReturnTypeAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFunctionTypeRefRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ("(" paramTypes+=TypeRef ("," paramTypes+=TypeRef)* ")")?
protected class FunctionTypeRef_Group_0 extends GroupToken {
	
	public FunctionTypeRef_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_RightParenthesisKeyword_0_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class FunctionTypeRef_LeftParenthesisKeyword_0_0 extends KeywordToken  {
	
	public FunctionTypeRef_LeftParenthesisKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getLeftParenthesisKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// paramTypes+=TypeRef
protected class FunctionTypeRef_ParamTypesAssignment_0_1 extends AssignmentToken  {
	
	public FunctionTypeRef_ParamTypesAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getParamTypesAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("paramTypes",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("paramTypes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionTypeRefAccess().getParamTypesTypeRefParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionTypeRef_LeftParenthesisKeyword_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," paramTypes+=TypeRef)*
protected class FunctionTypeRef_Group_0_2 extends GroupToken {
	
	public FunctionTypeRef_Group_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getGroup_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_ParamTypesAssignment_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class FunctionTypeRef_CommaKeyword_0_2_0 extends KeywordToken  {
	
	public FunctionTypeRef_CommaKeyword_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getCommaKeyword_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_Group_0_2(parent, this, 0, inst);
			case 1: return new FunctionTypeRef_ParamTypesAssignment_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// paramTypes+=TypeRef
protected class FunctionTypeRef_ParamTypesAssignment_0_2_1 extends AssignmentToken  {
	
	public FunctionTypeRef_ParamTypesAssignment_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getParamTypesAssignment_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("paramTypes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("paramTypes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionTypeRefAccess().getParamTypesTypeRefParserRuleCall_0_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionTypeRef_CommaKeyword_0_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ")"
protected class FunctionTypeRef_RightParenthesisKeyword_0_3 extends KeywordToken  {
	
	public FunctionTypeRef_RightParenthesisKeyword_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getRightParenthesisKeyword_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_Group_0_2(parent, this, 0, inst);
			case 1: return new FunctionTypeRef_ParamTypesAssignment_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// "=>"
protected class FunctionTypeRef_EqualsSignGreaterThanSignKeyword_1 extends KeywordToken  {
	
	public FunctionTypeRef_EqualsSignGreaterThanSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getEqualsSignGreaterThanSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_Group_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// returnType=TypeRef
protected class FunctionTypeRef_ReturnTypeAssignment_2 extends AssignmentToken  {
	
	public FunctionTypeRef_ReturnTypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getReturnTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("returnType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("returnType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionTypeRefAccess().getReturnTypeTypeRefParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionTypeRef_EqualsSignGreaterThanSignKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule FunctionTypeRef ****************/


/************ begin Rule SimpleTypeRef ****************
 *
 * SimpleTypeRef:
 *   type=[types::Type|QualifiedName] ("<" typeParams+=TypeParam ("," typeParams+=
 *   TypeParam)* ">")?;
 *
 **/

// type=[types::Type|QualifiedName] ("<" typeParams+=TypeParam ("," typeParams+=
// TypeParam)* ">")?
protected class SimpleTypeRef_Group extends GroupToken {
	
	public SimpleTypeRef_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group_1(parent, this, 0, inst);
			case 1: return new SimpleTypeRef_TypeAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSimpleTypeRefRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// type=[types::Type|QualifiedName]
protected class SimpleTypeRef_TypeAssignment_0 extends AssignmentToken  {
	
	public SimpleTypeRef_TypeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getTypeAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleTypeRefAccess().getTypeTypeCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSimpleTypeRefAccess().getTypeTypeCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("<" typeParams+=TypeParam ("," typeParams+=TypeParam)* ">")?
protected class SimpleTypeRef_Group_1 extends GroupToken {
	
	public SimpleTypeRef_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_GreaterThanSignKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class SimpleTypeRef_LessThanSignKeyword_1_0 extends KeywordToken  {
	
	public SimpleTypeRef_LessThanSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getLessThanSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_TypeAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// typeParams+=TypeParam
protected class SimpleTypeRef_TypeParamsAssignment_1_1 extends AssignmentToken  {
	
	public SimpleTypeRef_TypeParamsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getTypeParamsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParam_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeParams",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeParams");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeParamRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSimpleTypeRefAccess().getTypeParamsTypeParamParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SimpleTypeRef_LessThanSignKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," typeParams+=TypeParam)*
protected class SimpleTypeRef_Group_1_2 extends GroupToken {
	
	public SimpleTypeRef_Group_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGroup_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_TypeParamsAssignment_1_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class SimpleTypeRef_CommaKeyword_1_2_0 extends KeywordToken  {
	
	public SimpleTypeRef_CommaKeyword_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getCommaKeyword_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group_1_2(parent, this, 0, inst);
			case 1: return new SimpleTypeRef_TypeParamsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// typeParams+=TypeParam
protected class SimpleTypeRef_TypeParamsAssignment_1_2_1 extends AssignmentToken  {
	
	public SimpleTypeRef_TypeParamsAssignment_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getTypeParamsAssignment_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParam_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeParams",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeParams");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeParamRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSimpleTypeRefAccess().getTypeParamsTypeParamParserRuleCall_1_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SimpleTypeRef_CommaKeyword_1_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ">"
protected class SimpleTypeRef_GreaterThanSignKeyword_1_3 extends KeywordToken  {
	
	public SimpleTypeRef_GreaterThanSignKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGreaterThanSignKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group_1_2(parent, this, 0, inst);
			case 1: return new SimpleTypeRef_TypeParamsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule SimpleTypeRef ****************/


/************ begin Rule TypeParam ****************
 *
 * TypeParam returns TypeRef:
 *   TypeRef|WildcardParam;
 *
 **/

// TypeRef|WildcardParam
protected class TypeParam_Alternatives extends AlternativesToken {

	public TypeParam_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeParamAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParam_TypeRefParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TypeParam_WildcardParamParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeParamRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// TypeRef
protected class TypeParam_TypeRefParserRuleCall_0 extends RuleCallToken {
	
	public TypeParam_TypeRefParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeParamAccess().getTypeRefParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TypeRef_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// WildcardParam
protected class TypeParam_WildcardParamParserRuleCall_1 extends RuleCallToken {
	
	public TypeParam_WildcardParamParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeParamAccess().getWildcardParamParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(WildcardParam_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getWildcardParamRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule TypeParam ****************/


/************ begin Rule WildcardParam ****************
 *
 * WildcardParam returns TypeRef:
 *   {WildcardParam} "?" ("extends" extends=TypeRef|"super" super=TypeRef)?;
 *
 **/

// {WildcardParam} "?" ("extends" extends=TypeRef|"super" super=TypeRef)?
protected class WildcardParam_Group extends GroupToken {
	
	public WildcardParam_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_Alternatives_2(parent, this, 0, inst);
			case 1: return new WildcardParam_QuestionMarkKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWildcardParamRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {WildcardParam}
protected class WildcardParam_WildcardParamAction_0 extends ActionToken  {

	public WildcardParam_WildcardParamAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getWildcardParamAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getWildcardParamAccess().getWildcardParamAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "?"
protected class WildcardParam_QuestionMarkKeyword_1 extends KeywordToken  {
	
	public WildcardParam_QuestionMarkKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getQuestionMarkKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_WildcardParamAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("extends" extends=TypeRef|"super" super=TypeRef)?
protected class WildcardParam_Alternatives_2 extends AlternativesToken {

	public WildcardParam_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_Group_2_0(parent, this, 0, inst);
			case 1: return new WildcardParam_Group_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends" extends=TypeRef
protected class WildcardParam_Group_2_0 extends GroupToken {
	
	public WildcardParam_Group_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getGroup_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_ExtendsAssignment_2_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class WildcardParam_ExtendsKeyword_2_0_0 extends KeywordToken  {
	
	public WildcardParam_ExtendsKeyword_2_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getExtendsKeyword_2_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_QuestionMarkKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// extends=TypeRef
protected class WildcardParam_ExtendsAssignment_2_0_1 extends AssignmentToken  {
	
	public WildcardParam_ExtendsAssignment_2_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getExtendsAssignment_2_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWildcardParamAccess().getExtendsTypeRefParserRuleCall_2_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WildcardParam_ExtendsKeyword_2_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "super" super=TypeRef
protected class WildcardParam_Group_2_1 extends GroupToken {
	
	public WildcardParam_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_SuperAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "super"
protected class WildcardParam_SuperKeyword_2_1_0 extends KeywordToken  {
	
	public WildcardParam_SuperKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getSuperKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_QuestionMarkKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// super=TypeRef
protected class WildcardParam_SuperAssignment_2_1_1 extends AssignmentToken  {
	
	public WildcardParam_SuperAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getSuperAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("super",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("super");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWildcardParamAccess().getSuperTypeRefParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WildcardParam_SuperKeyword_2_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule WildcardParam ****************/


/************ begin Rule TypeParamDeclaration ****************
 *
 * TypeParamDeclaration:
 *   name=ID ("extends" extends+=TypeRef ("&" extends+=TypeRef)*|"super" super=TypeRef)?;
 *
 **/

// name=ID ("extends" extends+=TypeRef ("&" extends+=TypeRef)*|"super" super=TypeRef)?
protected class TypeParamDeclaration_Group extends GroupToken {
	
	public TypeParamDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_Alternatives_1(parent, this, 0, inst);
			case 1: return new TypeParamDeclaration_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeParamDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class TypeParamDeclaration_NameAssignment_0 extends AssignmentToken  {
	
	public TypeParamDeclaration_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTypeParamDeclarationAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("extends" extends+=TypeRef ("&" extends+=TypeRef)*|"super" super=TypeRef)?
protected class TypeParamDeclaration_Alternatives_1 extends AlternativesToken {

	public TypeParamDeclaration_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_Group_1_0(parent, this, 0, inst);
			case 1: return new TypeParamDeclaration_Group_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends" extends+=TypeRef ("&" extends+=TypeRef)*
protected class TypeParamDeclaration_Group_1_0 extends GroupToken {
	
	public TypeParamDeclaration_Group_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getGroup_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_Group_1_0_2(parent, this, 0, inst);
			case 1: return new TypeParamDeclaration_ExtendsAssignment_1_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class TypeParamDeclaration_ExtendsKeyword_1_0_0 extends KeywordToken  {
	
	public TypeParamDeclaration_ExtendsKeyword_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getExtendsKeyword_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// extends+=TypeRef
protected class TypeParamDeclaration_ExtendsAssignment_1_0_1 extends AssignmentToken  {
	
	public TypeParamDeclaration_ExtendsAssignment_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getExtendsAssignment_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypeParamDeclarationAccess().getExtendsTypeRefParserRuleCall_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypeParamDeclaration_ExtendsKeyword_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("&" extends+=TypeRef)*
protected class TypeParamDeclaration_Group_1_0_2 extends GroupToken {
	
	public TypeParamDeclaration_Group_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getGroup_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_ExtendsAssignment_1_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "&"
protected class TypeParamDeclaration_AmpersandKeyword_1_0_2_0 extends KeywordToken  {
	
	public TypeParamDeclaration_AmpersandKeyword_1_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getAmpersandKeyword_1_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_Group_1_0_2(parent, this, 0, inst);
			case 1: return new TypeParamDeclaration_ExtendsAssignment_1_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// extends+=TypeRef
protected class TypeParamDeclaration_ExtendsAssignment_1_0_2_1 extends AssignmentToken  {
	
	public TypeParamDeclaration_ExtendsAssignment_1_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getExtendsAssignment_1_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypeParamDeclarationAccess().getExtendsTypeRefParserRuleCall_1_0_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypeParamDeclaration_AmpersandKeyword_1_0_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "super" super=TypeRef
protected class TypeParamDeclaration_Group_1_1 extends GroupToken {
	
	public TypeParamDeclaration_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_SuperAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "super"
protected class TypeParamDeclaration_SuperKeyword_1_1_0 extends KeywordToken  {
	
	public TypeParamDeclaration_SuperKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getSuperKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// super=TypeRef
protected class TypeParamDeclaration_SuperAssignment_1_1_1 extends AssignmentToken  {
	
	public TypeParamDeclaration_SuperAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getSuperAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("super",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("super");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypeParamDeclarationAccess().getSuperTypeRefParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypeParamDeclaration_SuperKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule TypeParamDeclaration ****************/


}
