/*
* generated by Xtext
*/
package org.eclipse.xtext.xbase.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.xtext.xbase.services.XpressionGrammarAccess;

import com.google.inject.Inject;

public class XpressionParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private XpressionGrammarAccess grammarAccess;
	
	@Override	
	public XpressionGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			case 1: return new Assignment_Group(this, this, 1, inst);
			case 2: return new OrExpression_Group(this, this, 2, inst);
			case 3: return new AndExpression_Group(this, this, 3, inst);
			case 4: return new EqualityExpression_Group(this, this, 4, inst);
			case 5: return new RelationalExpression_Group(this, this, 5, inst);
			case 6: return new AdditiveExpression_Group(this, this, 6, inst);
			case 7: return new MultiplicativeExpression_Group(this, this, 7, inst);
			case 8: return new OtherOperatorExpression_Group(this, this, 8, inst);
			case 9: return new UnaryOperation_Alternatives(this, this, 9, inst);
			case 10: return new FeatureCall_Group(this, this, 10, inst);
			case 11: return new PrimaryExpression_Alternatives(this, this, 11, inst);
			case 12: return new Closure_Group(this, this, 12, inst);
			case 13: return new ParenthesizedExpression_Group(this, this, 13, inst);
			case 14: return new IfExpression_Group(this, this, 14, inst);
			case 15: return new SwitchExpression_Group(this, this, 15, inst);
			case 16: return new WhileExpression_Group(this, this, 16, inst);
			case 17: return new CasePart_Group(this, this, 17, inst);
			case 18: return new BlockExpression_Group(this, this, 18, inst);
			case 19: return new ExpressionInsideBlock_Alternatives(this, this, 19, inst);
			case 20: return new VariableDeclaration_Group(this, this, 20, inst);
			case 21: return new DeclaredParameter_Group(this, this, 21, inst);
			case 22: return new SimpleFeatureCall_Group(this, this, 22, inst);
			case 23: return new ConstructorCall_Group(this, this, 23, inst);
			case 24: return new BooleanLiteral_Alternatives(this, this, 24, inst);
			case 25: return new NullLiteral_Group(this, this, 25, inst);
			case 26: return new IntLiteral_ValueAssignment(this, this, 26, inst);
			case 27: return new StringLiteral_ValueAssignment(this, this, 27, inst);
			case 28: return new TypeLiteral_Group(this, this, 28, inst);
			case 29: return new RichString_Group(this, this, 29, inst);
			case 30: return new RichStringLiteral_ValueAssignment(this, this, 30, inst);
			case 31: return new TypeRef_Alternatives(this, this, 31, inst);
			case 32: return new FunctionTypeRef_Group(this, this, 32, inst);
			case 33: return new SimpleTypeRef_Group(this, this, 33, inst);
			case 34: return new TypeParam_Alternatives(this, this, 34, inst);
			case 35: return new WildcardParam_Group(this, this, 35, inst);
			case 36: return new TypeParamDeclaration_Group(this, this, 36, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Expression ****************
 *
 * Expression:
 *   Assignment;
 *
 **/

// Assignment
protected class Expression_AssignmentParserRuleCall extends RuleCallToken {
	
	public Expression_AssignmentParserRuleCall(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getAssignmentParserRuleCall();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Assignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

/************ end Rule Expression ****************/


/************ begin Rule Assignment ****************
 *
 * Assignment returns Expression:
 *   OrExpression ({BinaryOperation.left=current} operator=( "=" | "+=" ) right=OrExpression
 *   )?;
 *
 **/

// OrExpression ({BinaryOperation.left=current} operator=( "=" | "+=" ) right=OrExpression
// )?
protected class Assignment_Group extends GroupToken {
	
	public Assignment_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_Group_1(parent, this, 0, inst);
			case 1: return new Assignment_OrExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// OrExpression
protected class Assignment_OrExpressionParserRuleCall_0 extends RuleCallToken {
	
	public Assignment_OrExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getOrExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OrExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator=( "=" | "+=" ) right=OrExpression)?
protected class Assignment_Group_1 extends GroupToken {
	
	public Assignment_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class Assignment_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public Assignment_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_OrExpressionParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAssignmentAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "=" | "+=" )
protected class Assignment_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public Assignment_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAssignmentAccess().getOperatorEqualsSignKeyword_1_1_0_0();
			return obj;
		}
		if("+=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAssignmentAccess().getOperatorPlusSignEqualsSignKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// right=OrExpression
protected class Assignment_RightAssignment_1_2 extends AssignmentToken  {
	
	public Assignment_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAssignmentAccess().getRightOrExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Assignment_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Assignment ****************/


/************ begin Rule OrExpression ****************
 *
 * OrExpression returns Expression:
 *   AndExpression ({BinaryOperation.left=current} operator="||" right=AndExpression)*;
 *
 **/

// AndExpression ({BinaryOperation.left=current} operator="||" right=AndExpression)*
protected class OrExpression_Group extends GroupToken {
	
	public OrExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group_1(parent, this, 0, inst);
			case 1: return new OrExpression_AndExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOrExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AndExpression
protected class OrExpression_AndExpressionParserRuleCall_0 extends RuleCallToken {
	
	public OrExpression_AndExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getAndExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AndExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator="||" right=AndExpression)*
protected class OrExpression_Group_1 extends GroupToken {
	
	public OrExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class OrExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public OrExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_Group_1(parent, this, 0, inst);
			case 1: return new OrExpression_AndExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOrExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator="||"
protected class OrExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public OrExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OrExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("||".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getOrExpressionAccess().getOperatorVerticalLineVerticalLineKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// right=AndExpression
protected class OrExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public OrExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOrExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OrExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OrExpression ****************/


/************ begin Rule AndExpression ****************
 *
 * AndExpression returns Expression:
 *   EqualityExpression ({BinaryOperation.left=current} operator="&&" right=
 *   EqualityExpression)*;
 *
 **/

// EqualityExpression ({BinaryOperation.left=current} operator="&&" right=
// EqualityExpression)*
protected class AndExpression_Group extends GroupToken {
	
	public AndExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group_1(parent, this, 0, inst);
			case 1: return new AndExpression_EqualityExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAndExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// EqualityExpression
protected class AndExpression_EqualityExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AndExpression_EqualityExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getEqualityExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EqualityExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEqualityExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator="&&" right=EqualityExpression)*
protected class AndExpression_Group_1 extends GroupToken {
	
	public AndExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class AndExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public AndExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_Group_1(parent, this, 0, inst);
			case 1: return new AndExpression_EqualityExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAndExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator="&&"
protected class AndExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public AndExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AndExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("&&".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAndExpressionAccess().getOperatorAmpersandAmpersandKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}

// right=EqualityExpression
protected class AndExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public AndExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAndExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEqualityExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAndExpressionAccess().getRightEqualityExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AndExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AndExpression ****************/


/************ begin Rule EqualityExpression ****************
 *
 * EqualityExpression returns Expression:
 *   RelationalExpression ({BinaryOperation.left=current} operator=( "==" | "!=" ) right=
 *   RelationalExpression)*;
 *
 **/

// RelationalExpression ({BinaryOperation.left=current} operator=( "==" | "!=" ) right=
// RelationalExpression)*
protected class EqualityExpression_Group extends GroupToken {
	
	public EqualityExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group_1(parent, this, 0, inst);
			case 1: return new EqualityExpression_RelationalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEqualityExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// RelationalExpression
protected class EqualityExpression_RelationalExpressionParserRuleCall_0 extends RuleCallToken {
	
	public EqualityExpression_RelationalExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getRelationalExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RelationalExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator=( "==" | "!=" ) right=RelationalExpression)*
protected class EqualityExpression_Group_1 extends GroupToken {
	
	public EqualityExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class EqualityExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public EqualityExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_Group_1(parent, this, 0, inst);
			case 1: return new EqualityExpression_RelationalExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getEqualityExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "==" | "!=" )
protected class EqualityExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public EqualityExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EqualityExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("==".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getEqualityExpressionAccess().getOperatorEqualsSignEqualsSignKeyword_1_1_0_0();
			return obj;
		}
		if("!=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getEqualityExpressionAccess().getOperatorExclamationMarkEqualsSignKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// right=RelationalExpression
protected class EqualityExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public EqualityExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEqualityExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEqualityExpressionAccess().getRightRelationalExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EqualityExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule EqualityExpression ****************/


/************ begin Rule RelationalExpression ****************
 *
 * RelationalExpression returns Expression:
 *   AdditiveExpression ({InstanceOfExpression.expression=current} "instanceof" type=[
 *   types::Type|QualifiedName]|{BinaryOperation.left=current} operator=( ">=" | "<=" | ">"
 *   | "<" ) right=AdditiveExpression)*;
 *
 **/

// AdditiveExpression ({InstanceOfExpression.expression=current} "instanceof" type=[
// types::Type|QualifiedName]|{BinaryOperation.left=current} operator=( ">=" | "<=" | ">"
// | "<" ) right=AdditiveExpression)*
protected class RelationalExpression_Group extends GroupToken {
	
	public RelationalExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Alternatives_1(parent, this, 0, inst);
			case 1: return new RelationalExpression_AdditiveExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AdditiveExpression
protected class RelationalExpression_AdditiveExpressionParserRuleCall_0 extends RuleCallToken {
	
	public RelationalExpression_AdditiveExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getAdditiveExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AdditiveExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({InstanceOfExpression.expression=current} "instanceof" type=[types::Type|
// QualifiedName]|{BinaryOperation.left=current} operator=( ">=" | "<=" | ">" | "<" ) right=
// AdditiveExpression)*
protected class RelationalExpression_Alternatives_1 extends AlternativesToken {

	public RelationalExpression_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Group_1_0(parent, this, 0, inst);
			case 1: return new RelationalExpression_Group_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// {InstanceOfExpression.expression=current} "instanceof" type=[types::Type|
// QualifiedName]
protected class RelationalExpression_Group_1_0 extends GroupToken {
	
	public RelationalExpression_Group_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_TypeAssignment_1_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {InstanceOfExpression.expression=current}
protected class RelationalExpression_InstanceOfExpressionExpressionAction_1_0_0 extends ActionToken  {

	public RelationalExpression_InstanceOfExpressionExpressionAction_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getInstanceOfExpressionExpressionAction_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Alternatives_1(parent, this, 0, inst);
			case 1: return new RelationalExpression_AdditiveExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionAccess().getInstanceOfExpressionExpressionAction_1_0_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("expression", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("expression")) return null;
		return getDescr((EObject) val);
	}
}

// "instanceof"
protected class RelationalExpression_InstanceofKeyword_1_0_1 extends KeywordToken  {
	
	public RelationalExpression_InstanceofKeyword_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getInstanceofKeyword_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_InstanceOfExpressionExpressionAction_1_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=[types::Type|QualifiedName]
protected class RelationalExpression_TypeAssignment_1_0_2 extends AssignmentToken  {
	
	public RelationalExpression_TypeAssignment_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getTypeAssignment_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_InstanceofKeyword_1_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRelationalExpressionAccess().getTypeTypeCrossReference_1_0_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getRelationalExpressionAccess().getTypeTypeCrossReference_1_0_2_0(); 
				return obj;
			}
		}
		return null;
	}

}


// {BinaryOperation.left=current} operator=( ">=" | "<=" | ">" | "<" ) right=
// AdditiveExpression
protected class RelationalExpression_Group_1_1 extends GroupToken {
	
	public RelationalExpression_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_RightAssignment_1_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class RelationalExpression_BinaryOperationLeftAction_1_1_0 extends ActionToken  {

	public RelationalExpression_BinaryOperationLeftAction_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getBinaryOperationLeftAction_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_Alternatives_1(parent, this, 0, inst);
			case 1: return new RelationalExpression_AdditiveExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getRelationalExpressionAccess().getBinaryOperationLeftAction_1_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( ">=" | "<=" | ">" | "<" )
protected class RelationalExpression_OperatorAssignment_1_1_1 extends AssignmentToken  {
	
	public RelationalExpression_OperatorAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getOperatorAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RelationalExpression_BinaryOperationLeftAction_1_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if(">=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalExpressionAccess().getOperatorGreaterThanSignEqualsSignKeyword_1_1_1_0_0();
			return obj;
		}
		if("<=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalExpressionAccess().getOperatorLessThanSignEqualsSignKeyword_1_1_1_0_1();
			return obj;
		}
		if(">".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalExpressionAccess().getOperatorGreaterThanSignKeyword_1_1_1_0_2();
			return obj;
		}
		if("<".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRelationalExpressionAccess().getOperatorLessThanSignKeyword_1_1_1_0_3();
			return obj;
		}
		return null;
	}

}

// right=AdditiveExpression
protected class RelationalExpression_RightAssignment_1_1_2 extends AssignmentToken  {
	
	public RelationalExpression_RightAssignment_1_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRelationalExpressionAccess().getRightAssignment_1_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRelationalExpressionAccess().getRightAdditiveExpressionParserRuleCall_1_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RelationalExpression_OperatorAssignment_1_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule RelationalExpression ****************/


/************ begin Rule AdditiveExpression ****************
 *
 * AdditiveExpression returns Expression:
 *   MultiplicativeExpression ({BinaryOperation.left=current} operator=( "+" | "-" ) right=
 *   MultiplicativeExpression)*;
 *
 **/

// MultiplicativeExpression ({BinaryOperation.left=current} operator=( "+" | "-" ) right=
// MultiplicativeExpression)*
protected class AdditiveExpression_Group extends GroupToken {
	
	public AdditiveExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveExpression_MultiplicativeExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// MultiplicativeExpression
protected class AdditiveExpression_MultiplicativeExpressionParserRuleCall_0 extends RuleCallToken {
	
	public AdditiveExpression_MultiplicativeExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getMultiplicativeExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(MultiplicativeExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator=( "+" | "-" ) right=MultiplicativeExpression)
// *
protected class AdditiveExpression_Group_1 extends GroupToken {
	
	public AdditiveExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class AdditiveExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public AdditiveExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_Group_1(parent, this, 0, inst);
			case 1: return new AdditiveExpression_MultiplicativeExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAdditiveExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "+" | "-" )
protected class AdditiveExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public AdditiveExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AdditiveExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("+".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAdditiveExpressionAccess().getOperatorPlusSignKeyword_1_1_0_0();
			return obj;
		}
		if("-".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAdditiveExpressionAccess().getOperatorHyphenMinusKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// right=MultiplicativeExpression
protected class AdditiveExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public AdditiveExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditiveExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditiveExpressionAccess().getRightMultiplicativeExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AdditiveExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule AdditiveExpression ****************/


/************ begin Rule MultiplicativeExpression ****************
 *
 * MultiplicativeExpression returns Expression:
 *   OtherOperatorExpression ({BinaryOperation.left=current} operator=( "*" | "/" | "%" )
 *   right=OtherOperatorExpression)*;
 *
 **/

// OtherOperatorExpression ({BinaryOperation.left=current} operator=( "*" | "/" | "%" )
// right=OtherOperatorExpression)*
protected class MultiplicativeExpression_Group extends GroupToken {
	
	public MultiplicativeExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group_1(parent, this, 0, inst);
			case 1: return new MultiplicativeExpression_OtherOperatorExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// OtherOperatorExpression
protected class MultiplicativeExpression_OtherOperatorExpressionParserRuleCall_0 extends RuleCallToken {
	
	public MultiplicativeExpression_OtherOperatorExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getOtherOperatorExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(OtherOperatorExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOtherOperatorExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator=( "*" | "/" | "%" ) right=
// OtherOperatorExpression)*
protected class MultiplicativeExpression_Group_1 extends GroupToken {
	
	public MultiplicativeExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class MultiplicativeExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public MultiplicativeExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_Group_1(parent, this, 0, inst);
			case 1: return new MultiplicativeExpression_OtherOperatorExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getMultiplicativeExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "*" | "/" | "%" )
protected class MultiplicativeExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public MultiplicativeExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new MultiplicativeExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("*".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicativeExpressionAccess().getOperatorAsteriskKeyword_1_1_0_0();
			return obj;
		}
		if("/".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicativeExpressionAccess().getOperatorSolidusKeyword_1_1_0_1();
			return obj;
		}
		if("%".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicativeExpressionAccess().getOperatorPercentSignKeyword_1_1_0_2();
			return obj;
		}
		return null;
	}

}

// right=OtherOperatorExpression
protected class MultiplicativeExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public MultiplicativeExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicativeExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOtherOperatorExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMultiplicativeExpressionAccess().getRightOtherOperatorExpressionParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new MultiplicativeExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule MultiplicativeExpression ****************/


/************ begin Rule OtherOperatorExpression ****************
 *
 * OtherOperatorExpression returns Expression:
 *   UnaryOperation ({BinaryOperation.left=current} operator=( "+=" | ".." ) right=
 *   UnaryOperation)*;
 *
 **/

// UnaryOperation ({BinaryOperation.left=current} operator=( "+=" | ".." ) right=
// UnaryOperation)*
protected class OtherOperatorExpression_Group extends GroupToken {
	
	public OtherOperatorExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_Group_1(parent, this, 0, inst);
			case 1: return new OtherOperatorExpression_UnaryOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOtherOperatorExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// UnaryOperation
protected class OtherOperatorExpression_UnaryOperationParserRuleCall_0 extends RuleCallToken {
	
	public OtherOperatorExpression_UnaryOperationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getUnaryOperationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UnaryOperation_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUnaryOperationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({BinaryOperation.left=current} operator=( "+=" | ".." ) right=UnaryOperation)*
protected class OtherOperatorExpression_Group_1 extends GroupToken {
	
	public OtherOperatorExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BinaryOperation.left=current}
protected class OtherOperatorExpression_BinaryOperationLeftAction_1_0 extends ActionToken  {

	public OtherOperatorExpression_BinaryOperationLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getBinaryOperationLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_Group_1(parent, this, 0, inst);
			case 1: return new OtherOperatorExpression_UnaryOperationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOtherOperatorExpressionAccess().getBinaryOperationLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "+=" | ".." )
protected class OtherOperatorExpression_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public OtherOperatorExpression_OperatorAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getOperatorAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OtherOperatorExpression_BinaryOperationLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("+=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getOtherOperatorExpressionAccess().getOperatorPlusSignEqualsSignKeyword_1_1_0_0();
			return obj;
		}
		if("..".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getOtherOperatorExpressionAccess().getOperatorFullStopFullStopKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// right=UnaryOperation
protected class OtherOperatorExpression_RightAssignment_1_2 extends AssignmentToken  {
	
	public OtherOperatorExpression_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOtherOperatorExpressionAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getUnaryOperationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getOtherOperatorExpressionAccess().getRightUnaryOperationParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new OtherOperatorExpression_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule OtherOperatorExpression ****************/


/************ begin Rule UnaryOperation ****************
 *
 * UnaryOperation returns Expression:
 *   {UnaryOperation} operator=( "!" | "-" | "+" ) target=FeatureCall|{CastedExpression} "("
 *   type=TypeRef ")" target=Expression|FeatureCall;
 *
 **/

// {UnaryOperation} operator=( "!" | "-" | "+" ) target=FeatureCall|{CastedExpression} "("
// type=TypeRef ")" target=Expression|FeatureCall
protected class UnaryOperation_Alternatives extends AlternativesToken {

	public UnaryOperation_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_Group_0(parent, this, 0, inst);
			case 1: return new UnaryOperation_Group_1(parent, this, 1, inst);
			case 2: return new UnaryOperation_FeatureCallParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUnaryOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {UnaryOperation} operator=( "!" | "-" | "+" ) target=FeatureCall
protected class UnaryOperation_Group_0 extends GroupToken {
	
	public UnaryOperation_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_TargetAssignment_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {UnaryOperation}
protected class UnaryOperation_UnaryOperationAction_0_0 extends ActionToken  {

	public UnaryOperation_UnaryOperationAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getUnaryOperationAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getUnaryOperationAccess().getUnaryOperationAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// operator=( "!" | "-" | "+" )
protected class UnaryOperation_OperatorAssignment_0_1 extends AssignmentToken  {
	
	public UnaryOperation_OperatorAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getOperatorAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_UnaryOperationAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("!".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUnaryOperationAccess().getOperatorExclamationMarkKeyword_0_1_0_0();
			return obj;
		}
		if("-".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUnaryOperationAccess().getOperatorHyphenMinusKeyword_0_1_0_1();
			return obj;
		}
		if("+".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getUnaryOperationAccess().getOperatorPlusSignKeyword_0_1_0_2();
			return obj;
		}
		return null;
	}

}

// target=FeatureCall
protected class UnaryOperation_TargetAssignment_0_2 extends AssignmentToken  {
	
	public UnaryOperation_TargetAssignment_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getTargetAssignment_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFeatureCallRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnaryOperationAccess().getTargetFeatureCallParserRuleCall_0_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryOperation_OperatorAssignment_0_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// {CastedExpression} "(" type=TypeRef ")" target=Expression
protected class UnaryOperation_Group_1 extends GroupToken {
	
	public UnaryOperation_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_TargetAssignment_1_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {CastedExpression}
protected class UnaryOperation_CastedExpressionAction_1_0 extends ActionToken  {

	public UnaryOperation_CastedExpressionAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getCastedExpressionAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getUnaryOperationAccess().getCastedExpressionAction_1_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "("
protected class UnaryOperation_LeftParenthesisKeyword_1_1 extends KeywordToken  {
	
	public UnaryOperation_LeftParenthesisKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getLeftParenthesisKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_CastedExpressionAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=TypeRef
protected class UnaryOperation_TypeAssignment_1_2 extends AssignmentToken  {
	
	public UnaryOperation_TypeAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getTypeAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnaryOperationAccess().getTypeTypeRefParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryOperation_LeftParenthesisKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class UnaryOperation_RightParenthesisKeyword_1_3 extends KeywordToken  {
	
	public UnaryOperation_RightParenthesisKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getRightParenthesisKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UnaryOperation_TypeAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// target=Expression
protected class UnaryOperation_TargetAssignment_1_4 extends AssignmentToken  {
	
	public UnaryOperation_TargetAssignment_1_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getTargetAssignment_1_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("target",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("target");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUnaryOperationAccess().getTargetExpressionParserRuleCall_1_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UnaryOperation_RightParenthesisKeyword_1_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// FeatureCall
protected class UnaryOperation_FeatureCallParserRuleCall_2 extends RuleCallToken {
	
	public UnaryOperation_FeatureCallParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getUnaryOperationAccess().getFeatureCallParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FeatureCall_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFeatureCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule UnaryOperation ****************/


/************ begin Rule FeatureCall ****************
 *
 * FeatureCall returns Expression:
 *   PrimaryExpression ({FeatureCall.target=current} "." name=ID ("(" (params+=Expression (
 *   "," params+=Expression)*)? ")")?)*;
 *
 **/

// PrimaryExpression ({FeatureCall.target=current} "." name=ID ("(" (params+=Expression (
// "," params+=Expression)*)? ")")?)*
protected class FeatureCall_Group extends GroupToken {
	
	public FeatureCall_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1(parent, this, 0, inst);
			case 1: return new FeatureCall_PrimaryExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFeatureCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// PrimaryExpression
protected class FeatureCall_PrimaryExpressionParserRuleCall_0 extends RuleCallToken {
	
	public FeatureCall_PrimaryExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getPrimaryExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(PrimaryExpression_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({FeatureCall.target=current} "." name=ID ("(" (params+=Expression ("," params+=
// Expression)*)? ")")?)*
protected class FeatureCall_Group_1 extends GroupToken {
	
	public FeatureCall_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1_3(parent, this, 0, inst);
			case 1: return new FeatureCall_NameAssignment_1_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// {FeatureCall.target=current}
protected class FeatureCall_FeatureCallTargetAction_1_0 extends ActionToken  {

	public FeatureCall_FeatureCallTargetAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getFeatureCallTargetAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1(parent, this, 0, inst);
			case 1: return new FeatureCall_PrimaryExpressionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getFeatureCallAccess().getFeatureCallTargetAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("target", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("target")) return null;
		return getDescr((EObject) val);
	}
}

// "."
protected class FeatureCall_FullStopKeyword_1_1 extends KeywordToken  {
	
	public FeatureCall_FullStopKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getFullStopKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_FeatureCallTargetAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=ID
protected class FeatureCall_NameAssignment_1_2 extends AssignmentToken  {
	
	public FeatureCall_NameAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getNameAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_FullStopKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getFeatureCallAccess().getNameIDTerminalRuleCall_1_2_0();
			return obj;
		}
		return null;
	}

}

// ("(" (params+=Expression ("," params+=Expression)*)? ")")?
protected class FeatureCall_Group_1_3 extends GroupToken {
	
	public FeatureCall_Group_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getGroup_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_RightParenthesisKeyword_1_3_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class FeatureCall_LeftParenthesisKeyword_1_3_0 extends KeywordToken  {
	
	public FeatureCall_LeftParenthesisKeyword_1_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getLeftParenthesisKeyword_1_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_NameAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (params+=Expression ("," params+=Expression)*)?
protected class FeatureCall_Group_1_3_1 extends GroupToken {
	
	public FeatureCall_Group_1_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getGroup_1_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1_3_1_1(parent, this, 0, inst);
			case 1: return new FeatureCall_ParamsAssignment_1_3_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class FeatureCall_ParamsAssignment_1_3_1_0 extends AssignmentToken  {
	
	public FeatureCall_ParamsAssignment_1_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getParamsAssignment_1_3_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFeatureCallAccess().getParamsExpressionParserRuleCall_1_3_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FeatureCall_LeftParenthesisKeyword_1_3_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," params+=Expression)*
protected class FeatureCall_Group_1_3_1_1 extends GroupToken {
	
	public FeatureCall_Group_1_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getGroup_1_3_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_ParamsAssignment_1_3_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class FeatureCall_CommaKeyword_1_3_1_1_0 extends KeywordToken  {
	
	public FeatureCall_CommaKeyword_1_3_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getCommaKeyword_1_3_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1_3_1_1(parent, this, 0, inst);
			case 1: return new FeatureCall_ParamsAssignment_1_3_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class FeatureCall_ParamsAssignment_1_3_1_1_1 extends AssignmentToken  {
	
	public FeatureCall_ParamsAssignment_1_3_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getParamsAssignment_1_3_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFeatureCallAccess().getParamsExpressionParserRuleCall_1_3_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FeatureCall_CommaKeyword_1_3_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class FeatureCall_RightParenthesisKeyword_1_3_2 extends KeywordToken  {
	
	public FeatureCall_RightParenthesisKeyword_1_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFeatureCallAccess().getRightParenthesisKeyword_1_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FeatureCall_Group_1_3_1(parent, this, 0, inst);
			case 1: return new FeatureCall_LeftParenthesisKeyword_1_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}




/************ end Rule FeatureCall ****************/


/************ begin Rule PrimaryExpression ****************
 *
 * PrimaryExpression returns Expression:
 *   Closure|BooleanLiteral|IntLiteral|NullLiteral|StringLiteral|TypeLiteral|
 *   ConstructorCall|BlockExpression|RichString|IfExpression|SwitchExpression|
 *   WhileExpression|SimpleFeatureCall|ParenthesizedExpression;
 *
 **/

// Closure|BooleanLiteral|IntLiteral|NullLiteral|StringLiteral|TypeLiteral|
// ConstructorCall|BlockExpression|RichString|IfExpression|SwitchExpression|
// WhileExpression|SimpleFeatureCall|ParenthesizedExpression
protected class PrimaryExpression_Alternatives extends AlternativesToken {

	public PrimaryExpression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new PrimaryExpression_ClosureParserRuleCall_0(parent, this, 0, inst);
			case 1: return new PrimaryExpression_BooleanLiteralParserRuleCall_1(parent, this, 1, inst);
			case 2: return new PrimaryExpression_IntLiteralParserRuleCall_2(parent, this, 2, inst);
			case 3: return new PrimaryExpression_NullLiteralParserRuleCall_3(parent, this, 3, inst);
			case 4: return new PrimaryExpression_StringLiteralParserRuleCall_4(parent, this, 4, inst);
			case 5: return new PrimaryExpression_TypeLiteralParserRuleCall_5(parent, this, 5, inst);
			case 6: return new PrimaryExpression_ConstructorCallParserRuleCall_6(parent, this, 6, inst);
			case 7: return new PrimaryExpression_BlockExpressionParserRuleCall_7(parent, this, 7, inst);
			case 8: return new PrimaryExpression_RichStringParserRuleCall_8(parent, this, 8, inst);
			case 9: return new PrimaryExpression_IfExpressionParserRuleCall_9(parent, this, 9, inst);
			case 10: return new PrimaryExpression_SwitchExpressionParserRuleCall_10(parent, this, 10, inst);
			case 11: return new PrimaryExpression_WhileExpressionParserRuleCall_11(parent, this, 11, inst);
			case 12: return new PrimaryExpression_SimpleFeatureCallParserRuleCall_12(parent, this, 12, inst);
			case 13: return new PrimaryExpression_ParenthesizedExpressionParserRuleCall_13(parent, this, 13, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPrimaryExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Closure
protected class PrimaryExpression_ClosureParserRuleCall_0 extends RuleCallToken {
	
	public PrimaryExpression_ClosureParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getClosureParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Closure_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getClosureRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BooleanLiteral
protected class PrimaryExpression_BooleanLiteralParserRuleCall_1 extends RuleCallToken {
	
	public PrimaryExpression_BooleanLiteralParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getBooleanLiteralParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteral_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BooleanLiteral_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// IntLiteral
protected class PrimaryExpression_IntLiteralParserRuleCall_2 extends RuleCallToken {
	
	public PrimaryExpression_IntLiteralParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getIntLiteralParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntLiteral_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIntLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// NullLiteral
protected class PrimaryExpression_NullLiteralParserRuleCall_3 extends RuleCallToken {
	
	public PrimaryExpression_NullLiteralParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getNullLiteralParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteral_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NullLiteral_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNullLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// StringLiteral
protected class PrimaryExpression_StringLiteralParserRuleCall_4 extends RuleCallToken {
	
	public PrimaryExpression_StringLiteralParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getStringLiteralParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new StringLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(StringLiteral_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getStringLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// TypeLiteral
protected class PrimaryExpression_TypeLiteralParserRuleCall_5 extends RuleCallToken {
	
	public PrimaryExpression_TypeLiteralParserRuleCall_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getTypeLiteralParserRuleCall_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeLiteral_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TypeLiteral_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypeLiteralRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ConstructorCall
protected class PrimaryExpression_ConstructorCallParserRuleCall_6 extends RuleCallToken {
	
	public PrimaryExpression_ConstructorCallParserRuleCall_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getConstructorCallParserRuleCall_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ConstructorCall_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getConstructorCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// BlockExpression
protected class PrimaryExpression_BlockExpressionParserRuleCall_7 extends RuleCallToken {
	
	public PrimaryExpression_BlockExpressionParserRuleCall_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getBlockExpressionParserRuleCall_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(BlockExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// RichString
protected class PrimaryExpression_RichStringParserRuleCall_8 extends RuleCallToken {
	
	public PrimaryExpression_RichStringParserRuleCall_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getRichStringParserRuleCall_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RichString_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RichString_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRichStringRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// IfExpression
protected class PrimaryExpression_IfExpressionParserRuleCall_9 extends RuleCallToken {
	
	public PrimaryExpression_IfExpressionParserRuleCall_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getIfExpressionParserRuleCall_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IfExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getIfExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// SwitchExpression
protected class PrimaryExpression_SwitchExpressionParserRuleCall_10 extends RuleCallToken {
	
	public PrimaryExpression_SwitchExpressionParserRuleCall_10(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getSwitchExpressionParserRuleCall_10();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SwitchExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSwitchExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// WhileExpression
protected class PrimaryExpression_WhileExpressionParserRuleCall_11 extends RuleCallToken {
	
	public PrimaryExpression_WhileExpressionParserRuleCall_11(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getWhileExpressionParserRuleCall_11();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WhileExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(WhileExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getWhileExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// SimpleFeatureCall
protected class PrimaryExpression_SimpleFeatureCallParserRuleCall_12 extends RuleCallToken {
	
	public PrimaryExpression_SimpleFeatureCallParserRuleCall_12(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getSimpleFeatureCallParserRuleCall_12();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SimpleFeatureCall_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSimpleFeatureCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ParenthesizedExpression
protected class PrimaryExpression_ParenthesizedExpressionParserRuleCall_13 extends RuleCallToken {
	
	public PrimaryExpression_ParenthesizedExpressionParserRuleCall_13(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPrimaryExpressionAccess().getParenthesizedExpressionParserRuleCall_13();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ParenthesizedExpression_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParenthesizedExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule PrimaryExpression ****************/


/************ begin Rule Closure ****************
 *
 * Closure returns Expression:
 *   {Closure} (params+=DeclaredParameter ("," params+=DeclaredParameter)*)? "|"
 *   expression=Expression;
 *
 **/

// {Closure} (params+=DeclaredParameter ("," params+=DeclaredParameter)*)? "|"
// expression=Expression
protected class Closure_Group extends GroupToken {
	
	public Closure_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_ExpressionAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getClosureRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Closure}
protected class Closure_ClosureAction_0 extends ActionToken  {

	public Closure_ClosureAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getClosureAccess().getClosureAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getClosureAccess().getClosureAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// (params+=DeclaredParameter ("," params+=DeclaredParameter)*)?
protected class Closure_Group_1 extends GroupToken {
	
	public Closure_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_Group_1_1(parent, this, 0, inst);
			case 1: return new Closure_ParamsAssignment_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=DeclaredParameter
protected class Closure_ParamsAssignment_1_0 extends AssignmentToken  {
	
	public Closure_ParamsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureAccess().getParamsAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredParameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaredParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureAccess().getParamsDeclaredParameterParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Closure_ClosureAction_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," params+=DeclaredParameter)*
protected class Closure_Group_1_1 extends GroupToken {
	
	public Closure_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClosureAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_ParamsAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Closure_CommaKeyword_1_1_0 extends KeywordToken  {
	
	public Closure_CommaKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureAccess().getCommaKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_Group_1_1(parent, this, 0, inst);
			case 1: return new Closure_ParamsAssignment_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=DeclaredParameter
protected class Closure_ParamsAssignment_1_1_1 extends AssignmentToken  {
	
	public Closure_ParamsAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureAccess().getParamsAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredParameter_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getDeclaredParameterRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureAccess().getParamsDeclaredParameterParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Closure_CommaKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "|"
protected class Closure_VerticalLineKeyword_2 extends KeywordToken  {
	
	public Closure_VerticalLineKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClosureAccess().getVerticalLineKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Closure_Group_1(parent, this, 0, inst);
			case 1: return new Closure_ClosureAction_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// expression=Expression
protected class Closure_ExpressionAssignment_3 extends AssignmentToken  {
	
	public Closure_ExpressionAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClosureAccess().getExpressionAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClosureAccess().getExpressionExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Closure_VerticalLineKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Closure ****************/


/************ begin Rule ParenthesizedExpression ****************
 *
 * ParenthesizedExpression returns Expression:
 *   "(" Expression ")";
 *
 **/

// "(" Expression ")"
protected class ParenthesizedExpression_Group extends GroupToken {
	
	public ParenthesizedExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParenthesizedExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "("
protected class ParenthesizedExpression_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public ParenthesizedExpression_LeftParenthesisKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getLeftParenthesisKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// Expression
protected class ParenthesizedExpression_ExpressionParserRuleCall_1 extends RuleCallToken {
	
	public ParenthesizedExpression_ExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Expression_AssignmentParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_LeftParenthesisKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParenthesizedExpression_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public ParenthesizedExpression_RightParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedExpressionAccess().getRightParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_ExpressionParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ParenthesizedExpression ****************/


/************ begin Rule IfExpression ****************
 *
 * IfExpression:
 *   "if" "(" if=Expression ")" then=Expression ("else" else=Expression)?;
 *
 **/

// "if" "(" if=Expression ")" then=Expression ("else" else=Expression)?
protected class IfExpression_Group extends GroupToken {
	
	public IfExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_Group_5(parent, this, 0, inst);
			case 1: return new IfExpression_ThenAssignment_4(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIfExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "if"
protected class IfExpression_IfKeyword_0 extends KeywordToken  {
	
	public IfExpression_IfKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getIfKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "("
protected class IfExpression_LeftParenthesisKeyword_1 extends KeywordToken  {
	
	public IfExpression_LeftParenthesisKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getLeftParenthesisKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_IfKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// if=Expression
protected class IfExpression_IfAssignment_2 extends AssignmentToken  {
	
	public IfExpression_IfAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getIfAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("if",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("if");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpressionAccess().getIfExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpression_LeftParenthesisKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class IfExpression_RightParenthesisKeyword_3 extends KeywordToken  {
	
	public IfExpression_RightParenthesisKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getRightParenthesisKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_IfAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// then=Expression
protected class IfExpression_ThenAssignment_4 extends AssignmentToken  {
	
	public IfExpression_ThenAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getThenAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("then",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("then");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpressionAccess().getThenExpressionParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpression_RightParenthesisKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("else" else=Expression)?
protected class IfExpression_Group_5 extends GroupToken {
	
	public IfExpression_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_ElseAssignment_5_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "else"
protected class IfExpression_ElseKeyword_5_0 extends KeywordToken  {
	
	public IfExpression_ElseKeyword_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getElseKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IfExpression_ThenAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// else=Expression
protected class IfExpression_ElseAssignment_5_1 extends AssignmentToken  {
	
	public IfExpression_ElseAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIfExpressionAccess().getElseAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("else",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("else");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getIfExpressionAccess().getElseExpressionParserRuleCall_5_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new IfExpression_ElseKeyword_5_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule IfExpression ****************/


/************ begin Rule SwitchExpression ****************
 *
 * SwitchExpression:
 *   "switch" switch=Expression? "{" cases+=CasePart+ ("default" ":" default=Expression)?
 *   "}";
 *
 **/

// "switch" switch=Expression? "{" cases+=CasePart+ ("default" ":" default=Expression)?
// "}"
protected class SwitchExpression_Group extends GroupToken {
	
	public SwitchExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_RightCurlyBracketKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSwitchExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "switch"
protected class SwitchExpression_SwitchKeyword_0 extends KeywordToken  {
	
	public SwitchExpression_SwitchKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getSwitchKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// switch=Expression?
protected class SwitchExpression_SwitchAssignment_1 extends AssignmentToken  {
	
	public SwitchExpression_SwitchAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getSwitchAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("switch",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("switch");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSwitchExpressionAccess().getSwitchExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SwitchExpression_SwitchKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "{"
protected class SwitchExpression_LeftCurlyBracketKeyword_2 extends KeywordToken  {
	
	public SwitchExpression_LeftCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getLeftCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_SwitchAssignment_1(parent, this, 0, inst);
			case 1: return new SwitchExpression_SwitchKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// cases+=CasePart+
protected class SwitchExpression_CasesAssignment_3 extends AssignmentToken  {
	
	public SwitchExpression_CasesAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getCasesAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CasePart_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("cases",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("cases");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCasePartRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSwitchExpressionAccess().getCasesCasePartParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SwitchExpression_CasesAssignment_3(parent, next, actIndex, consumed);
			case 1: return new SwitchExpression_LeftCurlyBracketKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("default" ":" default=Expression)?
protected class SwitchExpression_Group_4 extends GroupToken {
	
	public SwitchExpression_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_DefaultAssignment_4_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "default"
protected class SwitchExpression_DefaultKeyword_4_0 extends KeywordToken  {
	
	public SwitchExpression_DefaultKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getDefaultKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_CasesAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ":"
protected class SwitchExpression_ColonKeyword_4_1 extends KeywordToken  {
	
	public SwitchExpression_ColonKeyword_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getColonKeyword_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_DefaultKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// default=Expression
protected class SwitchExpression_DefaultAssignment_4_2 extends AssignmentToken  {
	
	public SwitchExpression_DefaultAssignment_4_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getDefaultAssignment_4_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("default",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("default");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSwitchExpressionAccess().getDefaultExpressionParserRuleCall_4_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SwitchExpression_ColonKeyword_4_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class SwitchExpression_RightCurlyBracketKeyword_5 extends KeywordToken  {
	
	public SwitchExpression_RightCurlyBracketKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSwitchExpressionAccess().getRightCurlyBracketKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SwitchExpression_Group_4(parent, this, 0, inst);
			case 1: return new SwitchExpression_CasesAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule SwitchExpression ****************/


/************ begin Rule WhileExpression ****************
 *
 * WhileExpression:
 *   "while" predicate=ParenthesizedExpression body=Expression;
 *
 **/

// "while" predicate=ParenthesizedExpression body=Expression
protected class WhileExpression_Group extends GroupToken {
	
	public WhileExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWhileExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WhileExpression_BodyAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWhileExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "while"
protected class WhileExpression_WhileKeyword_0 extends KeywordToken  {
	
	public WhileExpression_WhileKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWhileExpressionAccess().getWhileKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// predicate=ParenthesizedExpression
protected class WhileExpression_PredicateAssignment_1 extends AssignmentToken  {
	
	public WhileExpression_PredicateAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWhileExpressionAccess().getPredicateAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("predicate",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("predicate");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParenthesizedExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWhileExpressionAccess().getPredicateParenthesizedExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WhileExpression_WhileKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// body=Expression
protected class WhileExpression_BodyAssignment_2 extends AssignmentToken  {
	
	public WhileExpression_BodyAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWhileExpressionAccess().getBodyAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("body",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("body");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWhileExpressionAccess().getBodyExpressionParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WhileExpression_PredicateAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule WhileExpression ****************/


/************ begin Rule CasePart ****************
 *
 * CasePart:
 *   "case" case=Expression ":" then=Expression;
 *
 **/

// "case" case=Expression ":" then=Expression
protected class CasePart_Group extends GroupToken {
	
	public CasePart_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCasePartAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CasePart_ThenAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCasePartRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "case"
protected class CasePart_CaseKeyword_0 extends KeywordToken  {
	
	public CasePart_CaseKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCasePartAccess().getCaseKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// case=Expression
protected class CasePart_CaseAssignment_1 extends AssignmentToken  {
	
	public CasePart_CaseAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCasePartAccess().getCaseAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("case",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("case");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCasePartAccess().getCaseExpressionParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CasePart_CaseKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ":"
protected class CasePart_ColonKeyword_2 extends KeywordToken  {
	
	public CasePart_ColonKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCasePartAccess().getColonKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CasePart_CaseAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// then=Expression
protected class CasePart_ThenAssignment_3 extends AssignmentToken  {
	
	public CasePart_ThenAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCasePartAccess().getThenAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("then",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("then");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCasePartAccess().getThenExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CasePart_ColonKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule CasePart ****************/


/************ begin Rule BlockExpression ****************
 *
 * BlockExpression:
 *   "{" (expressions+=ExpressionInsideBlock ";")+ "}";
 *
 **/

// "{" (expressions+=ExpressionInsideBlock ";")+ "}"
protected class BlockExpression_Group extends GroupToken {
	
	public BlockExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_RightCurlyBracketKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "{"
protected class BlockExpression_LeftCurlyBracketKeyword_0 extends KeywordToken  {
	
	public BlockExpression_LeftCurlyBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getLeftCurlyBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// (expressions+=ExpressionInsideBlock ";")+
protected class BlockExpression_Group_1 extends GroupToken {
	
	public BlockExpression_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_SemicolonKeyword_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expressions+=ExpressionInsideBlock
protected class BlockExpression_ExpressionsAssignment_1_0 extends AssignmentToken  {
	
	public BlockExpression_ExpressionsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getExpressionsAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExpressionInsideBlock_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionInsideBlockRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getBlockExpressionAccess().getExpressionsExpressionInsideBlockParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new BlockExpression_Group_1(parent, next, actIndex, consumed);
			case 1: return new BlockExpression_LeftCurlyBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class BlockExpression_SemicolonKeyword_1_1 extends KeywordToken  {
	
	public BlockExpression_SemicolonKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getSemicolonKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_ExpressionsAssignment_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "}"
protected class BlockExpression_RightCurlyBracketKeyword_2 extends KeywordToken  {
	
	public BlockExpression_RightCurlyBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBlockExpressionAccess().getRightCurlyBracketKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule BlockExpression ****************/


/************ begin Rule ExpressionInsideBlock ****************
 *
 * ExpressionInsideBlock returns Expression:
 *   VariableDeclaration|Expression;
 *
 **/

// VariableDeclaration|Expression
protected class ExpressionInsideBlock_Alternatives extends AlternativesToken {

	public ExpressionInsideBlock_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getExpressionInsideBlockAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExpressionInsideBlock_VariableDeclarationParserRuleCall_0(parent, this, 0, inst);
			case 1: return new ExpressionInsideBlock_ExpressionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionInsideBlockRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// VariableDeclaration
protected class ExpressionInsideBlock_VariableDeclarationParserRuleCall_0 extends RuleCallToken {
	
	public ExpressionInsideBlock_VariableDeclarationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionInsideBlockAccess().getVariableDeclarationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(VariableDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Expression
protected class ExpressionInsideBlock_ExpressionParserRuleCall_1 extends RuleCallToken {
	
	public ExpressionInsideBlock_ExpressionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionInsideBlockAccess().getExpressionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Expression_AssignmentParserRuleCall.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule ExpressionInsideBlock ****************/


/************ begin Rule VariableDeclaration ****************
 *
 * VariableDeclaration:
 *   ("def"|type=TypeRef) name=ID ":=" right=Expression;
 *
 **/

// ("def"|type=TypeRef) name=ID ":=" right=Expression
protected class VariableDeclaration_Group extends GroupToken {
	
	public VariableDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableDeclaration_RightAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "def"|type=TypeRef
protected class VariableDeclaration_Alternatives_0 extends AlternativesToken {

	public VariableDeclaration_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableDeclaration_DefKeyword_0_0(parent, this, 0, inst);
			case 1: return new VariableDeclaration_TypeAssignment_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "def"
protected class VariableDeclaration_DefKeyword_0_0 extends KeywordToken  {
	
	public VariableDeclaration_DefKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getDefKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// type=TypeRef
protected class VariableDeclaration_TypeAssignment_0_1 extends AssignmentToken  {
	
	public VariableDeclaration_TypeAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getTypeAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVariableDeclarationAccess().getTypeTypeRefParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}


// name=ID
protected class VariableDeclaration_NameAssignment_1 extends AssignmentToken  {
	
	public VariableDeclaration_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableDeclaration_Alternatives_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ":="
protected class VariableDeclaration_ColonEqualsSignKeyword_2 extends KeywordToken  {
	
	public VariableDeclaration_ColonEqualsSignKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getColonEqualsSignKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new VariableDeclaration_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// right=Expression
protected class VariableDeclaration_RightAssignment_3 extends AssignmentToken  {
	
	public VariableDeclaration_RightAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableDeclarationAccess().getRightAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getVariableDeclarationAccess().getRightExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new VariableDeclaration_ColonEqualsSignKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule VariableDeclaration ****************/


/************ begin Rule DeclaredParameter ****************
 *
 * DeclaredParameter:
 *   type=TypeRef? name=ID;
 *
 **/

// type=TypeRef? name=ID
protected class DeclaredParameter_Group extends GroupToken {
	
	public DeclaredParameter_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getDeclaredParameterAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredParameter_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclaredParameterRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// type=TypeRef?
protected class DeclaredParameter_TypeAssignment_0 extends AssignmentToken  {
	
	public DeclaredParameter_TypeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaredParameterAccess().getTypeAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getDeclaredParameterAccess().getTypeTypeRefParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// name=ID
protected class DeclaredParameter_NameAssignment_1 extends AssignmentToken  {
	
	public DeclaredParameter_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclaredParameterAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new DeclaredParameter_TypeAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getDeclaredParameterAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule DeclaredParameter ****************/


/************ begin Rule SimpleFeatureCall ****************
 *
 * SimpleFeatureCall returns FeatureCall:
 *   name=ID ("(" (params+=Expression ("," params+=Expression)*)? ")")?;
 *
 **/

// name=ID ("(" (params+=Expression ("," params+=Expression)*)? ")")?
protected class SimpleFeatureCall_Group extends GroupToken {
	
	public SimpleFeatureCall_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_Group_1(parent, this, 0, inst);
			case 1: return new SimpleFeatureCall_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSimpleFeatureCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class SimpleFeatureCall_NameAssignment_0 extends AssignmentToken  {
	
	public SimpleFeatureCall_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSimpleFeatureCallAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("(" (params+=Expression ("," params+=Expression)*)? ")")?
protected class SimpleFeatureCall_Group_1 extends GroupToken {
	
	public SimpleFeatureCall_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_RightParenthesisKeyword_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class SimpleFeatureCall_LeftParenthesisKeyword_1_0 extends KeywordToken  {
	
	public SimpleFeatureCall_LeftParenthesisKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getLeftParenthesisKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (params+=Expression ("," params+=Expression)*)?
protected class SimpleFeatureCall_Group_1_1 extends GroupToken {
	
	public SimpleFeatureCall_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_Group_1_1_1(parent, this, 0, inst);
			case 1: return new SimpleFeatureCall_ParamsAssignment_1_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class SimpleFeatureCall_ParamsAssignment_1_1_0 extends AssignmentToken  {
	
	public SimpleFeatureCall_ParamsAssignment_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getParamsAssignment_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSimpleFeatureCallAccess().getParamsExpressionParserRuleCall_1_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SimpleFeatureCall_LeftParenthesisKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," params+=Expression)*
protected class SimpleFeatureCall_Group_1_1_1 extends GroupToken {
	
	public SimpleFeatureCall_Group_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getGroup_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_ParamsAssignment_1_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class SimpleFeatureCall_CommaKeyword_1_1_1_0 extends KeywordToken  {
	
	public SimpleFeatureCall_CommaKeyword_1_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getCommaKeyword_1_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_Group_1_1_1(parent, this, 0, inst);
			case 1: return new SimpleFeatureCall_ParamsAssignment_1_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class SimpleFeatureCall_ParamsAssignment_1_1_1_1 extends AssignmentToken  {
	
	public SimpleFeatureCall_ParamsAssignment_1_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getParamsAssignment_1_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSimpleFeatureCallAccess().getParamsExpressionParserRuleCall_1_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SimpleFeatureCall_CommaKeyword_1_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class SimpleFeatureCall_RightParenthesisKeyword_1_2 extends KeywordToken  {
	
	public SimpleFeatureCall_RightParenthesisKeyword_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleFeatureCallAccess().getRightParenthesisKeyword_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleFeatureCall_Group_1_1(parent, this, 0, inst);
			case 1: return new SimpleFeatureCall_LeftParenthesisKeyword_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule SimpleFeatureCall ****************/


/************ begin Rule ConstructorCall ****************
 *
 * ConstructorCall:
 *   "new" type=TypeRef ("(" (params+=Expression ("," params+=Expression)*)? ")")?
 *   initializer=BlockExpression?;
 *
 **/

// "new" type=TypeRef ("(" (params+=Expression ("," params+=Expression)*)? ")")?
// initializer=BlockExpression?
protected class ConstructorCall_Group extends GroupToken {
	
	public ConstructorCall_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_InitializerAssignment_3(parent, this, 0, inst);
			case 1: return new ConstructorCall_Group_2(parent, this, 1, inst);
			case 2: return new ConstructorCall_TypeAssignment_1(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getConstructorCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "new"
protected class ConstructorCall_NewKeyword_0 extends KeywordToken  {
	
	public ConstructorCall_NewKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getNewKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// type=TypeRef
protected class ConstructorCall_TypeAssignment_1 extends AssignmentToken  {
	
	public ConstructorCall_TypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConstructorCallAccess().getTypeTypeRefParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstructorCall_NewKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("(" (params+=Expression ("," params+=Expression)*)? ")")?
protected class ConstructorCall_Group_2 extends GroupToken {
	
	public ConstructorCall_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_RightParenthesisKeyword_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class ConstructorCall_LeftParenthesisKeyword_2_0 extends KeywordToken  {
	
	public ConstructorCall_LeftParenthesisKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getLeftParenthesisKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_TypeAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (params+=Expression ("," params+=Expression)*)?
protected class ConstructorCall_Group_2_1 extends GroupToken {
	
	public ConstructorCall_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_Group_2_1_1(parent, this, 0, inst);
			case 1: return new ConstructorCall_ParamsAssignment_2_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class ConstructorCall_ParamsAssignment_2_1_0 extends AssignmentToken  {
	
	public ConstructorCall_ParamsAssignment_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getParamsAssignment_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConstructorCallAccess().getParamsExpressionParserRuleCall_2_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstructorCall_LeftParenthesisKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," params+=Expression)*
protected class ConstructorCall_Group_2_1_1 extends GroupToken {
	
	public ConstructorCall_Group_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getGroup_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_ParamsAssignment_2_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ConstructorCall_CommaKeyword_2_1_1_0 extends KeywordToken  {
	
	public ConstructorCall_CommaKeyword_2_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getCommaKeyword_2_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_Group_2_1_1(parent, this, 0, inst);
			case 1: return new ConstructorCall_ParamsAssignment_2_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// params+=Expression
protected class ConstructorCall_ParamsAssignment_2_1_1_1 extends AssignmentToken  {
	
	public ConstructorCall_ParamsAssignment_2_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getParamsAssignment_2_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("params",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("params");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConstructorCallAccess().getParamsExpressionParserRuleCall_2_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstructorCall_CommaKeyword_2_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class ConstructorCall_RightParenthesisKeyword_2_2 extends KeywordToken  {
	
	public ConstructorCall_RightParenthesisKeyword_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getRightParenthesisKeyword_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ConstructorCall_Group_2_1(parent, this, 0, inst);
			case 1: return new ConstructorCall_LeftParenthesisKeyword_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// initializer=BlockExpression?
protected class ConstructorCall_InitializerAssignment_3 extends AssignmentToken  {
	
	public ConstructorCall_InitializerAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getConstructorCallAccess().getInitializerAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BlockExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("initializer",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("initializer");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBlockExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getConstructorCallAccess().getInitializerBlockExpressionParserRuleCall_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ConstructorCall_Group_2(parent, next, actIndex, consumed);
			case 1: return new ConstructorCall_TypeAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule ConstructorCall ****************/


/************ begin Rule BooleanLiteral ****************
 *
 * BooleanLiteral:
 *   {BooleanLiteral} "false"|isTrue?="true";
 *
 **/

// {BooleanLiteral} "false"|isTrue?="true"
protected class BooleanLiteral_Alternatives extends AlternativesToken {

	public BooleanLiteral_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteral_Group_0(parent, this, 0, inst);
			case 1: return new BooleanLiteral_IsTrueAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {BooleanLiteral} "false"
protected class BooleanLiteral_Group_0 extends GroupToken {
	
	public BooleanLiteral_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteral_FalseKeyword_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {BooleanLiteral}
protected class BooleanLiteral_BooleanLiteralAction_0_0 extends ActionToken  {

	public BooleanLiteral_BooleanLiteralAction_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getBooleanLiteralAction_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getBooleanLiteralAccess().getBooleanLiteralAction_0_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "false"
protected class BooleanLiteral_FalseKeyword_0_1 extends KeywordToken  {
	
	public BooleanLiteral_FalseKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getFalseKeyword_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new BooleanLiteral_BooleanLiteralAction_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// isTrue?="true"
protected class BooleanLiteral_IsTrueAssignment_1 extends AssignmentToken  {
	
	public BooleanLiteral_IsTrueAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanLiteralAccess().getIsTrueAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("isTrue",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("isTrue");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getBooleanLiteralAccess().getIsTrueTrueKeyword_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule BooleanLiteral ****************/


/************ begin Rule NullLiteral ****************
 *
 * NullLiteral:
 *   {NullLiteral} "null";
 *
 **/

// {NullLiteral} "null"
protected class NullLiteral_Group extends GroupToken {
	
	public NullLiteral_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNullLiteralAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteral_NullKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNullLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {NullLiteral}
protected class NullLiteral_NullLiteralAction_0 extends ActionToken  {

	public NullLiteral_NullLiteralAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getNullLiteralAccess().getNullLiteralAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getNullLiteralAccess().getNullLiteralAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "null"
protected class NullLiteral_NullKeyword_1 extends KeywordToken  {
	
	public NullLiteral_NullKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNullLiteralAccess().getNullKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NullLiteral_NullLiteralAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule NullLiteral ****************/


/************ begin Rule IntLiteral ****************
 *
 * IntLiteral:
 *   value=INT;
 *
 **/

// value=INT
protected class IntLiteral_ValueAssignment extends AssignmentToken  {
	
	public IntLiteral_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getIntLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getIntLiteralAccess().getValueINTTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule IntLiteral ****************/


/************ begin Rule StringLiteral ****************
 *
 * StringLiteral:
 *   value=STRING;
 *
 **/

// value=STRING
protected class StringLiteral_ValueAssignment extends AssignmentToken  {
	
	public StringLiteral_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getStringLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getStringLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule StringLiteral ****************/


/************ begin Rule TypeLiteral ****************
 *
 * TypeLiteral:
 *   type=[types::Type|QualifiedName] "." "class";
 *
 **/

// type=[types::Type|QualifiedName] "." "class"
protected class TypeLiteral_Group extends GroupToken {
	
	public TypeLiteral_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeLiteralAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeLiteral_ClassKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// type=[types::Type|QualifiedName]
protected class TypeLiteral_TypeAssignment_0 extends AssignmentToken  {
	
	public TypeLiteral_TypeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeLiteralAccess().getTypeAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeLiteralAccess().getTypeTypeCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getTypeLiteralAccess().getTypeTypeCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "."
protected class TypeLiteral_FullStopKeyword_1 extends KeywordToken  {
	
	public TypeLiteral_FullStopKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeLiteralAccess().getFullStopKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeLiteral_TypeAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "class"
protected class TypeLiteral_ClassKeyword_2 extends KeywordToken  {
	
	public TypeLiteral_ClassKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeLiteralAccess().getClassKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeLiteral_FullStopKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule TypeLiteral ****************/


/************ begin Rule RichString ****************
 *
 * RichString:
 *   expressions+=RichStringLiteral (expressions+=Expression expressions+=
 *   RichStringLiteral)*;
 *
 **/

// expressions+=RichStringLiteral (expressions+=Expression expressions+=
// RichStringLiteral)*
protected class RichString_Group extends GroupToken {
	
	public RichString_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRichStringAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RichString_Group_1(parent, this, 0, inst);
			case 1: return new RichString_ExpressionsAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRichStringRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// expressions+=RichStringLiteral
protected class RichString_ExpressionsAssignment_0 extends AssignmentToken  {
	
	public RichString_ExpressionsAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRichStringAccess().getExpressionsAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RichStringLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRichStringLiteralRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRichStringAccess().getExpressionsRichStringLiteralParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// (expressions+=Expression expressions+=RichStringLiteral)*
protected class RichString_Group_1 extends GroupToken {
	
	public RichString_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRichStringAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RichString_ExpressionsAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// expressions+=Expression
protected class RichString_ExpressionsAssignment_1_0 extends AssignmentToken  {
	
	public RichString_ExpressionsAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRichStringAccess().getExpressionsAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_AssignmentParserRuleCall(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRichStringAccess().getExpressionsExpressionParserRuleCall_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RichString_Group_1(parent, next, actIndex, consumed);
			case 1: return new RichString_ExpressionsAssignment_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// expressions+=RichStringLiteral
protected class RichString_ExpressionsAssignment_1_1 extends AssignmentToken  {
	
	public RichString_ExpressionsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRichStringAccess().getExpressionsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RichStringLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRichStringLiteralRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getRichStringAccess().getExpressionsRichStringLiteralParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new RichString_ExpressionsAssignment_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule RichString ****************/


/************ begin Rule RichStringLiteral ****************
 *
 * RichStringLiteral:
 *   value=RICH_STRING;
 *
 **/

// value=RICH_STRING
protected class RichStringLiteral_ValueAssignment extends AssignmentToken  {
	
	public RichStringLiteral_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRichStringLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRichStringLiteralRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getRichStringLiteralAccess().getValueRICH_STRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule RichStringLiteral ****************/


/************ begin Rule TypeRef ****************
 *
 * TypeRef:
 *   SimpleTypeRef|FunctionTypeRef;
 *
 **/

// SimpleTypeRef|FunctionTypeRef
protected class TypeRef_Alternatives extends AlternativesToken {

	public TypeRef_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_SimpleTypeRefParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TypeRef_FunctionTypeRefParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// SimpleTypeRef
protected class TypeRef_SimpleTypeRefParserRuleCall_0 extends RuleCallToken {
	
	public TypeRef_SimpleTypeRefParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getSimpleTypeRefParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SimpleTypeRef_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSimpleTypeRefRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// FunctionTypeRef
protected class TypeRef_FunctionTypeRefParserRuleCall_1 extends RuleCallToken {
	
	public TypeRef_FunctionTypeRefParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getFunctionTypeRefParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(FunctionTypeRef_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFunctionTypeRefRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule TypeRef ****************/


/************ begin Rule FunctionTypeRef ****************
 *
 * FunctionTypeRef:
 *   ("(" paramTypes+=TypeRef ("," paramTypes+=TypeRef)* ")")? "=>" returnType=TypeRef;
 *
 **/

// ("(" paramTypes+=TypeRef ("," paramTypes+=TypeRef)* ")")? "=>" returnType=TypeRef
protected class FunctionTypeRef_Group extends GroupToken {
	
	public FunctionTypeRef_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_ReturnTypeAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getFunctionTypeRefRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ("(" paramTypes+=TypeRef ("," paramTypes+=TypeRef)* ")")?
protected class FunctionTypeRef_Group_0 extends GroupToken {
	
	public FunctionTypeRef_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_RightParenthesisKeyword_0_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "("
protected class FunctionTypeRef_LeftParenthesisKeyword_0_0 extends KeywordToken  {
	
	public FunctionTypeRef_LeftParenthesisKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getLeftParenthesisKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// paramTypes+=TypeRef
protected class FunctionTypeRef_ParamTypesAssignment_0_1 extends AssignmentToken  {
	
	public FunctionTypeRef_ParamTypesAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getParamTypesAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("paramTypes",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("paramTypes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionTypeRefAccess().getParamTypesTypeRefParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionTypeRef_LeftParenthesisKeyword_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," paramTypes+=TypeRef)*
protected class FunctionTypeRef_Group_0_2 extends GroupToken {
	
	public FunctionTypeRef_Group_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getGroup_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_ParamTypesAssignment_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class FunctionTypeRef_CommaKeyword_0_2_0 extends KeywordToken  {
	
	public FunctionTypeRef_CommaKeyword_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getCommaKeyword_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_Group_0_2(parent, this, 0, inst);
			case 1: return new FunctionTypeRef_ParamTypesAssignment_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// paramTypes+=TypeRef
protected class FunctionTypeRef_ParamTypesAssignment_0_2_1 extends AssignmentToken  {
	
	public FunctionTypeRef_ParamTypesAssignment_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getParamTypesAssignment_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("paramTypes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("paramTypes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionTypeRefAccess().getParamTypesTypeRefParserRuleCall_0_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionTypeRef_CommaKeyword_0_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ")"
protected class FunctionTypeRef_RightParenthesisKeyword_0_3 extends KeywordToken  {
	
	public FunctionTypeRef_RightParenthesisKeyword_0_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getRightParenthesisKeyword_0_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_Group_0_2(parent, this, 0, inst);
			case 1: return new FunctionTypeRef_ParamTypesAssignment_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// "=>"
protected class FunctionTypeRef_EqualsSignGreaterThanSignKeyword_1 extends KeywordToken  {
	
	public FunctionTypeRef_EqualsSignGreaterThanSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getEqualsSignGreaterThanSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new FunctionTypeRef_Group_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// returnType=TypeRef
protected class FunctionTypeRef_ReturnTypeAssignment_2 extends AssignmentToken  {
	
	public FunctionTypeRef_ReturnTypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFunctionTypeRefAccess().getReturnTypeAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("returnType",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("returnType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFunctionTypeRefAccess().getReturnTypeTypeRefParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new FunctionTypeRef_EqualsSignGreaterThanSignKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule FunctionTypeRef ****************/


/************ begin Rule SimpleTypeRef ****************
 *
 * SimpleTypeRef:
 *   type=[types::Type|QualifiedName] ("<" typeParams+=TypeParam ("," typeParams+=
 *   TypeParam)* ">")?;
 *
 **/

// type=[types::Type|QualifiedName] ("<" typeParams+=TypeParam ("," typeParams+=
// TypeParam)* ">")?
protected class SimpleTypeRef_Group extends GroupToken {
	
	public SimpleTypeRef_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group_1(parent, this, 0, inst);
			case 1: return new SimpleTypeRef_TypeAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSimpleTypeRefRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// type=[types::Type|QualifiedName]
protected class SimpleTypeRef_TypeAssignment_0 extends AssignmentToken  {
	
	public SimpleTypeRef_TypeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getTypeAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSimpleTypeRefAccess().getTypeTypeCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSimpleTypeRefAccess().getTypeTypeCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("<" typeParams+=TypeParam ("," typeParams+=TypeParam)* ">")?
protected class SimpleTypeRef_Group_1 extends GroupToken {
	
	public SimpleTypeRef_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_GreaterThanSignKeyword_1_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "<"
protected class SimpleTypeRef_LessThanSignKeyword_1_0 extends KeywordToken  {
	
	public SimpleTypeRef_LessThanSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getLessThanSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_TypeAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// typeParams+=TypeParam
protected class SimpleTypeRef_TypeParamsAssignment_1_1 extends AssignmentToken  {
	
	public SimpleTypeRef_TypeParamsAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getTypeParamsAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParam_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeParams",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeParams");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeParamRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSimpleTypeRefAccess().getTypeParamsTypeParamParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SimpleTypeRef_LessThanSignKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," typeParams+=TypeParam)*
protected class SimpleTypeRef_Group_1_2 extends GroupToken {
	
	public SimpleTypeRef_Group_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGroup_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_TypeParamsAssignment_1_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class SimpleTypeRef_CommaKeyword_1_2_0 extends KeywordToken  {
	
	public SimpleTypeRef_CommaKeyword_1_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getCommaKeyword_1_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group_1_2(parent, this, 0, inst);
			case 1: return new SimpleTypeRef_TypeParamsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// typeParams+=TypeParam
protected class SimpleTypeRef_TypeParamsAssignment_1_2_1 extends AssignmentToken  {
	
	public SimpleTypeRef_TypeParamsAssignment_1_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getTypeParamsAssignment_1_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParam_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("typeParams",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeParams");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeParamRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSimpleTypeRefAccess().getTypeParamsTypeParamParserRuleCall_1_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SimpleTypeRef_CommaKeyword_1_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ">"
protected class SimpleTypeRef_GreaterThanSignKeyword_1_3 extends KeywordToken  {
	
	public SimpleTypeRef_GreaterThanSignKeyword_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSimpleTypeRefAccess().getGreaterThanSignKeyword_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SimpleTypeRef_Group_1_2(parent, this, 0, inst);
			case 1: return new SimpleTypeRef_TypeParamsAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}



/************ end Rule SimpleTypeRef ****************/


/************ begin Rule TypeParam ****************
 *
 * TypeParam returns TypeRef:
 *   TypeRef|WildcardParam;
 *
 **/

// TypeRef|WildcardParam
protected class TypeParam_Alternatives extends AlternativesToken {

	public TypeParam_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeParamAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParam_TypeRefParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TypeParam_WildcardParamParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeParamRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// TypeRef
protected class TypeParam_TypeRefParserRuleCall_0 extends RuleCallToken {
	
	public TypeParam_TypeRefParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeParamAccess().getTypeRefParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TypeRef_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// WildcardParam
protected class TypeParam_WildcardParamParserRuleCall_1 extends RuleCallToken {
	
	public TypeParam_WildcardParamParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTypeParamAccess().getWildcardParamParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(WildcardParam_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getWildcardParamRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule TypeParam ****************/


/************ begin Rule WildcardParam ****************
 *
 * WildcardParam returns TypeRef:
 *   {WildcardParam} "?" ("extends" extends=TypeRef|"super" super=TypeRef)?;
 *
 **/

// {WildcardParam} "?" ("extends" extends=TypeRef|"super" super=TypeRef)?
protected class WildcardParam_Group extends GroupToken {
	
	public WildcardParam_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_Alternatives_2(parent, this, 0, inst);
			case 1: return new WildcardParam_QuestionMarkKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWildcardParamRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {WildcardParam}
protected class WildcardParam_WildcardParamAction_0 extends ActionToken  {

	public WildcardParam_WildcardParamAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getWildcardParamAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getWildcardParamAccess().getWildcardParamAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "?"
protected class WildcardParam_QuestionMarkKeyword_1 extends KeywordToken  {
	
	public WildcardParam_QuestionMarkKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getQuestionMarkKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_WildcardParamAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ("extends" extends=TypeRef|"super" super=TypeRef)?
protected class WildcardParam_Alternatives_2 extends AlternativesToken {

	public WildcardParam_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getAlternatives_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_Group_2_0(parent, this, 0, inst);
			case 1: return new WildcardParam_Group_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends" extends=TypeRef
protected class WildcardParam_Group_2_0 extends GroupToken {
	
	public WildcardParam_Group_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getGroup_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_ExtendsAssignment_2_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class WildcardParam_ExtendsKeyword_2_0_0 extends KeywordToken  {
	
	public WildcardParam_ExtendsKeyword_2_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getExtendsKeyword_2_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_QuestionMarkKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// extends=TypeRef
protected class WildcardParam_ExtendsAssignment_2_0_1 extends AssignmentToken  {
	
	public WildcardParam_ExtendsAssignment_2_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getExtendsAssignment_2_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWildcardParamAccess().getExtendsTypeRefParserRuleCall_2_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WildcardParam_ExtendsKeyword_2_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "super" super=TypeRef
protected class WildcardParam_Group_2_1 extends GroupToken {
	
	public WildcardParam_Group_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getGroup_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_SuperAssignment_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "super"
protected class WildcardParam_SuperKeyword_2_1_0 extends KeywordToken  {
	
	public WildcardParam_SuperKeyword_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getSuperKeyword_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WildcardParam_QuestionMarkKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// super=TypeRef
protected class WildcardParam_SuperAssignment_2_1_1 extends AssignmentToken  {
	
	public WildcardParam_SuperAssignment_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWildcardParamAccess().getSuperAssignment_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("super",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("super");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWildcardParamAccess().getSuperTypeRefParserRuleCall_2_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WildcardParam_SuperKeyword_2_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule WildcardParam ****************/


/************ begin Rule TypeParamDeclaration ****************
 *
 * TypeParamDeclaration:
 *   name=ID ("extends" extends+=TypeRef ("&" extends+=TypeRef)*|"super" super=TypeRef)?;
 *
 **/

// name=ID ("extends" extends+=TypeRef ("&" extends+=TypeRef)*|"super" super=TypeRef)?
protected class TypeParamDeclaration_Group extends GroupToken {
	
	public TypeParamDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_Alternatives_1(parent, this, 0, inst);
			case 1: return new TypeParamDeclaration_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeParamDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class TypeParamDeclaration_NameAssignment_0 extends AssignmentToken  {
	
	public TypeParamDeclaration_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTypeParamDeclarationAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("extends" extends+=TypeRef ("&" extends+=TypeRef)*|"super" super=TypeRef)?
protected class TypeParamDeclaration_Alternatives_1 extends AlternativesToken {

	public TypeParamDeclaration_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_Group_1_0(parent, this, 0, inst);
			case 1: return new TypeParamDeclaration_Group_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends" extends+=TypeRef ("&" extends+=TypeRef)*
protected class TypeParamDeclaration_Group_1_0 extends GroupToken {
	
	public TypeParamDeclaration_Group_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getGroup_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_Group_1_0_2(parent, this, 0, inst);
			case 1: return new TypeParamDeclaration_ExtendsAssignment_1_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class TypeParamDeclaration_ExtendsKeyword_1_0_0 extends KeywordToken  {
	
	public TypeParamDeclaration_ExtendsKeyword_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getExtendsKeyword_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// extends+=TypeRef
protected class TypeParamDeclaration_ExtendsAssignment_1_0_1 extends AssignmentToken  {
	
	public TypeParamDeclaration_ExtendsAssignment_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getExtendsAssignment_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypeParamDeclarationAccess().getExtendsTypeRefParserRuleCall_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypeParamDeclaration_ExtendsKeyword_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("&" extends+=TypeRef)*
protected class TypeParamDeclaration_Group_1_0_2 extends GroupToken {
	
	public TypeParamDeclaration_Group_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getGroup_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_ExtendsAssignment_1_0_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "&"
protected class TypeParamDeclaration_AmpersandKeyword_1_0_2_0 extends KeywordToken  {
	
	public TypeParamDeclaration_AmpersandKeyword_1_0_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getAmpersandKeyword_1_0_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_Group_1_0_2(parent, this, 0, inst);
			case 1: return new TypeParamDeclaration_ExtendsAssignment_1_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// extends+=TypeRef
protected class TypeParamDeclaration_ExtendsAssignment_1_0_2_1 extends AssignmentToken  {
	
	public TypeParamDeclaration_ExtendsAssignment_1_0_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getExtendsAssignment_1_0_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypeParamDeclarationAccess().getExtendsTypeRefParserRuleCall_1_0_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypeParamDeclaration_AmpersandKeyword_1_0_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// "super" super=TypeRef
protected class TypeParamDeclaration_Group_1_1 extends GroupToken {
	
	public TypeParamDeclaration_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_SuperAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "super"
protected class TypeParamDeclaration_SuperKeyword_1_1_0 extends KeywordToken  {
	
	public TypeParamDeclaration_SuperKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getSuperKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeParamDeclaration_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// super=TypeRef
protected class TypeParamDeclaration_SuperAssignment_1_1_1 extends AssignmentToken  {
	
	public TypeParamDeclaration_SuperAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeParamDeclarationAccess().getSuperAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("super",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("super");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTypeParamDeclarationAccess().getSuperTypeRefParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TypeParamDeclaration_SuperKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule TypeParamDeclaration ****************/


}
