<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Types</title>
<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="index.html" title="">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<a name="Types"></a>
<h1 xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0">Types</h1>

<p>
Xbase binds to the Java Virtual Machine. This means that expressions written in Xbase refer to Java types and Java type members. Xbase itself uses types 
defined in the Java language, such as classes, interfaces, annotations and enums. It also supports Java generics and shares the known syntax. In addition 
to Java, Xbase comes with the notion of function types. 
</p>

<p>
Xbase does not allow to define arrays or references to arrays. Instead, any references to arrays will
be transparently converted to lists and vice versa. The return type of an external function that calculates
an array <em>int[]</em> can be directly assigned to a variable of type <em>java.util.List&lt;java.lang.Integer&gt;</em> 
(in short <em>List&lt;Integer&gt;</em>). Any function, that takes an array as argument can be invoked with a <em>List</em>
instead. 
</p>


<a name="TypeReferences"></a>

<a name="TypeReferences"></a>
<div class="section" title="Simple Type References">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Simple Type References
</h2>
</div>
</div>
</div>



<p>
A simple type reference only consists of a <em>qualified name</em>. A qualified name is a name made up of identifiers which are separated by a dot 
(like in Java).
</p>




<a name="TypeReferences-2"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
QualifiedName:<br />
&nbsp;&nbsp;ID&nbsp;(&apos;.&apos;&nbsp;ID)*<br />
;
</p>
</div>
</div>


</p>

<p>
There is no parser rule for a simple type reference, as it is expressed as a parameterized type references without parameters.
</p>


</div>



<a name="TypeReferences-3"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>
<span class="inlinecode">java.lang.String</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">String</span>

</p>

</li>

</ul>

</p>


</div>

</div>

<a name="FunctionTypes"></a>

<a name="FunctionTypes"></a>
<div class="section" title="Function Types">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Function Types
</h2>
</div>
</div>
</div>



<p>
Xbase introduces <em>closures</em>, and therefore an additional function type signature. On the JVM-Level a closure (or more
generally any function object) is just an instance of one of the types in <span class="inlinecode">org.eclipse.xtext.xbase.lib.Function*</span>
, 
depending on the number of arguments. However, as closures are a very important language feature, 
a special sugared syntax for function types has been introduced.  
So instead of writing <span class="inlinecode">Function1&lt;String,Boolean&gt;</span>
 one can write <span class="inlinecode">(String)=&gt;Boolean</span>
.
</p>

<p>
For more information on closures see 
<a href="04-Expressions.xdoc.html#Closures">section Closures</a>.
</p>




<a name="FunctionTypes-3"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
XFunctionTypeRef:<br />
&nbsp;&nbsp;(&apos;(&apos;JvmTypeReference&nbsp;(&apos;,&apos;&nbsp;JvmTypeReference)*&apos;)&apos;)?&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&apos;=&gt;&apos;&nbsp;JvmTypeReference;
</p>
</div>
</div>


</p>


</div>



<a name="FunctionTypes-4"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>
<span class="inlinecode">=&gt;Boolean&nbsp;//&nbsp;predicate&nbsp;without&nbsp;parameters</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">(String)=&gt;Boolean&nbsp;//&nbsp;One&nbsp;argument&nbsp;predicate</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">(Mutable)=&gt;Void&nbsp;//&nbsp;A&nbsp;method&nbsp;doing&nbsp;side&nbsp;effects&nbsp;only&nbsp;-&nbsp;returns&nbsp;null</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">(List&lt;String&gt;,&nbsp;int)=&gt;String</span>

</p>

</li>

</ul>

</p>


</div>

</div>

<a name="ParameterizedTypeReference"></a>

<a name="ParameterizedTypeReference"></a>
<div class="section" title="Parameterized Type References">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Parameterized Type References
</h2>
</div>
</div>
</div>



<p>
The general syntax for type references allows to take any number of type arguments. The semantics as well as the syntax is almost the same as in Java, so please 
refer to the third edition of the  <a href="http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html">Java Language Specification</a>.
</p>

<p>
The only difference is that in Xbase a type reference can also be a function type. In the following the full syntax of type references is shown, including function types and
type arguments.
</p>




<a name="ParameterizedTypeReference-3"></a>
<div class="section" title="Syntax">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Syntax
</h3>
</div>
</div>
</div>



<p>

<div class="literallayout">
<div class="incode">
<p class="code">
JvmTypeReference:<br />
&nbsp;&nbsp;JvmParameterizedTypeReference&nbsp;|&nbsp;<br />
&nbsp;&nbsp;XFunctionTypeRef;<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
XFunctionTypeRef:<br />
&nbsp;&nbsp;(&apos;(&apos;&nbsp;JvmTypeReference&nbsp;(&apos;,&apos;&nbsp;JvmTypeReference)*&nbsp;&apos;)&apos;)?&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&apos;=&gt;&apos;&nbsp;JvmTypeReference;<br />
<br />
JvmParameterizedTypeReference:<br />
&nbsp;&nbsp;type=QualifiedName&nbsp;(&apos;&lt;&apos;&nbsp;JvmTypeArgument&nbsp;(&apos;,&apos;&nbsp;JvmTypeArgument)*&nbsp;&apos;&gt;&apos;)?;<br />
<br />
JvmTypeArgument:<br />
&nbsp;&nbsp;JvmReferenceTypeArgument&nbsp;|&nbsp;<br />
&nbsp;&nbsp;JvmWildcardTypeArgument;<br />
&nbsp;&nbsp;<br />
JvmReferenceTypeArgument&nbsp;:<br />
&nbsp;&nbsp;JvmTypeReference;<br />
<br />
JvmWildcardTypeArgument:<br />
&nbsp;&nbsp;&apos;?&apos;&nbsp;(JvmUpperBound&nbsp;|&nbsp;JvmLowerBound)?;<br />
<br />
JvmLowerBound&nbsp;:<br />
&nbsp;&apos;super&apos;&nbsp;JvmTypeReference;<br />
<br />
JvmUpperBound&nbsp;:&nbsp;<br />
&nbsp;&apos;extends&apos;&nbsp;JvmTypeReference;
</p>
</div>
</div>


</p>


</div>



<a name="ParameterizedTypeReference-4"></a>
<div class="section" title="Examples">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Examples
</h3>
</div>
</div>
</div>



<p>

<ul>

<li>

<p>
<span class="inlinecode">String</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">java.lang.String</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">List&lt;?&gt;</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">List&lt;?&nbsp;extends&nbsp;Comparable&lt;?&nbsp;extends&nbsp;FooBar&gt;</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">List&lt;?&nbsp;super&nbsp;MyLowerBound&gt;</span>

</p>

</li>

<li>

<p>
<span class="inlinecode">List&lt;?&nbsp;extends&nbsp;=&gt;Boolean&gt;</span>

</p>

</li>

</ul>

</p>


</div>

</div>

<a name="VoidType"></a>

<a name="VoidType"></a>
<div class="section" title="The type java.lang.Void">
<div class="titlepage">
<div>
<div>
<h2 class="title">
The type java.lang.Void
</h2>
</div>
</div>
</div>



<p>
The <span class="inlinecode">null</span>
 reference is the only valid value of the type <span class="inlinecode">Void</span>
, which gets some special treatment in Xbase. Every Java method which is declared 
<em>void</em> (i.e. without a return value) is translated to a method with return type <em>java.lang.Void</em>. At runtime such method invocations will result in 
<em>null</em>. The specialty is that while it is allowed to pass <span class="inlinecode">null</span>
 everywhere  instead of any other value, 
this does not mean that <em>java.lang.Void</em> is a subtype of any other type. The <span class="inlinecode">instanceof</span>
 operator as well as the type matchers in 
the 
<a href="04-Expressions.xdoc.html#SwitchExpression">section SwitchExpression</a> do not match <span class="inlinecode">null</span>
.
</p>


</div>

<a name="ConformanceRules"></a>

<a name="ConformanceRules"></a>
<div class="section" title="Conformance Rules">
<div class="titlepage">
<div>
<div>
<h2 class="title">
Conformance Rules
</h2>
</div>
</div>
</div>



<p>
Conformance is used in order to find out whether some expression can be used in a certain situation. For instance when assigning a value to a variable, 
the type of the right hand expression needs to conform to the type of the variable.
</p>

<p>
A type <em>T1</em> conforms to a type <em>T2</em> if 

<ul>

<li>

<p>
T1==T2
</p>

</li>

<li>

<p>
T1==java.lang.Void
</p>

</li>

<li>

<p>
T1 is a subtype of T2
</p>

</li>

</ul>

</p>

<p>
<em>T1&lt;T1P,..T1Pn&gt;</em> conforms to <em>T2&lt;T2P, ... T2Pn&gt;</em> if <em>T1</em> conforms to <em>T2</em> and each upper bound of a <em>T1Pn</em> conforms to the corresponding upper bound of <em>T2Pn</em>.
</p>

<p>

</p>


<a name="CommonSuperType"></a>

<a name="CommonSuperType"></a>
<div class="section" title="Common Super Type">
<div class="titlepage">
<div>
<div>
<h3 class="title">
Common Super Type
</h3>
</div>
</div>
</div>



<p>
For a set <em>[T1,T2,...Tn]</em> of types the common super type is computed by using the linear type inheritance sequence of <em>T1</em> and is iterated until one type
conforms to each <em>T2,..,Tn</em>. The linear type inheritance sequence of <em>T1</em> is computed by ordering all types which are part if the type hierarchy of <em>T1</em>
by their specificity. A type <em>T1</em> is considered more specific than <em>T2</em> if <em>T1</em> is a subtype of <em>T2</em>. Any types with equal specificity will be sorted by
the maximal distance to the originating subtype. <em>CharSequence</em> has distance 2 to <em>StringBuilder</em> because
the supertype <em>AbstractStringBuilder</em> implements the interface. Even if <em>StringBuilder</em> implements
<em>CharSequence</em> directly, the interface gets distance 2 in the ordering because it is not the first class
in the type hierarchy that implements the interface. If the distances for to classes are the same int
he hierarchy, their qualified name is used to ensure deterministic results. 
</p>


</div>

</div>

</body>
</html>
