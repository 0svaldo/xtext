chapter:Expressions[Expressions]

Expressions are the main language constructs which are used to express behavior and computation of values. Xbase doesn't support the concept of a statement, but instead comes with powerful 
expressions to handle situations in which the imperative nature of statements are a better fit. An expression always results in a value (might be the value 'null' though). In addition expressions can
be statically typed. That is by default it is assumed that languages making use of Xbase provide enough static context infromation to allow for static type analysis, which is the basis of a lot of
IDE features coming with Xbase for free. However, the static typing is not mandatory and might be completely skipped if not wished. The openess of the compiler even allows to change the generation of 
concrete feature invocations to reflective calls, so that the language can be fully dynamically typed.

section:Literals[Literals]

A literal denotes a fixed unchangeable value. Xbase comes with the following literals

section2:ExpressionsStringLiterals[String Literals]

A string literal as defined in ref:StringLiterals is a valid expression and returns an instance of code[java.lang.String] of the given value.

section2:ExpressionsIntegerLiterals[Integer Literals]

An integer literal as defined in ref:IntegerLiterals creates an instance of code[Integer].

section2:BooleanLiteral[Boolean Literals]

There are two boolean literals, code[true] and code[false] which each correspond to their Java counterpart of type e[java.lang.Boolean]. 

section2[Syntax]

code[
XBooleanLiteral:
	{XBooleanLiteral} 'false' | isTrue?='true';
]

section2:NullLiteral[Null Literal]

The null pointer literal again is like in Java: code[null]. 
It is the only value of the type e[java.lang.Void] which has some special meaning in Xbase (see ref:VoidType).

section2[Syntax]

code[
XNullLiteral:
	{XNullLiteral} 'null';
]

section2:TypeLiteral[Type Literals]

Also type literals are written like in Java, that is it it consists of a reference to a raw type suffixed with a dot and the keyword code[class].

section2[Syntax]

code[
XTypeLiteral:
	type=\[types::JvmType|QualifiedName\] '.' 'class';
 ]

section:Operators[Infix Operators]

Xbase supports the usual infix operators as well as some additional operators known from other languages. In contrast to Java, the operators are not fixed
to operations on certain types, but instead Xbase comes with an operator to method mapping, which allows users to redefine the operators for any type just by implementing
the corresponding method signature. The following defines the operators and the corresponding method signatures.

table[
	tr[td[code[e1.someProp = e2]]		td[code[e1.someProp = e2]]]
	tr[td[ ]								td[code[e1.someProp(e2)]]]
	tr[td[ ]								td[code[e1.setSomeProp(e2)]]]
	tr[td[code[e1 += e2]]				td[code[e1.add(e2)]]]
	tr[td[code[e1.someFeature += e2]]	td[code[e1.addSomeFeature(e2)]]]
	tr[td[code[ ]]td[code[ ]]]
	tr[td[code[e1 || e2]]				td[code[e1.or(e2)]]]
	tr[td[code[ ]]td[code[ ]]]
	tr[td[code[e1 && e2]]				td[code[e1.and(e2)]]]
	tr[td[code[ ]]td[code[ ]]]
	tr[td[code[e1 instanceof RawTypeRef]]td[code[e1 instanceof RawTypeRef /* direct translation to Java */]]]
	tr[td[code[e1 == e2]]				td[code[e1.equals(e2)]]]
	tr[td[code[e1 != e2]]				td[code[e1.notEquals(e2)]]]
	tr[td[code[e1 < e2]]				td[code[e1.lessThan(e2)]]]
	tr[td[code[e1 > e2]]				td[code[e1.greaterThan(e2)]]]
	tr[td[code[e1 <= e2]]				td[code[e1.lessEqualsThan(e2)]]]
	tr[td[code[e1 >= e2]]				td[code[e1.greaterEqualsThan(e2)]]]
	tr[td[code[ ]]td[code[ ]]]
	tr[td[code[e1 -> e2]]				td[code[e1.mappedTo(e2)]]]
	tr[td[code[e1 .. e2]]				td[code[e1.upTo(e2)]]]
	tr[td[code[ ]]td[code[ ]]]
	tr[td[code[e1 + e2]]				td[code[e1.plus(e2)]]]
	tr[td[code[e1 - e2]]				td[code[e1.minus(e2)]]]
	tr[td[code[ ]]td[code[ ]]]
	tr[td[code[e1 * e2]]				td[code[e1.multiply(e2)]]]
	tr[td[code[e1 / e2]]				td[code[e1.divide(e2)]]]
	tr[td[code[e1 % e2]]				td[code[e1.modulo(e2)]]]
	tr[td[code[e1 ** e2]]				td[code[e1.power(e2)]]]
	tr[td[code[ ]]td[code[ ]]]
	tr[td[code[! e1]]					td[code[e1.not()]]]
	tr[td[code[- e1]]					td[code[e1.minus()]]]
	tr[td[code[ ]]td[code[ ]]]
	tr[td[code[e1\[e2\]]]				td[code[e1.apply(<Exp2)]]]
]
		
The table above also defines the operator precedence (fom low to high precedence). The separator lines indicate a precedence level. 
The two assignment operators code[=] and code[+=] are right-to-left associative, that is a = b = c is executed as a = (b = c), all other
operators are left-to-right associative. Parenthesis can be used to adjust the default precedence and associativity. 

section2:propertyAssignment[Property Assignment]

The translation rule for the simple assignment operator code[=] is a bit more complicated.
Given the expression 

code[
	myObj.myProperty = "foo"
]

It first looks up whether, there is an accessible Java Field called code[myProperty] on the type of code[myObj]. If there is one it translates to
the following Java expression :

code[Java][
	myObj.myProperty = "foo";
]

Remember in Xbase everything is an expression and has to return something. In the case of simple assignments the return value is the value returned from the corresponding
Java expression, which is the assigned value.

If there is no accessible field on the left operands type, first a method called code[myProperty(OneArg)] and then code[setMyProperty(OneArg)] is looked up. It has to take 
one argument of the type (or a super type) of the right hand operand. The return value will be whatever the setter method returns (usually null i.e. type code[java.lang.Void]). 
As a result the compiler translates to :

code[Java][
	myObj.setMyProperty("foo")
]

section2:addAssignment[Add Assignment]

The translation rule for the add assignment operator code[+=] is as follows:
Given the expression 

code[
	myObj.myProperty += "foo"
]

It first looks up whether, the left hand side operand is of type e[java.util.Collection]. If it is the expression above translates to
the following Java expression :

code[Java][
	myObj.myProperty.add("foo");
]

If there's no such field, the compiler looks for a method called code[addMyProperty(OneArg)].

section2[Short-Circuit Boolean Operators]

If the operators code[||] and code[&&] are used in a context where both operands are of type boolean, the operation supports short circuit.
That is 
ol[
	item[in the case of code[||] the operand on the right hand side is not evaluated if the left operand evaluates to code[true].]
	item[in the case of code[&&] the operand on the right hand side is not evaluated if the left operand evaluates to code[false].]
]
 

section2[Examples]

ul[
	item[my.foo = 23]
	item[myList += 23]
	item[x > 23 && y < 23]
	item[x && y || z]
	item[1 + 3 * 5 * (- 23)]
	item[!(x]
	item[my.foo = 23]
	item[my.foo = 23]
]

section:FeatureCalls[Feature Calls]

A feature call is used to invoke members of objects, such as fields and methods, but also can refer to local variables and parameters, which are made available for the current expression's scope.

section2[Syntax]

The following snippet is a simplification of the real Xtext rules, which cover more than the concrete syntax.
code[
FeatureCall :
	ID |
	Expression ('.' ID ('(' Expression (',' Expression)* ')')?)*
]

section2:PropertyAccess[Property Access]

Feature calls are directly translated to their Java equivalent with the exception, that for calls to properties an equivalent rule as described in ref:propertyAssignment applies. 
That is, for the following expression

code[
	myObj.myProperty
]

the compiler first looks for an accessible field in the static type of myObj. If no such field exists it looks for a method called code[getMyProperty()] and binds to that if found.
Otherwise such an expression is not bound which results in a compilation error.

section2:ImplicitThis[Implicit 'this' variable]

If the current scope contains a variable named code[this], the compiler will make all its members available to the scope. 
That is if 
code[
	this.myProperty
]
if a valid expression
code[
	myProperty
]
is valid as well and is equivalent. 

section2[Examples]

ul[
	item[foo]
	item[my.foo]
	item[my.foo(x)]
	item[oh.my.foo(bar)]
]

section:Closures[Closures]

A closure is a literal to create anonymous functions. A closure also captures the current scope, so that variables and parameters visible at contruction time can be referred to in the
closure's expression. 

section2[Syntax]

code[
XClosure returns XExpression:
	(JvmFormalParameter (',' JvmFormalParameter)*)? '|' XExpression;
	
JvmFormalParameter returns types::JvmFormalParameter:
	JvmTypeReference? ID;
]

section2:FunctionMapping[Function Mapping]

An Xbase closure is a Java object of one of the Function interfaces shipped with the runtime library of Xbase. There's an interface for ech number of parameters.
The names of the interfaces are 
ul[
	item[Function0<ReturnType> for zero parameters, ]
	item[Function1<Param1Type, ReturnType> for one parameters, ]
	item[Function2<Param1Type, Param2Type, ReturnType> for two parameters, ]
	item[... ]
	item[Function6<Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type, ReturnType> for seven parameters, ]
]

To be discussed: In order to allow seamless integration with Google Guava (formerly known as Google Collect) and Google Guice the code[Function1] extends code[com.google.common.base.Function<F, T>] and the
e[Function0] extends code[com.google.common.base.Supplier<T>] as well as code[com.google.inject.Provider<T>].

section2:ClosuresTypeInference[Type Inference]

Closures are expressions which produce function objects. The type is a ref:FunctionTypes[function type], consisting of the types of the parameters as well as the types of the return type.
The return type is never specified explicitly but is always inferred from the expression. The parameter types can be inferred if the closure is used in a context where this is possible.

For instance, given the following Java method signature:
code[
	public T <T>getFirst(List<T> list, Function0<T,Boolean> predicate) 
] 

the type of the parameter can be inferred. Which allows users to write:
code[
	getFirst(arrayList("Foo","Bar"), e|e=="Bar")
]
instead of 
code[
	getFirst(arrayList("Foo","Bar"), String e|e=="Bar")
]

section2[Examples]

ul[
	item[| "foo"   // closure without parameters]
	item[String s | s.toUpperCase() // explicit argument type]
	item[a,b,a | a+b+c  // inferred argument types]
]

section:IfExpression[If Expression]

The If expressions are used to choose two different values, based on a predicate.
They are like if statements in java, but they are expressions. This means they always return a value and have a return type. Also this allows
to use if clauses deeply nested within expressions. 

section2[Syntax]

code[
XIfExpression:
	'if' '(' p=XExpression ')'
		e1=XExpression
	('else' e2=XExpression)?;
]

An expression code[if (p) e1 else e2] results to either the value code[e1] or code[e2] depending on whether the predicate code[p] evaluates to code[true] or code[false]. 
The else part is optional which is a shorthand for 'else null'.
That is 
code[
	if (foo) x // is the same as 'if (foo) x else null'
]

section2:IfTypeInference[Type Inference]

The type of an if expression is calculated by the return types code[T1] and code[T2] of the two expression code[e1] and code[e2].
ol[
	item[If the T1 == T2 the type of the if expression is T1]
	item[If one T1==java.lang.Void the type of if expression is T2]	 
	item[If one T2==java.lang.Void the type of if expression is T1]	 
	item[If both T1!=T2, the expected type T3 of the current context is used and it is checked whether T1 and T2 are both assignable to T3]	 
]

section2[Examples]

ul[
	item[if (isFoo) this else that]
	item[if (isFoo) this else if (thatFoo) that else other]
	item[if (isFoo) this]
]

section:SwitchExpression[Switch Expression]

section2[Syntax]

code[
XSwitchExpression:
	'switch' main=XExpression? '{'
		cases+=XCasePart+
		('default' (default=XBlockExpression 
			  | ':' default=XExpression ';'))?
	'}';

XCasePart:
	type=JvmTypeReference? 'case' guard=XExpression 
	(then=XBlockExpression | ':' then=XExpression ';');

XTypeCasePart:
	'instanceof' type=JvmTypeReference ':' then=XExpression;	
]

The switch statement is a bit different then the one in Java. First there is no fall through, which means only one case is evaluated at most.
Second the use of switch is not limited to certain values, but instead can be used for any object reference. 
For a switch expression 
code[
	switch e {
		case e1 : er1
		case e2 : er2
		...
		case en : ern
		default : er
	}
]

first the main expression code[e] is evaluated and then each case sequentially. 
If a case expression code[en] evaluates to something such that code[e == en] the result of the whole switch expression is code[ern]. If non of the 
case expressions code[e1...en] was equal to the result of the main expression code[e], the result of the default part code[er] is returned.

section2[Leaving out the main expression]

It is possible to leave out the main expression. Then the case expressions code[e1...en] have to be of type Boolean. They are evaluated 
in the specified order and as soon as one predicate code[ex] evaluates to true the corresponding then expression code[ex] is the result of the switch expression.

section2[Inline polymorphic dispatch]

Xbase allows to use class clauses instead of case clauses. The effect will be an inlined polymorphic dispatch, that is a value is taken depending on the runtime type of the main 
expression  code[e]. At compile time this has the effect that the type of code[e] if used in some code[erx] will be code[tx] instead of the statically computed type of code[e]. 

Example:
code[
	{
	var Object x = ...;
	switch x {
		instanceof String : x.length()
		instanceof List<?> : x.size()
		default : -1
	}
]

section2[Type inference]

The return type of a switch expression is computed similarly to how the type of an if expression is computed. 
ol[
	item[If all types of code[er1 ... ern] are the same or some are of type code[java.lang.Void], the type of the switch expression is the type of the first one which is not code[java.lang.Void].]
	item[if the types are different the context type is used and it is ensured at compilation time, that each code[erx] is assignable to that type.]	 
]

section:VariableDeclaration[Variable Declarations]

Variable Declarations are only allowed within a ref:Blocks[Block]. 

section2[Syntax]

code[
XVariableDeclaration:
	('val' | 'var') JvmTypeReference ID '=' XExpression;
]

By default all local variables are considered final which is unlike as it is in Java where variables or non-final by default.
In order to make a variable non-final, such that it is possible to use them on the left hand side of an assignment ref:propertyAssignment one has to add the keyword 'nonfinal' to the declaration.

code[
	nonfinal var i = 0;
]

section2[Type Inference]

The type of a variable declaration would only be interesting in case the declaration is the last expression of a block, which doesn't make sense and results in a compile time error.
However, the type of the variable can be defined in two way. It can be explicitly declared like in the following:
code[
	var List<String> msg = new ArrayList<String>(); 
]
In such cases, the right hand expression's type must be assignable to the type on the left hand side. 

Alternatively the type can be left off and corresponds to the type of the initialization expression:  
code[
	var msg = new ArrayList<String>(); // -> type ArrayList<String>  
]

section:Blocks[Blocks]

The block expression allows to simulate imperative code sequences. It conists of a sequence of expressions, and returns the value of the last expression.
The return type of a block is also the type of the last expression. 
Variable declarations are only possible within blocks.

section2[Syntax]

code[
XBlockExpression:
	'{'
		(expressions+=XExpressionInsideBlock ';')+
	'}';
] 

A block expression is surrounded by curly braces and contains at least one expression. Each expression is terminated with a semicolon.

section2[Examples]

ul[
	item[
	{
		doSideEffect("foo");
		result;
	}
	]
	item[
	{
		var x = greeting();
		if ((x.equals("Hello ")) {
			x+"World!"; 
		} else {
			x
		};
	}
	]
]

section:WhileExpression[While Loop]

A while loop code[while (p) e] is used to execute a certain expression code[e] unless a given predicate code[p] is evaluated to code[false].
The return type of a while loop is code[java.lang.Void] and the return value is code[null].

section2[Syntax]

code[
XWhileExpression:
	'while' '(' predicate=XExpression ')'
		body=XExpression;
] 

section2[Examples]

ul[
	item[
	while (true) {
		doSideEffect("foo");
	}
	]
	item[
	while ((i=i+1)<max) doSideEffect("foo")
	]
]

section:DoWhileExpression[Do-While Loop]

A do-while loop code[do e while (p)] is used to execute a certain expression code[e] unless a given predicate code[p] is evaluated to code[false].
The difference to the ref:WhileExpression[while loop] is that the execution starts by executing the block once before evaluating the predicate for the first time.
The return type of a do-while loop is code[java.lang.Void] and the return value is code[null].

section2[Syntax]

code[
XDoWhileExpression:
	'do'
		body=XExpression
	'while' '(' predicate=XExpression ')';
] 

section2[Examples]

ul[
	item[
	do {
		doSideEffect("foo");
	} while (true)
	]
	item[
	do doSideEffect("foo") while ((i=i+1)<max)
	]
]

section:ForLoop[For Loop]

The for loop code[for (T1 var : iterableOfT1) e] is used to execute a certain expression code[e] for each element of an code[java.lang.Iterable].
The return type of a for loop is code[java.lang.Void] and the return value is code[null].

section2[Syntax]

code[
XForExpression:
	'for' '(' var=JvmFormalParameter ':' iterable=XExpression ')' 
		body=XExpression
	;
] 

section2[Type Inference]

The type of the local variable can be left out. In that case it is inferred from the type of the code[java.lang.Iterable] returned by the iterable expression.

section2[Examples]

ul[
	item[code[for (String s : myStrings) {
	doSideEffect(s);
}]]
	item[
		code[
			for (s : myStrings)
				doSideEffect(s)
		]
	]
]

section:ConstructorCall[Constructor Call]



section2[Syntax]

code[
XConstructorCall:
  'new' (type=JvmTypeReference '('(XExpression (',' XExpression)*)?')')?;
]

section2[Example]

code[
	new Foo()
]
