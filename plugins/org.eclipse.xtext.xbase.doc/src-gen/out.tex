\documentclass[a4paper,10pt]{scrreprt}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}

%%\usepackage{helvet}

\lstdefinelanguage{Xtext}
  {morekeywords={grammar, generate, import, as, terminal, hidden},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
  }

\lstdefinelanguage{Xbase}
  {morekeywords={extends, instanceof, new, null, true, false, if, else, switch, case, default, do, while, for, def, class, as},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
  }

%\lstdefinelanguage{xtext}{keywords={terminal, grammar, import, generate, hidden, as}, sensitive=true,string={"},morestring={'},comment={//},morecomment=[s]{/*}{*/}}

\lstset{breaklines=true, tabsize=4, basicstyle=\sffamily\footnotesize, keywordstyle=\bfseries, language=Xbase}

\usepackage[english]{babel}

% import this as last package
\usepackage{hyperref}

\newlength{\itemindentlen}

\begin{document}

\chapter{Preface}
\label{Preface}
This document specifies the expression language library Xbase. Xbase is a partial programming language implemented in Xtext and is ment to be embedded and extended
 within other programming languages and domain-specific languages (DSL) written in Xtext. Xtext is a highly extendable language development framework 
covering all aspects of language infrastructure such as parsers, linkers, compilers, interpreters and even full-blown IDE support based on Eclipse.  

Developing DSLs has become incredibly easy with Xtext. Defining structural languages which introduce new coarse-grained concepts, such as services, entities, value objects or 
statemachines is no problem at all and can be done in minutes. However, software systems do not consist of structures solily. At some point a system needs to do something, hence
we want to specify some behavior which is usually done using so called expressions. Expressions are really the heart of a programming language and are not so easy to get right.
That is why most people don't add support for expressions in their DSL, but try to solve this differently. The most often used workaround is to only define the structural information in the DSL 
and add behavior by modifying or extending the generated code. It is not only unpleasant to write, read and maintain information which closely belongs together in two different places, abstraction levels 
and languages. Modifying the generated source code comes with a lot of additional problems. But still as of today this is the preferred solution since adding support for expressions (and
 a corresponding compiler) for your language is hard - even with Xtext.

Xbase serves as a language library providing a common expression language bound to the Java platform (i.e. Java Virtual Machine). It ships in form of an Xtext grammar, as well as 
reusable and adaptable implementations for the different aspects of a language infrastructure such as an AST structure, a compiler, an interpreter, a linker, and a static analyzer.
In addition it comes with implementations to integrate the expression language within an Xtext-based Eclipse IDE. Default implementations for aspects like content assistance, syntax coloring, 
hovering, folding and navigation can be easily integrated and reused within any Xtext based language. 

Conceptually and syntactically, Xbase is like Java statements+expressions, with the following differences:

\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
No checked exceptions
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Pure OO, i.e. no built-in types (incl. arrays) 
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Everything is an expression (no statements)
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Closures
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Type inference
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Properties
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Simple operator overloading
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Powerful switch expression
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}



\chapter{Lexical Syntax}

Xbase comes with a small set of lexer rules, which can be overridden and hence changed by users. However the default implementation is carefully choosen and it is recommended to stick 
with the lexical syntax described in the following.

\section{Identifiers}
\label{Identifiers}
Identifiers are used to name all constructs, such as types, methods and variables. They start with a "Java letter", which is a character for which the Java method 
\lstinline|Character.isJavaIdentifierstart(char)|

returns true. For the other characters also digits (0-9) are allowed. For those the method \lstinline|Character.isJavaIdentifierPart(char)|
 must be true.
See \href{http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.8}{§ 3.8 Identifiers} for the original definition in the Java Language Specification.

\subsection{Syntax}

\begin{lstlisting}
//TODO

\end{lstlisting}





\subsection{Escaped Identifiers}

Identifiers may not have the same spelling than any reserved keywords. 
However, Identifiers starting with a \lstinline|^|
 are so called escaped identifiers. Escaped identifiers are used in cases when there is a 
conflict with a reserved keyword. Imagine you had introduced a keyword 'service' in your language but want at some point call a Java property 'service'. 
In such cases you use an escaped identifier \lstinline|^service|
 to reference the Java property.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
Foo
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Foo42
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
FOO
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
\_42
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
\_foo
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
\textasciicircum{}extends
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{String Literals}
\label{StringLiterals}
String literals can either use single quotes (') or double quotes (") as their terminals. When using double quotes all literals allowed by Java string literals are
supported. In addition new line characters are allowed, that is in Xbase all string literals can span multiple lines. When using single quotes the only difference
is that singlequotes within the literal have to be escaped and double quotes don't.

See \href{http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.10.5}{§ 3.10.5 String Literals}

In contrast to Java, equal string literals within the same class do not neccessarily refer to the same instance at runtime.

\subsection{Syntax}

\begin{lstlisting}
//TODO

\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
'Foo Bar Baz'
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
"Foo Bar Baz"
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
" the quick brown fox 
		   jumps over the lazy dog."
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
'Escapes : \textbackslash{}' '
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
"Escapes : \textbackslash{}" "
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Integer Literals}
\label{IntegerLiterals}
Integer Literals consists of one or more digits. 
Only decimal literals are supported and they always result in a value of type java.lang.Integer 
(it might result in native type int when transalated to Java, see 
\autoref{Types}).

\subsection{Syntax}

\begin{lstlisting}
terminal INT returns ecore::EInt: 
	('0'..'9')+
;

\end{lstlisting}







\section{Comments}
\label{Comments}
Xbase comes with two different kinds of comments: Single-line comments and multi-line comments.
The syntax is the same as the one known from Java (see \href{http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.7}{§ 3.7 Comments})

\subsection{Syntax}

\begin{lstlisting}
terminal ML_COMMENT	: 
	'/*' -> '*/'
;
terminal SL_COMMENT : 
	'//' !('\n'|'\r')* ('\r'? '\n')?
;

\end{lstlisting}







\section{White Space}
\label{Whitespace}
Xbase ignores all white space.




\section{Reserved Keywords}
\label{Keywords}
The following list of words are reserved keywords, that reducing the set of possible identifiers:

\setlength{\itemindentlen}{\textwidth}
\begin{enumerate}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
extends
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
instanceof
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
new
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
null
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
false
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
true
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
if
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
else
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
switch
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
case
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
default
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
while
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
def
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
class
\end{minipage}
\end{enumerate}
\addtolength{\itemindentlen}{2em}

However, in case some of the keywords have to be used as identifiers at times, the escape character of 
\hyperref[Identifiers]{identifiers~(\ref*{Identifiers})} come in handy. 





\chapter{Types}
\label{Types}
Xbase binds to the Java Virtual Machine. This means that expressions written in Xbase refer to Java types and Java type members. Xbase itself uses only types 
defined in the Java language, such as classes, interfaces, annotations and enums. It also resembles Java generics and shares the known syntax. In addition to Java, Xbase comes with the
notion of function types, that is the type of a function. 

Xbase does bind to any of the built-in types such as \textit{int} or \textit{boolean}, instead any references to those built-in types will automatically use the corresponding wrapper type,
that is \textit{java.lang.Boolean} instead of \textit{boolean}. Also Arrays are supported in Xbase but are translated to a \textit{java.util.List}. For example an array \textit{int[]} binds to  
\textit{java.util.List<java.lang.Integer>} (in short \textit{List<Integer>}). 
This means when refering to \lstinline|myList.isEmpty()|
 within an Xbase expression the static return type is \textit{java.lang.Boolean}. 
At runtime however the compiler may be smarter and may use the native types. Especially the types \textit{int} and \textit{boolean} are most often used using there built-in operators
and the wrapper type is only occasionally needed (for instance when putting ints in collections).

\section{Simple Type References}
\label{TypeReferences}
A simple type reference only consists of a qualified name. A qualified name is a name made up of identifiers which are separated by a dot (like in Java).

\subsection{Syntax}

\begin{lstlisting}
QualifiedName:
  ID ('.' ID)*
;	

\end{lstlisting}


There's no rule for a simple type reference, as it is expressed as a parameterized type references without paramters.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
java.lang.String
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
String
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Function Types}
\label{FunctionTypes}
Xbase introduces closures, which need a special kind of type. On the Jvm-Level a closures (or more generally any function object) is just an instance of one of the 
types in \lstinline|org.eclipse.xtext.xbase.lib.Function*|
, dependening on the number of arguments. However, as closures are a very important language feature, and
it would be very inconvenient to write \lstinline|Function3<String,String,String,Boolean>|
 the syntax for funtcion types has been introduced. 
So instead of writing \lstinline|Function<String,Boolean>|
 one can write \lstinline|(String)=>Boolean|
 instead.

\subsection{Syntax}

\begin{lstlisting}
XFunctionTypeRef:
  ('('JvmTypeReference (',' JvmTypeReference)*')')? 
  	'=>' JvmTypeReference;

\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
=>Boolean // predicate without parameters
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
(String)=>Boolean // One argument predicate
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
(Mutable)=>Void // A method doing sideffects on an instance of Mutable and returns null
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
(List<String>)=>String
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Parameterized Type References}
\label{ParameterizedTypeReference}
The general syntax for type references allows to take any number of type arguments. The semantics as well as the syntax is exactly the same as in Java, so please 
refer to the third edition of the  \href{http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html}{Java Language Specification} which is available online for free.

The only difference is, that in Xbase a type reference can also be a function type. In the following the full syntax fo type references is shown, including function types and
type arguments.

\subsection{Syntax}

\begin{lstlisting}
JvmTypeReference:
  JvmParameterizedTypeReference|XFunctionTypeRef;
	
XFunctionTypeRef:
  ('(' JvmTypeReference (',' JvmTypeReference)* ')')? 
  	'=>' JvmTypeReference;

JvmParameterizedTypeReference:
  type=QualifiedName ('<' JvmTypeArgument (',' JvmTypeArgument)* '>')?;

JvmTypeArgument:
  JvmReferenceTypeArgument|JvmWildcardTypeArgument;
  
JvmReferenceTypeArgument :
  JvmTypeReference;

JvmWildcardTypeArgument:
  '?' (JvmUpperBound | JvmLowerBound)?;

JvmLowerBound :
 'super' JvmTypeReference;

JvmUpperBound : 
 'extends' JvmTypeReference;


\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
String
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
java.lang.String
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
List<?>
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
List<? extends Comparable<? extends FooBar>
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
List<? super MyLowerBound>
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
List<? extends =>Boolean>
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{The type java.lang.Void}
\label{VoidType}
The \lstinline|null|
 reference is the only valid value of the type Void, which gets some special treatment in Xbase. That is every Java method which is declared \textit{void} (i.e. without a return value)
is translated to a method with return type \textit{java.lang.Void}. At runtime such method invocations will result in \textit{null}.
The speciality is that while it is allowed to pass \lstinline|null|
 everywhere (TODO discuss use of nullable annotation) instead of any other value, this does not mean that \textit{java.lang.Void}
is a subtype of any other type. The \lstinline|instanceOf|
 operator as well as the type matchers in the 
\autoref{SwitchExpression} don't match \lstinline|null|
. 





\chapter{Expressions}
\label{Expressions}
Expressions are the main language constructs which are used to express behavior and computation of values. Xbase doesn't support the concept of a statement, but instead comes with powerful 
expressions to handle situations in which the imperative nature of statements are a better fit. An expression always results in a value (might be the value 'null' though). In addition expressions can
be statically typed. That is by default it is assumed that languages making use of Xbase provide enough static context infromation to allow for static type analysis, which is the basis of a lot of
IDE features coming with Xbase for free. However, the static typing is not mandatory and might be completely skipped if not wished. The openess of the compiler even allows to change the generation of 
concrete feature invocations to reflective calls, so that the language can be fully dynamically typed.

\section{Literals}
\label{Literals}
A literal denotes a fixed unchangeable value. Xbase comes with the following literals

\subsection{String Literals}
\label{ExpressionsStringLiterals}
A string literal as defined in 
\autoref{StringLiterals} is a valid expression and returns an instance of \lstinline|java.lang.String|
 of the given value.




\subsection{Integer Literals}
\label{ExpressionsIntegerLiterals}
An integer literal as defined in 
\autoref{IntegerLiterals} creates an instance of \lstinline|Integer|
.




\subsection{Boolean Literals}
\label{BooleanLiteral}
There are two boolean literals, \lstinline|true|
 and \lstinline|false|
 which each correspond to their Java counterpart of type \textit{java.lang.Boolean}. 




\subsection{Syntax}

\begin{lstlisting}
XBooleanLiteral:
	{XBooleanLiteral} 'false' | isTrue?='true';

\end{lstlisting}





\subsection{Null Literal}
\label{NullLiteral}
The null pointer literal again is like in Java: \lstinline|null|
. 
It is the only value of the type \textit{java.lang.Void} which has some special meaning in Xbase (see 
\autoref{VoidType}).




\subsection{Syntax}

\begin{lstlisting}
XNullLiteral:
	{XNullLiteral} 'null';

\end{lstlisting}





\subsection{Type Literals}
\label{TypeLiteral}
Also type literals are written like in Java, that is it it consists of a reference to a raw type suffixed with a dot and the keyword \lstinline|class|
.




\subsection{Syntax}

\begin{lstlisting}
XTypeLiteral:
	type=[types::JvmType|QualifiedName] '.' 'class';
 
\end{lstlisting}







\section{Infix Operators}
\label{Operators}
Xbase supports the usual infix operators as well as some additional operators known from other languages. In contrast to Java, the operators are not fixed
to operations on certain types, but instead Xbase comes with an operator to method mapping, which allows users to redefine the operators for any type just by implementing
the corresponding method signature. The following defines the operators and the corresponding method signatures.


\begin{tabular}{|p{0.5\textwidth}|p{0.5\textwidth}|}
\lstinline|e1.someProp = e2|
 & \lstinline|e1.someProp = e2|
\\
  & \lstinline|e1.someProp(e2)|
\\
  & \lstinline|e1.setSomeProp(e2)|
\\
\lstinline|e1 += e2|
 & \lstinline|e1.add(e2)|
\\
\lstinline|e1.someFeature += e2|
 & \lstinline|e1.addSomeFeature(e2)|
\\
\lstinline| |
 & \lstinline| |
\\
\lstinline|e1 || e2|
 & \lstinline|e1.or(e2)|
\\
\lstinline| |
 & \lstinline| |
\\
\lstinline|e1 && e2|
 & \lstinline|e1.and(e2)|
\\
\lstinline| |
 & \lstinline| |
\\
\lstinline|e1 instanceof RawTypeRef|
 & \lstinline|e1 instanceof RawTypeRef /* direct translation to Java */|
\\
\lstinline|e1 == e2|
 & \lstinline|e1.equals(e2)|
\\
\lstinline|e1 != e2|
 & \lstinline|e1.notEquals(e2)|
\\
\lstinline|e1 < e2|
 & \lstinline|e1.lessThan(e2)|
\\
\lstinline|e1 > e2|
 & \lstinline|e1.greaterThan(e2)|
\\
\lstinline|e1 <= e2|
 & \lstinline|e1.lessEqualsThan(e2)|
\\
\lstinline|e1 >= e2|
 & \lstinline|e1.greaterEqualsThan(e2)|
\\
\lstinline| |
 & \lstinline| |
\\
\lstinline|e1 -> e2|
 & \lstinline|e1.mappedTo(e2)|
\\
\lstinline|e1 .. e2|
 & \lstinline|e1.upTo(e2)|
\\
\lstinline| |
 & \lstinline| |
\\
\lstinline|e1 + e2|
 & \lstinline|e1.plus(e2)|
\\
\lstinline|e1 - e2|
 & \lstinline|e1.minus(e2)|
\\
\lstinline| |
 & \lstinline| |
\\
\lstinline|e1 * e2|
 & \lstinline|e1.multiply(e2)|
\\
\lstinline|e1 / e2|
 & \lstinline|e1.divide(e2)|
\\
\lstinline|e1 % e2|
 & \lstinline|e1.modulo(e2)|
\\
\lstinline|e1 ** e2|
 & \lstinline|e1.power(e2)|
\\
\lstinline| |
 & \lstinline| |
\\
\lstinline|! e1|
 & \lstinline|e1.not()|
\\
\lstinline|- e1|
 & \lstinline|e1.minus()|
\\
\lstinline| |
 & \lstinline| |
\\
\lstinline|e1[e2]|
 & \lstinline|e1.apply(<Exp2)|

\end{tabular}

		
The table above also defines the operator precedence (fom low to high precedence). The separator lines indicate a precedence level. 
The two assignment operators \lstinline|=|
 and \lstinline|+=|
 are right-to-left associative, that is a = b = c is executed as a = (b = c), all other
operators are left-to-right associative. Parenthesis can be used to adjust the default precedence and associativity. 

\subsection{Property Assignment}
\label{propertyAssignment}
The translation rule for the simple assignment operator \lstinline|=|
 is a bit more complicated.
Given the expression 

\begin{lstlisting}
myObj.myProperty = "foo"

\end{lstlisting}


It first looks up whether, there is an accessible Java Field called \lstinline|myProperty|
 on the type of \lstinline|myObj|
. If there is one it translates to
the following Java expression :

\begin{lstlisting} [language=Java]
myObj.myProperty = "foo";

\end{lstlisting}


Remember in Xbase everything is an expression and has to return something. In the case of simple assignments the return value is the value returned from the corresponding
Java expression, which is the assigned value.

If there is no accessible field on the left operands type, first a method called \lstinline|myProperty(OneArg)|
 and then \lstinline|setMyProperty(OneArg)|
 is looked up. It has to take 
one argument of the type (or a super type) of the right hand operand. The return value will be whatever the setter method returns (usually null i.e. type \lstinline|java.lang.Void|
). 
As a result the compiler translates to :

\begin{lstlisting} [language=Java]
myObj.setMyProperty("foo")

\end{lstlisting}





\subsection{Add Assignment}
\label{addAssignment}
The translation rule for the add assignment operator \lstinline|+=|
 is as follows:
Given the expression 

\begin{lstlisting}
myObj.myProperty += "foo"

\end{lstlisting}


It first looks up whether, the left hand side operand is of type \textit{java.util.Collection}. If it is the expression above translates to
the following Java expression :

\begin{lstlisting} [language=Java]
myObj.myProperty.add("foo");

\end{lstlisting}


If there's no such field, the compiler looks for a method called \lstinline|addMyProperty(OneArg)|
.




\subsection{Short-Circuit Boolean Operators}

If the operators \lstinline||||
 and \lstinline|&&|
 are used in a context where both operands are of type boolean, the operation supports short circuit.
That is 

\setlength{\itemindentlen}{\textwidth}
\begin{enumerate}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
in the case of \lstinline||||
 the operand on the right hand side is not evaluated if the left operand evaluates to \lstinline|true|
.
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
in the case of \lstinline|&&|
 the operand on the right hand side is not evaluated if the left operand evaluates to \lstinline|false|
.
\end{minipage}
\end{enumerate}
\addtolength{\itemindentlen}{2em}
 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
my.foo = 23
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
myList += 23
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
x > 23 \&\& y < 23
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
x \&\& y || z
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
1 + 3 * 5 * (- 23)
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
!(x
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
my.foo = 23
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
my.foo = 23
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Feature Calls}
\label{FeatureCalls}
A feature call is used to invoke members of objects, such as fields and methods, but also can refer to local variables and parameters, which are made available for the current expression's scope.

\subsection{Syntax}

The following snippet is a simplification of the real Xtext rules, which cover more than the concrete syntax.
\begin{lstlisting}
FeatureCall :
	ID |
	Expression ('.' ID ('(' Expression (',' Expression)* ')')?)*

\end{lstlisting}





\subsection{Property Access}
\label{PropertyAccess}
Feature calls are directly translated to their Java equivalent with the exception, that for calls to properties an equivalent rule as described in 
\autoref{propertyAssignment} applies. 
That is, for the following expression

\begin{lstlisting}
myObj.myProperty

\end{lstlisting}


the compiler first looks for an accessible field in the static type of myObj. If no such field exists it looks for a method called \lstinline|getMyProperty()|
 and binds to that if found.
Otherwise such an expression is not bound which results in a compilation error.




\subsection{Implicit 'this' variable}
\label{ImplicitThis}
If the current scope contains a variable named \lstinline|this|
, the compiler will make all its members available to the scope. 
That is if 
\begin{lstlisting}
this.myProperty

\end{lstlisting}

if a valid expression
\begin{lstlisting}
myProperty

\end{lstlisting}

is valid as well and is equivalent. 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
foo
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
my.foo
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
my.foo(x)
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
oh.my.foo(bar)
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Closures}
\label{Closures}
A closure is a literal to create anonymous functions. A closure also captures the current scope, so that variables and parameters visible at contruction time can be referred to in the
closure's expression. 

\subsection{Syntax}

\begin{lstlisting}
XClosure returns XExpression:
	(JvmFormalParameter (',' JvmFormalParameter)*)? '|' XExpression;
	
JvmFormalParameter returns types::JvmFormalParameter:
	JvmTypeReference? ID;

\end{lstlisting}





\subsection{Function Mapping}
\label{FunctionMapping}
An Xbase closure is a Java object of one of the Function interfaces shipped with the runtime library of Xbase. There's an interface for ech number of parameters.
The names of the interfaces are 

\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
Function0<ReturnType> for zero parameters, 
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Function1<Param1Type, ReturnType> for one parameters, 
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Function2<Param1Type, Param2Type, ReturnType> for two parameters, 
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
... 
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Function6<Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type, ReturnType> for seven parameters, 
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}

To be discussed: In order to allow seamless integration with Google Guava (formerly known as Google Collect) and Google Guice the \lstinline|Function1|
 extends \lstinline|com.google.common.base.Function<F, T>|
 and the
\textit{Function0} extends \lstinline|com.google.common.base.Supplier<T>|
 as well as \lstinline|com.google.inject.Provider<T>|
.




\subsection{Type Inference}
\label{ClosuresTypeInference}
Closures are expressions which produce function objects. The type is a 
\hyperref[FunctionTypes]{function type~(\ref*{FunctionTypes})}, consisting of the types of the parameters as well as the types of the return type.
The return type is never specified explicitly but is always inferred from the expression. The parameter types can be inferred if the closure is used in a context where this is possible.

For instance, given the following Java method signature:
\begin{lstlisting}
public T <T>getFirst(List<T> list, Function0<T,Boolean> predicate) 

\end{lstlisting}
 

the type of the parameter can be inferred. Which allows users to write:
\begin{lstlisting}
getFirst(arrayList("Foo","Bar"), e|e=="Bar")

\end{lstlisting}

instead of 
\begin{lstlisting}
getFirst(arrayList("Foo","Bar"), String e|e=="Bar")

\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
| "foo"   // closure without parameters
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
String s | s.toUpperCase() // explicit argument type
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
a,b,a | a+b+c  // inferred argument types
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{If Expression}
\label{IfExpression}
The If expressions are used to choose two different values, based on a predicate.
They are like if statements in java, but they are expressions. This means they always return a value and have a return type. Also this allows
to use if clauses deeply nested within expressions. 

\subsection{Syntax}

\begin{lstlisting}
XIfExpression:
	'if' '(' p=XExpression ')'
		e1=XExpression
	('else' e2=XExpression)?;

\end{lstlisting}


An expression \lstinline|if (p) e1 else e2|
 results to either the value \lstinline|e1|
 or \lstinline|e2|
 depending on whether the predicate \lstinline|p|
 evaluates to \lstinline|true|
 or \lstinline|false|
. 
The else part is optional which is a shorthand for 'else null'.
That is 
\begin{lstlisting}
if (foo) x // is the same as 'if (foo) x else null'

\end{lstlisting}





\subsection{Type Inference}
\label{IfTypeInference}
The type of an if expression is calculated by the return types \lstinline|T1|
 and \lstinline|T2|
 of the two expression \lstinline|e1|
 and \lstinline|e2|
.

\setlength{\itemindentlen}{\textwidth}
\begin{enumerate}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
If the T1 == T2 the type of the if expression is T1
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
If one T1==java.lang.Void the type of if expression is T2
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
If one T2==java.lang.Void the type of if expression is T1
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
If both T1!=T2, the expected type T3 of the current context is used and it is checked whether T1 and T2 are both assignable to T3
\end{minipage}
\end{enumerate}
\addtolength{\itemindentlen}{2em}




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
if (isFoo) this else that
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
if (isFoo) this else if (thatFoo) that else other
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
if (isFoo) this
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Switch Expression}
\label{SwitchExpression}


\subsection{Syntax}

\begin{lstlisting}
XSwitchExpression:
	'switch' main=XExpression? '{'
		cases+=XCasePart+
		('default' (default=XBlockExpression 
			  | ':' default=XExpression ';'))?
	'}';

XCasePart:
	type=JvmTypeReference? 'case' guard=XExpression 
	(then=XBlockExpression | ':' then=XExpression ';');

XTypeCasePart:
	'instanceof' type=JvmTypeReference ':' then=XExpression;	

\end{lstlisting}


The switch statement is a bit different then the one in Java. First there is no fall through, which means only one case is evaluated at most.
Second the use of switch is not limited to certain values, but instead can be used for any object reference. 
For a switch expression 
\begin{lstlisting}
switch e {
	case e1 : er1
	case e2 : er2
	...
	case en : ern
	default : er
}

\end{lstlisting}


first the main expression \lstinline|e|
 is evaluated and then each case sequentially. 
If a case expression \lstinline|en|
 evaluates to something such that \lstinline|e == en|
 the result of the whole switch expression is \lstinline|ern|
. If non of the 
case expressions \lstinline|e1...en|
 was equal to the result of the main expression \lstinline|e|
, the result of the default part \lstinline|er|
 is returned.




\subsection{Leaving out the main expression}

It is possible to leave out the main expression. Then the case expressions \lstinline|e1...en|
 have to be of type Boolean. They are evaluated 
in the specified order and as soon as one predicate \lstinline|ex|
 evaluates to true the corresponding then expression \lstinline|ex|
 is the result of the switch expression.




\subsection{Inline polymorphic dispatch}

Xbase allows to use class clauses instead of case clauses. The effect will be an inlined polymorphic dispatch, that is a value is taken depending on the runtime type of the main 
expression  \lstinline|e|
. At compile time this has the effect that the type of \lstinline|e|
 if used in some \lstinline|erx|
 will be \lstinline|tx|
 instead of the statically computed type of \lstinline|e|
. 

Example:
\begin{lstlisting}
{
var Object x = ...;
switch x {
	instanceof String : x.length()
	instanceof List<?> : x.size()
	default : -1
}

\end{lstlisting}





\subsection{Type inference}

The return type of a switch expression is computed similarly to how the type of an if expression is computed. 

\setlength{\itemindentlen}{\textwidth}
\begin{enumerate}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
If all types of \lstinline|er1 ... ern|
 are the same or some are of type \lstinline|java.lang.Void|
, the type of the switch expression is the type of the first one which is not \lstinline|java.lang.Void|
.
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
if the types are different the context type is used and it is ensured at compilation time, that each \lstinline|erx|
 is assignable to that type.
\end{minipage}
\end{enumerate}
\addtolength{\itemindentlen}{2em}






\section{Variable Declarations}
\label{VariableDeclaration}
Variable Declarations are only allowed within a 
\hyperref[Blocks]{Block~(\ref*{Blocks})}. 

\subsection{Syntax}

\begin{lstlisting}
XVariableDeclaration:
	('val' | 'var') JvmTypeReference ID '=' XExpression;

\end{lstlisting}


By default all local variables are considered final which is unlike as it is in Java where variables or non-final by default.
In order to make a variable non-final, such that it is possible to use them on the left hand side of an assignment 
\autoref{propertyAssignment} one has to add the keyword 'nonfinal' to the declaration.

\begin{lstlisting}
nonfinal var i = 0;

\end{lstlisting}





\subsection{Type Inference}

The type of a variable declaration would only be interesting in case the declaration is the last expression of a block, which doesn't make sense and results in a compile time error.
However, the type of the variable can be defined in two way. It can be explicitly declared like in the following:
\begin{lstlisting}
var List<String> msg = new ArrayList<String>(); 

\end{lstlisting}

In such cases, the right hand expression's type must be assignable to the type on the left hand side. 

Alternatively the type can be left off and corresponds to the type of the initialization expression:  
\begin{lstlisting}
var msg = new ArrayList<String>(); // -> type ArrayList<String>  

\end{lstlisting}







\section{Blocks}
\label{Blocks}
The block expression allows to simulate imperative code sequences. It conists of a sequence of expressions, and returns the value of the last expression.
The return type of a block is also the type of the last expression. 
Variable declarations are only possible within blocks.

\subsection{Syntax}

\begin{lstlisting}
XBlockExpression:
	'{'
		(expressions+=XExpressionInsideBlock ';')+
	'}';

\end{lstlisting}
 

A block expression is surrounded by curly braces and contains at least one expression. Each expression is terminated with a semicolon.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}

	\{
		doSideEffect("foo");
		result;
	\}
	
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}

	\{
		var x = greeting();
		if ((x.equals("Hello ")) \{
			x+"World!"; 
		\} else \{
			x
		\};
	\}
	
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{While Loop}
\label{WhileExpression}
A while loop \lstinline|while (p) e|
 is used to execute a certain expression \lstinline|e|
 unless a given predicate \lstinline|p|
 is evaluated to \lstinline|false|
.
The return type of a while loop is \lstinline|java.lang.Void|
 and the return value is \lstinline|null|
.

\subsection{Syntax}

\begin{lstlisting}
XWhileExpression:
	'while' '(' predicate=XExpression ')'
		body=XExpression;

\end{lstlisting}
 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}

	while (true) \{
		doSideEffect("foo");
	\}
	
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}

	while ((i=i+1)<max) doSideEffect("foo")
	
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Do-While Loop}
\label{DoWhileExpression}
A do-while loop \lstinline|do e while (p)|
 is used to execute a certain expression \lstinline|e|
 unless a given predicate \lstinline|p|
 is evaluated to \lstinline|false|
.
The difference to the 
\hyperref[WhileExpression]{while loop~(\ref*{WhileExpression})} is that the execution starts by executing the block once before evaluating the predicate for the first time.
The return type of a do-while loop is \lstinline|java.lang.Void|
 and the return value is \lstinline|null|
.

\subsection{Syntax}

\begin{lstlisting}
XDoWhileExpression:
	'do'
		body=XExpression
	'while' '(' predicate=XExpression ')';

\end{lstlisting}
 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}

	do \{
		doSideEffect("foo");
	\} while (true)
	
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}

	do doSideEffect("foo") while ((i=i+1)<max)
	
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{For Loop}
\label{ForLoop}
The for loop \lstinline|for (T1 var : iterableOfT1) e|
 is used to execute a certain expression \lstinline|e|
 for each element of an \lstinline|java.lang.Iterable|
.
The return type of a for loop is \lstinline|java.lang.Void|
 and the return value is \lstinline|null|
.

\subsection{Syntax}

\begin{lstlisting}
XForExpression:
	'for' '(' var=JvmFormalParameter ':' iterable=XExpression ')' 
		body=XExpression
	;

\end{lstlisting}
 




\subsection{Type Inference}

The type of the local variable can be left out. In that case it is inferred from the type of the \lstinline|java.lang.Iterable|
 returned by the iterable expression.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\begin{lstlisting}
for (String s : myStrings) {
	doSideEffect(s);
}
\end{lstlisting}

\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}

		\begin{lstlisting}
for (s : myStrings)
	doSideEffect(s)
		
\end{lstlisting}

	
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Constructor Call}
\label{ConstructorCall}


\subsection{Syntax}

\begin{lstlisting}
XConstructorCall:
  'new' (type=JvmTypeReference '('(XExpression (',' XExpression)*)?')')?;

\end{lstlisting}





\subsection{Example}

\begin{lstlisting}
new Foo()

\end{lstlisting}








\end{document}
