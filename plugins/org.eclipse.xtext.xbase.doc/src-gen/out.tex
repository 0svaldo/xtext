\documentclass[a4paper,10pt]{scrreprt}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}

%%\usepackage{helvet}

\lstdefinelanguage{Xtext}
  {morekeywords={grammar, generate, import, as, terminal, hidden},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
  }

\lstdefinelanguage{Xbase}
  {morekeywords={extends, instanceof, new, null, true, false, if, else, switch, case, default, do, while, for, def, class, as},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
  }

%\lstdefinelanguage{xtext}{keywords={terminal, grammar, import, generate, hidden, as}, sensitive=true,string={"},morestring={'},comment={//},morecomment=[s]{/*}{*/}}

\lstset{breaklines=true, tabsize=4, basicstyle=\sffamily\footnotesize, keywordstyle=\bfseries, language=Xbase}

\usepackage[english]{babel}

% import this as last package
\usepackage{hyperref}

\newlength{\itemindentlen}

\begin{document}

\chapter{Preface}
\label{Preface}
This document specifies the programming language library Xbase. Xbase is a partial programming language implemented in Xtext and is ment to be used and extended
 within other programming languages and domain-specific languages (DSL) which are also implemented in Xtext. Xtext is a highly extendable language development framework 
covering all aspects of language infrastructure such as parsers, linkers, compilers, interpreters and even full-blown IDE support based on Eclipse. 

Xbase serves as a language library providing a common expression language bound to the Java platform (i.e. Java Virtual Machine). It ships in form of an Xtext grammar, as well as 
reusable and adaptable implementations for the different aspects of a language infrastructure such as an AST structure, a compiler, an interpreter, a linker,  and  a static analyzer.
In addition it comes with implementations to integrate the expression language within an Xtext-based Eclipse IDE. Default implementations for aspects like content assistance, syntax coloring, 
hovering, folding and navigation can be easily integrated and reused within any Xtext based language. 



\chapter{Lexical Syntax}

Xbase comes with a small set of lexer rules, which can be overridden and hence changed by users. However the default implementation is carefully choosen and it is recommended to stick 
with the lexical syntax described in the following.

\section{Identifiers}
\label{Identifiers}
Identifiers are used to name all constructs, such as types, methods and variables.

\subsection{Syntax}

\begin{lstlisting}
terminal ID  : 
	'^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
;

\end{lstlisting}


Identifiers start with any alphabetic character or an undercore followed by any number of alphabetic characters, underscores or numbers. Identifiers starting with a \lstinline{^}
 are
so called escaped identifiers. Escaped identifiers are used in cases when there is a conflict with a reserved keyword. Imagine you had introduced
a keyword 'service' in your language but want at some point call a Java property 'service'. In such cases you use an escaped identifier \lstinline{^service}
 to reference the Java property.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
Foo
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
Foo42
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
FOO
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
\_42
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
\_foo
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
\textasciicircum{}extends
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{String Literals}
\label{StringLiterals}
In Xbase string literals can span multiple lines. In addition there are two different terminals you can use which allows for avoiding escape sequences as far as possible.
Note that there are no character literals in Xbase.

\subsection{Syntax}

\begin{lstlisting}
terminal STRING	: 
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"' |
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )* "'"
;

\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
'Foo Bar Baz'
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
"Foo Bar Baz"
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
" the quick brown fox 
		   jumps over the lazy dog."
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
'Escapes : \textbackslash\{\}' '
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
"Escapes : \textbackslash\{\}" "
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{Integer Literals}
\label{IntegerLiterals}
Integer Literals consists of one or more digits.

\subsection{Syntax}

\begin{lstlisting}
terminal INT returns ecore::EInt: 
	('0'..'9')+
;

\end{lstlisting}







\section{Comments}
\label{Comments}
Xbase comes with two different kinds of comments: Single-line comments and multi-line comments.
The syntax is the same to the one from Java:

\subsection{Syntax}

\begin{lstlisting}
terminal ML_COMMENT	: 
	'/*' -> '*/'
;
terminal SL_COMMENT : 
	'//' !('\n'|'\r')* ('\r'? '\n')?
;

\end{lstlisting}







\section{White Space}
\label{Whitespace}
Xbase ignores all white space.




\section{Reserved Keywords}
\label{Keywords}
The following list of words are reserved keywords, that reducing the set of possible identifiers:

\setlength{\itemindentlen}{\textwidth}
\begin{enumerate}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
extends
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
instanceof
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
new
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
null
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
false
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
true
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
if
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
else
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
switch
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
case
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
default
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
while
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
def
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
class
\end{minipage}

\end{enumerate}
\addtolength{\itemindentlen}{2em}


However, in case some of the keywords have to be used as identifiers at times, the escape character of 
\hyperref[Identifiers]{identifiers~(\ref*{Identifiers})} come in handy. 





\chapter{Types}
\label{Types}
Xbase binds to the Java Virtual Machine. This means that expressions written in Xbase refer to Java types and Java type members. Xbase itself uses only types 
defined in the Java language, such as classes, interfaces, annotations and enums. It also resembles Java generics and shares the known syntax. In addition to Java, Xbase comes with the
notion of function types, that is the type of a function. 

\section{Simple Type References}
\label{TypeReferences}
A simple type reference only consists of a qualified name. A qualified name is a name made up of identifiers which are separated by a dot (like in Java).

\subsection{Syntax}

\begin{lstlisting}
QualifiedName:
  ID ('.' ID)*
;	

\end{lstlisting}


There's no rule for a simple type reference, as it is expressed as a parameterized type references without paramters.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
java.lang.String
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
String
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{Function Types}
\label{FunctionTypes}
Xbase introduces closures, which need a special kind of type. On the Jvm-Level a closures (or more generally any function object) is just an instance of one of the 
types in \lstinline{org.eclipse.xtext.xbase.lib.Function*}
, dependening on the number of arguments. However, as closures are a very important language feature, and
it would be very inconvenient to write \lstinline{Function3<String,String,String,Boolean>}
 the syntax for funtcion types has been introduced. 
So instead of writing \lstinline{Function<String,Boolean>}
 one can write \lstinline{(String)=>Boolean}
 instead.

\subsection{Syntax}

\begin{lstlisting}
XFunctionTypeRef:
  ('(' parameterTypes+=JvmTypeReference (',' parameterTypes+=JvmTypeReference)* ')')? '=>' returnType+=JvmTypeReference;

\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
=>Boolean // predicate without parameters
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
(String)=>Boolean // One argument predicate
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
(Mutable)=>Void // A method doing sideffects on an instance of Mutable and returns null
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
(List<String>)=>String
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{Parameterized Type References}
\label{ParameterizedTypeReference}
The general syntax for type references allows to take any number of type arguments. The semantics as well as the syntax is exactly the same as in Java, so please 
refer to the third edition of the  \href{http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html}{Java Language Specification} which is available online for free.

The only difference is, that in Xbase a type reference can also be a function type. In the following the full syntax fo type references is shown, including function types and
type arguments.

\subsection{Syntax}

\begin{lstlisting}
JvmTypeReference:
  JvmParameterizedTypeReference|XFunctionTypeRef;
	
XFunctionTypeRef:
  ('(' parameterTypes+=JvmTypeReference (',' parameterTypes+=JvmTypeReference)* ')')? '=>' returnType+=JvmTypeReference;

JvmParameterizedTypeReference:
  type=[JvmType|QualifiedName] ('<' arguments+=JvmTypeArgument (',' arguments+=JvmTypeArgument)* '>')?;

JvmTypeArgument:
  JvmReferenceTypeArgument|JvmWildcardTypeArgument;
  
JvmReferenceTypeArgument :
  typeReference=JvmTypeReference;

JvmWildcardTypeArgument:
  {JvmWildcardTypeArgument} '?' (constraints+=JvmUpperBound | constraints+=JvmLowerBound)?;

JvmLowerBound :
 'super' typeReference=JvmTypeReference;

JvmUpperBound : 
 'extends' typeReference=JvmTypeReference;


\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
String
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
java.lang.String
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
List<?>
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
List<? extends Comparable<? extends FooBar>
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
List<? super MyLowerBound>
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
List<? extends =>Boolean>
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}








\chapter{Expressions}
\label{Expressions}
Expressions are the main language constructs which are used to express behavior and computation of values. Xbase doesn't support the concept of a statement, but instead comes with powerful 
expressions to handle situations in which the imperative nature of statements are a better fit. An expression always results in a value (might be the value 'null' though). In addition expressions can
be statically typed. That is by default it is assumed that languages making use of Xbase provide enough static context infromation to allow for static type analysis, which is the basis of a lot of
IDE features coming with Xbase for free. However, the static typing is not mandatory and might be completely skipped if not wished. The openess of the compiler even allows to change the generation of 
concrete feature invocations to reflective calls, so that the language can be fully dynamically typed.

\section{Literals}
\label{Literals}
A literal denotes a fixed unchangeable value. Xbase comes with the following literals

\subsection{String Literals}
\label{ExpressionsStringLiterals}
A string literal as defined in 
\autoref{StringLiterals} is a valid expression and returns an instance of \lstinline{java.lang.String}
 of the given value.




\subsection{Integer Literals}
\label{ExpressionsIntegerLiterals}
An integer literal as defined in 
\autoref{IntegerLiterals} creates an instance of \lstinline{Integer}
 (TODO discuss how we want to go about the built-in types of Java).




\subsection{Boolean Literals}
\label{BooleanLiteral}
There are two boolean literals, \lstinline{true}
 and \lstinline{false}
 which correspond to the respective Java values of the native type \lstinline{boolean}
 




\subsection{Syntax}

\begin{lstlisting}
XBooleanLiteral:
	{XBooleanLiteral} 'false' | isTrue?='true';

\end{lstlisting}





\subsection{Null Literal}
\label{NullLiteral}
The null pointer literal again is like in Java: \lstinline{null}
. 




\subsection{Syntax}

\begin{lstlisting}
XNullLiteral:
	{XNullLiteral} 'null';

\end{lstlisting}





\subsection{Type Literals}
\label{TypeLiteral}
Also type literals are written like in Java, that is it it consists of a reference to a raw type suffixed with a dot and the keyword \lstinline{class}
.




\subsection{Syntax}

\begin{lstlisting}
XTypeLiteral:
	type=[types::JvmType|QualifiedName] '.' 'class';
 
\end{lstlisting}







\section{Infix Operators}
\label{Operators}
Xbase supports the usual infix operators as well as some additional operators known from other languages. In contrast to Java, the operators are not fixed
to operations on certain types, but instead Xbase comes with an operator to method mapping, which allows users to redefine the operators for any type just by implementing
the corresponding method signature. The following defines the operators and the corresponding method signatures.


\begin{tabular}{p{0.5\textwidth}p{0.5\textwidth}}
<Exp1>.someProp = <Exp2>&<Exp1>.setSomeProp(<Exp2>)\\
<Exp1> += <Exp2>&<Exp1>.add(<Exp2>)\\
 & \\
<Exp1> || <Exp2>&<Exp1>.or(<Exp2>)\\
 & \\
<Exp1> \&\& <Exp2>&<Exp1>.and(<Exp2>)\\
 & \\
<Exp1> instanceof RawTypeRef&<Exp1> instanceof RawTypeRef /* direct translation to Java */\\
<Exp1> == <Exp2>&<Exp1>.equals(<Exp2>)\\
<Exp1> != <Exp2>&<Exp1>.notEquals(<Exp2>)\\
<Exp1> < <Exp2>&<Exp1>.lessThan(<Exp2>)\\
<Exp1> > <Exp2>&<Exp1>.greaterThan(<Exp2>)\\
<Exp1> <= <Exp2>&<Exp1>.lessEqualsThan(<Exp2>)\\
<Exp1> >= <Exp2>&<Exp1>.greaterEqualsThan(<Exp2>)\\
 & \\
<Exp1> -> <Exp2>&<Exp1>.mappedTo(<Exp2>)\\
<Exp1> .. <Exp2>&<Exp1>.upTo(<Exp2>)\\
 & \\
<Exp1> + <Exp2>&<Exp1>.plus(<Exp2>)\\
<Exp1> - <Exp2>&<Exp1>.minus(<Exp2>)\\
 & \\
<Exp1> * <Exp2>&<Exp1>.multiply(<Exp2>)\\
<Exp1> / <Exp2>&<Exp1>.divide(<Exp2>)\\
<Exp1> % <Exp2>&<Exp1>.modulo(<Exp2>)\\
<Exp1> ** <Exp2>&<Exp1>.power(<Exp2>)\\
 & \\
! <Exp1>&<Exp1>.not()\\
- <Exp1>&<Exp1>.minus()\\
 & \\
<Exp1>[<Exp2>]&<Exp1>.apply(<Exp2)
\end{tabular}


		
The table above also defines the operator precedence (fom low to high precedence). The separator lines indicate a precedence level. 
The two assignment operators \lstinline{=}
 and \lstinline{+=}
 are right-to-left associative, that is a = b = c is executed as a = (b = c), all other
operators are left-to-right associative. Parenthesis can be used to adjust the default precedence and associativity. 

\subsection{Property Assignment}
\label{propertyAssignment}
The translation rule for the simple assignment operator \lstinline{=}
 is a bit more complicated.
Given the expression 

\begin{lstlisting}
myObj.myProperty = "foo"

\end{lstlisting}


It first looks up whether, there is an accessible Java Field called \lstinline{myProperty}
 on the type of \lstinline{myObj}
. If there is one it translates to
the following Java expression :

\begin{lstlisting} [language=Java]
myObj.myProperty = "foo";

\end{lstlisting}


Remember in Xbase everything is an expression and has to return something. In the case of simple assignments the return value is the value returned from the corresponding
Java expression, which is the assigned value.

If there is no accessible field on the left operands type, a method called \lstinline{setMyProperty}
 is looked up. It has to take one argument of the type (or a super type) of the right hand operand.
The return value will be whatever the setter method returns (usually null i.e. type \lstinline{java.lang.Void}
). 
As a result the compiler translates to :

\begin{lstlisting} [language=Java]
myObj.setMyProperty("foo")

\end{lstlisting}





\subsection{Short-Circuit Boolean Operators}

If the operators \lstinline{||}
 and \lstinline{&&}
 are used in a context where both operands are of type boolean, the operation supports short circuit.
That is 

\setlength{\itemindentlen}{\textwidth}
\begin{enumerate}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
in the case of \lstinline{||}
 the operand on the right hand side is not evaluated if the left operand evaluates to \lstinline{true}
.
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
in the case of \lstinline{&&}
 the operand on the right hand side is not evaluated if the left operand evaluates to \lstinline{false}
.
\end{minipage}

\end{enumerate}
\addtolength{\itemindentlen}{2em}

 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
my.foo = 23
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
myList += 23
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
x > 23 \&\& y < 23
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
x \&\& y || z
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
1 + 3 * 5 * (- 23)
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
!(x
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
my.foo = 23
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
my.foo = 23
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{Feature Calls}
\label{FeatureCalls}
A feature call is used to invoke members of objects, such as fields and methods, but also can refer to local variables and parameters, which are made available for the current expression's scope.

\subsection{Syntax}

The following snippet is a simplification of the real Xtext rules, which cover more than the concrete syntax.
\begin{lstlisting}
FeatureCall :
	ID |
	Expression ('.' ID ('(' Expression (',' Expression)* ')')?)*

\end{lstlisting}





\subsection{Property Access}
\label{PropertyAccess}
Feature calls are directly translated to their Java equivalent with the exception, that for calls to properties an equivalent rule as described in 
\autoref{propertyAssignment} applies. 
That is, for the following expression

\begin{lstlisting}
myObj.myProperty

\end{lstlisting}


the compiler first looks for an accessible field in the static type of myObj. If no such field exists it looks for a method called \lstinline{getMyProperty()}
 and binds to that if found.
Otherwise such an expression is not bound which results in a compilation error.




\subsection{Implicit 'this' variable}
\label{ImplicitThis}
If the current scope contains a variable named \lstinline{this}
, the compiler will make all its members available to the scope. 
That is if 
\begin{lstlisting}
this.myProperty

\end{lstlisting}

if a valid expression
\begin{lstlisting}
myProperty

\end{lstlisting}

is valid as well and is equivalent. 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
foo
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
my.foo
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
my.foo(x)
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
oh.my.foo(bar)
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{Closures}
\label{Closures}
A closure is a literal to create anonymous functions. A closure also captures the current scope, so that variables and parameters visible at contruction time can be referred to in the
closure's expression. 

\subsection{Syntax}

\begin{lstlisting}
XClosure returns XExpression:
	{XClosure} (params+=JvmFormalParameter (',' params+=JvmFormalParameter)*)? '|' expression=XExpression;
	
JvmFormalParameter returns types::JvmFormalParameter:
	nonfinal?='nonfinal'? (parameterType=JvmTypeReference)? name=ID;

\end{lstlisting}





\subsection{Function Mapping}
\label{FunctionMapping}
An Xbase closure is a Java object of one of the Function interfaces shipped with the runtime library of Xbase. There's an interface for ech number of parameters.
The names of the interfaces are 

\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
Function0<ReturnType> for zero parameters, 
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
Function1<Param1Type, ReturnType> for one parameters, 
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
Function2<Param1Type, Param2Type, ReturnType> for two parameters, 
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
... 
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
Function6<Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type, ReturnType> for seven parameters, 
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}


To be discussed: In order to allow seamless integration with Google Guava (formerly known as Google Collect) and Google Guice the \lstinline{Function1}
 extends \lstinline{com.google.common.base.Function<F, T>}
 and the
\emph{Function0} extends \lstinline{com.google.common.base.Supplier<T>}
 as well as \lstinline{com.google.inject.Provider<T>}
.




\subsection{Type Inference}
\label{ClosuresTypeInference}
Closures are expressions which produce function objects. The type is a 
\hyperref[FunctionTypes]{function type~(\ref*{FunctionTypes})}, consisting of the types of the parameters as well as the types of the return type.
The return type is never specified explicitly but is always inferred from the expression. The parameter types can be inferred if the closure is used in a context where this is possible.

For instance, given the following Java method signature:
\begin{lstlisting}
public T <T>getFirst(List<T> list, Function0<T,Boolean> predicate) 

\end{lstlisting}
 

the type of the parameter can be inferred. Which allows users to write:
\begin{lstlisting}
getFirst(arrayList("Foo","Bar"), e|e=="Bar")

\end{lstlisting}

instead of 
\begin{lstlisting}
getFirst(arrayList("Foo","Bar"), String e|e=="Bar")

\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
| "foo"   // closure without parameters
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
String s | s.toUpperCase() // explicit argument type
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
a,b,a | a+b+c  // inferred argument types
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{If Expression}
\label{IfExpression}
The If expressions are used to choose two different values, based on a predicate.
They are like if statements in java, but they are expressions. This means they always return a value and have a return type. Also this allows
to use if clauses deeply nested within expressions. 

\subsection{Syntax}

\begin{lstlisting}
XIfExpression:
	'if' '(' p=XExpression ')'
		e1=XExpression
	('else' e2=XExpression)?;

\end{lstlisting}


An expression \lstinline{if (p) e1 else e2}
 results to either the value \lstinline{e1}
 or \lstinline{e2}
 depending on whether the predicate \lstinline{p}
 evaluates to \lstinline{true}
 or \lstinline{false}
. 
The else part is optional which is a shorthand for 'else null'.
That is 
\begin{lstlisting}
if (foo) x // is the same as 'if (foo) x else null' 

\end{lstlisting}





\subsection{Type Inference}
\label{IfTypeInference}
The type of an if expression is calculated by the return types \lstinline{T1}
 and \lstinline{T2}
 of the two expression \lstinline{e1}
 and \lstinline{e2}
.

\setlength{\itemindentlen}{\textwidth}
\begin{enumerate}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
If the T1 == T2 the type of the if expression is T1
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
If one T1==java.lang.Void the type of if expression is T2
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
If one T2==java.lang.Void the type of if expression is T1
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
If both T1!=T2, the expected type T3 of the current context is used and it is checked whether T1 and T2 are both assignable to T3
\end{minipage}

\end{enumerate}
\addtolength{\itemindentlen}{2em}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
if (isFoo) this else that
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
if (isFoo) this else if (thatFoo) that else other
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
if (isFoo) this
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{Switch Expression}
\label{SwitchExpression}


\subsection{Syntax}

\begin{lstlisting}
XSwitchExpression:
	'switch' main=XExpression? '{'
		cases+=XCasePart+
		('default' (default=XBlockExpression | ':' default=XExpression ';'))?
	'}';

XCasePart:
	type=JvmTypeReference? 'case' guard=XExpression (then=XBlockExpression | ':' then=XExpression ';');	

XTypeCasePart:
	'instanceof' type=JvmTypeReference ':' then=XExpression;	

\end{lstlisting}


The switch statement is a bit different then the one in Java. First there is no fall through, which means only one case is evaluated at most.
Second the use of switch is not limited to certain values, but instead can be used for any object reference. 
For a switch expression 
\begin{lstlisting}
switch e {
	case e1 : er1
	case e2 : er2
	...
	case en : ern
	default : er
}

\end{lstlisting}


first the main expression \lstinline{e}
 is evaluated and then each case sequentially. 
If a case expression \lstinline{en}
 evaluates to something such that \lstinline{e == en}
 the result of the whole switch expression is \lstinline{ern}
. If non of the 
case expressions \lstinline{e1...en}
 was equal to the result of the main expression \lstinline{e}
, the result of the default part \lstinline{er}
 is returned.




\subsection{Leaving out the main expression}

It is possible to leave out the main expression. Then the case expressions \lstinline{e1...en}
 have to be of type Boolean. They are evaluated 
in the specified order and as soon as one predicate \lstinline{ex}
 evaluates to true the corresponding then expression \lstinline{ex}
 is the result of the switch expression.




\subsection{Inline polymorphic dispatch}

Xbase allows to use class clauses instead of case clauses. The effect will be an inlined polymorphic dispatch, that is a value is taken depending on the runtime type of the main 
expression  \lstinline{e}
. At compile time this has the effect that the type of \lstinline{e}
 if used in some \lstinline{erx}
 will be \lstinline{tx}
 instead of the statically computed type of \lstinline{e}
. 

Example:
\begin{lstlisting}
{
var Object x = ...;
switch x {
	instanceof String : x.length()
	instanceof List<?> : x.size()
	default : -1
}

\end{lstlisting}





\subsection{Type inference}

The return type of a switch expression is computed similarly to how the type of an if expression is computed. 

\setlength{\itemindentlen}{\textwidth}
\begin{enumerate}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
If all types of \lstinline{er1 ... ern}
 are the same or some are of type \lstinline{java.lang.Void}
, the type of the switch expression is the type of the first one which is not \lstinline{java.lang.Void}
.
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}
if the types are different the context type is used and it is ensured at compilation time, that each \lstinline{erx}
 is assignable to that type.
\end{minipage}

\end{enumerate}
\addtolength{\itemindentlen}{2em}







\section{Variable Declarations}
\label{VariableDeclaration}
Variable Declarations are only allowed within a 
\hyperref[Blocks]{Block~(\ref*{Blocks})}. 

\subsection{Syntax}

\begin{lstlisting}
XVariableDeclaration:
	nonfinal?='nonfinal'? 'var' type=JvmTypeReference? name=ID '=' right=XExpression;

\end{lstlisting}


By default all local variables are considered final which is unlike as it is in Java where variables or non-final by default.
In order to make a variable non-final, such that it is possible to use them on the left hand side of an assignment 
\autoref{propertyAssignment} one has to add the keyword 'nonfinal' to the declaration.

\begin{lstlisting}
nonfinal var i = 0;

\end{lstlisting}





\subsection{Type Inference}

The type of a variable declaration would only be interesting in case the declaration is the last expression of a block, which doesn't make sense and results in a compile time error.
However, the type of the variable can be defined in two way. It can be explicitly declared like in the following:
\begin{lstlisting}
var List<String> msg = new ArrayList<String>(); 

\end{lstlisting}

In such cases, the right hand expression's type must be assignable to the type on the left hand side. 

Alternatively the type can be left off and corresponds to the type of the initialization expression:  
\begin{lstlisting}
var msg = new ArrayList<String>(); // msg will be of type ArrayList<String>  

\end{lstlisting}







\section{Blocks}
\label{Blocks}
The block expression allows to simulate imperative code sequences. It conists of a sequence of expressions, and returns the value of the last expression.
The return type of a block is also the type of the last expression. 
Variable declarations are only possible within blocks.

\subsection{Syntax}

\begin{lstlisting}
XBlockExpression:
	'{'
		(expressions+=XExpressionInsideBlock ';')+
	'}';

\end{lstlisting}
 

A block expression is surrounded by curly braces and contains at least one expression. Each expression is terminated with a semicolon.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}

	\{
		doSideEffect("foo");
		result;
	\}
	
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}

	\{
		var x = greeting();
		if ((x.equals("Hello ")) \{
			x+"World!"; 
		\} else \{
			x
		\};
	\}
	
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{While Loop}
\label{WhileExpression}
A while loop \lstinline{while (p) e}
 is used to execute a certain expression \lstinline{e}
 unless a given predicate \lstinline{p}
 is evaluated to \lstinline{false}
.
The return type of a while loop is \lstinline{java.lang.Void}
 and the return value is \lstinline{null}
.

\subsection{Syntax}

\begin{lstlisting}
XWhileExpression:
	'while' '(' predicate=XExpression ')'
		body=XExpression;

\end{lstlisting}
 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}

	while (true) \{
		doSideEffect("foo");
	\}
	
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}

	while ((i=i+1)<max) doSideEffect("foo")
	
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{Do-While Loop}
\label{DoWhileExpression}
A do-while loop \lstinline{do e while (p)}
 is used to execute a certain expression \lstinline{e}
 unless a given predicate \lstinline{p}
 is evaluated to \lstinline{false}
.
The difference to the 
\hyperref[WhileExpression]{while loop~(\ref*{WhileExpression})} is that the execution starts by executing the block once before evaluating the predicate for the first time.
The return type of a do-while loop is \lstinline{java.lang.Void}
 and the return value is \lstinline{null}
.

\subsection{Syntax}

\begin{lstlisting}
XDoWhileExpression:
	'do'
		body=XExpression
	'while' '(' predicate=XExpression ')';

\end{lstlisting}
 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}

	do \{
		doSideEffect("foo");
	\} while (true)
	
\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}

	do doSideEffect("foo") while ((i=i+1)<max)
	
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{For Loop}
\label{ForLoop}
The for loop \lstinline{for (T1 var : iterableOfT1) e}
 is used to execute a certain expression \lstinline{e}
 for each element of an \lstinline{java.lang.Iterable}
.
The return type of a for loop is \lstinline{java.lang.Void}
 and the return value is \lstinline{null}
.

\subsection{Syntax}

\begin{lstlisting}
XForExpression:
	'for' '(' var=JvmFormalParameter ':' iterable=XExpression ')' 
		body=XExpression
	;

\end{lstlisting}
 




\subsection{Type Inference}

The type of the local variable can be left out. In that case it is inferred from the type of the \lstinline{java.lang.Iterable}
 returned by the iterable expression.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\begin{lstlisting}
for (String s : myStrings) {
	doSideEffect(s);
}
\end{lstlisting}

\end{minipage}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}

		\begin{lstlisting}
for (s : myStrings)
	doSideEffect(s)
		
\end{lstlisting}

	
\end{minipage}

\end{itemize}
\addtolength{\itemindentlen}{2em}







\section{Constructor Call}
\label{ConstructorCall}


\subsection{Syntax}

\begin{lstlisting}
XConstructorCall:
	'new' type=JvmTypeReference '(' (params+=XExpression (',' params+=XExpression)*)? ')';

\end{lstlisting}





\subsection{Example}

\begin{lstlisting}
new Foo()

\end{lstlisting}








\end{document}
