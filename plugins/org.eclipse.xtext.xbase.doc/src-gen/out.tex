\documentclass[a4paper]{scrreprt}

\usepackage[T1]{fontenc}
\usepackage{ae,aecompl} 
\usepackage[latin1]{inputenc}
\usepackage{listings}

%%\usepackage{helvet}

\lstdefinelanguage{Xtext}
  {morekeywords={grammar, generate, import, as, terminal, hidden},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
  }

\lstdefinelanguage{Xbase}
  {morekeywords={extends, instanceof, new, null, true, false, if, else, switch, case, default, do, while, for, def, class, as},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
  }

%\lstdefinelanguage{xtext}{keywords={terminal, grammar, import, generate, hidden, as}, sensitive=true,string={"},morestring={'},comment={//},morecomment=[s]{/*}{*/}}

\lstset{breaklines=true, tabsize=4, basicstyle=\sffamily\footnotesize, keywordstyle=\bfseries, language=Xbase, columns=[r]fullflexible}

\usepackage[english]{babel}

% import this as last package
\usepackage{hyperref}

\newlength{\itemindentlen}

\begin{document}

\chapter{Preface}

This document specifies the expression language Xbase. Xbase is a partial programming language implemented in Xtext and is meant to be embedded and extended
within other programming languages and domain-specific languages (DSL) written in Xtext. Xtext is a highly extendable language development framework 
covering all aspects of language infrastructure such as parsers, linkers, compilers, interpreters and even full-blown IDE support based on Eclipse.  

Developing DSLs has become incredibly easy with Xtext. Structural languages which introduce new coarse-grained concepts, such as services, entities, value objects or 
statemachines can be developed in minutes. However, software systems do not consist of structures solely. At some point a system needs to show some behavior, 
which is usually specified using so called \textit{expressions}. Expressions are the heart of every programming language and are not easy to get right.
That is why most people do not add support for expressions in their DSL, but try to solve this differently. The most often used workaround is to define only the structural information in the DSL 
and add behavior by modifying or extending the generated code. It is not only unpleasant to write, read and maintain information which closely belongs together in two different places, abstraction levels 
and languages. Also, modifying the generated source code comes with a lot of additional problems. But as of today this is the preferred solution since adding support for expressions (and
a corresponding execution environment) for your language is hard - even with Xtext.

Xbase serves as a language library providing a common expression language bound to the Java platform (i.e. Java Virtual Machine). It ships in form of an Xtext grammar, as well as 
reusable and adaptable implementations for the different aspects of a language infrastructure such as an AST structure, a compiler, an interpreter, a linker, and a static analyzer.
In addition it comes with implementations to integrate the expression language within an Xtext-based Eclipse IDE. Default implementations for aspects like content assistance, syntax coloring, 
hovering, folding and navigation can be easily integrated and reused within any Xtext based language. 

Conceptually and syntactically, Xbase is like Java statements+expressions, with the following differences:

\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
No checked exceptions
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Pure object-oriented, i.e. no built-in types and no arrays
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Everything is an expression, there are no statements
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Closures
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Type inference
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Properties
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Simple operator overloading
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
Powerful switch expressions
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}




\chapter{Lexical Syntax}

Xbase comes with a small set of lexer rules, which can be overridden and hence changed by users. However the default implementation is carefully chosen and it is recommended to stick 
with the lexical syntax described in the following.

\section{Identifiers}
\label{Identifiers}
Identifiers are used to name all constructs, such as types, methods and variables. They start with a "Java letter", which is a character for which the Java method 
\textit{Character.isJavaIdentifierstart(char)}
returns \textit{true}. For the other characters also digits (0...9) are allowed. For those the method \textit{Character.isJavaIdentifierPart(char)} must be true.
See \href{http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.8}{§ 3.8 Identifiers} for the original definition in the Java Language Specification.

\subsection{Syntax}

\begin{lstlisting}
//TODO

\end{lstlisting}





\subsection{Escaped Identifiers}

Identifiers may not have the same spelling as any reserved keyword. 
However, identifiers starting with a \lstinline°^° are so called escaped identifiers. Escaped identifiers are used in cases when there is a 
conflict with a reserved keyword. Imagine you have introduced a keyword \lstinline°service° in your language but want to call a Java property \textit{service} at some point. 
In such cases you use an escaped identifier \lstinline°^service° to reference the Java property.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°Foo°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°Foo42°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°FOO°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°_42°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°_foo°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°^extends°
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{String Literals}
\label{StringLiterals}
String literals can either use single quotes (') or double quotes (") as their terminals. When using double quotes all literals allowed by Java string literals are
supported. In addition new line characters are allowed, that is in Xbase all string literals can span multiple lines. When using single quotes the only difference
is that single quotes within the literal have to be escaped and double quotes do not.

See \href{http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.10.5}{§ 3.10.5 String Literals}

In contrast to Java, equal string literals within the same class do not neccessarily refer to the same instance at runtime.

\subsection{Syntax}

\begin{lstlisting}
//TODO

\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°'Foo Bar Baz'°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°"Foo Bar Baz"°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\begin{lstlisting}
" the quick brown fox 
		   jumps over the lazy dog."
\end{lstlisting}

\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°'Escapes : \' '°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°"Escapes : \" "°
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Integer Literals}
\label{IntegerLiterals}
Integer literals consist of one or more digits. 
Only decimal literals are supported and they always result in a value of type \lstinline°java.lang.Integer° 
(it might result in native type \lstinline°int° when translated to Java, see 
\hyperref[Types]{Types~(\ref*{Types})}).
The compiler makes sure that only numbers between 0 and \textit{Integer.MAX} (0x7fffffff) are used.

There is no negative integer literal, instead the expression \lstinline°-23° is parsed as the prefix operator \lstinline°-° applied to an integer literal.

\subsection{Syntax}

\begin{lstlisting}
terminal INT returns ecore::EInt: 
	('0'..'9')+
;

\end{lstlisting}







\section{Comments}
\label{Comments}
Xbase comes with two different kinds of comments: Single-line comments and multi-line comments.
The syntax is the same as the one known from Java (see \href{http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.7}{§ 3.7 Comments})

\subsection{Syntax}

\begin{lstlisting}
terminal ML_COMMENT	: 
	'/*' -> '*/'
;
terminal SL_COMMENT : 
	'//' !('\n'|'\r')* ('\r'? '\n')?
;

\end{lstlisting}







\section{White Space}
\label{Whitespace}
The white space characters \lstinline°' '°, \lstinline°'\t'°, \lstinline°'\n'°, and \lstinline°'\r° are allowed to occur anywhere between the other syntactic elements. 




\section{Reserved Keywords}
\label{Keywords}
The following list of words are reserved keywords, thus reducing the set of possible identifiers:

\setlength{\itemindentlen}{\textwidth}
\begin{enumerate}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°extends°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°super°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°instanceof°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°new°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°null°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°false°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°true°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°val°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°var°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°if°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°else°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°switch°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°case°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°default°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°do°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°while°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°for°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°class°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°throw°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°try°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°catch°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°finally°
\end{minipage}
\end{enumerate}
\addtolength{\itemindentlen}{2em}

However, in case some of the keywords have to be used as identifiers, the escape character for 
\hyperref[Identifiers]{identifiers~(\ref*{Identifiers})} comes in handy. 






\chapter{Types}

Xbase binds to the Java Virtual Machine. This means that expressions written in Xbase refer to Java types and Java type members. Xbase itself uses only types 
defined in the Java language, such as classes, interfaces, annotations and enums. It also supports Java generics and shares the known syntax. In addition to Java, 
Xbase comes with the notion of function types. 

Xbase does not bind to any of the built-in types such as \textit{int} or \textit{boolean}, instead any references to those built-in types will automatically use the corresponding 
wrapper type, e.g. \textit{java.lang.Boolean} instead of \textit{boolean}. Arrays are supported also in Xbase but are translated to \textit{java.util.List}s: An 
array \textit{int[]} binds to \textit{java.util.List<java.lang.Integer>} (in short \textit{List<Integer>}). 
This means when referring to \lstinline°myList.isEmpty()° within an Xbase expression the static return type is \textit{java.lang.Boolean}. 
At runtime however the compiler may be smarter and use the native types. Especially the types \textit{int} and \textit{boolean} are most often used with
 built-in operators and the wrapper type is only occasionally needed (for instance when putting \lstinline°int°s into collections).

\section{Simple Type References}
\label{TypeReferences}
A simple type reference only consists of a \textit{qualified name}. A qualified name is a name made up of identifiers which are separated by a dot (like in Java).

\subsection{Syntax}

\begin{lstlisting}
QualifiedName:
  ID ('.' ID)*
;	

\end{lstlisting}


There is no rule for a simple type reference, as it is expressed as a parameterized type references without paramters.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°java.lang.String°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°String°
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Function Types}
\label{FunctionTypes}
Xbase introduces \textit{closures}, which require an additional kind of type. On the JVM-Level a closure (or more generally any function object) is just an instance of one of the 
types in \lstinline°org.eclipse.xtext.xbase.lib.Function*°, dependening on the number of arguments. However, as closures are a very important language feature, a special 
sugared syntax for function types has been introduced.  
So instead of writing \lstinline°Function1<String,Boolean>° one can write \lstinline°(String)=>Boolean°.

\subsection{Syntax}

\begin{lstlisting}
XFunctionTypeRef:
  ('('JvmTypeReference (',' JvmTypeReference)*')')? 
  	'=>' JvmTypeReference;

\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°=>Boolean // predicate without parameters°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°(String)=>Boolean // One argument predicate°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°(Mutable)=>Void // A method doing side effects on an instance of Mutable and returns null°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°(List<String>)=>String°
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Parameterized Type References}
\label{ParameterizedTypeReference}
The general syntax for type references allows to take any number of type arguments. The semantics as well as the syntax is almost the same as in Java, so please 
refer to the third edition of the  \href{http://java.sun.com/docs/books/jls/third_edition/html/j3TOC.html}{Java Language Specification}.

The only difference is that in Xbase a type reference can also be a function type. In the following the full syntax fo type references is shown, including function types and
type arguments.

\subsection{Syntax}

\begin{lstlisting}
JvmTypeReference:
  JvmParameterizedTypeReference | 
  XFunctionTypeRef;
	
XFunctionTypeRef:
  ('(' JvmTypeReference (',' JvmTypeReference)* ')')? 
  	'=>' JvmTypeReference;

JvmParameterizedTypeReference:
  type=QualifiedName ('<' JvmTypeArgument (',' JvmTypeArgument)* '>')?;

JvmTypeArgument:
  JvmReferenceTypeArgument | 
  JvmWildcardTypeArgument;
  
JvmReferenceTypeArgument :
  JvmTypeReference;

JvmWildcardTypeArgument:
  '?' (JvmUpperBound | JvmLowerBound)?;

JvmLowerBound :
 'super' JvmTypeReference;

JvmUpperBound : 
 'extends' JvmTypeReference;


\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°String°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°java.lang.String°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°List<?>°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°List<? extends Comparable<? extends FooBar>°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°List<? super MyLowerBound>°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°List<? extends =>Boolean>°
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{The type java.lang.Void}
\label{VoidType}
The \lstinline°null° reference is the only valid value of the type \lstinline°Void°, which gets some special treatment in Xbase. Every Java method which is declared \textit{void} (i.e. without a return value)
is translated to a method with return type \textit{java.lang.Void}. At runtime such method invocations will result in \textit{null}.
The speciality is that while it is allowed to pass \lstinline°null° everywhere (TODO discuss use of nullable annotation) instead of any other value, this does not mean that \textit{java.lang.Void}
is a subtype of any other type. The \lstinline°instanceOf° operator as well as the type matchers in the 
\autoref{SwitchExpression} do not match \lstinline°null°.




\section{Conformance Rules}
\label{ConformanceRules}
Conformance is used in order to find out whether some expression can be used in a certain situation. For instance when assigning a value to a variable, 
the type of the right hand expression needs to conform to the type of the variable.

A type \textit{T1} conforms to a type \textit{T2} if 

\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
T1==T2
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
T1==java.lang.Void
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
T1 is a subtype of T2
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}

\textit{T1<T1P,..T1Pn>} conforms to \textit{T2<T2P, ... T2Pn>} if \textit{T1} conforms to \textit{T2} and each upper bound of a \textit{T1Pn} conforms to the corresponding upper bound of \textit{T2Pn}.

\subsection{Common Super Type}
\label{CommonSuperType}
For a set \textit{[T1,T2,...Tn]} of types the common super type is computed by using the linear type inheritance sequence of \textit{T1} and is iterated until one type
conforms to each \textit{T2,..,Tn}. The linear type inheritance sequence of \textit{T1} is computed by ordering all types which are part if the type hierarchy of \textit{T1}
by their specificity. A type \textit{T1} is considered more specific than \textit{T2} if \textit{T1} is a subtype of \textit{T2}. Any types with equal specificity will be sorted 
by their qualified name just to ensure deterministic results. 







\chapter{Expressions}

Expressions are the main language constructs which are used to express behavior and computation of values. Xbase does not support the concept of a statement, but instead comes with powerful 
expressions to handle situations in which the imperative nature of statements are a better fit. An expression always results in a value (might be the value 'null' though). In addition expressions can
be statically typed. By default it is assumed that languages making use of Xbase provide enough static context information for static type analysis, which is the basis of a lot of
IDE features coming with Xbase. However, the static typing is not mandatory and might be completely skipped if not wished. The openness of the compiler even allows to change the generation of 
concrete feature invocations to reflective calls, such that the language can be fully dynamically typed.

\section{Literals}
\label{Literals}
A literal denotes a fixed unchangeable value. Xbase comes with the following literals

\subsection{String Literals}
\label{ExpressionsStringLiterals}
A string literal as defined in 
\autoref{StringLiterals} is a valid expression and returns an instance of \lstinline°java.lang.String° of the given value.




\subsection{Syntax}

\begin{lstlisting}
XStringLiteral:
	STRING;

\end{lstlisting}





\subsection{Integer Literals}
\label{ExpressionsIntegerLiterals}
An integer literal as defined in 
\autoref{IntegerLiterals} creates an instance of \lstinline°Integer°.




\subsection{Syntax}

\begin{lstlisting}
XIntegerLiteral:
	INT;

\end{lstlisting}





\subsection{Boolean Literals}
\label{BooleanLiteral}
There are two boolean literals, \lstinline°true° and \lstinline°false° which correspond to their Java counterpart of type \textit{java.lang.Boolean}. 




\subsection{Syntax}

\begin{lstlisting}
XBooleanLiteral:
	'false' | 'true';

\end{lstlisting}





\subsection{Null Literal}
\label{NullLiteral}
The null pointer literal is, like in Java, \lstinline°null°. 
It is the only value of the type \textit{java.lang.Void} which has a special meaning in Xbase (see 
\autoref{VoidType}).




\subsection{Syntax}

\begin{lstlisting}
XNullLiteral:
	{XNullLiteral} 'null';

\end{lstlisting}





\subsection{Type Literals}
\label{TypeLiteral}
Type literals are written like in Java. They consist of a reference to a raw type suffixed with a dot and the keyword \lstinline°class°.




\subsection{Syntax}

\begin{lstlisting}
XTypeLiteral:
	QualifiedName '.' 'class';

\end{lstlisting}







\section{Infix Operators}
\label{Operators}
Xbase supports a couple of predefined infix operators. In contrast to Java, the operators are not fixed
to operations on certain types. Instead Xbase comes with an operator to method mapping, which allows users to redefine the 
operators for any type just by implementing the corresponding method signature.
The following defines the operators and the corresponding Java method signatures / expressions.


\begin{tabular}{|p{0.5\textwidth}|p{0.5\textwidth}|}
\lstinline°e1.someProp = e2° & \lstinline°e1.someProp = e2°\\
  & \lstinline°e1.someProp(e2)°\\
  & \lstinline°e1.setSomeProp(e2)°\\
\lstinline°e1 += e2° & \lstinline°e1.add(e2)°\\
\lstinline°e1.someFeature += e2° & \lstinline°e1.addSomeFeature(e2)°\\
\lstinline° ° & \lstinline° °\\
\lstinline°e1 || e2° & \lstinline°e1.or(e2)°\\
\lstinline° ° & \lstinline° °\\
\lstinline°e1 && e2° & \lstinline°e1.and(e2)°\\
\lstinline° ° & \lstinline° °\\
\lstinline°e1 instanceof RawTypeRef° & \lstinline°e1 instanceof RawTypeRef /* direct translation to Java */°\\
\lstinline°e1 == e2° & \lstinline°e1.equals(e2)°\\
\lstinline°e1 != e2° & \lstinline°e1.notEquals(e2)°\\
\lstinline°e1 < e2° & \lstinline°e1.lessThan(e2)°\\
\lstinline°e1 > e2° & \lstinline°e1.greaterThan(e2)°\\
\lstinline°e1 <= e2° & \lstinline°e1.lessEqualsThan(e2)°\\
\lstinline°e1 >= e2° & \lstinline°e1.greaterEqualsThan(e2)°\\
\lstinline° ° & \lstinline° °\\
\lstinline°e1 -> e2° & \lstinline°e1.mappedTo(e2)°\\
\lstinline°e1 .. e2° & \lstinline°e1.upTo(e2)°\\
\lstinline° ° & \lstinline° °\\
\lstinline°e1 + e2° & \lstinline°e1.plus(e2)°\\
\lstinline°e1 - e2° & \lstinline°e1.minus(e2)°\\
\lstinline° ° & \lstinline° °\\
\lstinline°e1 * e2° & \lstinline°e1.multiply(e2)°\\
\lstinline°e1 / e2° & \lstinline°e1.divide(e2)°\\
\lstinline°e1 % e2° & \lstinline°e1.modulo(e2)°\\
\lstinline°e1 ** e2° & \lstinline°e1.power(e2)°\\
\lstinline° ° & \lstinline° °\\
\lstinline°! e1° & \lstinline°e1.not()°\\
\lstinline°- e1° & \lstinline°e1.minus()°\\
\lstinline° ° & \lstinline° °\\
\lstinline°e1[e2]° & \lstinline°e1.apply(<Exp2)°
\end{tabular}

		
The table above also defines the operator precedence in ascending order. The blank lines separate precedence levels. 
The two assignment operators \lstinline°=° and \lstinline°+=° are right-to-left associative, that is a = b = c is executed as a = (b = c), all other
operators are left-to-right associative. Parenthesis can be used to adjust the default precedence and associativity. 

\subsection{Property Assignment}
\label{propertyAssignment}
The translation rule for the simple assignment operator \lstinline°=° is a bit more complicated.
Given the expression 

\begin{lstlisting}
myObj.myProperty = "foo"

\end{lstlisting}


The compiler first looks up whether there is an accessible Java Field called \lstinline°myProperty° on the type of \lstinline°myObj°. If there is one it translates to
the following Java expression :

\begin{lstlisting} [language=Java]
myObj.myProperty = "foo";

\end{lstlisting}


Remember in Xbase everything is an expression and has to return something. In the case of simple assignments the return value is the value returned from the corresponding
Java expression, which is the assigned value.

If there is no accessible field on the left operand's type, first a method called \lstinline°myProperty(OneArg)° and then \lstinline°setMyProperty(OneArg)° is looked up. It has to take 
one argument of the type (or a super type) of the right hand operand. The return value will be whatever the setter method returns (which usually is \lstinline°null°). 
As a result the compiler translates to :

\begin{lstlisting} [language=Java]
myObj.setMyProperty("foo")

\end{lstlisting}





\subsection{Add Assignment}
\label{addAssignment}
The translation rule for the add assignment operator \lstinline°+=° is as follows:
Given the expression 

\begin{lstlisting}
myObj.myProperty += "foo"

\end{lstlisting}


The compiler first looks up whether, the left hand side operand is of some type providing a method \lstinline°add(StringOrSuperType)°. 
In that case the expression translates to the following Java expression :

\begin{lstlisting} [language=Java]
myObj.myProperty.add("foo");

\end{lstlisting}


If there is no such method, the compiler looks for a method called \lstinline°addMyProperty(OneArg)° on the type of the target expression
of the feature call. That is it looks whether the type of \lstinline°myObj° provides a method called \lstinline°addMyProperty(StringOrSuperType)°.

The return value and compile-time type will be whatever the invoked Java method returns.




\subsection{Short-Circuit Boolean Operators}

If the operators \lstinline°||° and \lstinline°&&° are used in a context where the left hand operand is of type boolean, the operation is evaluated
in short circuit mode, which means that the right hand operand might not be evaluated at all in the following cases: 

\setlength{\itemindentlen}{\textwidth}
\begin{enumerate}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
in the case of \lstinline°||° the operand on the right hand side is not evaluated if the left operand evaluates to \lstinline°true°.
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
in the case of \lstinline°&&° the operand on the right hand side is not evaluated if the left operand evaluates to \lstinline°false°.
\end{minipage}
\end{enumerate}
\addtolength{\itemindentlen}{2em}
 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°my.foo = 23°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°myList += 23°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°x > 23 && y < 23°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°x && y || z°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°1 + 3 * 5 * (- 23)°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°!(x)°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°my.foo = 23°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°my.foo = 23°
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Feature Calls}
\label{FeatureCalls}
A feature call is used to invoke members of objects, such as fields and methods, but also can refer to local variables and parameters, 
which are made available for the current expression's scope (TODO define how scopes are declared around expressions). 

\subsection{Syntax}

The following snippet is a simplification of the real Xtext rules, which cover more than the concrete syntax.
\begin{lstlisting}
FeatureCall :
	ID |
	Expression ('.' ID ('(' Expression (',' Expression)* ')')?)*

\end{lstlisting}





\subsection{Property Access}
\label{PropertyAccess}
Feature calls are directly translated to their Java equivalent with the exception, that for calls to properties an equivalent rule as 
described in 
\autoref{propertyAssignment} applies. 
That is, for the following expression

\begin{lstlisting}
myObj.myProperty

\end{lstlisting}


the compiler first looks for an accessible field in the type of \lstinline°myObj°. If no such field exists it looks for a method called \lstinline°myProperty()° before it looks 
for the getter methods \lstinline°getMyProperty()°. If none of these members can be found the expression is unbound and a compiliation error is thrown.




\subsection{Implicit 'this' variable}
\label{ImplicitThis}
If the current scope contains a variable named \lstinline°this°, the compiler will make all its members available to the scope. 
That is if 
\begin{lstlisting}
this.myProperty

\end{lstlisting}

if a valid expression
\begin{lstlisting}
myProperty

\end{lstlisting}

is valid as well and is equivalent. 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°foo°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°my.foo°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°my.foo(x)°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°oh.my.foo(bar)°
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Closures}
\label{Closures}
A closure is a literal that defines an anonymous function. A closure also captures the current scope, so that any final variables and parameters visible at construction time 
can be referred to in the closure's expression. 

\subsection{Syntax}

\begin{lstlisting}
XClosure:
	(JvmFormalParameter (',' JvmFormalParameter)*)? '|' XExpression;
	
JvmFormalParameter:
	JvmTypeReference? ID;

\end{lstlisting}





\subsection{Function Mapping}
\label{FunctionMapping}
An Xbase closure is a Java object of one of the \textit{Function} interfaces shipped with the runtime library of Xbase. There is an interface for each number of parameters.
The names of the interfaces are 

\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}
\textit{Function0<ReturnType>} for zero parameters, 
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
\textit{Function1<Param1Type, ReturnType>} for one parameters, 
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
\textit{Function2<Param1Type, Param2Type, ReturnType>} for two parameters, 
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
... 
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}
\textit{Function6<Param1Type, Param2Type, Param3Type, Param4Type, Param5Type, Param6Type, ReturnType>} for six parameters, 
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}

In order to allow seamless integration with Google Guava (formerly known as Google Collect) the type \lstinline°Function1° 
extends \lstinline°com.google.common.base.Function<F, T>° and the type \textit{Function0} extends \lstinline°com.google.common.base.Supplier<T>°. 
There is also an auto-coercion for any \lstinline°Function1<T,Boolean>° to \lstinline°com.google.common.base.Predicate<T>°.

\textit{TODO: Discuss, whether we want to go a step further and do auto conversion to any type declaring only one method. That would allow to pass
closures also to methods expecting other such types like e.g. \lstinline°Iterable°. This would avoid a fixed dependency to Google Guava, too.}




\subsection{Typing}
\label{ClosuresTypeInference}
Closures are expressions which produce function objects. The type is a 
\hyperref[FunctionTypes]{function type~(\ref*{FunctionTypes})}, consisting of the types of the 
parameters as well as the return type. The return type is never specified explicitly but is always inferred from the expression. 
The parameter types can be inferred if the closure is used in a context where this is possible.

For instance, given the following Java method signature:
\begin{lstlisting}
public T <T>getFirst(List<T> list, Function0<T,Boolean> predicate) 

\end{lstlisting}
 

the type of the parameter can be inferred. Which allows users to write:
\begin{lstlisting}
getFirst(arrayList("Foo","Bar"), e|e=="Bar")

\end{lstlisting}

instead of 
\begin{lstlisting}
getFirst(arrayList("Foo","Bar"), String e|e=="Bar")

\end{lstlisting}





\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°| "foo"   // closure without parameters°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°String s | s.toUpperCase() // explicit argument type°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°a,b,a | a+b+c  // inferred argument types°
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{If Expression}
\label{IfExpression}
An if expression is used to choose two different values based on a predicate. While it has the syntax of Java's if statement it behaves  
like Java's ternary operator (\lstinline°predicate ? thenPart : elsePart°), i.e. it is an expression that returns a value. Consequently, you can use 
if expressions deeply nested within expressions.

\subsection{Syntax}

\begin{lstlisting}
XIfExpression:
	'if' '(' XExpression ')'
		XExpression
	('else' XExpression)?;

\end{lstlisting}


An expression \lstinline°if (p) e1 else e2° results to either the value \lstinline°e1° or \lstinline°e2° depending on whether the predicate \lstinline°p° evaluates to \lstinline°true° or \lstinline°false°. 
The else part is optional which is a shorthand for \lstinline°else null°.
That is 
\begin{lstlisting}
if (foo) x // is the same as 'if (foo) x else null'

\end{lstlisting}





\subsection{Typing}
\label{IfTypeInference}
The type of an if expression is calculated by the return types \lstinline°T1° and \lstinline°T2° of the two expression \lstinline°e1° and \lstinline°e2°.
It uses the rules defined in 
\autoref{CommonSuperType}.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°if (isFoo) this else that°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°if (isFoo) this else if (thatFoo) that else other°
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\lstinline°if (isFoo) this°
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Switch Expression}
\label{SwitchExpression}


\subsection{Syntax}

\begin{lstlisting}
XSwitchExpression:
	'switch' XExpression? '{'
		XCasePart+
		('default' ':' (XBlockExpression 
			  		  | XExpression ';'))?
	'}';

XCasePart:
	JvmTypeReference? ('case' XExpression)? ':' 
		(XBlockExpression | XExpression ';');

\end{lstlisting}


The switch statement is a bit different from the one in Java. First, there is no fall through which means only one case is evaluated at most.
Second, the use of switch is not limited to certain values but can be used for any object reference instead. 
For a switch expression 
\begin{lstlisting}
switch e {
	case e1 : er1
	case e2 : er2
	...
	case en : ern
	default : er
}

\end{lstlisting}


the main expression \lstinline°e° is evaluated first and then each case sequentially. 
If a case expression \lstinline°en° evaluates to something such that \lstinline°e == en° the result of the switch expression is \lstinline°ern°. If none of the 
case expressions \lstinline°e1...en° is equal to the result of the main expression \lstinline°e° the result of the optional default part \lstinline°er° is returned.
If not default is defined the expression returns \lstinline°null°.




\subsection{Leaving out the main expression}

It is possible to leave out the main expression. Then the case expressions \lstinline°e1...en° have to be of type Boolean. They are evaluated 
in the specified order and as soon as one predicate \lstinline°ex° evaluates to true the corresponding then expression \lstinline°ex° is the result of the switch expression.
So it is mainly an alternative syntax to the 
\autoref{IfExpression}.




\subsection{Type guards}

In addition to the case predicate one can add a so called \textit{Type Guard} which is syntactically just 
\hyperref[TypeReferences]{type reference~(\ref*{TypeReferences})} in front of the case keyword.  
The compiler will use that type for the switch expression in subsequent expressions.
Example:
\begin{lstlisting}
{
var Object x = ...;
switch x {
	String case x.length()>0 : x.length()
	List<?> : x.size()
	default : -1
}

\end{lstlisting}


The expression x, will be of type \lstinline°String° in any expression within the first case and of type \lstinline°List<?>° in the second. Note that the case expression
has to be a predicate (i.e. it has to be of type \lstinline°Boolean°). At runtime a type guard is translated to an \lstinline°instanceof° of test and subsequent casts.
The expression x is reevaluated everytime it is used. If the expression returns a different value on a subsequent evaluation, it might cause a
\lstinline°ClassCastException° at runtime.




\subsection{Typing}

The return type of a switch expression is computed using the rules defined in 
\autoref{CommonSuperType}. 
The set of types from which the common super type is computed corresponds to the types of each case's result expression.






\section{Variable Declarations}
\label{VariableDeclaration}
Variable declarations are only allowed within a 
\hyperref[Blocks]{block~(\ref*{Blocks})}. They are visible in any subsequent expressions in
the block.

\subsection{Syntax}

\begin{lstlisting}
XVariableDeclaration:
	('val' | 'var') JvmTypeReference ID '=' XExpression;

\end{lstlisting}


Xbase resembles the keywords \lstinline°val° and \lstinline°var° known from Scala (\href{http://www.scala-lang.org/docu/files/ScalaReference.pdf}{The Scala Language Specification 2.8}).
A variable declaration starting with the keyword \lstinline°val° denotes a so called value, which is essentially a final (i.e. unsettable) variable. In rare cases, one
needs to update the value of a reference. In such situations the variable needs to be declared with the keyowrd \lstinline°var°, which stands for 'variable'.

\begin{lstlisting}
{
	var i = 0
	while (i>MAX) {
		print("Hi there!")
	}
}
{
	val myFoo = my.complex(expression)
	myFoo.call(myFoo)
}

\end{lstlisting}





\subsection{Typing}

The return type of a variable declaration expression is always \lstinline°java.lang.Void°. 
The type of the variable itself can either be explicitly declared or be inferred from the right hand side expression.
Here is an example for an explicitly declared type:
\begin{lstlisting}
var List<String> msg = new ArrayList<String>(); 

\end{lstlisting}

In such cases, the right hand expression's type must 
\hyperref[ConformanceRules]{conform~(\ref*{ConformanceRules})} to the type on the left hand side. 

Alternatively the type can be left out and will be inferred from the initialization expression:  
\begin{lstlisting}
var msg = new ArrayList<String>(); // -> type ArrayList<String>  

\end{lstlisting}







\section{Blocks}
\label{Blocks}
The block expression allows to simulate imperative code sequences. It consists of a sequence of expressions, and returns the value of the last expression.
The return type of a block is also the type of the last expression. 

\hyperref[VariableDeclaration]{Variable declarations~(\ref*{VariableDeclaration})} are only allowed within blocks and cannot be used as a block's last expression.

\subsection{Syntax}

\begin{lstlisting}
XBlockExpression:
	'{'
		(XExpressionInsideBlock ';'?)*
	'}';

\end{lstlisting}
 

A block expression is surrounded by curly braces and contains at least one expression.
It can optionally be terminated by a semicolon.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}

	\{
		doSideEffect("foo")
		result
	\}
	
\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}

	\{
		var x = greeting();
		if ((x.equals("Hello ")) \{
			x+"World!"; 
		\} else \{
			x;
		\}
	\}
	
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{While Loop}
\label{WhileExpression}
A while loop \lstinline°while (predicate) expression° is used to execute a certain \lstinline°expression° unless the \lstinline°predicate° is evaluated to \lstinline°false°.
The return type of a while loop is \lstinline°java.lang.Void° and the return value is \lstinline°null°.

\subsection{Syntax}

\begin{lstlisting}
XWhileExpression:
	'while' '(' predicate=XExpression ')'
		body=XExpression;

\end{lstlisting}
 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\begin{lstlisting}
while (true) {
	doSideEffect("foo");
}

\end{lstlisting}

\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\begin{lstlisting}
while ((i=i+1)<max) doSideEffect("foo")

\end{lstlisting}

\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Do-While Loop}
\label{DoWhileExpression}
A do-while loop \lstinline°do expression while (predicate)° is used to execute a certain \lstinline°expression° unless the \lstinline°predicate° is evaluated to \lstinline°false°.
The difference to the 
\hyperref[WhileExpression]{while loop~(\ref*{WhileExpression})} is that the execution starts by executing the block once before evaluating the predicate for the first time.
The return type of a do-while loop is \lstinline°java.lang.Void° and the return value is \lstinline°null°.

\subsection{Syntax}

\begin{lstlisting}
XDoWhileExpression:
	'do'
		body=XExpression
	'while' '(' predicate=XExpression ')';

\end{lstlisting}
 




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\begin{lstlisting}
do {
	doSideEffect("foo");
} while (true)

\end{lstlisting}

\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\begin{lstlisting}
do doSideEffect("foo") while ((i=i+1)<max)

\end{lstlisting}

\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{For Loop}
\label{ForLoop}
The for loop \lstinline°for (T1 variable : iterableOfT1) expression° is used to execute a certain \lstinline°expression° for each element of an \lstinline°java.lang.Iterable°.
The local \lstinline°variable° is final, hence canot be updated. 

\subsection{Syntax}

\begin{lstlisting}
XForExpression:
	'for' '(' JvmFormalParameter ':' XExpression ')' 
		XExpression
	;

\end{lstlisting}
 




\subsection{Typing}

The return type of a for loop is \lstinline°java.lang.Void° and the return value is \lstinline°null°.
The type of the local variable can be left out. In that case it is inferred from the type of the \lstinline°java.lang.Iterable° returned by the iterable expression.




\subsection{Examples}


\setlength{\itemindentlen}{\textwidth}
\begin{itemize}
\addtolength{\itemindentlen}{-2em}

\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}
\begin{lstlisting}
for (String s : myStrings) {
	doSideEffect(s);
}
\end{lstlisting}

\end{minipage}
\item \begin{minipage}[t]{\itemindentlen}\vspace*{-\baselineskip}

		\begin{lstlisting}
for (s : myStrings)
	doSideEffect(s)
		
\end{lstlisting}

	
\end{minipage}
\end{itemize}
\addtolength{\itemindentlen}{2em}






\section{Constructor Call}
\label{ConstructorCall}
Construction of objects is done by invoking Java constructors. Xbase uses the \lstinline°new° keyword and the syntax is like the one known from Java.

\subsection{Syntax}

\begin{lstlisting}
XConstructorCall:
  'new' (type=JvmTypeReference '('(XExpression (',' XExpression)*)?')')?;

\end{lstlisting}





\subsection{Example}

\begin{lstlisting}
new Foo()

\end{lstlisting}







\section{Throwing Exceptions}
\label{Throw}
Like in Java it is possible to throw \lstinline°java.lang.Throwable°. The syntax is exactly the same as in Java.

\subsection{Syntax}

\begin{lstlisting}
XThrow:
  'throw' XExpression;

\end{lstlisting}





\subsection{Typing}

The type of a throw expression is always \lstinline°java.lang.Void°. 
The type of the expression after the \lstinline°throw° keyword needs to conform to \lstinline°java.lang.Throwable°.




\subsection{Example}

\begin{lstlisting}
throw new RuntimeException()

\end{lstlisting}







\section{Try, Catch, Finally}
\label{TryCatch}
The try-catch-finally expression is used to handle exceptional situations gracefully.
Xbase never forces you to catch exceptions, because there is no such concept like checked exceptions in Java. 
The syntax again is like the one known from Java.

\subsection{Syntax}

\begin{lstlisting}
XTryCatchFinally:
  'try' XBlockExpression
  CatchClause*
  FinallyClause?;
  
CatchClause:
	'catch' XDeclaredParameter 
		XBlockExpression  

FinallyClause:
	'finally' XBlockExpression  

\end{lstlisting}





\subsection{Example}

\begin{lstlisting}
try {
	throw new RuntimeException()
} catch (NullPointerException e) {
	// handle e
} finally {
	// do stuff
}

\end{lstlisting}








\end{document}
