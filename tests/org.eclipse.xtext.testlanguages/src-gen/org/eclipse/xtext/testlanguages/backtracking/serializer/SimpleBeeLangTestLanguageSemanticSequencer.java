/*
 * generated by Xtext
 */
package org.eclipse.xtext.testlanguages.backtracking.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AliasedRequiredCapability;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AndExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AssignmentExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AtExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.BeeLangTestLanguagePackage;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.BinaryOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CachedExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CallFeature;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CallFunction;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CallNamedFunction;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ChainedExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ClosureParameter;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ClosureTypeRef;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CreateExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.DefValue;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.FeatureExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Function;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.GuardExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Model;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.OrExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Parameter;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ParameterDeclaration;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ParameterList;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ProvidedCapability;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.RequiredCapability;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.SimpleTypeRef;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.UnaryOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.UnaryPostOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.UnaryPreOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Unit;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ValueLiteral;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.VariableExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.WithContextExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.WithExpression;
import org.eclipse.xtext.testlanguages.backtracking.serializer.BeeLangTestLanguageSemanticSequencer;
import org.eclipse.xtext.testlanguages.backtracking.services.SimpleBeeLangTestLanguageGrammarAccess;

@SuppressWarnings("all")
public class SimpleBeeLangTestLanguageSemanticSequencer extends BeeLangTestLanguageSemanticSequencer {

	@Inject
	private SimpleBeeLangTestLanguageGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == BeeLangTestLanguagePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case BeeLangTestLanguagePackage.ALIASED_REQUIRED_CAPABILITY:
				sequence_AliasedRequiredCapability(context, (AliasedRequiredCapability) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.ASSIGNMENT_EXPRESSION:
				if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAssignmentExpressionRule() ||
				   context == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getCachedExpressionRule() ||
				   context == grammarAccess.getCallExpressionRule() ||
				   context == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getOneOrManyExpressionsRule() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPostopExpressionRule() ||
				   context == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getSetExpressionRule() ||
				   context == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getTopLevelExpressionRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInitializationExpressionRule()) {
					sequence_InitializationExpression(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.AT_EXPRESSION:
				sequence_InfixExpression(context, (AtExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.BINARY_OP_EXPRESSION:
				sequence_AdditiveExpression_MultiplicativeExpression_RelationalExpression_SetExpression(context, (BinaryOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CACHED_EXPRESSION:
				sequence_CachedExpression(context, (CachedExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CALL_FEATURE:
				sequence_InfixExpression(context, (CallFeature) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CALL_FUNCTION:
				sequence_CallExpression(context, (CallFunction) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CALL_NAMED_FUNCTION:
				sequence_OperationCall(context, (CallNamedFunction) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CHAINED_EXPRESSION:
				if(context == grammarAccess.getBlockExpressionWithoutBracketsRule()) {
					sequence_BlockExpressionWithoutBrackets(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getOneOrManyExpressionsRule()) {
					sequence_BlockExpression_BlockExpressionWithoutBrackets_OneOrManyExpressions(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAssignmentExpressionRule() ||
				   context == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getBlockExpressionRule() ||
				   context == grammarAccess.getCachedExpressionRule() ||
				   context == grammarAccess.getCallExpressionRule() ||
				   context == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPostopExpressionRule() ||
				   context == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getSetExpressionRule() ||
				   context == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getTopLevelExpressionRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_BlockExpression(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInitializationBlockExpressionRule()) {
					sequence_InitializationBlockExpression(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.CLOSURE_PARAMETER:
				sequence_ClosureParameter(context, (ClosureParameter) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CLOSURE_TYPE_REF:
				sequence_ClosureTypeRef(context, (ClosureTypeRef) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CREATE_EXPRESSION:
				sequence_ConstructorCallExpression(context, (CreateExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.DEF_VALUE:
				if(context == grammarAccess.getTopLevelExpressionRule()) {
					sequence_TopLevelExpression_ValDeclaration_VarDeclaration(context, (DefValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getValDeclarationRule()) {
					sequence_ValDeclaration(context, (DefValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getVarDeclarationRule()) {
					sequence_VarDeclaration(context, (DefValue) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.FEATURE_EXPRESSION:
				if(context == grammarAccess.getFeatureOfThisRule()) {
					sequence_FeatureOfThis(context, (FeatureExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAssignmentExpressionRule() ||
				   context == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getCachedExpressionRule() ||
				   context == grammarAccess.getCallExpressionRule() ||
				   context == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getOneOrManyExpressionsRule() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPostopExpressionRule() ||
				   context == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getSetExpressionRule() ||
				   context == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getTopLevelExpressionRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_InfixExpression(context, (FeatureExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.FUNCTION:
				if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAssignmentExpressionRule() ||
				   context == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getCachedExpressionRule() ||
				   context == grammarAccess.getCallExpressionRule() ||
				   context == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0() ||
				   context == grammarAccess.getClosureExpressionRule() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0() ||
				   context == grammarAccess.getLiteralRule() ||
				   context == grammarAccess.getLiteralFunctionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getOneOrManyExpressionsRule() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPostopExpressionRule() ||
				   context == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getSetExpressionRule() ||
				   context == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getTopLevelExpressionRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_ClosureExpression(context, (Function) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFunctionRule()) {
					sequence_Function(context, (Function) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.GUARD_EXPRESSION:
				sequence_GuardExpression(context, (GuardExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PARAMETER:
				sequence_Parameter(context, (Parameter) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PROVIDED_CAPABILITY:
				sequence_ProvidedCapability(context, (ProvidedCapability) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.REQUIRED_CAPABILITY:
				sequence_RequiredCapability(context, (RequiredCapability) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.SIMPLE_TYPE_REF:
				sequence_SimpleTypeRef(context, (SimpleTypeRef) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNARY_OP_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNARY_POST_OP_EXPRESSION:
				sequence_PostopExpression(context, (UnaryPostOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNARY_PRE_OP_EXPRESSION:
				sequence_PreopExpression(context, (UnaryPreOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.VALUE_LITERAL:
				sequence_ValueLiteral(context, (ValueLiteral) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.VARIABLE_EXPRESSION:
				if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAssignmentExpressionRule() ||
				   context == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getCachedExpressionRule() ||
				   context == grammarAccess.getCallExpressionRule() ||
				   context == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getOneOrManyExpressionsRule() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPostopExpressionRule() ||
				   context == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getSetExpressionRule() ||
				   context == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getTopLevelExpressionRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_KeywordVariables_PrimaryExpression_Value(context, (VariableExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getKeywordVariablesRule()) {
					sequence_KeywordVariables(context, (VariableExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getValueRule()) {
					sequence_Value(context, (VariableExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.WITH_CONTEXT_EXPRESSION:
				sequence_WithContextExpression(context, (WithContextExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.WITH_EXPRESSION:
				sequence_WithExpression(context, (WithExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
}
