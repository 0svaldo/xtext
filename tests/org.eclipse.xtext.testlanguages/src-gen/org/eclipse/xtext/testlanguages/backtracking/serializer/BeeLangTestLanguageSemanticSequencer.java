/*
 * generated by Xtext
 */
package org.eclipse.xtext.testlanguages.backtracking.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AliasedRequiredCapability;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AndExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AssignmentExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AtExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.BeeLangTestLanguagePackage;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.BinaryOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CachedExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CallFeature;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CallFunction;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CallNamedFunction;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ChainedExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ClosureParameter;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ClosureTypeRef;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CreateExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.DefValue;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.FeatureExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Function;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.GuardExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Model;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.OrExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ParameterDeclaration;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ParameterList;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ProvidedCapability;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.RequiredCapability;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.SimpleTypeRef;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.UnaryOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.UnaryPostOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.UnaryPreOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Unit;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ValueLiteral;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.VariableExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.WithContextExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.WithExpression;
import org.eclipse.xtext.testlanguages.backtracking.services.BeeLangTestLanguageGrammarAccess;

@SuppressWarnings("all")
public class BeeLangTestLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BeeLangTestLanguageGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BeeLangTestLanguagePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BeeLangTestLanguagePackage.ALIASED_REQUIRED_CAPABILITY:
				sequence_AliasedRequiredCapability(context, (AliasedRequiredCapability) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.ASSIGNMENT_EXPRESSION:
				if (rule == grammarAccess.getTopLevelExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentExpressionRule()
						|| action == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getCachedExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getSetExpressionRule()
						|| action == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getUnaryOrInfixExpressionRule()
						|| rule == grammarAccess.getPostopExpressionRule()
						|| action == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0()
						|| rule == grammarAccess.getInfixExpressionRule()
						|| action == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0()
						|| action == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0()
						|| action == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0()
						|| rule == grammarAccess.getCallExpressionRule()
						|| action == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getOneOrManyExpressionsRule()
						|| rule == grammarAccess.getParanthesizedExpressionRule()) {
					sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInitializationExpressionRule()) {
					sequence_InitializationExpression(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.AT_EXPRESSION:
				sequence_InfixExpression(context, (AtExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.BINARY_OP_EXPRESSION:
				sequence_AdditiveExpression_MultiplicativeExpression_RelationalExpression_SetExpression(context, (BinaryOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CACHED_EXPRESSION:
				sequence_CachedExpression(context, (CachedExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CALL_FEATURE:
				sequence_InfixExpression(context, (CallFeature) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CALL_FUNCTION:
				sequence_CallExpression(context, (CallFunction) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CALL_NAMED_FUNCTION:
				sequence_OperationCall(context, (CallNamedFunction) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CHAINED_EXPRESSION:
				if (rule == grammarAccess.getBlockExpressionWithoutBracketsRule()) {
					sequence_BlockExpressionWithoutBrackets(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOneOrManyExpressionsRule()) {
					sequence_BlockExpression_BlockExpressionWithoutBrackets(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTopLevelExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentExpressionRule()
						|| action == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getCachedExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getSetExpressionRule()
						|| action == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getUnaryOrInfixExpressionRule()
						|| rule == grammarAccess.getPostopExpressionRule()
						|| action == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0()
						|| rule == grammarAccess.getInfixExpressionRule()
						|| action == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0()
						|| action == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0()
						|| action == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0()
						|| rule == grammarAccess.getCallExpressionRule()
						|| action == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getBlockExpressionRule()
						|| rule == grammarAccess.getParanthesizedExpressionRule()) {
					sequence_BlockExpression(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInitializationBlockExpressionRule()) {
					sequence_InitializationBlockExpression(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.CLOSURE_PARAMETER:
				sequence_ClosureParameter(context, (ClosureParameter) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CLOSURE_TYPE_REF:
				sequence_ClosureTypeRef(context, (ClosureTypeRef) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CREATE_EXPRESSION:
				sequence_ConstructorCallExpression(context, (CreateExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.DEF_VALUE:
				if (rule == grammarAccess.getValDeclarationRule()) {
					sequence_ValDeclaration(context, (DefValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTopLevelExpressionRule()) {
					sequence_ValDeclaration_VarDeclaration(context, (DefValue) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVarDeclarationRule()) {
					sequence_VarDeclaration(context, (DefValue) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.FEATURE_EXPRESSION:
				if (rule == grammarAccess.getFeatureOfThisRule()) {
					sequence_FeatureOfThis(context, (FeatureExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTopLevelExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentExpressionRule()
						|| action == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getCachedExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getSetExpressionRule()
						|| action == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getUnaryOrInfixExpressionRule()
						|| rule == grammarAccess.getPostopExpressionRule()
						|| action == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0()
						|| rule == grammarAccess.getInfixExpressionRule()
						|| action == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0()
						|| action == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0()
						|| action == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0()
						|| rule == grammarAccess.getCallExpressionRule()
						|| action == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getOneOrManyExpressionsRule()
						|| rule == grammarAccess.getParanthesizedExpressionRule()) {
					sequence_InfixExpression(context, (FeatureExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.FUNCTION:
				if (rule == grammarAccess.getTopLevelExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentExpressionRule()
						|| action == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getCachedExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getSetExpressionRule()
						|| action == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getUnaryOrInfixExpressionRule()
						|| rule == grammarAccess.getPostopExpressionRule()
						|| action == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0()
						|| rule == grammarAccess.getInfixExpressionRule()
						|| action == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0()
						|| action == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0()
						|| action == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0()
						|| rule == grammarAccess.getCallExpressionRule()
						|| action == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getLiteralRule()
						|| rule == grammarAccess.getLiteralFunctionRule()
						|| rule == grammarAccess.getClosureExpressionRule()
						|| rule == grammarAccess.getOneOrManyExpressionsRule()
						|| rule == grammarAccess.getParanthesizedExpressionRule()) {
					sequence_ClosureExpression(context, (Function) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFunctionRule()) {
					sequence_Function(context, (Function) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.GUARD_EXPRESSION:
				sequence_GuardExpression(context, (GuardExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PARAMETER:
				sequence_Parameter(context, (org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Parameter) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PROVIDED_CAPABILITY:
				sequence_ProvidedCapability(context, (ProvidedCapability) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.REQUIRED_CAPABILITY:
				sequence_RequiredCapability(context, (RequiredCapability) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.SIMPLE_TYPE_REF:
				sequence_SimpleTypeRef(context, (SimpleTypeRef) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNARY_OP_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNARY_POST_OP_EXPRESSION:
				sequence_PostopExpression(context, (UnaryPostOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNARY_PRE_OP_EXPRESSION:
				sequence_PreopExpression(context, (UnaryPreOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.VALUE_LITERAL:
				sequence_ValueLiteral(context, (ValueLiteral) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.VARIABLE_EXPRESSION:
				if (rule == grammarAccess.getTopLevelExpressionRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentExpressionRule()
						|| action == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getCachedExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getSetExpressionRule()
						|| action == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0()
						|| rule == grammarAccess.getUnaryOrInfixExpressionRule()
						|| rule == grammarAccess.getPostopExpressionRule()
						|| action == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0()
						|| rule == grammarAccess.getInfixExpressionRule()
						|| action == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0()
						|| action == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0()
						|| action == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0()
						|| rule == grammarAccess.getCallExpressionRule()
						|| action == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getOneOrManyExpressionsRule()
						|| rule == grammarAccess.getParanthesizedExpressionRule()) {
					sequence_KeywordVariables_Value(context, (VariableExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeywordVariablesRule()) {
					sequence_KeywordVariables(context, (VariableExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueRule()) {
					sequence_Value(context, (VariableExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.WITH_CONTEXT_EXPRESSION:
				sequence_WithContextExpression(context, (WithContextExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.WITH_EXPRESSION:
				sequence_WithExpression(context, (WithExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         (leftExpr=RelationalExpression_BinaryOpExpression_1_0 functionName=RelationalOperator rightExpr=AdditiveExpression) | 
	 *         (leftExpr=AdditiveExpression_BinaryOpExpression_1_0 (functionName='+' | functionName='-') rightExpr=MultiplicativeExpression) | 
	 *         (leftExpr=MultiplicativeExpression_BinaryOpExpression_1_0 (functionName='*' | functionName='/' | functionName='%') rightExpr=SetExpression) | 
	 *         (leftExpr=SetExpression_BinaryOpExpression_1_0 functionName='..' rightExpr=UnaryOrInfixExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression_RelationalExpression_SetExpression(ISerializationContext context, BinaryOpExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (nameSpace=ID? name=ID alias=ID? (condExpr=Expression | greedy?='greedy' | min=INT | max=INT | versionRange=ID)*)
	 */
	protected void sequence_AliasedRequiredCapability(ISerializationContext context, AliasedRequiredCapability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpr=AndExpression_AndExpression_1_0 rightExpr=RelationalExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.AND_EXPRESSION__LEFT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.AND_EXPRESSION__LEFT_EXPR));
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.AND_EXPRESSION__RIGHT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.AND_EXPRESSION__RIGHT_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0(), semanticObject.getLeftExpr());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightExprRelationalExpressionParserRuleCall_1_2_0(), semanticObject.getRightExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpr=AssignmentExpression_AssignmentExpression_1_0 functionName=AssignmentOperator rightExpr=AssignmentExpression)
	 */
	protected void sequence_AssignmentExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__LEFT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__LEFT_EXPR));
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__FUNCTION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__FUNCTION_NAME));
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0(), semanticObject.getLeftExpr());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getFunctionNameAssignmentOperatorParserRuleCall_1_1_0(), semanticObject.getFunctionName());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getRightExprAssignmentExpressionParserRuleCall_1_2_0(), semanticObject.getRightExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expressions+=TopLevelExpression+
	 */
	protected void sequence_BlockExpressionWithoutBrackets(ISerializationContext context, ChainedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expressions+=TopLevelExpression+ | expressions+=TopLevelExpression+)?
	 */
	protected void sequence_BlockExpression_BlockExpressionWithoutBrackets(ISerializationContext context, ChainedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expressions+=TopLevelExpression*
	 */
	protected void sequence_BlockExpression(ISerializationContext context, ChainedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=OrExpression
	 */
	protected void sequence_CachedExpression(ISerializationContext context, CachedExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.CACHED_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.CACHED_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCachedExpressionAccess().getExprOrExpressionParserRuleCall_0_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (funcExpr=CallExpression_CallFunction_1_0 parameterList=ParameterList?)
	 */
	protected void sequence_CallExpression(ISerializationContext context, CallFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         returnType=TypeRef? 
	 *         (
	 *             (parameters+=ParameterDeclaration parameters+=ParameterDeclaration* (varArgs?='...' parameters+=ParameterDeclaration)?) | 
	 *             (varArgs?='...' parameters+=ParameterDeclaration)
	 *         )? 
	 *         funcExpr=OneOrManyExpressions
	 *     )
	 */
	protected void sequence_ClosureExpression(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=ClosureExpression
	 */
	protected void sequence_ClosureParameter(ISerializationContext context, ClosureParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.PARAMETER__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.PARAMETER__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClosureParameterAccess().getExprClosureExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (((parameterTypes+=ID parameterTypes+=ID* (varArgs?='...' parameterTypes+=ID)?) | (varArgs?='...' parameterTypes+=ID))? returnType=ID)
	 */
	protected void sequence_ClosureTypeRef(ISerializationContext context, ClosureTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (typeExpr=ID parameterList=ParameterList? alias=ID? contextBlock=InitializationBlockExpression?)
	 */
	protected void sequence_ConstructorCallExpression(ISerializationContext context, CreateExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     featureName=ID
	 */
	protected void sequence_FeatureOfThis(ISerializationContext context, FeatureExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.FEATURE_EXPRESSION__FEATURE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.FEATURE_EXPRESSION__FEATURE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureOfThisAccess().getFeatureNameIDTerminalRuleCall_1_0(), semanticObject.getFeatureName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         documentation=DOCUMENTATION? 
	 *         visibility=ID? 
	 *         final?='final'? 
	 *         returnType=TypeRef? 
	 *         name=ID 
	 *         (
	 *             (parameters+=ParameterDeclaration parameters+=ParameterDeclaration* (varArgs?='...' parameters+=ParameterDeclaration)?) | 
	 *             (varArgs?='...' parameters+=ParameterDeclaration)
	 *         )? 
	 *         guard=GuardExpression? 
	 *         (funcExpr=Expression | funcExpr=BlockExpression)
	 *     )
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (guardExpr=Expression | guardExpr=BlockExpression)
	 */
	protected void sequence_GuardExpression(ISerializationContext context, GuardExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (objExpr=InfixExpression_AtExpression_1_1_0 indexExpr=Expression)
	 */
	protected void sequence_InfixExpression(ISerializationContext context, AtExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.AT_EXPRESSION__OBJ_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.AT_EXPRESSION__OBJ_EXPR));
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.AT_EXPRESSION__INDEX_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.AT_EXPRESSION__INDEX_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0(), semanticObject.getObjExpr());
		feeder.accept(grammarAccess.getInfixExpressionAccess().getIndexExprExpressionParserRuleCall_1_1_2_0(), semanticObject.getIndexExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (funcExpr=InfixExpression_CallFeature_1_0_0 name=ID parameterList=ParameterList?)
	 */
	protected void sequence_InfixExpression(ISerializationContext context, CallFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (objExpr=InfixExpression_FeatureExpression_1_2_0 featureName=ID)
	 */
	protected void sequence_InfixExpression(ISerializationContext context, FeatureExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.FEATURE_EXPRESSION__OBJ_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.FEATURE_EXPRESSION__OBJ_EXPR));
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.FEATURE_EXPRESSION__FEATURE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.FEATURE_EXPRESSION__FEATURE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0(), semanticObject.getObjExpr());
		feeder.accept(grammarAccess.getInfixExpressionAccess().getFeatureNameIDTerminalRuleCall_1_2_2_0(), semanticObject.getFeatureName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expressions+=InitializationExpression
	 */
	protected void sequence_InitializationBlockExpression(ISerializationContext context, ChainedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpr=FeatureOfThis functionName=':' rightExpr=Expression)
	 */
	protected void sequence_InitializationExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__LEFT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__LEFT_EXPR));
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__FUNCTION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__FUNCTION_NAME));
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitializationExpressionAccess().getLeftExprFeatureOfThisParserRuleCall_1_0(), semanticObject.getLeftExpr());
		feeder.accept(grammarAccess.getInitializationExpressionAccess().getFunctionNameColonKeyword_2_0(), semanticObject.getFunctionName());
		feeder.accept(grammarAccess.getInitializationExpressionAccess().getRightExprExpressionParserRuleCall_3_0(), semanticObject.getRightExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID | 
	 *         name='input' | 
	 *         name='output' | 
	 *         name='source' | 
	 *         name='properties' | 
	 *         name='builder' | 
	 *         name='unit' | 
	 *         name='this'
	 *     )
	 */
	protected void sequence_KeywordVariables_Value(ISerializationContext context, VariableExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='input' | 
	 *         name='output' | 
	 *         name='source' | 
	 *         name='properties' | 
	 *         name='builder' | 
	 *         name='unit' | 
	 *         name='this'
	 *     )
	 */
	protected void sequence_KeywordVariables(ISerializationContext context, VariableExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (units+=Unit+ | functions+=Function+)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID parameterList=ParameterList?)
	 */
	protected void sequence_OperationCall(ISerializationContext context, CallNamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpr=OrExpression_OrExpression_1_0 rightExpr=AndExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.OR_EXPRESSION__LEFT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.OR_EXPRESSION__LEFT_EXPR));
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.OR_EXPRESSION__RIGHT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.OR_EXPRESSION__RIGHT_EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0(), semanticObject.getLeftExpr());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightExprAndExpressionParserRuleCall_1_2_0(), semanticObject.getRightExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=TypeRef? name=ID)
	 */
	protected void sequence_ParameterDeclaration(ISerializationContext context, ParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (parameters+=FirstParameter parameters+=FirstParameter*)
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_Parameter(ISerializationContext context, org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.PARAMETER__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.PARAMETER__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getExprExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expr=PostopExpression_UnaryPostOpExpression_1_0 (functionName='--' | functionName='++'))
	 */
	protected void sequence_PostopExpression(ISerializationContext context, UnaryPostOpExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((functionName='++' | functionName='--') expr=InfixExpression)
	 */
	protected void sequence_PreopExpression(ISerializationContext context, UnaryPreOpExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (nameSpace=ID? (condExpr=Expression | name=ID | version=ID)*)
	 */
	protected void sequence_ProvidedCapability(ISerializationContext context, ProvidedCapability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (nameSpace=ID? name=ID (condExpr=Expression | greedy?='greedy' | min=INT | max=INT | versionRange=ID)*)
	 */
	protected void sequence_RequiredCapability(ISerializationContext context, RequiredCapability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (rawType=ID (actualArgumentsList+=ID actualArgumentsList+=ID*)?)
	 */
	protected void sequence_SimpleTypeRef(ISerializationContext context, SimpleTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((functionName='!' | functionName='-') expr=InfixExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryOpExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         documentation=DOCUMENTATION? 
	 *         name=ID? 
	 *         version=ID? 
	 *         (implements+=SimpleTypeRef implements+=SimpleTypeRef*)? 
	 *         (
	 *             sourceLocation=Path | 
	 *             outputLocation=Path | 
	 *             providedCapabilities+=ProvidedCapability | 
	 *             requiredCapabilities+=AliasedRequiredCapability | 
	 *             metaRequiredCapabilities+=RequiredCapability | 
	 *             functions+=Function
	 *         )*
	 *     )
	 */
	protected void sequence_Unit(ISerializationContext context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (final?='final'? immutable?='val' type=TypeRef? name=ID valueExpr=Expression)
	 */
	protected void sequence_ValDeclaration(ISerializationContext context, DefValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((final?='final'? type=TypeRef? name=ID valueExpr=Expression?) | (final?='final'? immutable?='val' type=TypeRef? name=ID valueExpr=Expression))
	 */
	protected void sequence_ValDeclaration_VarDeclaration(ISerializationContext context, DefValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_ValueLiteral(ISerializationContext context, ValueLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.VALUE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.VALUE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Value(ISerializationContext context, VariableExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.VARIABLE_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.VARIABLE_EXPRESSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (final?='final'? type=TypeRef? name=ID valueExpr=Expression?)
	 */
	protected void sequence_VarDeclaration(ISerializationContext context, DefValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr=Expression alias=ID? contextBlock=BlockExpression)
	 */
	protected void sequence_WithContextExpression(ISerializationContext context, WithContextExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((referencedAdvice+=ID referencedAdvice+=ID*)? (funcExpr=Expression | funcExpr=BlockExpressionWithoutBrackets))
	 */
	protected void sequence_WithExpression(ISerializationContext context, WithExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
