/*
 * generated by Xtext
 */
package org.eclipse.xtext.testlanguages.backtracking.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AliasedRequiredCapability;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AndExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AssignmentExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.AtExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.BeeLangTestLanguagePackage;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.BinaryOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CachedExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CallFeature;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CallFunction;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CallNamedFunction;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ChainedExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ClosureParameter;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ClosureTypeRef;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.CreateExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.DefValue;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.FeatureExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Function;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.GuardExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Model;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.OrExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Parameter;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ParameterDeclaration;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ParameterList;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ProvidedCapability;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.RequiredCapability;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.SimpleTypeRef;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.UnaryOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.UnaryPostOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.UnaryPreOpExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.Unit;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.ValueLiteral;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.VariableExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.WithContextExpression;
import org.eclipse.xtext.testlanguages.backtracking.beeLangTestLanguage.WithExpression;
import org.eclipse.xtext.testlanguages.backtracking.services.BeeLangTestLanguageGrammarAccess;

@SuppressWarnings("all")
public class BeeLangTestLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BeeLangTestLanguageGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == BeeLangTestLanguagePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case BeeLangTestLanguagePackage.ALIASED_REQUIRED_CAPABILITY:
				sequence_AliasedRequiredCapability(context, (AliasedRequiredCapability) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.ASSIGNMENT_EXPRESSION:
				if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAssignmentExpressionRule() ||
				   context == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getCachedExpressionRule() ||
				   context == grammarAccess.getCallExpressionRule() ||
				   context == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getOneOrManyExpressionsRule() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPostopExpressionRule() ||
				   context == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getSetExpressionRule() ||
				   context == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getTopLevelExpressionRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInitializationExpressionRule()) {
					sequence_InitializationExpression(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.AT_EXPRESSION:
				sequence_InfixExpression(context, (AtExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.BINARY_OP_EXPRESSION:
				sequence_AdditiveExpression_MultiplicativeExpression_RelationalExpression_SetExpression(context, (BinaryOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CACHED_EXPRESSION:
				sequence_CachedExpression(context, (CachedExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CALL_FEATURE:
				sequence_InfixExpression(context, (CallFeature) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CALL_FUNCTION:
				sequence_CallExpression(context, (CallFunction) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CALL_NAMED_FUNCTION:
				sequence_OperationCall(context, (CallNamedFunction) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CHAINED_EXPRESSION:
				if(context == grammarAccess.getBlockExpressionWithoutBracketsRule()) {
					sequence_BlockExpressionWithoutBrackets(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getOneOrManyExpressionsRule()) {
					sequence_BlockExpression_BlockExpressionWithoutBrackets_OneOrManyExpressions(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAssignmentExpressionRule() ||
				   context == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getBlockExpressionRule() ||
				   context == grammarAccess.getCachedExpressionRule() ||
				   context == grammarAccess.getCallExpressionRule() ||
				   context == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPostopExpressionRule() ||
				   context == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getSetExpressionRule() ||
				   context == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getTopLevelExpressionRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_BlockExpression(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getInitializationBlockExpressionRule()) {
					sequence_InitializationBlockExpression(context, (ChainedExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.CLOSURE_PARAMETER:
				sequence_ClosureParameter(context, (ClosureParameter) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CLOSURE_TYPE_REF:
				sequence_ClosureTypeRef(context, (ClosureTypeRef) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.CREATE_EXPRESSION:
				sequence_ConstructorCallExpression(context, (CreateExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.DEF_VALUE:
				if(context == grammarAccess.getTopLevelExpressionRule()) {
					sequence_TopLevelExpression_ValDeclaration_VarDeclaration(context, (DefValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getValDeclarationRule()) {
					sequence_ValDeclaration(context, (DefValue) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getVarDeclarationRule()) {
					sequence_VarDeclaration(context, (DefValue) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.FEATURE_EXPRESSION:
				if(context == grammarAccess.getFeatureOfThisRule()) {
					sequence_FeatureOfThis(context, (FeatureExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAssignmentExpressionRule() ||
				   context == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getCachedExpressionRule() ||
				   context == grammarAccess.getCallExpressionRule() ||
				   context == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getOneOrManyExpressionsRule() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPostopExpressionRule() ||
				   context == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getSetExpressionRule() ||
				   context == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getTopLevelExpressionRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_InfixExpression(context, (FeatureExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.FUNCTION:
				if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAssignmentExpressionRule() ||
				   context == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getCachedExpressionRule() ||
				   context == grammarAccess.getCallExpressionRule() ||
				   context == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0() ||
				   context == grammarAccess.getClosureExpressionRule() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0() ||
				   context == grammarAccess.getLiteralRule() ||
				   context == grammarAccess.getLiteralFunctionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getOneOrManyExpressionsRule() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPostopExpressionRule() ||
				   context == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getSetExpressionRule() ||
				   context == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getTopLevelExpressionRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_ClosureExpression(context, (Function) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFunctionRule()) {
					sequence_Function(context, (Function) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.GUARD_EXPRESSION:
				sequence_GuardExpression(context, (GuardExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PARAMETER:
				sequence_Parameter(context, (Parameter) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.PROVIDED_CAPABILITY:
				sequence_ProvidedCapability(context, (ProvidedCapability) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.REQUIRED_CAPABILITY:
				sequence_RequiredCapability(context, (RequiredCapability) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.SIMPLE_TYPE_REF:
				sequence_SimpleTypeRef(context, (SimpleTypeRef) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNARY_OP_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNARY_POST_OP_EXPRESSION:
				sequence_PostopExpression(context, (UnaryPostOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNARY_PRE_OP_EXPRESSION:
				sequence_PreopExpression(context, (UnaryPreOpExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.UNIT:
				sequence_Unit(context, (Unit) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.VALUE_LITERAL:
				sequence_ValueLiteral(context, (ValueLiteral) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.VARIABLE_EXPRESSION:
				if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getAssignmentExpressionRule() ||
				   context == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getCachedExpressionRule() ||
				   context == grammarAccess.getCallExpressionRule() ||
				   context == grammarAccess.getCallExpressionAccess().getCallFunctionFuncExprAction_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getCallFeatureFuncExprAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getOneOrManyExpressionsRule() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPostopExpressionRule() ||
				   context == grammarAccess.getPostopExpressionAccess().getUnaryPostOpExpressionExprAction_1_0() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getSetExpressionRule() ||
				   context == grammarAccess.getSetExpressionAccess().getBinaryOpExpressionLeftExprAction_1_0() ||
				   context == grammarAccess.getTopLevelExpressionRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_KeywordVariables_PrimaryExpression_Value(context, (VariableExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getKeywordVariablesRule()) {
					sequence_KeywordVariables(context, (VariableExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getValueRule()) {
					sequence_Value(context, (VariableExpression) semanticObject); 
					return; 
				}
				else break;
			case BeeLangTestLanguagePackage.WITH_CONTEXT_EXPRESSION:
				sequence_WithContextExpression(context, (WithContextExpression) semanticObject); 
				return; 
			case BeeLangTestLanguagePackage.WITH_EXPRESSION:
				sequence_WithExpression(context, (WithExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         (leftExpr=MultiplicativeExpression_BinaryOpExpression_1_0 (functionName='*' | functionName='/' | functionName='%') rightExpr=SetExpression) | 
	 *         (leftExpr=SetExpression_BinaryOpExpression_1_0 functionName='..' rightExpr=UnaryOrInfixExpression) | 
	 *         (leftExpr=AdditiveExpression_BinaryOpExpression_1_0 (functionName='+' | functionName='-') rightExpr=MultiplicativeExpression) | 
	 *         (leftExpr=RelationalExpression_BinaryOpExpression_1_0 functionName=RelationalOperator rightExpr=AdditiveExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression_RelationalExpression_SetExpression(EObject context, BinaryOpExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         nameSpace=ID? 
	 *         name=ID 
	 *         alias=ID? 
	 *         condExpr=Expression? 
	 *         greedy?='greedy'? 
	 *         min=INT? 
	 *         max=INT? 
	 *         versionRange=ID?
	 *     )
	 */
	protected void sequence_AliasedRequiredCapability(EObject context, AliasedRequiredCapability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpr=AndExpression_AndExpression_1_0 rightExpr=RelationalExpression)
	 */
	protected void sequence_AndExpression(EObject context, AndExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.AND_EXPRESSION__LEFT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.AND_EXPRESSION__LEFT_EXPR));
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.AND_EXPRESSION__RIGHT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.AND_EXPRESSION__RIGHT_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftExprAction_1_0(), semanticObject.getLeftExpr());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightExprRelationalExpressionParserRuleCall_1_2_0(), semanticObject.getRightExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpr=AssignmentExpression_AssignmentExpression_1_0 functionName=AssignmentOperator rightExpr=AssignmentExpression)
	 */
	protected void sequence_AssignmentExpression(EObject context, AssignmentExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__LEFT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__LEFT_EXPR));
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__FUNCTION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__FUNCTION_NAME));
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftExprAction_1_0(), semanticObject.getLeftExpr());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getFunctionNameAssignmentOperatorParserRuleCall_1_1_0(), semanticObject.getFunctionName());
		feeder.accept(grammarAccess.getAssignmentExpressionAccess().getRightExprAssignmentExpressionParserRuleCall_1_2_0(), semanticObject.getRightExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expressions+=TopLevelExpression+
	 */
	protected void sequence_BlockExpressionWithoutBrackets(EObject context, ChainedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expressions+=TopLevelExpression+ | (expressions+=TopLevelExpression*))
	 */
	protected void sequence_BlockExpression_BlockExpressionWithoutBrackets_OneOrManyExpressions(EObject context, ChainedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expressions+=TopLevelExpression*)
	 */
	protected void sequence_BlockExpression(EObject context, ChainedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=OrExpression
	 */
	protected void sequence_CachedExpression(EObject context, CachedExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.CACHED_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.CACHED_EXPRESSION__EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCachedExpressionAccess().getExprOrExpressionParserRuleCall_0_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((funcExpr=CallExpression_CallFunction_1_0 parameterList=ParameterList?) | funcExpr=CallExpression_CallFunction_1_0)
	 */
	protected void sequence_CallExpression(EObject context, CallFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         returnType=TypeRef? 
	 *         (
	 *             (parameters+=ParameterDeclaration parameters+=ParameterDeclaration* (varArgs?='...' parameters+=ParameterDeclaration)?) | 
	 *             (varArgs?='...' parameters+=ParameterDeclaration)
	 *         )? 
	 *         funcExpr=OneOrManyExpressions
	 *     )
	 */
	protected void sequence_ClosureExpression(EObject context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=ClosureExpression
	 */
	protected void sequence_ClosureParameter(EObject context, ClosureParameter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.PARAMETER__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.PARAMETER__EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getClosureParameterAccess().getExprClosureExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (((parameterTypes+=ID parameterTypes+=ID* (varArgs?='...' parameterTypes+=ID)?) | (varArgs?='...' parameterTypes+=ID))? returnType=ID)
	 */
	protected void sequence_ClosureTypeRef(EObject context, ClosureTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (typeExpr=ID parameterList=ParameterList? alias=ID? contextBlock=InitializationBlockExpression?)
	 */
	protected void sequence_ConstructorCallExpression(EObject context, CreateExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     featureName=ID
	 */
	protected void sequence_FeatureOfThis(EObject context, FeatureExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         documentation=DOCUMENTATION? 
	 *         visibility=ID? 
	 *         final?='final'? 
	 *         returnType=TypeRef? 
	 *         name=ID 
	 *         (
	 *             (parameters+=ParameterDeclaration parameters+=ParameterDeclaration* (varArgs?='...' parameters+=ParameterDeclaration)?) | 
	 *             (varArgs?='...' parameters+=ParameterDeclaration)
	 *         )? 
	 *         guard=GuardExpression? 
	 *         (funcExpr=Expression | funcExpr=BlockExpression)
	 *     )
	 */
	protected void sequence_Function(EObject context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (guardExpr=Expression | guardExpr=BlockExpression)
	 */
	protected void sequence_GuardExpression(EObject context, GuardExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (objExpr=InfixExpression_AtExpression_1_1_0 indexExpr=Expression)
	 */
	protected void sequence_InfixExpression(EObject context, AtExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.AT_EXPRESSION__OBJ_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.AT_EXPRESSION__OBJ_EXPR));
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.AT_EXPRESSION__INDEX_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.AT_EXPRESSION__INDEX_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInfixExpressionAccess().getAtExpressionObjExprAction_1_1_0(), semanticObject.getObjExpr());
		feeder.accept(grammarAccess.getInfixExpressionAccess().getIndexExprExpressionParserRuleCall_1_1_2_0(), semanticObject.getIndexExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (funcExpr=InfixExpression_CallFeature_1_0_0 name=ID parameterList=ParameterList?)
	 */
	protected void sequence_InfixExpression(EObject context, CallFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (objExpr=InfixExpression_FeatureExpression_1_2_0 featureName=ID)
	 */
	protected void sequence_InfixExpression(EObject context, FeatureExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.FEATURE_EXPRESSION__OBJ_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.FEATURE_EXPRESSION__OBJ_EXPR));
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.FEATURE_EXPRESSION__FEATURE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.FEATURE_EXPRESSION__FEATURE_NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInfixExpressionAccess().getFeatureExpressionObjExprAction_1_2_0(), semanticObject.getObjExpr());
		feeder.accept(grammarAccess.getInfixExpressionAccess().getFeatureNameIDTerminalRuleCall_1_2_2_0(), semanticObject.getFeatureName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expressions+=InitializationExpression
	 */
	protected void sequence_InitializationBlockExpression(EObject context, ChainedExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpr=FeatureOfThis functionName=':' rightExpr=Expression)
	 */
	protected void sequence_InitializationExpression(EObject context, AssignmentExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__LEFT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__LEFT_EXPR));
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__FUNCTION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__FUNCTION_NAME));
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.ASSIGNMENT_EXPRESSION__RIGHT_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInitializationExpressionAccess().getLeftExprFeatureOfThisParserRuleCall_1_0(), semanticObject.getLeftExpr());
		feeder.accept(grammarAccess.getInitializationExpressionAccess().getFunctionNameColonKeyword_2_0(), semanticObject.getFunctionName());
		feeder.accept(grammarAccess.getInitializationExpressionAccess().getRightExprExpressionParserRuleCall_3_0(), semanticObject.getRightExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID | 
	 *         name='input' | 
	 *         name='output' | 
	 *         name='source' | 
	 *         name='properties' | 
	 *         name='builder' | 
	 *         name='unit' | 
	 *         name='this'
	 *     )
	 */
	protected void sequence_KeywordVariables_PrimaryExpression_Value(EObject context, VariableExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name='input' | 
	 *         name='output' | 
	 *         name='source' | 
	 *         name='properties' | 
	 *         name='builder' | 
	 *         name='unit' | 
	 *         name='this'
	 *     )
	 */
	protected void sequence_KeywordVariables(EObject context, VariableExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (units+=Unit* | functions+=Function*)
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID parameterList=ParameterList?)
	 */
	protected void sequence_OperationCall(EObject context, CallNamedFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (leftExpr=OrExpression_OrExpression_1_0 rightExpr=AndExpression)
	 */
	protected void sequence_OrExpression(EObject context, OrExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.OR_EXPRESSION__LEFT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.OR_EXPRESSION__LEFT_EXPR));
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.OR_EXPRESSION__RIGHT_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.OR_EXPRESSION__RIGHT_EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftExprAction_1_0(), semanticObject.getLeftExpr());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightExprAndExpressionParserRuleCall_1_2_0(), semanticObject.getRightExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=TypeRef? name=ID)
	 */
	protected void sequence_ParameterDeclaration(EObject context, ParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (parameters+=FirstParameter parameters+=FirstParameter*)
	 */
	protected void sequence_ParameterList(EObject context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_Parameter(EObject context, Parameter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.PARAMETER__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.PARAMETER__EXPR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParameterAccess().getExprExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expr=PostopExpression_UnaryPostOpExpression_1_0 (functionName='--' | functionName='++'))
	 */
	protected void sequence_PostopExpression(EObject context, UnaryPostOpExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((functionName='++' | functionName='--') expr=InfixExpression)
	 */
	protected void sequence_PreopExpression(EObject context, UnaryPreOpExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (nameSpace=ID? (condExpr=Expression? name=ID version=ID?)?)
	 */
	protected void sequence_ProvidedCapability(EObject context, ProvidedCapability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         nameSpace=ID? 
	 *         name=ID 
	 *         condExpr=Expression? 
	 *         greedy?='greedy'? 
	 *         min=INT? 
	 *         max=INT? 
	 *         versionRange=ID?
	 *     )
	 */
	protected void sequence_RequiredCapability(EObject context, RequiredCapability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (rawType=ID (actualArgumentsList+=ID actualArgumentsList+=ID*)?)
	 */
	protected void sequence_SimpleTypeRef(EObject context, SimpleTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((final?='final'? type=TypeRef? name=ID valueExpr=Expression?) | (final?='final'? immutable?='val' type=TypeRef? name=ID valueExpr=Expression))
	 */
	protected void sequence_TopLevelExpression_ValDeclaration_VarDeclaration(EObject context, DefValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((functionName='!' | functionName='-') expr=InfixExpression)
	 */
	protected void sequence_UnaryExpression(EObject context, UnaryOpExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         documentation=DOCUMENTATION? 
	 *         name=ID? 
	 *         version=ID? 
	 *         (implements+=SimpleTypeRef implements+=SimpleTypeRef*)? 
	 *         sourceLocation=Path? 
	 *         outputLocation=Path? 
	 *         providedCapabilities+=ProvidedCapability* 
	 *         requiredCapabilities+=AliasedRequiredCapability* 
	 *         metaRequiredCapabilities+=RequiredCapability* 
	 *         functions+=Function*
	 *     )
	 */
	protected void sequence_Unit(EObject context, Unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (final?='final'? immutable?='val' type=TypeRef? name=ID valueExpr=Expression)
	 */
	protected void sequence_ValDeclaration(EObject context, DefValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_ValueLiteral(EObject context, ValueLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.VALUE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.VALUE_LITERAL__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValueLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Value(EObject context, VariableExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BeeLangTestLanguagePackage.Literals.VARIABLE_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BeeLangTestLanguagePackage.Literals.VARIABLE_EXPRESSION__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValueAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (final?='final'? type=TypeRef? name=ID valueExpr=Expression?)
	 */
	protected void sequence_VarDeclaration(EObject context, DefValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expr=Expression alias=ID? contextBlock=BlockExpression)
	 */
	protected void sequence_WithContextExpression(EObject context, WithContextExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((referencedAdvice+=ID referencedAdvice+=ID*)? (funcExpr=Expression | funcExpr=BlockExpressionWithoutBrackets))
	 */
	protected void sequence_WithExpression(EObject context, WithExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
