/*
* generated by Xtext
*/
package org.eclipse.xtext.serializer.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IEObjectConsumer;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.xtext.serializer.services.ContextFinderTestLanguageGrammarAccess;

import com.google.inject.Inject;

@SuppressWarnings("all")
public class ContextFinderTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private ContextFinderTestLanguageGrammarAccess grammarAccess;
	
	@Override
	protected AbstractToken getRootToken(IEObjectConsumer inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IEObjectConsumer inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Model_Alternatives(this, this, 0, inst);
			case 1: return new AttributeExclusionTest1_Group(this, this, 1, inst);
			case 2: return new AttributeExclusionTest2_Group(this, this, 2, inst);
			case 3: return new NestedTypeTest1_NestedAssignment(this, this, 3, inst);
			case 4: return new NestedTypeTest2_NestedAssignment(this, this, 4, inst);
			case 5: return new NestedTypeChild_Alternatives(this, this, 5, inst);
			case 6: return new NestedTypeChild1_Group(this, this, 6, inst);
			case 7: return new NestedTypeChild2_Group(this, this, 7, inst);
			case 8: return new NestedTypeRecursiveTest1_Group(this, this, 8, inst);
			case 9: return new NestedTypeRecursiveTest2_Group(this, this, 9, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Model ****************
 *
 * Model:
 * 	"#1" attributeExclusion=(AttributeExclusionTest1 | AttributeExclusionTest2) | "#2" nestedType=(NestedTypeTest1 |
 * 	NestedTypeTest2) | "#3" nestedTypeRecursiveTest2=(NestedTypeRecursiveTest1 | NestedTypeRecursiveTest2);
 *
 **/

// "#1" attributeExclusion=(AttributeExclusionTest1 | AttributeExclusionTest2) | "#2" nestedType=(NestedTypeTest1 |
// NestedTypeTest2) | "#3" nestedTypeRecursiveTest2=(NestedTypeRecursiveTest1 | NestedTypeRecursiveTest2)
protected class Model_Alternatives extends AlternativesToken {

	public Model_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getModelAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Model_Group_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new Model_Group_1(lastRuleCallOrigin, this, 1, inst);
			case 2: return new Model_Group_2(lastRuleCallOrigin, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getModelRule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "#1" attributeExclusion=(AttributeExclusionTest1 | AttributeExclusionTest2)
protected class Model_Group_0 extends GroupToken {
	
	public Model_Group_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getModelAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Model_AttributeExclusionAssignment_0_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "#1"
protected class Model_NumberSignDigitOneKeyword_0_0 extends KeywordToken  {
	
	public Model_NumberSignDigitOneKeyword_0_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getModelAccess().getNumberSignDigitOneKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// attributeExclusion=(AttributeExclusionTest1 | AttributeExclusionTest2)
protected class Model_AttributeExclusionAssignment_0_1 extends AssignmentToken  {
	
	public Model_AttributeExclusionAssignment_0_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getAttributeExclusionAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AttributeExclusionTest1_Group(this, this, 0, inst);
			case 1: return new AttributeExclusionTest2_Group(this, this, 1, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("attributeExclusion",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("attributeExclusion");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeExclusionTest1Rule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getModelAccess().getAttributeExclusionAttributeExclusionTest1ParserRuleCall_0_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeExclusionTest2Rule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getModelAccess().getAttributeExclusionAttributeExclusionTest2ParserRuleCall_0_1_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_NumberSignDigitOneKeyword_0_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "#2" nestedType=(NestedTypeTest1 | NestedTypeTest2)
protected class Model_Group_1 extends GroupToken {
	
	public Model_Group_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getModelAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Model_NestedTypeAssignment_1_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "#2"
protected class Model_NumberSignDigitTwoKeyword_1_0 extends KeywordToken  {
	
	public Model_NumberSignDigitTwoKeyword_1_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getModelAccess().getNumberSignDigitTwoKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// nestedType=(NestedTypeTest1 | NestedTypeTest2)
protected class Model_NestedTypeAssignment_1_1 extends AssignmentToken  {
	
	public Model_NestedTypeAssignment_1_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getNestedTypeAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeTest1_NestedAssignment(this, this, 0, inst);
			case 1: return new NestedTypeTest2_NestedAssignment(this, this, 1, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("nestedType",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("nestedType");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNestedTypeTest1Rule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getModelAccess().getNestedTypeNestedTypeTest1ParserRuleCall_1_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNestedTypeTest2Rule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getModelAccess().getNestedTypeNestedTypeTest2ParserRuleCall_1_1_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_NumberSignDigitTwoKeyword_1_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "#3" nestedTypeRecursiveTest2=(NestedTypeRecursiveTest1 | NestedTypeRecursiveTest2)
protected class Model_Group_2 extends GroupToken {
	
	public Model_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getModelAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new Model_NestedTypeRecursiveTest2Assignment_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// "#3"
protected class Model_NumberSignDigitThreeKeyword_2_0 extends KeywordToken  {
	
	public Model_NumberSignDigitThreeKeyword_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getModelAccess().getNumberSignDigitThreeKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// nestedTypeRecursiveTest2=(NestedTypeRecursiveTest1 | NestedTypeRecursiveTest2)
protected class Model_NestedTypeRecursiveTest2Assignment_2_1 extends AssignmentToken  {
	
	public Model_NestedTypeRecursiveTest2Assignment_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getNestedTypeRecursiveTest2Assignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeRecursiveTest1_Group(this, this, 0, inst);
			case 1: return new NestedTypeRecursiveTest2_Group(this, this, 1, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("nestedTypeRecursiveTest2",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("nestedTypeRecursiveTest2");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNestedTypeRecursiveTest1Rule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getModelAccess().getNestedTypeRecursiveTest2NestedTypeRecursiveTest1ParserRuleCall_2_1_0_0(); 
				consumed = obj;
				return param;
			}
		}
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNestedTypeRecursiveTest2Rule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getModelAccess().getNestedTypeRecursiveTest2NestedTypeRecursiveTest2ParserRuleCall_2_1_0_1(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_NumberSignDigitThreeKeyword_2_0(lastRuleCallOrigin, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Model ****************/


/************ begin Rule AttributeExclusionTest1 ****************
 *
 * AttributeExclusionTest1 returns AttributeExclusionTest:
 * 	"kw1" attr1=ID;
 *
 **/

// "kw1" attr1=ID
protected class AttributeExclusionTest1_Group extends GroupToken {
	
	public AttributeExclusionTest1_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeExclusionTest1Access().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AttributeExclusionTest1_Attr1Assignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAttributeExclusionTest1Rule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "kw1"
protected class AttributeExclusionTest1_Kw1Keyword_0 extends KeywordToken  {
	
	public AttributeExclusionTest1_Kw1Keyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeExclusionTest1Access().getKw1Keyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// attr1=ID
protected class AttributeExclusionTest1_Attr1Assignment_1 extends AssignmentToken  {
	
	public AttributeExclusionTest1_Attr1Assignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeExclusionTest1Access().getAttr1Assignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AttributeExclusionTest1_Kw1Keyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("attr1",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("attr1");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getAttributeExclusionTest1Access().getAttr1IDTerminalRuleCall_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getAttributeExclusionTest1Access().getAttr1IDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule AttributeExclusionTest1 ****************/


/************ begin Rule AttributeExclusionTest2 ****************
 *
 * AttributeExclusionTest2 returns AttributeExclusionTest:
 * 	"kw2" attr2=ID;
 *
 **/

// "kw2" attr2=ID
protected class AttributeExclusionTest2_Group extends GroupToken {
	
	public AttributeExclusionTest2_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeExclusionTest2Access().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AttributeExclusionTest2_Attr2Assignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getAttributeExclusionTest2Rule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "kw2"
protected class AttributeExclusionTest2_Kw2Keyword_0 extends KeywordToken  {
	
	public AttributeExclusionTest2_Kw2Keyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeExclusionTest2Access().getKw2Keyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// attr2=ID
protected class AttributeExclusionTest2_Attr2Assignment_1 extends AssignmentToken  {
	
	public AttributeExclusionTest2_Attr2Assignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeExclusionTest2Access().getAttr2Assignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new AttributeExclusionTest2_Kw2Keyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("attr2",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("attr2");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getAttributeExclusionTest2Access().getAttr2IDTerminalRuleCall_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getAttributeExclusionTest2Access().getAttr2IDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule AttributeExclusionTest2 ****************/


/************ begin Rule NestedTypeTest1 ****************
 *
 * NestedTypeTest1 returns NestedTypeTest:
 * 	nested=NestedTypeChild1;
 *
 **/

// nested=NestedTypeChild1
protected class NestedTypeTest1_NestedAssignment extends AssignmentToken  {
	
	public NestedTypeTest1_NestedAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNestedTypeTest1Access().getNestedAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeChild1_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNestedTypeTest1Rule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("nested",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("nested");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNestedTypeChild1Rule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNestedTypeTest1Access().getNestedNestedTypeChild1ParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

/************ end Rule NestedTypeTest1 ****************/


/************ begin Rule NestedTypeTest2 ****************
 *
 * NestedTypeTest2 returns NestedTypeTest:
 * 	nested=NestedTypeChild2;
 *
 **/

// nested=NestedTypeChild2
protected class NestedTypeTest2_NestedAssignment extends AssignmentToken  {
	
	public NestedTypeTest2_NestedAssignment(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNestedTypeTest2Access().getNestedAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeChild2_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNestedTypeTest2Rule().getType().getClassifier())
			return null;
		if((value = eObjectConsumer.getConsumable("nested",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("nested");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IEObjectConsumer param = createEObjectConsumer((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNestedTypeChild2Rule().getType().getClassifier())) {
				type = AssignmentType.PARSER_RULE_CALL;
				element = grammarAccess.getNestedTypeTest2Access().getNestedNestedTypeChild2ParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		if(value == inst.getEObject() && !inst.isConsumed()) return null;
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, consumed);
		}	
	}	
}

/************ end Rule NestedTypeTest2 ****************/


/************ begin Rule NestedTypeChild ****************
 *
 * NestedTypeChild:
 * 	NestedTypeChild1 | NestedTypeChild2;
 *
 **/

// NestedTypeChild1 | NestedTypeChild2
protected class NestedTypeChild_Alternatives extends AlternativesToken {

	public NestedTypeChild_Alternatives(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNestedTypeChildAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeChild_NestedTypeChild1ParserRuleCall_0(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NestedTypeChild_NestedTypeChild2ParserRuleCall_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNestedTypeChild1Rule().getType().getClassifier() && 
		   getEObject().eClass() != grammarAccess.getNestedTypeChild2Rule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// NestedTypeChild1
protected class NestedTypeChild_NestedTypeChild1ParserRuleCall_0 extends RuleCallToken {
	
	public NestedTypeChild_NestedTypeChild1ParserRuleCall_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNestedTypeChildAccess().getNestedTypeChild1ParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeChild1_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNestedTypeChild1Rule().getType().getClassifier())
			return null;
		if(checkForRecursion(NestedTypeChild1_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}

// NestedTypeChild2
protected class NestedTypeChild_NestedTypeChild2ParserRuleCall_1 extends RuleCallToken {
	
	public NestedTypeChild_NestedTypeChild2ParserRuleCall_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNestedTypeChildAccess().getNestedTypeChild2ParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeChild2_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNestedTypeChild2Rule().getType().getClassifier())
			return null;
		if(checkForRecursion(NestedTypeChild2_Group.class, eObjectConsumer)) return null;
		return eObjectConsumer;
	}
	
    @Override
	public AbstractToken createFollowerAfterReturn(AbstractToken next,	int actIndex, int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule NestedTypeChild ****************/


/************ begin Rule NestedTypeChild1 ****************
 *
 * NestedTypeChild1:
 * 	"kw1" val=ID;
 *
 **/

// "kw1" val=ID
protected class NestedTypeChild1_Group extends GroupToken {
	
	public NestedTypeChild1_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNestedTypeChild1Access().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeChild1_ValAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNestedTypeChild1Rule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "kw1"
protected class NestedTypeChild1_Kw1Keyword_0 extends KeywordToken  {
	
	public NestedTypeChild1_Kw1Keyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNestedTypeChild1Access().getKw1Keyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// val=ID
protected class NestedTypeChild1_ValAssignment_1 extends AssignmentToken  {
	
	public NestedTypeChild1_ValAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNestedTypeChild1Access().getValAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeChild1_Kw1Keyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("val",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("val");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getNestedTypeChild1Access().getValIDTerminalRuleCall_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getNestedTypeChild1Access().getValIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule NestedTypeChild1 ****************/


/************ begin Rule NestedTypeChild2 ****************
 *
 * NestedTypeChild2:
 * 	"kw2" val=ID;
 *
 **/

// "kw2" val=ID
protected class NestedTypeChild2_Group extends GroupToken {
	
	public NestedTypeChild2_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNestedTypeChild2Access().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeChild2_ValAssignment_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNestedTypeChild2Rule().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// "kw2"
protected class NestedTypeChild2_Kw2Keyword_0 extends KeywordToken  {
	
	public NestedTypeChild2_Kw2Keyword_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNestedTypeChild2Access().getKw2Keyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

}

// val=ID
protected class NestedTypeChild2_ValAssignment_1 extends AssignmentToken  {
	
	public NestedTypeChild2_ValAssignment_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNestedTypeChild2Access().getValAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeChild2_Kw2Keyword_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	public IEObjectConsumer tryConsume() {
		if((value = eObjectConsumer.getConsumable("val",true)) == null) return null;
		IEObjectConsumer obj = eObjectConsumer.cloneAndConsume("val");
		if(valueSerializer.isValid(obj.getEObject(), grammarAccess.getNestedTypeChild2Access().getValIDTerminalRuleCall_1_0(), value, null)) {
			type = AssignmentType.TERMINAL_RULE_CALL;
			element = grammarAccess.getNestedTypeChild2Access().getValIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule NestedTypeChild2 ****************/


/************ begin Rule NestedTypeRecursiveTest1 ****************
 *
 * NestedTypeRecursiveTest1 returns NestedTypeRecursiveTest:
 * 	{NestedTypeRecursiveTest1} "kw1" ({NestedTypeRecursiveTest.left=current} ".")+;
 *
 **/

// {NestedTypeRecursiveTest1} "kw1" ({NestedTypeRecursiveTest.left=current} ".")+
protected class NestedTypeRecursiveTest1_Group extends GroupToken {
	
	public NestedTypeRecursiveTest1_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest1Access().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeRecursiveTest1_Group_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNestedTypeRecursiveTest1Access().getNestedTypeRecursiveTestLeftAction_2_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {NestedTypeRecursiveTest1}
protected class NestedTypeRecursiveTest1_NestedTypeRecursiveTest1Action_0 extends ActionToken  {

	public NestedTypeRecursiveTest1_NestedTypeRecursiveTest1Action_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest1Access().getNestedTypeRecursiveTest1Action_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// "kw1"
protected class NestedTypeRecursiveTest1_Kw1Keyword_1 extends KeywordToken  {
	
	public NestedTypeRecursiveTest1_Kw1Keyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest1Access().getKw1Keyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeRecursiveTest1_NestedTypeRecursiveTest1Action_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNestedTypeRecursiveTest1Access().getNestedTypeRecursiveTest1Action_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ({NestedTypeRecursiveTest.left=current} ".")+
protected class NestedTypeRecursiveTest1_Group_2 extends GroupToken {
	
	public NestedTypeRecursiveTest1_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest1Access().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeRecursiveTest1_FullStopKeyword_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// {NestedTypeRecursiveTest.left=current}
protected class NestedTypeRecursiveTest1_NestedTypeRecursiveTestLeftAction_2_0 extends ActionToken  {

	public NestedTypeRecursiveTest1_NestedTypeRecursiveTestLeftAction_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest1Access().getNestedTypeRecursiveTestLeftAction_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeRecursiveTest1_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NestedTypeRecursiveTest1_Kw1Keyword_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("left", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("left")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "."
protected class NestedTypeRecursiveTest1_FullStopKeyword_2_1 extends KeywordToken  {
	
	public NestedTypeRecursiveTest1_FullStopKeyword_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest1Access().getFullStopKeyword_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeRecursiveTest1_NestedTypeRecursiveTestLeftAction_2_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule NestedTypeRecursiveTest1 ****************/


/************ begin Rule NestedTypeRecursiveTest2 ****************
 *
 * NestedTypeRecursiveTest2 returns NestedTypeRecursiveTest:
 * 	{NestedTypeRecursiveTest2} "kw2" ({NestedTypeRecursiveTest.left=current} ".")+;
 *
 **/

// {NestedTypeRecursiveTest2} "kw2" ({NestedTypeRecursiveTest.left=current} ".")+
protected class NestedTypeRecursiveTest2_Group extends GroupToken {
	
	public NestedTypeRecursiveTest2_Group(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest2Access().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeRecursiveTest2_Group_2(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNestedTypeRecursiveTest2Access().getNestedTypeRecursiveTestLeftAction_2_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// {NestedTypeRecursiveTest2}
protected class NestedTypeRecursiveTest2_NestedTypeRecursiveTest2Action_0 extends ActionToken  {

	public NestedTypeRecursiveTest2_NestedTypeRecursiveTest2Action_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest2Access().getNestedTypeRecursiveTest2Action_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			default: return lastRuleCallOrigin.createFollowerAfterReturn(this, index, index, inst);
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(!eObjectConsumer.isConsumed()) return null;
		return eObjectConsumer;
	}
}

// "kw2"
protected class NestedTypeRecursiveTest2_Kw2Keyword_1 extends KeywordToken  {
	
	public NestedTypeRecursiveTest2_Kw2Keyword_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest2Access().getKw2Keyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeRecursiveTest2_NestedTypeRecursiveTest2Action_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		if(getEObject().eClass() != grammarAccess.getNestedTypeRecursiveTest2Access().getNestedTypeRecursiveTest2Action_0().getType().getClassifier())
			return null;
		return eObjectConsumer;
	}

}

// ({NestedTypeRecursiveTest.left=current} ".")+
protected class NestedTypeRecursiveTest2_Group_2 extends GroupToken {
	
	public NestedTypeRecursiveTest2_Group_2(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest2Access().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeRecursiveTest2_FullStopKeyword_2_1(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}

// {NestedTypeRecursiveTest.left=current}
protected class NestedTypeRecursiveTest2_NestedTypeRecursiveTestLeftAction_2_0 extends ActionToken  {

	public NestedTypeRecursiveTest2_NestedTypeRecursiveTestLeftAction_2_0(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest2Access().getNestedTypeRecursiveTestLeftAction_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeRecursiveTest2_Group_2(lastRuleCallOrigin, this, 0, inst);
			case 1: return new NestedTypeRecursiveTest2_Kw2Keyword_1(lastRuleCallOrigin, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IEObjectConsumer tryConsume() {
		Object val = eObjectConsumer.getConsumable("left", false);
		if(val == null) return null;
		if(!eObjectConsumer.isConsumedWithLastConsumtion("left")) return null;
		return createEObjectConsumer((EObject) val);
	}
}

// "."
protected class NestedTypeRecursiveTest2_FullStopKeyword_2_1 extends KeywordToken  {
	
	public NestedTypeRecursiveTest2_FullStopKeyword_2_1(AbstractToken lastRuleCallOrigin, AbstractToken next, int transitionIndex, IEObjectConsumer eObjectConsumer) {
		super(lastRuleCallOrigin, next, transitionIndex, eObjectConsumer);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNestedTypeRecursiveTest2Access().getFullStopKeyword_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IEObjectConsumer inst) {
		switch(index) {
			case 0: return new NestedTypeRecursiveTest2_NestedTypeRecursiveTestLeftAction_2_0(lastRuleCallOrigin, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule NestedTypeRecursiveTest2 ****************/

}
