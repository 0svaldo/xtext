/*
 * generated by Xtext
 */
package org.eclipse.xtext.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.services.XtextGrammarTestLanguageGrammarAccess;
import org.eclipse.xtext.xtextTest.AbstractElement;
import org.eclipse.xtext.xtextTest.Action;
import org.eclipse.xtext.xtextTest.Alternatives;
import org.eclipse.xtext.xtextTest.Assignment;
import org.eclipse.xtext.xtextTest.CharacterRange;
import org.eclipse.xtext.xtextTest.ConditionalBranch;
import org.eclipse.xtext.xtextTest.CrossReference;
import org.eclipse.xtext.xtextTest.EOF;
import org.eclipse.xtext.xtextTest.EnumLiteralDeclaration;
import org.eclipse.xtext.xtextTest.EnumRule;
import org.eclipse.xtext.xtextTest.GeneratedMetamodel;
import org.eclipse.xtext.xtextTest.Grammar;
import org.eclipse.xtext.xtextTest.Group;
import org.eclipse.xtext.xtextTest.Keyword;
import org.eclipse.xtext.xtextTest.NamedArgument;
import org.eclipse.xtext.xtextTest.NegatedToken;
import org.eclipse.xtext.xtextTest.Parameter;
import org.eclipse.xtext.xtextTest.ParserRule;
import org.eclipse.xtext.xtextTest.ReferencedMetamodel;
import org.eclipse.xtext.xtextTest.RuleCall;
import org.eclipse.xtext.xtextTest.TerminalRule;
import org.eclipse.xtext.xtextTest.TypeRef;
import org.eclipse.xtext.xtextTest.UnorderedGroup;
import org.eclipse.xtext.xtextTest.UntilToken;
import org.eclipse.xtext.xtextTest.Wildcard;
import org.eclipse.xtext.xtextTest.XtextTestPackage;

@SuppressWarnings("all")
public class XtextGrammarTestLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XtextGrammarTestLanguageGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == XtextTestPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case XtextTestPackage.ABSTRACT_ELEMENT:
				if(context == grammarAccess.getAssignmentRule()) {
					sequence_Assignment_Predicate(context, (AbstractElement) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAbstractTerminalRule() ||
				   context == grammarAccess.getAbstractTokenRule() ||
				   context == grammarAccess.getAbstractTokenWithCardinalityRule() ||
				   context == grammarAccess.getAlternativesRule() ||
				   context == grammarAccess.getAlternativesAccess().getAlternativesElementsAction_1_0() ||
				   context == grammarAccess.getConditionalBranchRule() ||
				   context == grammarAccess.getGroupRule() ||
				   context == grammarAccess.getGroupAccess().getGroupElementsAction_1_0() ||
				   context == grammarAccess.getParenthesizedElementRule() ||
				   context == grammarAccess.getUnorderedGroupRule() ||
				   context == grammarAccess.getUnorderedGroupAccess().getUnorderedGroupElementsAction_1_0()) {
					sequence_Assignment_Predicate_PredicatedGroup_PredicatedKeyword_PredicatedRuleCall(context, (AbstractElement) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPredicatedGroupRule()) {
					sequence_Predicate_PredicatedGroup(context, (AbstractElement) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPredicatedKeywordRule()) {
					sequence_Predicate_PredicatedKeyword(context, (AbstractElement) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getPredicatedRuleCallRule()) {
					sequence_Predicate_PredicatedRuleCall(context, (AbstractElement) semanticObject); 
					return; 
				}
				else break;
			case XtextTestPackage.ACTION:
				sequence_Action(context, (Action) semanticObject); 
				return; 
			case XtextTestPackage.ALTERNATIVES:
				if(context == grammarAccess.getAbstractTerminalRule() ||
				   context == grammarAccess.getAbstractTokenRule() ||
				   context == grammarAccess.getAbstractTokenWithCardinalityRule() ||
				   context == grammarAccess.getAlternativesRule() ||
				   context == grammarAccess.getAlternativesAccess().getAlternativesElementsAction_1_0() ||
				   context == grammarAccess.getConditionalBranchRule() ||
				   context == grammarAccess.getGroupRule() ||
				   context == grammarAccess.getGroupAccess().getGroupElementsAction_1_0() ||
				   context == grammarAccess.getParenthesizedElementRule() ||
				   context == grammarAccess.getUnorderedGroupRule() ||
				   context == grammarAccess.getUnorderedGroupAccess().getUnorderedGroupElementsAction_1_0()) {
					sequence_Alternatives(context, (Alternatives) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAssignableAlternativesRule() ||
				   context == grammarAccess.getAssignableAlternativesAccess().getAlternativesElementsAction_1_0() ||
				   context == grammarAccess.getAssignableTerminalRule() ||
				   context == grammarAccess.getParenthesizedAssignableElementRule()) {
					sequence_AssignableAlternatives(context, (Alternatives) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEnumLiteralsRule()) {
					sequence_EnumLiterals(context, (Alternatives) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getParenthesizedTerminalElementRule() ||
				   context == grammarAccess.getTerminalAlternativesRule() ||
				   context == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0() ||
				   context == grammarAccess.getTerminalGroupRule() ||
				   context == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0() ||
				   context == grammarAccess.getTerminalTokenRule() ||
				   context == grammarAccess.getTerminalTokenElementRule()) {
					sequence_TerminalAlternatives(context, (Alternatives) semanticObject); 
					return; 
				}
				else break;
			case XtextTestPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case XtextTestPackage.CHARACTER_RANGE:
				sequence_CharacterRange(context, (CharacterRange) semanticObject); 
				return; 
			case XtextTestPackage.CONDITIONAL_BRANCH:
				sequence_ConditionalBranch(context, (ConditionalBranch) semanticObject); 
				return; 
			case XtextTestPackage.CROSS_REFERENCE:
				sequence_CrossReference(context, (CrossReference) semanticObject); 
				return; 
			case XtextTestPackage.EOF:
				sequence_EOF(context, (EOF) semanticObject); 
				return; 
			case XtextTestPackage.ENUM_LITERAL_DECLARATION:
				sequence_EnumLiteralDeclaration(context, (EnumLiteralDeclaration) semanticObject); 
				return; 
			case XtextTestPackage.ENUM_RULE:
				sequence_EnumRule_ReturnsClause(context, (EnumRule) semanticObject); 
				return; 
			case XtextTestPackage.GENERATED_METAMODEL:
				sequence_GeneratedMetamodel(context, (GeneratedMetamodel) semanticObject); 
				return; 
			case XtextTestPackage.GRAMMAR:
				sequence_Grammar_HiddenClause(context, (Grammar) semanticObject); 
				return; 
			case XtextTestPackage.GROUP:
				if(context == grammarAccess.getAbstractTerminalRule() ||
				   context == grammarAccess.getAbstractTokenRule() ||
				   context == grammarAccess.getAbstractTokenWithCardinalityRule() ||
				   context == grammarAccess.getAlternativesRule() ||
				   context == grammarAccess.getAlternativesAccess().getAlternativesElementsAction_1_0() ||
				   context == grammarAccess.getConditionalBranchRule() ||
				   context == grammarAccess.getGroupRule() ||
				   context == grammarAccess.getGroupAccess().getGroupElementsAction_1_0() ||
				   context == grammarAccess.getParenthesizedElementRule() ||
				   context == grammarAccess.getUnorderedGroupRule() ||
				   context == grammarAccess.getUnorderedGroupAccess().getUnorderedGroupElementsAction_1_0()) {
					sequence_Group(context, (Group) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getParenthesizedTerminalElementRule() ||
				   context == grammarAccess.getTerminalAlternativesRule() ||
				   context == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0() ||
				   context == grammarAccess.getTerminalGroupRule() ||
				   context == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0() ||
				   context == grammarAccess.getTerminalTokenRule() ||
				   context == grammarAccess.getTerminalTokenElementRule()) {
					sequence_TerminalGroup(context, (Group) semanticObject); 
					return; 
				}
				else break;
			case XtextTestPackage.KEYWORD:
				sequence_Keyword(context, (Keyword) semanticObject); 
				return; 
			case XtextTestPackage.NAMED_ARGUMENT:
				sequence_NamedArgument(context, (NamedArgument) semanticObject); 
				return; 
			case XtextTestPackage.NEGATED_TOKEN:
				sequence_NegatedToken(context, (NegatedToken) semanticObject); 
				return; 
			case XtextTestPackage.PARAMETER:
				sequence_Parameter(context, (Parameter) semanticObject); 
				return; 
			case XtextTestPackage.PARSER_RULE:
				sequence_HiddenClause_ParserRule_RuleNameAndParams(context, (ParserRule) semanticObject); 
				return; 
			case XtextTestPackage.REFERENCED_METAMODEL:
				sequence_ReferencedMetamodel(context, (ReferencedMetamodel) semanticObject); 
				return; 
			case XtextTestPackage.RULE_CALL:
				if(context == grammarAccess.getAbstractTerminalRule() ||
				   context == grammarAccess.getAbstractTokenRule() ||
				   context == grammarAccess.getAbstractTokenWithCardinalityRule() ||
				   context == grammarAccess.getAlternativesRule() ||
				   context == grammarAccess.getAlternativesAccess().getAlternativesElementsAction_1_0() ||
				   context == grammarAccess.getAssignableAlternativesRule() ||
				   context == grammarAccess.getAssignableAlternativesAccess().getAlternativesElementsAction_1_0() ||
				   context == grammarAccess.getAssignableTerminalRule() ||
				   context == grammarAccess.getConditionalBranchRule() ||
				   context == grammarAccess.getCrossReferenceableTerminalRule() ||
				   context == grammarAccess.getGroupRule() ||
				   context == grammarAccess.getGroupAccess().getGroupElementsAction_1_0() ||
				   context == grammarAccess.getParenthesizedAssignableElementRule() ||
				   context == grammarAccess.getParenthesizedElementRule() ||
				   context == grammarAccess.getRuleCallRule() ||
				   context == grammarAccess.getUnorderedGroupRule() ||
				   context == grammarAccess.getUnorderedGroupAccess().getUnorderedGroupElementsAction_1_0()) {
					sequence_RuleCall(context, (RuleCall) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getParenthesizedTerminalElementRule() ||
				   context == grammarAccess.getTerminalAlternativesRule() ||
				   context == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0() ||
				   context == grammarAccess.getTerminalGroupRule() ||
				   context == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0() ||
				   context == grammarAccess.getTerminalRuleCallRule() ||
				   context == grammarAccess.getTerminalTokenRule() ||
				   context == grammarAccess.getTerminalTokenElementRule()) {
					sequence_TerminalRuleCall(context, (RuleCall) semanticObject); 
					return; 
				}
				else break;
			case XtextTestPackage.TERMINAL_RULE:
				sequence_ReturnsClause_TerminalRule(context, (TerminalRule) semanticObject); 
				return; 
			case XtextTestPackage.TYPE_REF:
				sequence_TypeRef(context, (TypeRef) semanticObject); 
				return; 
			case XtextTestPackage.UNORDERED_GROUP:
				sequence_UnorderedGroup(context, (UnorderedGroup) semanticObject); 
				return; 
			case XtextTestPackage.UNTIL_TOKEN:
				sequence_UntilToken(context, (UntilToken) semanticObject); 
				return; 
			case XtextTestPackage.WILDCARD:
				sequence_Wildcard(context, (Wildcard) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (type=TypeRef (feature=ID (operator='=' | operator='+='))?)
	 */
	protected void sequence_Action(EObject context, Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=Alternatives_Alternatives_1_0 elements+=ConditionalBranch+)
	 */
	protected void sequence_Alternatives(EObject context, Alternatives semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=AssignableAlternatives_Alternatives_1_0 elements+=AssignableTerminal+)
	 */
	protected void sequence_AssignableAlternatives(EObject context, Alternatives semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (feature=ID (operator='+=' | operator='=' | operator='?=') terminal=AssignableTerminal)
	 */
	protected void sequence_Assignment(EObject context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((predicated?='=>' | firstSetPredicated?='->') feature=ID (operator='+=' | operator='=' | operator='?=') terminal=AssignableTerminal)
	 */
	protected void sequence_Assignment_Predicate(EObject context, AbstractElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (predicated?='=>' | firstSetPredicated?='->') 
	 *         (
	 *             value=STRING | 
	 *             rule=[AbstractRule|ID] | 
	 *             (feature=ID (operator='+=' | operator='=' | operator='?=') terminal=AssignableTerminal) | 
	 *             elements+=Alternatives
	 *         )
	 *     )
	 */
	protected void sequence_Assignment_Predicate_PredicatedGroup_PredicatedKeyword_PredicatedRuleCall(EObject context, AbstractElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=CharacterRange_CharacterRange_1_0 right=Keyword)
	 */
	protected void sequence_CharacterRange(EObject context, CharacterRange semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtextTestPackage.Literals.CHARACTER_RANGE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextTestPackage.Literals.CHARACTER_RANGE__LEFT));
			if(transientValues.isValueTransient(semanticObject, XtextTestPackage.Literals.CHARACTER_RANGE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextTestPackage.Literals.CHARACTER_RANGE__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCharacterRangeAccess().getCharacterRangeLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCharacterRangeAccess().getRightKeywordParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (filtered=InverseLiteralValue parameter=[Parameter|ID] guardedElement=UnorderedGroup)
	 */
	protected void sequence_ConditionalBranch(EObject context, ConditionalBranch semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtextTestPackage.Literals.CONDITIONAL_BRANCH__FILTERED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextTestPackage.Literals.CONDITIONAL_BRANCH__FILTERED));
			if(transientValues.isValueTransient(semanticObject, XtextTestPackage.Literals.CONDITIONAL_BRANCH__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextTestPackage.Literals.CONDITIONAL_BRANCH__PARAMETER));
			if(transientValues.isValueTransient(semanticObject, XtextTestPackage.Literals.CONDITIONAL_BRANCH__GUARDED_ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextTestPackage.Literals.CONDITIONAL_BRANCH__GUARDED_ELEMENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConditionalBranchAccess().getFilteredInverseLiteralValueParserRuleCall_1_2_0(), semanticObject.isFiltered());
		feeder.accept(grammarAccess.getConditionalBranchAccess().getParameterParameterIDTerminalRuleCall_1_3_0_1(), semanticObject.getParameter());
		feeder.accept(grammarAccess.getConditionalBranchAccess().getGuardedElementUnorderedGroupParserRuleCall_1_5_0(), semanticObject.getGuardedElement());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=TypeRef terminal=CrossReferenceableTerminal?)
	 */
	protected void sequence_CrossReference(EObject context, CrossReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {EOF}
	 */
	protected void sequence_EOF(EObject context, EOF semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (enumLiteral=[EEnumLiteral|ID] literal=Keyword?)
	 */
	protected void sequence_EnumLiteralDeclaration(EObject context, EnumLiteralDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=EnumLiterals_Alternatives_1_0 elements+=EnumLiteralDeclaration+)
	 */
	protected void sequence_EnumLiterals(EObject context, Alternatives semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=TypeRef? alternatives=EnumLiterals)
	 */
	protected void sequence_EnumRule_ReturnsClause(EObject context, EnumRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID ePackage=[EPackage|STRING] alias=ID?)
	 */
	protected void sequence_GeneratedMetamodel(EObject context, GeneratedMetamodel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=GrammarID 
	 *         (usedGrammars+=[Grammar|GrammarID] usedGrammars+=[Grammar|GrammarID]*)? 
	 *         (definesHiddenTokens?='hidden' (hiddenTokens+=[AbstractRule|ID] hiddenTokens+=[AbstractRule|ID]*)?)? 
	 *         metamodelDeclarations+=AbstractMetamodelDeclaration* 
	 *         rules+=AbstractRule+
	 *     )
	 */
	protected void sequence_Grammar_HiddenClause(EObject context, Grammar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=Group_Group_1_0 elements+=AbstractToken+)
	 */
	protected void sequence_Group(EObject context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         fragment?='fragment'? 
	 *         name=ID 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         wildcard?='*'? 
	 *         (definesHiddenTokens?='hidden' (hiddenTokens+=[AbstractRule|ID] hiddenTokens+=[AbstractRule|ID]*)?)? 
	 *         alternatives=Alternatives
	 *     )
	 */
	protected void sequence_HiddenClause_ParserRule_RuleNameAndParams(EObject context, ParserRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Keyword(EObject context, Keyword semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtextTestPackage.Literals.KEYWORD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextTestPackage.Literals.KEYWORD__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getKeywordAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((literalValue=LiteralValue? parameter=[Parameter|ID]) | (parameter=[Parameter|ID] value=[Parameter|ID]))
	 */
	protected void sequence_NamedArgument(EObject context, NamedArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     terminal=TerminalTokenElement
	 */
	protected void sequence_NegatedToken(EObject context, NegatedToken semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtextTestPackage.Literals.ABSTRACT_NEGATED_TOKEN__TERMINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextTestPackage.Literals.ABSTRACT_NEGATED_TOKEN__TERMINAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNegatedTokenAccess().getTerminalTerminalTokenElementParserRuleCall_1_0(), semanticObject.getTerminal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Parameter(EObject context, Parameter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtextTestPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextTestPackage.Literals.PARAMETER__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((predicated?='=>' | firstSetPredicated?='->') elements+=Alternatives)
	 */
	protected void sequence_Predicate_PredicatedGroup(EObject context, AbstractElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((predicated?='=>' | firstSetPredicated?='->') value=STRING)
	 */
	protected void sequence_Predicate_PredicatedKeyword(EObject context, AbstractElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((predicated?='=>' | firstSetPredicated?='->') rule=[AbstractRule|ID])
	 */
	protected void sequence_Predicate_PredicatedRuleCall(EObject context, AbstractElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ePackage=[EPackage|STRING] alias=ID?)
	 */
	protected void sequence_ReferencedMetamodel(EObject context, ReferencedMetamodel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (((fragment?='fragment' name=ID) | (name=ID type=TypeRef?)) alternatives=TerminalAlternatives)
	 */
	protected void sequence_ReturnsClause_TerminalRule(EObject context, TerminalRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (rule=[AbstractRule|RuleID] (arguments+=NamedArgument arguments+=NamedArgument*)?)
	 */
	protected void sequence_RuleCall(EObject context, RuleCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=TerminalAlternatives_Alternatives_1_0 elements+=TerminalGroup+)
	 */
	protected void sequence_TerminalAlternatives(EObject context, Alternatives semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=TerminalGroup_Group_1_0 elements+=TerminalToken+)
	 */
	protected void sequence_TerminalGroup(EObject context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     rule=[AbstractRule|RuleID]
	 */
	protected void sequence_TerminalRuleCall(EObject context, RuleCall semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtextTestPackage.Literals.RULE_CALL__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextTestPackage.Literals.RULE_CALL__RULE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTerminalRuleCallAccess().getRuleAbstractRuleRuleIDParserRuleCall_0_1(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (metamodel=[AbstractMetamodelDeclaration|ID]? classifier=[EClassifier|ID])
	 */
	protected void sequence_TypeRef(EObject context, TypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (elements+=UnorderedGroup_UnorderedGroup_1_0 elements+=Group+)
	 */
	protected void sequence_UnorderedGroup(EObject context, UnorderedGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     terminal=TerminalTokenElement
	 */
	protected void sequence_UntilToken(EObject context, UntilToken semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, XtextTestPackage.Literals.ABSTRACT_NEGATED_TOKEN__TERMINAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XtextTestPackage.Literals.ABSTRACT_NEGATED_TOKEN__TERMINAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getUntilTokenAccess().getTerminalTerminalTokenElementParserRuleCall_1_0(), semanticObject.getTerminal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {Wildcard}
	 */
	protected void sequence_Wildcard(EObject context, Wildcard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
