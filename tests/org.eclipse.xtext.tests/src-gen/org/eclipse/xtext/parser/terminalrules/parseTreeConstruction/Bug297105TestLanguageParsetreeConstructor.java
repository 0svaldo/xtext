/*
* generated by Xtext
*/
package org.eclipse.xtext.parser.terminalrules.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.xtext.parser.terminalrules.services.Bug297105TestLanguageGrammarAccess;

import com.google.inject.Inject;

public class Bug297105TestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private Bug297105TestLanguageGrammarAccess grammarAccess;
	
	@Override	
	public Bug297105TestLanguageGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_ExpressionsAssignment(this, this, 0, inst);
			case 1: return new Expression_Group(this, this, 1, inst);
			case 2: return new Literal_Alternatives(this, this, 2, inst);
			case 3: return new IntLiteral_ValueAssignment(this, this, 3, inst);
			case 4: return new RealLiteral_ValueAssignment(this, this, 4, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Model ****************
 *
 * Model:
 *   expressions+=Expression*;
 *
 **/

// expressions+=Expression*
protected class Model_ExpressionsAssignment extends AssignmentToken  {
	
	public Model_ExpressionsAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getExpressionsAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getExpressionsExpressionParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_ExpressionsAssignment(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

/************ end Rule Model ****************/


/************ begin Rule Expression ****************
 *
 * Expression:
 *   left=Literal "+" right=Literal;
 *
 **/

// left=Literal "+" right=Literal
protected class Expression_Group extends GroupToken {
	
	public Expression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_RightAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IInstanceDescription tryConsume() {
		if(current.getDelegate().eClass() == grammarAccess.getExpressionRule().getType().getClassifier())
			return tryConsumeVal();
		return null;
	}

}

// left=Literal
protected class Expression_LeftAssignment_0 extends AssignmentToken  {
	
	public Expression_LeftAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExpressionAccess().getLeftAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Literal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("left",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("left");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLiteralRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExpressionAccess().getLeftLiteralParserRuleCall_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, consumed);
		}	
	}	
}

// "+"
protected class Expression_PlusSignKeyword_1 extends KeywordToken  {
	
	public Expression_PlusSignKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getExpressionAccess().getPlusSignKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LeftAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}

}

// right=Literal
protected class Expression_RightAssignment_2 extends AssignmentToken  {
	
	public Expression_RightAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExpressionAccess().getRightAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Literal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLiteralRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getExpressionAccess().getRightLiteralParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Expression_PlusSignKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Expression ****************/


/************ begin Rule Literal ****************
 *
 * Literal:
 *   RealLiteral|IntLiteral;
 *
 **/

// RealLiteral|IntLiteral
protected class Literal_Alternatives extends AlternativesToken {

	public Literal_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getLiteralAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Literal_RealLiteralParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Literal_IntLiteralParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}

    @Override
	public IInstanceDescription tryConsume() {
		if(current.getDelegate().eClass() == grammarAccess.getIntLiteralRule().getType().getClassifier() || 
		   current.getDelegate().eClass() == grammarAccess.getRealLiteralRule().getType().getClassifier())
			return tryConsumeVal();
		return null;
	}

}

// RealLiteral
protected class Literal_RealLiteralParserRuleCall_0 extends RuleCallToken {
	
	public Literal_RealLiteralParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralAccess().getRealLiteralParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RealLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IInstanceDescription tryConsume() {
		if(current.getDelegate().eClass() == grammarAccess.getRealLiteralRule().getType().getClassifier())
			return tryConsumeVal();
		return null;
	}

    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RealLiteral_ValueAssignment.class, current)) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// IntLiteral
protected class Literal_IntLiteralParserRuleCall_1 extends RuleCallToken {
	
	public Literal_IntLiteralParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getLiteralAccess().getIntLiteralParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new IntLiteral_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IInstanceDescription tryConsume() {
		if(current.getDelegate().eClass() == grammarAccess.getIntLiteralRule().getType().getClassifier())
			return tryConsumeVal();
		return null;
	}

    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(IntLiteral_ValueAssignment.class, current)) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Literal ****************/


/************ begin Rule IntLiteral ****************
 *
 * IntLiteral:
 *   value=IntValue;
 *
 **/

// value=IntValue
protected class IntLiteral_ValueAssignment extends AssignmentToken  {
	
	public IntLiteral_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getIntLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}

    @Override
	public IInstanceDescription tryConsume() {
		if(current.getDelegate().eClass() == grammarAccess.getIntLiteralRule().getType().getClassifier())
			return tryConsumeVal();
		return null;
	}

    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(valueSerializer.isValid(obj.getDelegate(), grammarAccess.getIntLiteralAccess().getValueIntValueParserRuleCall_0(), value, null)) {
			type = AssignmentType.DRC;
			element = grammarAccess.getIntLiteralAccess().getValueIntValueParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule IntLiteral ****************/


/************ begin Rule RealLiteral ****************
 *
 * RealLiteral:
 *   value=RealValue;
 *
 **/

// value=RealValue
protected class RealLiteral_ValueAssignment extends AssignmentToken  {
	
	public RealLiteral_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRealLiteralAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}

    @Override
	public IInstanceDescription tryConsume() {
		if(current.getDelegate().eClass() == grammarAccess.getRealLiteralRule().getType().getClassifier())
			return tryConsumeVal();
		return null;
	}

    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(valueSerializer.isValid(obj.getDelegate(), grammarAccess.getRealLiteralAccess().getValueRealValueParserRuleCall_0(), value, null)) {
			type = AssignmentType.DRC;
			element = grammarAccess.getRealLiteralAccess().getValueRealValueParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule RealLiteral ****************/




}
