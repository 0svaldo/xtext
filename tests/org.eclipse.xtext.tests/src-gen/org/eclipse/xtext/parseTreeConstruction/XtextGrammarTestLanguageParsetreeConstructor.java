/*
* generated by Xtext
*/
package org.eclipse.xtext.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.xtext.services.XtextGrammarTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class XtextGrammarTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private XtextGrammarTestLanguageGrammarAccess grammarAccess;
	
	@Override	
	public XtextGrammarTestLanguageGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_Group(this, this, 0, inst);
			case 1: return new AbstractRule_Alternatives(this, this, 1, inst);
			case 2: return new AbstractMetamodelDeclaration_Alternatives(this, this, 2, inst);
			case 3: return new GeneratedMetamodel_Group(this, this, 3, inst);
			case 4: return new ReferencedMetamodel_Group(this, this, 4, inst);
			case 5: return new ParserRule_Group(this, this, 5, inst);
			case 6: return new TypeRef_Group(this, this, 6, inst);
			case 7: return new Alternatives_Group(this, this, 7, inst);
			case 8: return new Group_Group(this, this, 8, inst);
			case 9: return new AbstractToken_Alternatives(this, this, 9, inst);
			case 10: return new AbstractTokenWithCardinality_Group(this, this, 10, inst);
			case 11: return new Action_Group(this, this, 11, inst);
			case 12: return new AbstractTerminal_Alternatives(this, this, 12, inst);
			case 13: return new Keyword_ValueAssignment(this, this, 13, inst);
			case 14: return new RuleCall_RuleAssignment(this, this, 14, inst);
			case 15: return new Assignment_Group(this, this, 15, inst);
			case 16: return new AssignableTerminal_Alternatives(this, this, 16, inst);
			case 17: return new ParenthesizedAssignableElement_Group(this, this, 17, inst);
			case 18: return new AssignableAlternatives_Group(this, this, 18, inst);
			case 19: return new CrossReference_Group(this, this, 19, inst);
			case 20: return new CrossReferenceableTerminal_Alternatives(this, this, 20, inst);
			case 21: return new ParenthesizedCrossReferenceableElement_Group(this, this, 21, inst);
			case 22: return new CrossReferenceableAlternatives_Group(this, this, 22, inst);
			case 23: return new ParenthesizedElement_Group(this, this, 23, inst);
			case 24: return new TerminalRule_Group(this, this, 24, inst);
			case 25: return new TerminalAlternatives_Group(this, this, 25, inst);
			case 26: return new TerminalGroup_Group(this, this, 26, inst);
			case 27: return new TerminalToken_Group(this, this, 27, inst);
			case 28: return new TerminalTokenElement_Alternatives(this, this, 28, inst);
			case 29: return new ParenthesizedTerminalElement_Group(this, this, 29, inst);
			case 30: return new AbstractNegatedToken_Alternatives(this, this, 30, inst);
			case 31: return new NegatedToken_Group(this, this, 31, inst);
			case 32: return new UntilToken_Group(this, this, 32, inst);
			case 33: return new Wildcard_Group(this, this, 33, inst);
			case 34: return new CharacterRange_Group(this, this, 34, inst);
			case 35: return new EnumRule_Group(this, this, 35, inst);
			case 36: return new EnumLiterals_Group(this, this, 36, inst);
			case 37: return new EnumLiteralDeclaration_Group(this, this, 37, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Grammar ****************
 *
 * Grammar:
 *   "grammar" name=GrammarID ("with" usedGrammars+=[Grammar|GrammarID] ("," usedGrammars
 *   +=[Grammar|GrammarID])*)? (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[
 *   AbstractRule] ("," hiddenTokens+=[AbstractRule])*)? ")")? metamodelDeclarations+=
 *   AbstractMetamodelDeclaration* rules+=AbstractRule+;
 *
 **/

// "grammar" name=GrammarID ("with" usedGrammars+=[Grammar|GrammarID] ("," usedGrammars
// +=[Grammar|GrammarID])*)? (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[
// AbstractRule] ("," hiddenTokens+=[AbstractRule])*)? ")")? metamodelDeclarations+=
// AbstractMetamodelDeclaration* rules+=AbstractRule+
protected class Grammar_Group extends GroupToken {
	
	public Grammar_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_RulesAssignment_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getGrammarRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "grammar"
protected class Grammar_GrammarKeyword_0 extends KeywordToken  {
	
	public Grammar_GrammarKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGrammarKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=GrammarID
protected class Grammar_NameAssignment_1 extends AssignmentToken  {
	
	public Grammar_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_GrammarKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getGrammarAccess().getNameGrammarIDParserRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("with" usedGrammars+=[Grammar|GrammarID] ("," usedGrammars+=[Grammar|GrammarID])*)
// ?
protected class Grammar_Group_2 extends GroupToken {
	
	public Grammar_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_Group_2_2(parent, this, 0, inst);
			case 1: return new Grammar_UsedGrammarsAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "with"
protected class Grammar_WithKeyword_2_0 extends KeywordToken  {
	
	public Grammar_WithKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getWithKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// usedGrammars+=[Grammar|GrammarID]
protected class Grammar_UsedGrammarsAssignment_2_1 extends AssignmentToken  {
	
	public Grammar_UsedGrammarsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getUsedGrammarsAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_WithKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("usedGrammars",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("usedGrammars");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGrammarAccess().getUsedGrammarsGrammarCrossReference_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getGrammarAccess().getUsedGrammarsGrammarCrossReference_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("," usedGrammars+=[Grammar|GrammarID])*
protected class Grammar_Group_2_2 extends GroupToken {
	
	public Grammar_Group_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_UsedGrammarsAssignment_2_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Grammar_CommaKeyword_2_2_0 extends KeywordToken  {
	
	public Grammar_CommaKeyword_2_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getCommaKeyword_2_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_Group_2_2(parent, this, 0, inst);
			case 1: return new Grammar_UsedGrammarsAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// usedGrammars+=[Grammar|GrammarID]
protected class Grammar_UsedGrammarsAssignment_2_2_1 extends AssignmentToken  {
	
	public Grammar_UsedGrammarsAssignment_2_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getUsedGrammarsAssignment_2_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_CommaKeyword_2_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("usedGrammars",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("usedGrammars");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGrammarAccess().getUsedGrammarsGrammarCrossReference_2_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getGrammarAccess().getUsedGrammarsGrammarCrossReference_2_2_1_0(); 
				return obj;
			}
		}
		return null;
	}

}



// (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=
// [AbstractRule])*)? ")")?
protected class Grammar_Group_3 extends GroupToken {
	
	public Grammar_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_RightParenthesisKeyword_3_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// definesHiddenTokens?="hidden"
protected class Grammar_DefinesHiddenTokensAssignment_3_0 extends AssignmentToken  {
	
	public Grammar_DefinesHiddenTokensAssignment_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getDefinesHiddenTokensAssignment_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_Group_2(parent, this, 0, inst);
			case 1: return new Grammar_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("definesHiddenTokens",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("definesHiddenTokens");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getGrammarAccess().getDefinesHiddenTokensHiddenKeyword_3_0_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class Grammar_LeftParenthesisKeyword_3_1 extends KeywordToken  {
	
	public Grammar_LeftParenthesisKeyword_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getLeftParenthesisKeyword_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_DefinesHiddenTokensAssignment_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=[AbstractRule])*)?
protected class Grammar_Group_3_2 extends GroupToken {
	
	public Grammar_Group_3_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup_3_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_Group_3_2_1(parent, this, 0, inst);
			case 1: return new Grammar_HiddenTokensAssignment_3_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// hiddenTokens+=[AbstractRule]
protected class Grammar_HiddenTokensAssignment_3_2_0 extends AssignmentToken  {
	
	public Grammar_HiddenTokensAssignment_3_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getHiddenTokensAssignment_3_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_LeftParenthesisKeyword_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hiddenTokens",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGrammarAccess().getHiddenTokensAbstractRuleCrossReference_3_2_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getGrammarAccess().getHiddenTokensAbstractRuleCrossReference_3_2_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("," hiddenTokens+=[AbstractRule])*
protected class Grammar_Group_3_2_1 extends GroupToken {
	
	public Grammar_Group_3_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup_3_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_HiddenTokensAssignment_3_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Grammar_CommaKeyword_3_2_1_0 extends KeywordToken  {
	
	public Grammar_CommaKeyword_3_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getCommaKeyword_3_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_Group_3_2_1(parent, this, 0, inst);
			case 1: return new Grammar_HiddenTokensAssignment_3_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// hiddenTokens+=[AbstractRule]
protected class Grammar_HiddenTokensAssignment_3_2_1_1 extends AssignmentToken  {
	
	public Grammar_HiddenTokensAssignment_3_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getHiddenTokensAssignment_3_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_CommaKeyword_3_2_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hiddenTokens",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGrammarAccess().getHiddenTokensAbstractRuleCrossReference_3_2_1_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getGrammarAccess().getHiddenTokensAbstractRuleCrossReference_3_2_1_1_0(); 
				return obj;
			}
		}
		return null;
	}

}



// ")"
protected class Grammar_RightParenthesisKeyword_3_3 extends KeywordToken  {
	
	public Grammar_RightParenthesisKeyword_3_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getRightParenthesisKeyword_3_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Grammar_Group_3_2(parent, this, 0, inst);
			case 1: return new Grammar_LeftParenthesisKeyword_3_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// metamodelDeclarations+=AbstractMetamodelDeclaration*
protected class Grammar_MetamodelDeclarationsAssignment_4 extends AssignmentToken  {
	
	public Grammar_MetamodelDeclarationsAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getMetamodelDeclarationsAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractMetamodelDeclaration_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("metamodelDeclarations",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("metamodelDeclarations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractMetamodelDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getGrammarAccess().getMetamodelDeclarationsAbstractMetamodelDeclarationParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Grammar_MetamodelDeclarationsAssignment_4(parent, next, actIndex, consumed);
			case 1: return new Grammar_Group_3(parent, next, actIndex, consumed);
			case 2: return new Grammar_Group_2(parent, next, actIndex, consumed);
			case 3: return new Grammar_NameAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// rules+=AbstractRule+
protected class Grammar_RulesAssignment_5 extends AssignmentToken  {
	
	public Grammar_RulesAssignment_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getRulesAssignment_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractRule_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rules",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rules");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractRuleRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getGrammarAccess().getRulesAbstractRuleParserRuleCall_5_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Grammar_RulesAssignment_5(parent, next, actIndex, consumed);
			case 1: return new Grammar_MetamodelDeclarationsAssignment_4(parent, next, actIndex, consumed);
			case 2: return new Grammar_Group_3(parent, next, actIndex, consumed);
			case 3: return new Grammar_Group_2(parent, next, actIndex, consumed);
			case 4: return new Grammar_NameAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Grammar ****************/



/************ begin Rule AbstractRule ****************
 *
 * AbstractRule:
 *   ParserRule|TerminalRule|EnumRule;
 *
 **/

// ParserRule|TerminalRule|EnumRule
protected class AbstractRule_Alternatives extends AlternativesToken {

	public AbstractRule_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractRuleAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractRule_ParserRuleParserRuleCall_0(parent, this, 0, inst);
			case 1: return new AbstractRule_TerminalRuleParserRuleCall_1(parent, this, 1, inst);
			case 2: return new AbstractRule_EnumRuleParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAbstractRuleRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// ParserRule
protected class AbstractRule_ParserRuleParserRuleCall_0 extends RuleCallToken {
	
	public AbstractRule_ParserRuleParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractRuleAccess().getParserRuleParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ParserRule_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParserRuleRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// TerminalRule
protected class AbstractRule_TerminalRuleParserRuleCall_1 extends RuleCallToken {
	
	public AbstractRule_TerminalRuleParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractRuleAccess().getTerminalRuleParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TerminalRule_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTerminalRuleRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// EnumRule
protected class AbstractRule_EnumRuleParserRuleCall_2 extends RuleCallToken {
	
	public AbstractRule_EnumRuleParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractRuleAccess().getEnumRuleParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumRule_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumRuleRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractRule ****************/


/************ begin Rule AbstractMetamodelDeclaration ****************
 *
 * AbstractMetamodelDeclaration:
 *   GeneratedMetamodel|ReferencedMetamodel;
 *
 **/

// GeneratedMetamodel|ReferencedMetamodel
protected class AbstractMetamodelDeclaration_Alternatives extends AlternativesToken {

	public AbstractMetamodelDeclaration_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractMetamodelDeclarationAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractMetamodelDeclaration_GeneratedMetamodelParserRuleCall_0(parent, this, 0, inst);
			case 1: return new AbstractMetamodelDeclaration_ReferencedMetamodelParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAbstractMetamodelDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// GeneratedMetamodel
protected class AbstractMetamodelDeclaration_GeneratedMetamodelParserRuleCall_0 extends RuleCallToken {
	
	public AbstractMetamodelDeclaration_GeneratedMetamodelParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractMetamodelDeclarationAccess().getGeneratedMetamodelParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GeneratedMetamodel_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(GeneratedMetamodel_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getGeneratedMetamodelRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ReferencedMetamodel
protected class AbstractMetamodelDeclaration_ReferencedMetamodelParserRuleCall_1 extends RuleCallToken {
	
	public AbstractMetamodelDeclaration_ReferencedMetamodelParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractMetamodelDeclarationAccess().getReferencedMetamodelParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ReferencedMetamodel_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ReferencedMetamodel_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getReferencedMetamodelRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractMetamodelDeclaration ****************/


/************ begin Rule GeneratedMetamodel ****************
 *
 * // constraint: typeSelect(GeneratedMetamodel).size() == typeSelect(GeneratedMetamodel).alias.size()
 * // generated metamodels have to have different aliases
 * 
 * 
 * GeneratedMetamodel:
 *   "generate" name=ID ePackage=[ecore::EPackage|STRING] ("as" alias=ID)?;
 *
 **/

// "generate" name=ID ePackage=[ecore::EPackage|STRING] ("as" alias=ID)?
protected class GeneratedMetamodel_Group extends GroupToken {
	
	public GeneratedMetamodel_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GeneratedMetamodel_Group_3(parent, this, 0, inst);
			case 1: return new GeneratedMetamodel_EPackageAssignment_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getGeneratedMetamodelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "generate"
protected class GeneratedMetamodel_GenerateKeyword_0 extends KeywordToken  {
	
	public GeneratedMetamodel_GenerateKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getGenerateKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class GeneratedMetamodel_NameAssignment_1 extends AssignmentToken  {
	
	public GeneratedMetamodel_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GeneratedMetamodel_GenerateKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getGeneratedMetamodelAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ePackage=[ecore::EPackage|STRING]
protected class GeneratedMetamodel_EPackageAssignment_2 extends AssignmentToken  {
	
	public GeneratedMetamodel_EPackageAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getEPackageAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GeneratedMetamodel_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("ePackage",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ePackage");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGeneratedMetamodelAccess().getEPackageEPackageCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getGeneratedMetamodelAccess().getEPackageEPackageCrossReference_2_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("as" alias=ID)?
protected class GeneratedMetamodel_Group_3 extends GroupToken {
	
	public GeneratedMetamodel_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getGroup_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GeneratedMetamodel_AliasAssignment_3_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "as"
protected class GeneratedMetamodel_AsKeyword_3_0 extends KeywordToken  {
	
	public GeneratedMetamodel_AsKeyword_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getAsKeyword_3_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GeneratedMetamodel_EPackageAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// alias=ID
protected class GeneratedMetamodel_AliasAssignment_3_1 extends AssignmentToken  {
	
	public GeneratedMetamodel_AliasAssignment_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getAliasAssignment_3_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new GeneratedMetamodel_AsKeyword_3_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("alias",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getGeneratedMetamodelAccess().getAliasIDTerminalRuleCall_3_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule GeneratedMetamodel ****************/


/************ begin Rule ReferencedMetamodel ****************
 *
 * // referenced metamodels may share aliases with other referenced metamodels
 * // and with generated metamodels
 * 
 * 
 * ReferencedMetamodel:
 *   "import" ePackage=[ecore::EPackage|STRING] ("as" alias=ID)?;
 *
 **/

// "import" ePackage=[ecore::EPackage|STRING] ("as" alias=ID)?
protected class ReferencedMetamodel_Group extends GroupToken {
	
	public ReferencedMetamodel_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ReferencedMetamodel_Group_2(parent, this, 0, inst);
			case 1: return new ReferencedMetamodel_EPackageAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getReferencedMetamodelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "import"
protected class ReferencedMetamodel_ImportKeyword_0 extends KeywordToken  {
	
	public ReferencedMetamodel_ImportKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getImportKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// ePackage=[ecore::EPackage|STRING]
protected class ReferencedMetamodel_EPackageAssignment_1 extends AssignmentToken  {
	
	public ReferencedMetamodel_EPackageAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getEPackageAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ReferencedMetamodel_ImportKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("ePackage",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ePackage");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReferencedMetamodelAccess().getEPackageEPackageCrossReference_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getReferencedMetamodelAccess().getEPackageEPackageCrossReference_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("as" alias=ID)?
protected class ReferencedMetamodel_Group_2 extends GroupToken {
	
	public ReferencedMetamodel_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ReferencedMetamodel_AliasAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "as"
protected class ReferencedMetamodel_AsKeyword_2_0 extends KeywordToken  {
	
	public ReferencedMetamodel_AsKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getAsKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ReferencedMetamodel_EPackageAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// alias=ID
protected class ReferencedMetamodel_AliasAssignment_2_1 extends AssignmentToken  {
	
	public ReferencedMetamodel_AliasAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getAliasAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ReferencedMetamodel_AsKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("alias",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getReferencedMetamodelAccess().getAliasIDTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule ReferencedMetamodel ****************/


/************ begin Rule ParserRule ****************
 *
 * ParserRule:
 *   name=ID ("returns" type=TypeRef)? (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[
 *   AbstractRule] ("," hiddenTokens+=[AbstractRule])*)? ")")? ":" alternatives=
 *   Alternatives ";";
 *
 **/

// name=ID ("returns" type=TypeRef)? (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[
// AbstractRule] ("," hiddenTokens+=[AbstractRule])*)? ")")? ":" alternatives=
// Alternatives ";"
protected class ParserRule_Group extends GroupToken {
	
	public ParserRule_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_SemicolonKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParserRuleRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class ParserRule_NameAssignment_0 extends AssignmentToken  {
	
	public ParserRule_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getParserRuleAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ("returns" type=TypeRef)?
protected class ParserRule_Group_1 extends GroupToken {
	
	public ParserRule_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_TypeAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "returns"
protected class ParserRule_ReturnsKeyword_1_0 extends KeywordToken  {
	
	public ParserRule_ReturnsKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getReturnsKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=TypeRef
protected class ParserRule_TypeAssignment_1_1 extends AssignmentToken  {
	
	public ParserRule_TypeAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getTypeAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParserRuleAccess().getTypeTypeRefParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ParserRule_ReturnsKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=
// [AbstractRule])*)? ")")?
protected class ParserRule_Group_2 extends GroupToken {
	
	public ParserRule_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_RightParenthesisKeyword_2_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// definesHiddenTokens?="hidden"
protected class ParserRule_DefinesHiddenTokensAssignment_2_0 extends AssignmentToken  {
	
	public ParserRule_DefinesHiddenTokensAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getDefinesHiddenTokensAssignment_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_Group_1(parent, this, 0, inst);
			case 1: return new ParserRule_NameAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("definesHiddenTokens",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("definesHiddenTokens");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getParserRuleAccess().getDefinesHiddenTokensHiddenKeyword_2_0_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class ParserRule_LeftParenthesisKeyword_2_1 extends KeywordToken  {
	
	public ParserRule_LeftParenthesisKeyword_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getLeftParenthesisKeyword_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_DefinesHiddenTokensAssignment_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=[AbstractRule])*)?
protected class ParserRule_Group_2_2 extends GroupToken {
	
	public ParserRule_Group_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getGroup_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_Group_2_2_1(parent, this, 0, inst);
			case 1: return new ParserRule_HiddenTokensAssignment_2_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// hiddenTokens+=[AbstractRule]
protected class ParserRule_HiddenTokensAssignment_2_2_0 extends AssignmentToken  {
	
	public ParserRule_HiddenTokensAssignment_2_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getHiddenTokensAssignment_2_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_LeftParenthesisKeyword_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hiddenTokens",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParserRuleAccess().getHiddenTokensAbstractRuleCrossReference_2_2_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getParserRuleAccess().getHiddenTokensAbstractRuleCrossReference_2_2_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("," hiddenTokens+=[AbstractRule])*
protected class ParserRule_Group_2_2_1 extends GroupToken {
	
	public ParserRule_Group_2_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getGroup_2_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_HiddenTokensAssignment_2_2_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class ParserRule_CommaKeyword_2_2_1_0 extends KeywordToken  {
	
	public ParserRule_CommaKeyword_2_2_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getCommaKeyword_2_2_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_Group_2_2_1(parent, this, 0, inst);
			case 1: return new ParserRule_HiddenTokensAssignment_2_2_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// hiddenTokens+=[AbstractRule]
protected class ParserRule_HiddenTokensAssignment_2_2_1_1 extends AssignmentToken  {
	
	public ParserRule_HiddenTokensAssignment_2_2_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getHiddenTokensAssignment_2_2_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_CommaKeyword_2_2_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("hiddenTokens",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParserRuleAccess().getHiddenTokensAbstractRuleCrossReference_2_2_1_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getParserRuleAccess().getHiddenTokensAbstractRuleCrossReference_2_2_1_1_0(); 
				return obj;
			}
		}
		return null;
	}

}



// ")"
protected class ParserRule_RightParenthesisKeyword_2_3 extends KeywordToken  {
	
	public ParserRule_RightParenthesisKeyword_2_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getRightParenthesisKeyword_2_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_Group_2_2(parent, this, 0, inst);
			case 1: return new ParserRule_LeftParenthesisKeyword_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// ":"
protected class ParserRule_ColonKeyword_3 extends KeywordToken  {
	
	public ParserRule_ColonKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getColonKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_Group_2(parent, this, 0, inst);
			case 1: return new ParserRule_Group_1(parent, this, 1, inst);
			case 2: return new ParserRule_NameAssignment_0(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// alternatives=Alternatives
protected class ParserRule_AlternativesAssignment_4 extends AssignmentToken  {
	
	public ParserRule_AlternativesAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getAlternativesAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Alternatives_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("alternatives",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alternatives");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAlternativesRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getParserRuleAccess().getAlternativesAlternativesParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new ParserRule_ColonKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class ParserRule_SemicolonKeyword_5 extends KeywordToken  {
	
	public ParserRule_SemicolonKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getSemicolonKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParserRule_AlternativesAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ParserRule ****************/


/************ begin Rule TypeRef ****************
 *
 * TypeRef:
 *   (metamodel=[AbstractMetamodelDeclaration] "::")? classifier=[ecore::EClassifier];
 *
 **/

// (metamodel=[AbstractMetamodelDeclaration] "::")? classifier=[ecore::EClassifier]
protected class TypeRef_Group extends GroupToken {
	
	public TypeRef_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_ClassifierAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// (metamodel=[AbstractMetamodelDeclaration] "::")?
protected class TypeRef_Group_0 extends GroupToken {
	
	public TypeRef_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_ColonColonKeyword_0_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// metamodel=[AbstractMetamodelDeclaration]
protected class TypeRef_MetamodelAssignment_0_0 extends AssignmentToken  {
	
	public TypeRef_MetamodelAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getMetamodelAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("metamodel",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("metamodel");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefAccess().getMetamodelAbstractMetamodelDeclarationCrossReference_0_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getTypeRefAccess().getMetamodelAbstractMetamodelDeclarationCrossReference_0_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// "::"
protected class TypeRef_ColonColonKeyword_0_1 extends KeywordToken  {
	
	public TypeRef_ColonColonKeyword_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getColonColonKeyword_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_MetamodelAssignment_0_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// classifier=[ecore::EClassifier]
protected class TypeRef_ClassifierAssignment_1 extends AssignmentToken  {
	
	public TypeRef_ClassifierAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getClassifierAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Group_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("classifier",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("classifier");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefAccess().getClassifierEClassifierCrossReference_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getTypeRefAccess().getClassifierEClassifierCrossReference_1_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule TypeRef ****************/


/************ begin Rule Alternatives ****************
 *
 * Alternatives returns AbstractElement:
 *   Group ({Alternatives.groups+=current} ("|" groups+=Group)+)?;
 *
 **/

// Group ({Alternatives.groups+=current} ("|" groups+=Group)+)?
protected class Alternatives_Group extends GroupToken {
	
	public Alternatives_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Alternatives_Group_1(parent, this, 0, inst);
			case 1: return new Alternatives_GroupParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAlternativesRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Group
protected class Alternatives_GroupParserRuleCall_0 extends RuleCallToken {
	
	public Alternatives_GroupParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getGroupParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Group_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Group_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getGroupRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Alternatives.groups+=current} ("|" groups+=Group)+)?
protected class Alternatives_Group_1 extends GroupToken {
	
	public Alternatives_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Alternatives_Group_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Alternatives.groups+=current}
protected class Alternatives_AlternativesGroupsAction_1_0 extends ActionToken  {

	public Alternatives_AlternativesGroupsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getAlternativesGroupsAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Alternatives_GroupParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAlternativesAccess().getAlternativesGroupsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return getDescr((EObject) val);
	}
}

// ("|" groups+=Group)+
protected class Alternatives_Group_1_1 extends GroupToken {
	
	public Alternatives_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Alternatives_GroupsAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "|"
protected class Alternatives_VerticalLineKeyword_1_1_0 extends KeywordToken  {
	
	public Alternatives_VerticalLineKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getVerticalLineKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Alternatives_Group_1_1(parent, this, 0, inst);
			case 1: return new Alternatives_AlternativesGroupsAction_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// groups+=Group
protected class Alternatives_GroupsAssignment_1_1_1 extends AssignmentToken  {
	
	public Alternatives_GroupsAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getGroupsAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Group_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("groups",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGroupRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAlternativesAccess().getGroupsGroupParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Alternatives_VerticalLineKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule Alternatives ****************/


/************ begin Rule Group ****************
 *
 * Group returns AbstractElement:
 *   AbstractToken ({Group.tokens+=current} tokens+=AbstractToken+)?;
 *
 **/

// AbstractToken ({Group.tokens+=current} tokens+=AbstractToken+)?
protected class Group_Group extends GroupToken {
	
	public Group_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGroupAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Group_Group_1(parent, this, 0, inst);
			case 1: return new Group_AbstractTokenParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getGroupRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AbstractToken
protected class Group_AbstractTokenParserRuleCall_0 extends RuleCallToken {
	
	public Group_AbstractTokenParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getGroupAccess().getAbstractTokenParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractToken_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AbstractToken_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAbstractTokenRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Group.tokens+=current} tokens+=AbstractToken+)?
protected class Group_Group_1 extends GroupToken {
	
	public Group_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGroupAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Group_TokensAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Group.tokens+=current}
protected class Group_GroupTokensAction_1_0 extends ActionToken  {

	public Group_GroupTokensAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getGroupAccess().getGroupTokensAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Group_AbstractTokenParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getGroupAccess().getGroupTokensAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("tokens", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("tokens")) return null;
		return getDescr((EObject) val);
	}
}

// tokens+=AbstractToken+
protected class Group_TokensAssignment_1_1 extends AssignmentToken  {
	
	public Group_TokensAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGroupAccess().getTokensAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractToken_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("tokens",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("tokens");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractTokenRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getGroupAccess().getTokensAbstractTokenParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Group_TokensAssignment_1_1(parent, next, actIndex, consumed);
			case 1: return new Group_GroupTokensAction_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Group ****************/


/************ begin Rule AbstractToken ****************
 *
 * AbstractToken returns AbstractElement:
 *   AbstractTokenWithCardinality|Action;
 *
 **/

// AbstractTokenWithCardinality|Action
protected class AbstractToken_Alternatives extends AlternativesToken {

	public AbstractToken_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractTokenAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractToken_AbstractTokenWithCardinalityParserRuleCall_0(parent, this, 0, inst);
			case 1: return new AbstractToken_ActionParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAbstractTokenRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AbstractTokenWithCardinality
protected class AbstractToken_AbstractTokenWithCardinalityParserRuleCall_0 extends RuleCallToken {
	
	public AbstractToken_AbstractTokenWithCardinalityParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTokenAccess().getAbstractTokenWithCardinalityParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractTokenWithCardinality_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AbstractTokenWithCardinality_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAbstractTokenWithCardinalityRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Action
protected class AbstractToken_ActionParserRuleCall_1 extends RuleCallToken {
	
	public AbstractToken_ActionParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTokenAccess().getActionParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Action_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getActionRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractToken ****************/


/************ begin Rule AbstractTokenWithCardinality ****************
 *
 * AbstractTokenWithCardinality returns AbstractElement:
 *   (Assignment|AbstractTerminal) cardinality=( "?" | "*" | "+" )?;
 *
 **/

// (Assignment|AbstractTerminal) cardinality=( "?" | "*" | "+" )?
protected class AbstractTokenWithCardinality_Group extends GroupToken {
	
	public AbstractTokenWithCardinality_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAbstractTokenWithCardinalityAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractTokenWithCardinality_CardinalityAssignment_1(parent, this, 0, inst);
			case 1: return new AbstractTokenWithCardinality_Alternatives_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAbstractTokenWithCardinalityRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Assignment|AbstractTerminal
protected class AbstractTokenWithCardinality_Alternatives_0 extends AlternativesToken {

	public AbstractTokenWithCardinality_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractTokenWithCardinalityAccess().getAlternatives_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractTokenWithCardinality_AssignmentParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new AbstractTokenWithCardinality_AbstractTerminalParserRuleCall_0_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// Assignment
protected class AbstractTokenWithCardinality_AssignmentParserRuleCall_0_0 extends RuleCallToken {
	
	public AbstractTokenWithCardinality_AssignmentParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTokenWithCardinalityAccess().getAssignmentParserRuleCall_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Assignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// AbstractTerminal
protected class AbstractTokenWithCardinality_AbstractTerminalParserRuleCall_0_1 extends RuleCallToken {
	
	public AbstractTokenWithCardinality_AbstractTerminalParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTokenWithCardinalityAccess().getAbstractTerminalParserRuleCall_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractTerminal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AbstractTerminal_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAbstractTerminalRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


// cardinality=( "?" | "*" | "+" )?
protected class AbstractTokenWithCardinality_CardinalityAssignment_1 extends AssignmentToken  {
	
	public AbstractTokenWithCardinality_CardinalityAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAbstractTokenWithCardinalityAccess().getCardinalityAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractTokenWithCardinality_Alternatives_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("cardinality",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("cardinality");
		if("?".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAbstractTokenWithCardinalityAccess().getCardinalityQuestionMarkKeyword_1_0_0();
			return obj;
		}
		if("*".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAbstractTokenWithCardinalityAccess().getCardinalityAsteriskKeyword_1_0_1();
			return obj;
		}
		if("+".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAbstractTokenWithCardinalityAccess().getCardinalityPlusSignKeyword_1_0_2();
			return obj;
		}
		return null;
	}

}


/************ end Rule AbstractTokenWithCardinality ****************/


/************ begin Rule Action ****************
 *
 * Action:
 *   "{" type=TypeRef ("." feature=ID operator=( "=" | "+=" ) "current")? "}";
 *
 **/

// "{" type=TypeRef ("." feature=ID operator=( "=" | "+=" ) "current")? "}"
protected class Action_Group extends GroupToken {
	
	public Action_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_RightCurlyBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getActionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "{"
protected class Action_LeftCurlyBracketKeyword_0 extends KeywordToken  {
	
	public Action_LeftCurlyBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getLeftCurlyBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// type=TypeRef
protected class Action_TypeAssignment_1 extends AssignmentToken  {
	
	public Action_TypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getActionAccess().getTypeTypeRefParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Action_LeftCurlyBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("." feature=ID operator=( "=" | "+=" ) "current")?
protected class Action_Group_2 extends GroupToken {
	
	public Action_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_CurrentKeyword_2_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "."
protected class Action_FullStopKeyword_2_0 extends KeywordToken  {
	
	public Action_FullStopKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getFullStopKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_TypeAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// feature=ID
protected class Action_FeatureAssignment_2_1 extends AssignmentToken  {
	
	public Action_FeatureAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getFeatureAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_FullStopKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("feature",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getActionAccess().getFeatureIDTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}

// operator=( "=" | "+=" )
protected class Action_OperatorAssignment_2_2 extends AssignmentToken  {
	
	public Action_OperatorAssignment_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getOperatorAssignment_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_FeatureAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getActionAccess().getOperatorEqualsSignKeyword_2_2_0_0();
			return obj;
		}
		if("+=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getActionAccess().getOperatorPlusSignEqualsSignKeyword_2_2_0_1();
			return obj;
		}
		return null;
	}

}

// "current"
protected class Action_CurrentKeyword_2_3 extends KeywordToken  {
	
	public Action_CurrentKeyword_2_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getCurrentKeyword_2_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_OperatorAssignment_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


// "}"
protected class Action_RightCurlyBracketKeyword_3 extends KeywordToken  {
	
	public Action_RightCurlyBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getRightCurlyBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Action_Group_2(parent, this, 0, inst);
			case 1: return new Action_TypeAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Action ****************/


/************ begin Rule AbstractTerminal ****************
 *
 * AbstractTerminal returns AbstractElement:
 *   Keyword|RuleCall|ParenthesizedElement;
 *
 **/

// Keyword|RuleCall|ParenthesizedElement
protected class AbstractTerminal_Alternatives extends AlternativesToken {

	public AbstractTerminal_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractTerminalAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractTerminal_KeywordParserRuleCall_0(parent, this, 0, inst);
			case 1: return new AbstractTerminal_RuleCallParserRuleCall_1(parent, this, 1, inst);
			case 2: return new AbstractTerminal_ParenthesizedElementParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAbstractTerminalRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Keyword
protected class AbstractTerminal_KeywordParserRuleCall_0 extends RuleCallToken {
	
	public AbstractTerminal_KeywordParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTerminalAccess().getKeywordParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Keyword_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Keyword_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// RuleCall
protected class AbstractTerminal_RuleCallParserRuleCall_1 extends RuleCallToken {
	
	public AbstractTerminal_RuleCallParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTerminalAccess().getRuleCallParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RuleCall_RuleAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RuleCall_RuleAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRuleCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ParenthesizedElement
protected class AbstractTerminal_ParenthesizedElementParserRuleCall_2 extends RuleCallToken {
	
	public AbstractTerminal_ParenthesizedElementParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTerminalAccess().getParenthesizedElementParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedElement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ParenthesizedElement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParenthesizedElementRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractTerminal ****************/


/************ begin Rule Keyword ****************
 *
 * Keyword:
 *   value=STRING;
 *
 **/

// value=STRING
protected class Keyword_ValueAssignment extends AssignmentToken  {
	
	public Keyword_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getKeywordAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getKeywordAccess().getValueSTRINGTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Keyword ****************/


/************ begin Rule RuleCall ****************
 *
 * RuleCall:
 *   rule=[AbstractRule];
 *
 **/

// rule=[AbstractRule]
protected class RuleCall_RuleAssignment extends AssignmentToken  {
	
	public RuleCall_RuleAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRuleCallAccess().getRuleAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRuleCallRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("rule",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rule");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRuleCallAccess().getRuleAbstractRuleCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getRuleCallAccess().getRuleAbstractRuleCrossReference_0(); 
				return obj;
			}
		}
		return null;
	}

}

/************ end Rule RuleCall ****************/


/************ begin Rule Assignment ****************
 *
 * Assignment:
 *   feature=ID operator=( "+=" | "=" | "?=" ) ^terminal=AssignableTerminal;
 *
 **/

// feature=ID operator=( "+=" | "=" | "?=" ) ^terminal=AssignableTerminal
protected class Assignment_Group extends GroupToken {
	
	public Assignment_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_TerminalAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// feature=ID
protected class Assignment_FeatureAssignment_0 extends AssignmentToken  {
	
	public Assignment_FeatureAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getFeatureAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("feature",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getAssignmentAccess().getFeatureIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// operator=( "+=" | "=" | "?=" )
protected class Assignment_OperatorAssignment_1 extends AssignmentToken  {
	
	public Assignment_OperatorAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getOperatorAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assignment_FeatureAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("+=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAssignmentAccess().getOperatorPlusSignEqualsSignKeyword_1_0_0();
			return obj;
		}
		if("=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAssignmentAccess().getOperatorEqualsSignKeyword_1_0_1();
			return obj;
		}
		if("?=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAssignmentAccess().getOperatorQuestionMarkEqualsSignKeyword_1_0_2();
			return obj;
		}
		return null;
	}

}

// ^terminal=AssignableTerminal
protected class Assignment_TerminalAssignment_2 extends AssignmentToken  {
	
	public Assignment_TerminalAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getTerminalAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignableTerminal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("terminal",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("terminal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignableTerminalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAssignmentAccess().getTerminalAssignableTerminalParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Assignment_OperatorAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Assignment ****************/


/************ begin Rule AssignableTerminal ****************
 *
 * AssignableTerminal returns AbstractElement:
 *   Keyword|RuleCall|ParenthesizedAssignableElement|CrossReference;
 *
 **/

// Keyword|RuleCall|ParenthesizedAssignableElement|CrossReference
protected class AssignableTerminal_Alternatives extends AlternativesToken {

	public AssignableTerminal_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAssignableTerminalAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignableTerminal_KeywordParserRuleCall_0(parent, this, 0, inst);
			case 1: return new AssignableTerminal_RuleCallParserRuleCall_1(parent, this, 1, inst);
			case 2: return new AssignableTerminal_ParenthesizedAssignableElementParserRuleCall_2(parent, this, 2, inst);
			case 3: return new AssignableTerminal_CrossReferenceParserRuleCall_3(parent, this, 3, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssignableTerminalRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Keyword
protected class AssignableTerminal_KeywordParserRuleCall_0 extends RuleCallToken {
	
	public AssignableTerminal_KeywordParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignableTerminalAccess().getKeywordParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Keyword_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Keyword_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// RuleCall
protected class AssignableTerminal_RuleCallParserRuleCall_1 extends RuleCallToken {
	
	public AssignableTerminal_RuleCallParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignableTerminalAccess().getRuleCallParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RuleCall_RuleAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RuleCall_RuleAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRuleCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ParenthesizedAssignableElement
protected class AssignableTerminal_ParenthesizedAssignableElementParserRuleCall_2 extends RuleCallToken {
	
	public AssignableTerminal_ParenthesizedAssignableElementParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignableTerminalAccess().getParenthesizedAssignableElementParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedAssignableElement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ParenthesizedAssignableElement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParenthesizedAssignableElementRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// CrossReference
protected class AssignableTerminal_CrossReferenceParserRuleCall_3 extends RuleCallToken {
	
	public AssignableTerminal_CrossReferenceParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignableTerminalAccess().getCrossReferenceParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReference_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CrossReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCrossReferenceRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AssignableTerminal ****************/


/************ begin Rule ParenthesizedAssignableElement ****************
 *
 * ParenthesizedAssignableElement returns AbstractElement:
 *   "(" AssignableAlternatives ")";
 *
 **/

// "(" AssignableAlternatives ")"
protected class ParenthesizedAssignableElement_Group extends GroupToken {
	
	public ParenthesizedAssignableElement_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParenthesizedAssignableElementAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedAssignableElement_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParenthesizedAssignableElementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "("
protected class ParenthesizedAssignableElement_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public ParenthesizedAssignableElement_LeftParenthesisKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedAssignableElementAccess().getLeftParenthesisKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// AssignableAlternatives
protected class ParenthesizedAssignableElement_AssignableAlternativesParserRuleCall_1 extends RuleCallToken {
	
	public ParenthesizedAssignableElement_AssignableAlternativesParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParenthesizedAssignableElementAccess().getAssignableAlternativesParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignableAlternatives_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AssignableAlternatives_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignableAlternativesRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedAssignableElement_LeftParenthesisKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParenthesizedAssignableElement_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public ParenthesizedAssignableElement_RightParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedAssignableElementAccess().getRightParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedAssignableElement_AssignableAlternativesParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ParenthesizedAssignableElement ****************/


/************ begin Rule AssignableAlternatives ****************
 *
 * AssignableAlternatives returns AbstractElement:
 *   AssignableTerminal ({Alternatives.groups+=current} ("|" groups+=AssignableTerminal)
 *   +)?;
 *
 **/

// AssignableTerminal ({Alternatives.groups+=current} ("|" groups+=AssignableTerminal)
// +)?
protected class AssignableAlternatives_Group extends GroupToken {
	
	public AssignableAlternatives_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignableAlternatives_Group_1(parent, this, 0, inst);
			case 1: return new AssignableAlternatives_AssignableTerminalParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssignableAlternativesRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// AssignableTerminal
protected class AssignableAlternatives_AssignableTerminalParserRuleCall_0 extends RuleCallToken {
	
	public AssignableAlternatives_AssignableTerminalParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getAssignableTerminalParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignableTerminal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AssignableTerminal_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignableTerminalRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Alternatives.groups+=current} ("|" groups+=AssignableTerminal)+)?
protected class AssignableAlternatives_Group_1 extends GroupToken {
	
	public AssignableAlternatives_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignableAlternatives_Group_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Alternatives.groups+=current}
protected class AssignableAlternatives_AlternativesGroupsAction_1_0 extends ActionToken  {

	public AssignableAlternatives_AlternativesGroupsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getAlternativesGroupsAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignableAlternatives_AssignableTerminalParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAssignableAlternativesAccess().getAlternativesGroupsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return getDescr((EObject) val);
	}
}

// ("|" groups+=AssignableTerminal)+
protected class AssignableAlternatives_Group_1_1 extends GroupToken {
	
	public AssignableAlternatives_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignableAlternatives_GroupsAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "|"
protected class AssignableAlternatives_VerticalLineKeyword_1_1_0 extends KeywordToken  {
	
	public AssignableAlternatives_VerticalLineKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getVerticalLineKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignableAlternatives_Group_1_1(parent, this, 0, inst);
			case 1: return new AssignableAlternatives_AlternativesGroupsAction_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// groups+=AssignableTerminal
protected class AssignableAlternatives_GroupsAssignment_1_1_1 extends AssignmentToken  {
	
	public AssignableAlternatives_GroupsAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getGroupsAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AssignableTerminal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("groups",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignableTerminalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAssignableAlternativesAccess().getGroupsAssignableTerminalParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new AssignableAlternatives_VerticalLineKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule AssignableAlternatives ****************/


/************ begin Rule CrossReference ****************
 *
 * CrossReference:
 *   "[" type=TypeRef ("|" ^terminal=CrossReferenceableTerminal)? "]";
 *
 **/

// "[" type=TypeRef ("|" ^terminal=CrossReferenceableTerminal)? "]"
protected class CrossReference_Group extends GroupToken {
	
	public CrossReference_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReference_RightSquareBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCrossReferenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "["
protected class CrossReference_LeftSquareBracketKeyword_0 extends KeywordToken  {
	
	public CrossReference_LeftSquareBracketKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getLeftSquareBracketKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// type=TypeRef
protected class CrossReference_TypeAssignment_1 extends AssignmentToken  {
	
	public CrossReference_TypeAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getTypeAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCrossReferenceAccess().getTypeTypeRefParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CrossReference_LeftSquareBracketKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("|" ^terminal=CrossReferenceableTerminal)?
protected class CrossReference_Group_2 extends GroupToken {
	
	public CrossReference_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReference_TerminalAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "|"
protected class CrossReference_VerticalLineKeyword_2_0 extends KeywordToken  {
	
	public CrossReference_VerticalLineKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getVerticalLineKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReference_TypeAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ^terminal=CrossReferenceableTerminal
protected class CrossReference_TerminalAssignment_2_1 extends AssignmentToken  {
	
	public CrossReference_TerminalAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getTerminalAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReferenceableTerminal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("terminal",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("terminal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCrossReferenceableTerminalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCrossReferenceAccess().getTerminalCrossReferenceableTerminalParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CrossReference_VerticalLineKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "]"
protected class CrossReference_RightSquareBracketKeyword_3 extends KeywordToken  {
	
	public CrossReference_RightSquareBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getRightSquareBracketKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReference_Group_2(parent, this, 0, inst);
			case 1: return new CrossReference_TypeAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule CrossReference ****************/


/************ begin Rule CrossReferenceableTerminal ****************
 *
 * CrossReferenceableTerminal returns AbstractElement:
 *   Keyword|RuleCall|ParenthesizedCrossReferenceableElement;
 *
 **/

// Keyword|RuleCall|ParenthesizedCrossReferenceableElement
protected class CrossReferenceableTerminal_Alternatives extends AlternativesToken {

	public CrossReferenceableTerminal_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCrossReferenceableTerminalAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReferenceableTerminal_KeywordParserRuleCall_0(parent, this, 0, inst);
			case 1: return new CrossReferenceableTerminal_RuleCallParserRuleCall_1(parent, this, 1, inst);
			case 2: return new CrossReferenceableTerminal_ParenthesizedCrossReferenceableElementParserRuleCall_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCrossReferenceableTerminalRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Keyword
protected class CrossReferenceableTerminal_KeywordParserRuleCall_0 extends RuleCallToken {
	
	public CrossReferenceableTerminal_KeywordParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCrossReferenceableTerminalAccess().getKeywordParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Keyword_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Keyword_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// RuleCall
protected class CrossReferenceableTerminal_RuleCallParserRuleCall_1 extends RuleCallToken {
	
	public CrossReferenceableTerminal_RuleCallParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCrossReferenceableTerminalAccess().getRuleCallParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RuleCall_RuleAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RuleCall_RuleAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRuleCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ParenthesizedCrossReferenceableElement
protected class CrossReferenceableTerminal_ParenthesizedCrossReferenceableElementParserRuleCall_2 extends RuleCallToken {
	
	public CrossReferenceableTerminal_ParenthesizedCrossReferenceableElementParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCrossReferenceableTerminalAccess().getParenthesizedCrossReferenceableElementParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedCrossReferenceableElement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ParenthesizedCrossReferenceableElement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParenthesizedCrossReferenceableElementRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule CrossReferenceableTerminal ****************/


/************ begin Rule ParenthesizedCrossReferenceableElement ****************
 *
 * ParenthesizedCrossReferenceableElement returns AbstractElement:
 *   "(" CrossReferenceableAlternatives ")";
 *
 **/

// "(" CrossReferenceableAlternatives ")"
protected class ParenthesizedCrossReferenceableElement_Group extends GroupToken {
	
	public ParenthesizedCrossReferenceableElement_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParenthesizedCrossReferenceableElementAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedCrossReferenceableElement_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParenthesizedCrossReferenceableElementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "("
protected class ParenthesizedCrossReferenceableElement_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public ParenthesizedCrossReferenceableElement_LeftParenthesisKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedCrossReferenceableElementAccess().getLeftParenthesisKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// CrossReferenceableAlternatives
protected class ParenthesizedCrossReferenceableElement_CrossReferenceableAlternativesParserRuleCall_1 extends RuleCallToken {
	
	public ParenthesizedCrossReferenceableElement_CrossReferenceableAlternativesParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParenthesizedCrossReferenceableElementAccess().getCrossReferenceableAlternativesParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReferenceableAlternatives_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CrossReferenceableAlternatives_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCrossReferenceableAlternativesRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedCrossReferenceableElement_LeftParenthesisKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParenthesizedCrossReferenceableElement_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public ParenthesizedCrossReferenceableElement_RightParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedCrossReferenceableElementAccess().getRightParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedCrossReferenceableElement_CrossReferenceableAlternativesParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ParenthesizedCrossReferenceableElement ****************/


/************ begin Rule CrossReferenceableAlternatives ****************
 *
 * CrossReferenceableAlternatives returns AbstractElement:
 *   CrossReferenceableTerminal ({Alternatives.groups+=current} ("|" groups+=
 *   CrossReferenceableTerminal)+)?;
 *
 **/

// CrossReferenceableTerminal ({Alternatives.groups+=current} ("|" groups+=
// CrossReferenceableTerminal)+)?
protected class CrossReferenceableAlternatives_Group extends GroupToken {
	
	public CrossReferenceableAlternatives_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReferenceableAlternatives_Group_1(parent, this, 0, inst);
			case 1: return new CrossReferenceableAlternatives_CrossReferenceableTerminalParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCrossReferenceableAlternativesRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// CrossReferenceableTerminal
protected class CrossReferenceableAlternatives_CrossReferenceableTerminalParserRuleCall_0 extends RuleCallToken {
	
	public CrossReferenceableAlternatives_CrossReferenceableTerminalParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getCrossReferenceableTerminalParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReferenceableTerminal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CrossReferenceableTerminal_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCrossReferenceableTerminalRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Alternatives.groups+=current} ("|" groups+=CrossReferenceableTerminal)+)?
protected class CrossReferenceableAlternatives_Group_1 extends GroupToken {
	
	public CrossReferenceableAlternatives_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReferenceableAlternatives_Group_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Alternatives.groups+=current}
protected class CrossReferenceableAlternatives_AlternativesGroupsAction_1_0 extends ActionToken  {

	public CrossReferenceableAlternatives_AlternativesGroupsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getAlternativesGroupsAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReferenceableAlternatives_CrossReferenceableTerminalParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCrossReferenceableAlternativesAccess().getAlternativesGroupsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return getDescr((EObject) val);
	}
}

// ("|" groups+=CrossReferenceableTerminal)+
protected class CrossReferenceableAlternatives_Group_1_1 extends GroupToken {
	
	public CrossReferenceableAlternatives_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReferenceableAlternatives_GroupsAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "|"
protected class CrossReferenceableAlternatives_VerticalLineKeyword_1_1_0 extends KeywordToken  {
	
	public CrossReferenceableAlternatives_VerticalLineKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getVerticalLineKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReferenceableAlternatives_Group_1_1(parent, this, 0, inst);
			case 1: return new CrossReferenceableAlternatives_AlternativesGroupsAction_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// groups+=CrossReferenceableTerminal
protected class CrossReferenceableAlternatives_GroupsAssignment_1_1_1 extends AssignmentToken  {
	
	public CrossReferenceableAlternatives_GroupsAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getGroupsAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CrossReferenceableTerminal_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("groups",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCrossReferenceableTerminalRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCrossReferenceableAlternativesAccess().getGroupsCrossReferenceableTerminalParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CrossReferenceableAlternatives_VerticalLineKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule CrossReferenceableAlternatives ****************/


/************ begin Rule ParenthesizedElement ****************
 *
 * ParenthesizedElement returns AbstractElement:
 *   "(" Alternatives ")";
 *
 **/

// "(" Alternatives ")"
protected class ParenthesizedElement_Group extends GroupToken {
	
	public ParenthesizedElement_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParenthesizedElementAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedElement_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParenthesizedElementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "("
protected class ParenthesizedElement_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public ParenthesizedElement_LeftParenthesisKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedElementAccess().getLeftParenthesisKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// Alternatives
protected class ParenthesizedElement_AlternativesParserRuleCall_1 extends RuleCallToken {
	
	public ParenthesizedElement_AlternativesParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParenthesizedElementAccess().getAlternativesParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Alternatives_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Alternatives_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAlternativesRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedElement_LeftParenthesisKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParenthesizedElement_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public ParenthesizedElement_RightParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedElementAccess().getRightParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedElement_AlternativesParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ParenthesizedElement ****************/


/************ begin Rule TerminalRule ****************
 *
 * TerminalRule:
 *   "terminal" name=ID ("returns" type=TypeRef)? ":" alternatives=TerminalAlternatives ";"
 * ;
 *
 **/

// "terminal" name=ID ("returns" type=TypeRef)? ":" alternatives=TerminalAlternatives ";"
protected class TerminalRule_Group extends GroupToken {
	
	public TerminalRule_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalRule_SemicolonKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTerminalRuleRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "terminal"
protected class TerminalRule_TerminalKeyword_0 extends KeywordToken  {
	
	public TerminalRule_TerminalKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getTerminalKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class TerminalRule_NameAssignment_1 extends AssignmentToken  {
	
	public TerminalRule_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalRule_TerminalKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getTerminalRuleAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("returns" type=TypeRef)?
protected class TerminalRule_Group_2 extends GroupToken {
	
	public TerminalRule_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalRule_TypeAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "returns"
protected class TerminalRule_ReturnsKeyword_2_0 extends KeywordToken  {
	
	public TerminalRule_ReturnsKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getReturnsKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalRule_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=TypeRef
protected class TerminalRule_TypeAssignment_2_1 extends AssignmentToken  {
	
	public TerminalRule_TypeAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getTypeAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTerminalRuleAccess().getTypeTypeRefParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TerminalRule_ReturnsKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ":"
protected class TerminalRule_ColonKeyword_3 extends KeywordToken  {
	
	public TerminalRule_ColonKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getColonKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalRule_Group_2(parent, this, 0, inst);
			case 1: return new TerminalRule_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// alternatives=TerminalAlternatives
protected class TerminalRule_AlternativesAssignment_4 extends AssignmentToken  {
	
	public TerminalRule_AlternativesAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getAlternativesAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalAlternatives_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("alternatives",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alternatives");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTerminalAlternativesRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTerminalRuleAccess().getAlternativesTerminalAlternativesParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TerminalRule_ColonKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class TerminalRule_SemicolonKeyword_5 extends KeywordToken  {
	
	public TerminalRule_SemicolonKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getSemicolonKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalRule_AlternativesAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule TerminalRule ****************/


/************ begin Rule TerminalAlternatives ****************
 *
 * TerminalAlternatives returns AbstractElement:
 *   TerminalGroup ({Alternatives.groups+=current} ("|" groups+=TerminalGroup)+)?;
 *
 **/

// TerminalGroup ({Alternatives.groups+=current} ("|" groups+=TerminalGroup)+)?
protected class TerminalAlternatives_Group extends GroupToken {
	
	public TerminalAlternatives_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalAlternatives_Group_1(parent, this, 0, inst);
			case 1: return new TerminalAlternatives_TerminalGroupParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTerminalAlternativesRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// TerminalGroup
protected class TerminalAlternatives_TerminalGroupParserRuleCall_0 extends RuleCallToken {
	
	public TerminalAlternatives_TerminalGroupParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getTerminalGroupParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalGroup_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TerminalGroup_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTerminalGroupRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Alternatives.groups+=current} ("|" groups+=TerminalGroup)+)?
protected class TerminalAlternatives_Group_1 extends GroupToken {
	
	public TerminalAlternatives_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalAlternatives_Group_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Alternatives.groups+=current}
protected class TerminalAlternatives_AlternativesGroupsAction_1_0 extends ActionToken  {

	public TerminalAlternatives_AlternativesGroupsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getAlternativesGroupsAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalAlternatives_TerminalGroupParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getTerminalAlternativesAccess().getAlternativesGroupsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return getDescr((EObject) val);
	}
}

// ("|" groups+=TerminalGroup)+
protected class TerminalAlternatives_Group_1_1 extends GroupToken {
	
	public TerminalAlternatives_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalAlternatives_GroupsAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "|"
protected class TerminalAlternatives_VerticalLineKeyword_1_1_0 extends KeywordToken  {
	
	public TerminalAlternatives_VerticalLineKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getVerticalLineKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalAlternatives_Group_1_1(parent, this, 0, inst);
			case 1: return new TerminalAlternatives_AlternativesGroupsAction_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// groups+=TerminalGroup
protected class TerminalAlternatives_GroupsAssignment_1_1_1 extends AssignmentToken  {
	
	public TerminalAlternatives_GroupsAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getGroupsAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalGroup_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("groups",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTerminalGroupRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTerminalAlternativesAccess().getGroupsTerminalGroupParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TerminalAlternatives_VerticalLineKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule TerminalAlternatives ****************/


/************ begin Rule TerminalGroup ****************
 *
 * TerminalGroup returns AbstractElement:
 *   TerminalToken ({Group.tokens+=current} tokens+=TerminalToken+)?;
 *
 **/

// TerminalToken ({Group.tokens+=current} tokens+=TerminalToken+)?
protected class TerminalGroup_Group extends GroupToken {
	
	public TerminalGroup_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalGroupAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalGroup_Group_1(parent, this, 0, inst);
			case 1: return new TerminalGroup_TerminalTokenParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTerminalGroupRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// TerminalToken
protected class TerminalGroup_TerminalTokenParserRuleCall_0 extends RuleCallToken {
	
	public TerminalGroup_TerminalTokenParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalGroupAccess().getTerminalTokenParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalToken_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TerminalToken_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTerminalTokenRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Group.tokens+=current} tokens+=TerminalToken+)?
protected class TerminalGroup_Group_1 extends GroupToken {
	
	public TerminalGroup_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalGroupAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalGroup_TokensAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Group.tokens+=current}
protected class TerminalGroup_GroupTokensAction_1_0 extends ActionToken  {

	public TerminalGroup_GroupTokensAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getTerminalGroupAccess().getGroupTokensAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalGroup_TerminalTokenParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getTerminalGroupAccess().getGroupTokensAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("tokens", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("tokens")) return null;
		return getDescr((EObject) val);
	}
}

// tokens+=TerminalToken+
protected class TerminalGroup_TokensAssignment_1_1 extends AssignmentToken  {
	
	public TerminalGroup_TokensAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalGroupAccess().getTokensAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalToken_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("tokens",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("tokens");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTerminalTokenRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTerminalGroupAccess().getTokensTerminalTokenParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TerminalGroup_TokensAssignment_1_1(parent, next, actIndex, consumed);
			case 1: return new TerminalGroup_GroupTokensAction_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule TerminalGroup ****************/


/************ begin Rule TerminalToken ****************
 *
 * TerminalToken returns AbstractElement:
 *   TerminalTokenElement cardinality=( "?" | "*" | "+" )?;
 *
 **/

// TerminalTokenElement cardinality=( "?" | "*" | "+" )?
protected class TerminalToken_Group extends GroupToken {
	
	public TerminalToken_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalTokenAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalToken_CardinalityAssignment_1(parent, this, 0, inst);
			case 1: return new TerminalToken_TerminalTokenElementParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTerminalTokenRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// TerminalTokenElement
protected class TerminalToken_TerminalTokenElementParserRuleCall_0 extends RuleCallToken {
	
	public TerminalToken_TerminalTokenElementParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenAccess().getTerminalTokenElementParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalTokenElement_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TerminalTokenElement_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTerminalTokenElementRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// cardinality=( "?" | "*" | "+" )?
protected class TerminalToken_CardinalityAssignment_1 extends AssignmentToken  {
	
	public TerminalToken_CardinalityAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalTokenAccess().getCardinalityAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalToken_TerminalTokenElementParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("cardinality",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("cardinality");
		if("?".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getTerminalTokenAccess().getCardinalityQuestionMarkKeyword_1_0_0();
			return obj;
		}
		if("*".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getTerminalTokenAccess().getCardinalityAsteriskKeyword_1_0_1();
			return obj;
		}
		if("+".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getTerminalTokenAccess().getCardinalityPlusSignKeyword_1_0_2();
			return obj;
		}
		return null;
	}

}


/************ end Rule TerminalToken ****************/


/************ begin Rule TerminalTokenElement ****************
 *
 * TerminalTokenElement returns AbstractElement:
 *   CharacterRange|RuleCall|ParenthesizedTerminalElement|AbstractNegatedToken|
 *   Wildcard;
 *
 **/

// CharacterRange|RuleCall|ParenthesizedTerminalElement|AbstractNegatedToken|
// Wildcard
protected class TerminalTokenElement_Alternatives extends AlternativesToken {

	public TerminalTokenElement_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalTokenElement_CharacterRangeParserRuleCall_0(parent, this, 0, inst);
			case 1: return new TerminalTokenElement_RuleCallParserRuleCall_1(parent, this, 1, inst);
			case 2: return new TerminalTokenElement_ParenthesizedTerminalElementParserRuleCall_2(parent, this, 2, inst);
			case 3: return new TerminalTokenElement_AbstractNegatedTokenParserRuleCall_3(parent, this, 3, inst);
			case 4: return new TerminalTokenElement_WildcardParserRuleCall_4(parent, this, 4, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTerminalTokenElementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// CharacterRange
protected class TerminalTokenElement_CharacterRangeParserRuleCall_0 extends RuleCallToken {
	
	public TerminalTokenElement_CharacterRangeParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getCharacterRangeParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharacterRange_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(CharacterRange_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCharacterRangeRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// RuleCall
protected class TerminalTokenElement_RuleCallParserRuleCall_1 extends RuleCallToken {
	
	public TerminalTokenElement_RuleCallParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getRuleCallParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new RuleCall_RuleAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(RuleCall_RuleAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRuleCallRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ParenthesizedTerminalElement
protected class TerminalTokenElement_ParenthesizedTerminalElementParserRuleCall_2 extends RuleCallToken {
	
	public TerminalTokenElement_ParenthesizedTerminalElementParserRuleCall_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getParenthesizedTerminalElementParserRuleCall_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedTerminalElement_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ParenthesizedTerminalElement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParenthesizedTerminalElementRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// AbstractNegatedToken
protected class TerminalTokenElement_AbstractNegatedTokenParserRuleCall_3 extends RuleCallToken {
	
	public TerminalTokenElement_AbstractNegatedTokenParserRuleCall_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getAbstractNegatedTokenParserRuleCall_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractNegatedToken_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(AbstractNegatedToken_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAbstractNegatedTokenRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Wildcard
protected class TerminalTokenElement_WildcardParserRuleCall_4 extends RuleCallToken {
	
	public TerminalTokenElement_WildcardParserRuleCall_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getWildcardParserRuleCall_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Wildcard_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Wildcard_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getWildcardRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule TerminalTokenElement ****************/


/************ begin Rule ParenthesizedTerminalElement ****************
 *
 * ParenthesizedTerminalElement returns AbstractElement:
 *   "(" TerminalAlternatives ")";
 *
 **/

// "(" TerminalAlternatives ")"
protected class ParenthesizedTerminalElement_Group extends GroupToken {
	
	public ParenthesizedTerminalElement_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParenthesizedTerminalElementAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedTerminalElement_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParenthesizedTerminalElementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "("
protected class ParenthesizedTerminalElement_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public ParenthesizedTerminalElement_LeftParenthesisKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedTerminalElementAccess().getLeftParenthesisKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// TerminalAlternatives
protected class ParenthesizedTerminalElement_TerminalAlternativesParserRuleCall_1 extends RuleCallToken {
	
	public ParenthesizedTerminalElement_TerminalAlternativesParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParenthesizedTerminalElementAccess().getTerminalAlternativesParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalAlternatives_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TerminalAlternatives_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTerminalAlternativesRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedTerminalElement_LeftParenthesisKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class ParenthesizedTerminalElement_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public ParenthesizedTerminalElement_RightParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedTerminalElementAccess().getRightParenthesisKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ParenthesizedTerminalElement_TerminalAlternativesParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule ParenthesizedTerminalElement ****************/


/************ begin Rule AbstractNegatedToken ****************
 *
 * AbstractNegatedToken:
 *   NegatedToken|UntilToken;
 *
 **/

// NegatedToken|UntilToken
protected class AbstractNegatedToken_Alternatives extends AlternativesToken {

	public AbstractNegatedToken_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractNegatedTokenAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractNegatedToken_NegatedTokenParserRuleCall_0(parent, this, 0, inst);
			case 1: return new AbstractNegatedToken_UntilTokenParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAbstractNegatedTokenRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// NegatedToken
protected class AbstractNegatedToken_NegatedTokenParserRuleCall_0 extends RuleCallToken {
	
	public AbstractNegatedToken_NegatedTokenParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractNegatedTokenAccess().getNegatedTokenParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NegatedToken_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(NegatedToken_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNegatedTokenRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// UntilToken
protected class AbstractNegatedToken_UntilTokenParserRuleCall_1 extends RuleCallToken {
	
	public AbstractNegatedToken_UntilTokenParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractNegatedTokenAccess().getUntilTokenParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UntilToken_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(UntilToken_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUntilTokenRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule AbstractNegatedToken ****************/


/************ begin Rule NegatedToken ****************
 *
 * NegatedToken:
 *   "!" ^terminal=TerminalTokenElement;
 *
 **/

// "!" ^terminal=TerminalTokenElement
protected class NegatedToken_Group extends GroupToken {
	
	public NegatedToken_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNegatedTokenAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new NegatedToken_TerminalAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getNegatedTokenRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "!"
protected class NegatedToken_ExclamationMarkKeyword_0 extends KeywordToken  {
	
	public NegatedToken_ExclamationMarkKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getNegatedTokenAccess().getExclamationMarkKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// ^terminal=TerminalTokenElement
protected class NegatedToken_TerminalAssignment_1 extends AssignmentToken  {
	
	public NegatedToken_TerminalAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNegatedTokenAccess().getTerminalAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalTokenElement_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("terminal",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("terminal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTerminalTokenElementRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getNegatedTokenAccess().getTerminalTerminalTokenElementParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new NegatedToken_ExclamationMarkKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule NegatedToken ****************/


/************ begin Rule UntilToken ****************
 *
 * UntilToken:
 *   "->" ^terminal=TerminalTokenElement;
 *
 **/

// "->" ^terminal=TerminalTokenElement
protected class UntilToken_Group extends GroupToken {
	
	public UntilToken_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUntilTokenAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new UntilToken_TerminalAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getUntilTokenRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "->"
protected class UntilToken_HyphenMinusGreaterThanSignKeyword_0 extends KeywordToken  {
	
	public UntilToken_HyphenMinusGreaterThanSignKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getUntilTokenAccess().getHyphenMinusGreaterThanSignKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// ^terminal=TerminalTokenElement
protected class UntilToken_TerminalAssignment_1 extends AssignmentToken  {
	
	public UntilToken_TerminalAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUntilTokenAccess().getTerminalAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TerminalTokenElement_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("terminal",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("terminal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTerminalTokenElementRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getUntilTokenAccess().getTerminalTerminalTokenElementParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new UntilToken_HyphenMinusGreaterThanSignKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule UntilToken ****************/


/************ begin Rule Wildcard ****************
 *
 * Wildcard:
 *   {Wildcard} ".";
 *
 **/

// {Wildcard} "."
protected class Wildcard_Group extends GroupToken {
	
	public Wildcard_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Wildcard_FullStopKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWildcardRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Wildcard}
protected class Wildcard_WildcardAction_0 extends ActionToken  {

	public Wildcard_WildcardAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getWildcardAccess().getWildcardAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getWildcardAccess().getWildcardAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "."
protected class Wildcard_FullStopKeyword_1 extends KeywordToken  {
	
	public Wildcard_FullStopKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardAccess().getFullStopKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Wildcard_WildcardAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Wildcard ****************/


/************ begin Rule CharacterRange ****************
 *
 * CharacterRange returns AbstractElement:
 *   Keyword ({CharacterRange.left=current} ".." right=Keyword)?;
 *
 **/

// Keyword ({CharacterRange.left=current} ".." right=Keyword)?
protected class CharacterRange_Group extends GroupToken {
	
	public CharacterRange_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharacterRange_Group_1(parent, this, 0, inst);
			case 1: return new CharacterRange_KeywordParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getCharacterRangeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Keyword
protected class CharacterRange_KeywordParserRuleCall_0 extends RuleCallToken {
	
	public CharacterRange_KeywordParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getKeywordParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Keyword_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Keyword_ValueAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({CharacterRange.left=current} ".." right=Keyword)?
protected class CharacterRange_Group_1 extends GroupToken {
	
	public CharacterRange_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharacterRange_RightAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {CharacterRange.left=current}
protected class CharacterRange_CharacterRangeLeftAction_1_0 extends ActionToken  {

	public CharacterRange_CharacterRangeLeftAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getCharacterRangeLeftAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharacterRange_KeywordParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getCharacterRangeAccess().getCharacterRangeLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return getDescr((EObject) val);
	}
}

// ".."
protected class CharacterRange_FullStopFullStopKeyword_1_1 extends KeywordToken  {
	
	public CharacterRange_FullStopFullStopKeyword_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getFullStopFullStopKeyword_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new CharacterRange_CharacterRangeLeftAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// right=Keyword
protected class CharacterRange_RightAssignment_1_2 extends AssignmentToken  {
	
	public CharacterRange_RightAssignment_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getRightAssignment_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Keyword_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("right",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getCharacterRangeAccess().getRightKeywordParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new CharacterRange_FullStopFullStopKeyword_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule CharacterRange ****************/


/************ begin Rule EnumRule ****************
 *
 * EnumRule:
 *   "enum" name=ID ("returns" type=TypeRef)? ":" alternatives=EnumLiterals ";";
 *
 **/

// "enum" name=ID ("returns" type=TypeRef)? ":" alternatives=EnumLiterals ";"
protected class EnumRule_Group extends GroupToken {
	
	public EnumRule_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumRule_SemicolonKeyword_5(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumRuleRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "enum"
protected class EnumRule_EnumKeyword_0 extends KeywordToken  {
	
	public EnumRule_EnumKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getEnumKeyword_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class EnumRule_NameAssignment_1 extends AssignmentToken  {
	
	public EnumRule_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumRule_EnumKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumRuleAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("returns" type=TypeRef)?
protected class EnumRule_Group_2 extends GroupToken {
	
	public EnumRule_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumRule_TypeAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "returns"
protected class EnumRule_ReturnsKeyword_2_0 extends KeywordToken  {
	
	public EnumRule_ReturnsKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getReturnsKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumRule_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type=TypeRef
protected class EnumRule_TypeAssignment_2_1 extends AssignmentToken  {
	
	public EnumRule_TypeAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getTypeAssignment_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TypeRef_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumRuleAccess().getTypeTypeRefParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EnumRule_ReturnsKeyword_2_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// ":"
protected class EnumRule_ColonKeyword_3 extends KeywordToken  {
	
	public EnumRule_ColonKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getColonKeyword_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumRule_Group_2(parent, this, 0, inst);
			case 1: return new EnumRule_NameAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// alternatives=EnumLiterals
protected class EnumRule_AlternativesAssignment_4 extends AssignmentToken  {
	
	public EnumRule_AlternativesAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getAlternativesAssignment_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumLiterals_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("alternatives",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alternatives");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumLiteralsRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumRuleAccess().getAlternativesEnumLiteralsParserRuleCall_4_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EnumRule_ColonKeyword_3(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ";"
protected class EnumRule_SemicolonKeyword_5 extends KeywordToken  {
	
	public EnumRule_SemicolonKeyword_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getSemicolonKeyword_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumRule_AlternativesAssignment_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule EnumRule ****************/


/************ begin Rule EnumLiterals ****************
 *
 * EnumLiterals returns AbstractElement:
 *   EnumLiteralDeclaration ({Alternatives.groups+=current} ("|" groups+=
 *   EnumLiteralDeclaration)+)?;
 *
 **/

// EnumLiteralDeclaration ({Alternatives.groups+=current} ("|" groups+=
// EnumLiteralDeclaration)+)?
protected class EnumLiterals_Group extends GroupToken {
	
	public EnumLiterals_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumLiterals_Group_1(parent, this, 0, inst);
			case 1: return new EnumLiterals_EnumLiteralDeclarationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumLiteralsRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// EnumLiteralDeclaration
protected class EnumLiterals_EnumLiteralDeclarationParserRuleCall_0 extends RuleCallToken {
	
	public EnumLiterals_EnumLiteralDeclarationParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getEnumLiteralDeclarationParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumLiteralDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(EnumLiteralDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumLiteralDeclarationRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Alternatives.groups+=current} ("|" groups+=EnumLiteralDeclaration)+)?
protected class EnumLiterals_Group_1 extends GroupToken {
	
	public EnumLiterals_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumLiterals_Group_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Alternatives.groups+=current}
protected class EnumLiterals_AlternativesGroupsAction_1_0 extends ActionToken  {

	public EnumLiterals_AlternativesGroupsAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getAlternativesGroupsAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumLiterals_EnumLiteralDeclarationParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getEnumLiteralsAccess().getAlternativesGroupsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return getDescr((EObject) val);
	}
}

// ("|" groups+=EnumLiteralDeclaration)+
protected class EnumLiterals_Group_1_1 extends GroupToken {
	
	public EnumLiterals_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumLiterals_GroupsAssignment_1_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "|"
protected class EnumLiterals_VerticalLineKeyword_1_1_0 extends KeywordToken  {
	
	public EnumLiterals_VerticalLineKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getVerticalLineKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumLiterals_Group_1_1(parent, this, 0, inst);
			case 1: return new EnumLiterals_AlternativesGroupsAction_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// groups+=EnumLiteralDeclaration
protected class EnumLiterals_GroupsAssignment_1_1_1 extends AssignmentToken  {
	
	public EnumLiterals_GroupsAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getGroupsAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumLiteralDeclaration_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("groups",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumLiteralDeclarationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumLiteralsAccess().getGroupsEnumLiteralDeclarationParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EnumLiterals_VerticalLineKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}




/************ end Rule EnumLiterals ****************/


/************ begin Rule EnumLiteralDeclaration ****************
 *
 * EnumLiteralDeclaration:
 *   enumLiteral=[ecore::EEnumLiteral] ("=" literal=Keyword)?;
 *
 **/

// enumLiteral=[ecore::EEnumLiteral] ("=" literal=Keyword)?
protected class EnumLiteralDeclaration_Group extends GroupToken {
	
	public EnumLiteralDeclaration_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumLiteralDeclarationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumLiteralDeclaration_Group_1(parent, this, 0, inst);
			case 1: return new EnumLiteralDeclaration_EnumLiteralAssignment_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getEnumLiteralDeclarationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// enumLiteral=[ecore::EEnumLiteral]
protected class EnumLiteralDeclaration_EnumLiteralAssignment_0 extends AssignmentToken  {
	
	public EnumLiteralDeclaration_EnumLiteralAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumLiteralDeclarationAccess().getEnumLiteralAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("enumLiteral",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("enumLiteral");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumLiteralDeclarationAccess().getEnumLiteralEEnumLiteralCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getEnumLiteralDeclarationAccess().getEnumLiteralEEnumLiteralCrossReference_0_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("=" literal=Keyword)?
protected class EnumLiteralDeclaration_Group_1 extends GroupToken {
	
	public EnumLiteralDeclaration_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumLiteralDeclarationAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumLiteralDeclaration_LiteralAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class EnumLiteralDeclaration_EqualsSignKeyword_1_0 extends KeywordToken  {
	
	public EnumLiteralDeclaration_EqualsSignKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumLiteralDeclarationAccess().getEqualsSignKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new EnumLiteralDeclaration_EnumLiteralAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// literal=Keyword
protected class EnumLiteralDeclaration_LiteralAssignment_1_1 extends AssignmentToken  {
	
	public EnumLiteralDeclaration_LiteralAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumLiteralDeclarationAccess().getLiteralAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Keyword_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("literal",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("literal");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getEnumLiteralDeclarationAccess().getLiteralKeywordParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new EnumLiteralDeclaration_EqualsSignKeyword_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule EnumLiteralDeclaration ****************/

}
