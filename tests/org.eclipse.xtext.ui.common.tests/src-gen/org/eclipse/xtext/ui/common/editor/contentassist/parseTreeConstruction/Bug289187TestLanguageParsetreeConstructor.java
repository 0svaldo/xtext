/*
* generated by Xtext
*/
package org.eclipse.xtext.ui.common.editor.contentassist.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.xtext.ui.common.editor.contentassist.services.Bug289187TestLanguageGrammarAccess;

import com.google.inject.Inject;

public class Bug289187TestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private Bug289187TestLanguageGrammarAccess grammarAccess;
	
	@Override	
	public Bug289187TestLanguageGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_ClassesAssignment(this, this, 0, inst);
			case 1: return new Class_Group(this, this, 1, inst);
			case 2: return new Attribute_Group(this, this, 2, inst);
			case 3: return new Operation_Group(this, this, 3, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Model ****************
 *
 * Model:
 *   classes+=Class*;
 *
 **/

// classes+=Class*
protected class Model_ClassesAssignment extends AssignmentToken  {
	
	public Model_ClassesAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getClassesAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getModelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("classes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("classes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getClassRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getClassesClassParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_ClassesAssignment(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

/************ end Rule Model ****************/


/************ begin Rule Class ****************
 *
 * Class:
 *   abstract?="abstract"? transient?="transient"? "class" name=ID ("extends" superClass=[
 *   Class])? ("implements" implementedInterfaces+=[Class] ("," "implements"
 *   implementedInterfaces+=[Class])*)? "{" ("classNumber" "=" classNumber=INT)? ("quid"
 *   "=" quid=INT)? ("documentation" "=" documentation=STRING)? attributes+=Attribute*
 *   operations+=Operation* "}";
 *
 **/

// abstract?="abstract"? transient?="transient"? "class" name=ID ("extends" superClass=[
// Class])? ("implements" implementedInterfaces+=[Class] ("," "implements"
// implementedInterfaces+=[Class])*)? "{" ("classNumber" "=" classNumber=INT)? ("quid"
// "=" quid=INT)? ("documentation" "=" documentation=STRING)? attributes+=Attribute*
// operations+=Operation* "}"
protected class Class_Group extends GroupToken {
	
	public Class_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_RightCurlyBracketKeyword_12(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getClassRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// abstract?="abstract"?
protected class Class_AbstractAssignment_0 extends AssignmentToken  {
	
	public Class_AbstractAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getAbstractAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("abstract",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("abstract");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getClassAccess().getAbstractAbstractKeyword_0_0();
			return obj;
		}
		return null;
	}

}

// transient?="transient"?
protected class Class_TransientAssignment_1 extends AssignmentToken  {
	
	public Class_TransientAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getTransientAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_AbstractAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("transient",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("transient");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getClassAccess().getTransientTransientKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// "class"
protected class Class_ClassKeyword_2 extends KeywordToken  {
	
	public Class_ClassKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getClassKeyword_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_TransientAssignment_1(parent, this, 0, inst);
			case 1: return new Class_AbstractAssignment_0(parent, this, 1, inst);
			default: return parent.createParentFollower(this, index, index - 2, inst);
		}	
	}	
		
}

// name=ID
protected class Class_NameAssignment_3 extends AssignmentToken  {
	
	public Class_NameAssignment_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getNameAssignment_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_ClassKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getClassAccess().getNameIDTerminalRuleCall_3_0();
			return obj;
		}
		return null;
	}

}

// ("extends" superClass=[Class])?
protected class Class_Group_4 extends GroupToken {
	
	public Class_Group_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_SuperClassAssignment_4_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "extends"
protected class Class_ExtendsKeyword_4_0 extends KeywordToken  {
	
	public Class_ExtendsKeyword_4_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getExtendsKeyword_4_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_NameAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// superClass=[Class]
protected class Class_SuperClassAssignment_4_1 extends AssignmentToken  {
	
	public Class_SuperClassAssignment_4_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getSuperClassAssignment_4_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_ExtendsKeyword_4_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("superClass",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("superClass");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getClassAccess().getSuperClassClassCrossReference_4_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getClassAccess().getSuperClassClassCrossReference_4_1_0(); 
				return obj;
			}
		}
		return null;
	}

}


// ("implements" implementedInterfaces+=[Class] ("," "implements" implementedInterfaces
// +=[Class])*)?
protected class Class_Group_5 extends GroupToken {
	
	public Class_Group_5(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup_5();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Group_5_2(parent, this, 0, inst);
			case 1: return new Class_ImplementedInterfacesAssignment_5_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "implements"
protected class Class_ImplementsKeyword_5_0 extends KeywordToken  {
	
	public Class_ImplementsKeyword_5_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getImplementsKeyword_5_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Group_4(parent, this, 0, inst);
			case 1: return new Class_NameAssignment_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// implementedInterfaces+=[Class]
protected class Class_ImplementedInterfacesAssignment_5_1 extends AssignmentToken  {
	
	public Class_ImplementedInterfacesAssignment_5_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getImplementedInterfacesAssignment_5_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_ImplementsKeyword_5_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("implementedInterfaces",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("implementedInterfaces");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getClassAccess().getImplementedInterfacesClassCrossReference_5_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getClassAccess().getImplementedInterfacesClassCrossReference_5_1_0(); 
				return obj;
			}
		}
		return null;
	}

}

// ("," "implements" implementedInterfaces+=[Class])*
protected class Class_Group_5_2 extends GroupToken {
	
	public Class_Group_5_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup_5_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_ImplementedInterfacesAssignment_5_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Class_CommaKeyword_5_2_0 extends KeywordToken  {
	
	public Class_CommaKeyword_5_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getCommaKeyword_5_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Group_5_2(parent, this, 0, inst);
			case 1: return new Class_ImplementedInterfacesAssignment_5_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "implements"
protected class Class_ImplementsKeyword_5_2_1 extends KeywordToken  {
	
	public Class_ImplementsKeyword_5_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getImplementsKeyword_5_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_CommaKeyword_5_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// implementedInterfaces+=[Class]
protected class Class_ImplementedInterfacesAssignment_5_2_2 extends AssignmentToken  {
	
	public Class_ImplementedInterfacesAssignment_5_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getImplementedInterfacesAssignment_5_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_ImplementsKeyword_5_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("implementedInterfaces",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("implementedInterfaces");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getClassAccess().getImplementedInterfacesClassCrossReference_5_2_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getClassAccess().getImplementedInterfacesClassCrossReference_5_2_2_0(); 
				return obj;
			}
		}
		return null;
	}

}



// "{"
protected class Class_LeftCurlyBracketKeyword_6 extends KeywordToken  {
	
	public Class_LeftCurlyBracketKeyword_6(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getLeftCurlyBracketKeyword_6();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Group_5(parent, this, 0, inst);
			case 1: return new Class_Group_4(parent, this, 1, inst);
			case 2: return new Class_NameAssignment_3(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// ("classNumber" "=" classNumber=INT)?
protected class Class_Group_7 extends GroupToken {
	
	public Class_Group_7(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup_7();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_ClassNumberAssignment_7_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "classNumber"
protected class Class_ClassNumberKeyword_7_0 extends KeywordToken  {
	
	public Class_ClassNumberKeyword_7_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getClassNumberKeyword_7_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_LeftCurlyBracketKeyword_6(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class Class_EqualsSignKeyword_7_1 extends KeywordToken  {
	
	public Class_EqualsSignKeyword_7_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getEqualsSignKeyword_7_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_ClassNumberKeyword_7_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// classNumber=INT
protected class Class_ClassNumberAssignment_7_2 extends AssignmentToken  {
	
	public Class_ClassNumberAssignment_7_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getClassNumberAssignment_7_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_EqualsSignKeyword_7_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("classNumber",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("classNumber");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getClassAccess().getClassNumberINTTerminalRuleCall_7_2_0();
			return obj;
		}
		return null;
	}

}


// ("quid" "=" quid=INT)?
protected class Class_Group_8 extends GroupToken {
	
	public Class_Group_8(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup_8();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_QuidAssignment_8_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "quid"
protected class Class_QuidKeyword_8_0 extends KeywordToken  {
	
	public Class_QuidKeyword_8_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getQuidKeyword_8_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Group_7(parent, this, 0, inst);
			case 1: return new Class_LeftCurlyBracketKeyword_6(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class Class_EqualsSignKeyword_8_1 extends KeywordToken  {
	
	public Class_EqualsSignKeyword_8_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getEqualsSignKeyword_8_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_QuidKeyword_8_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// quid=INT
protected class Class_QuidAssignment_8_2 extends AssignmentToken  {
	
	public Class_QuidAssignment_8_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getQuidAssignment_8_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_EqualsSignKeyword_8_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("quid",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("quid");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getClassAccess().getQuidINTTerminalRuleCall_8_2_0();
			return obj;
		}
		return null;
	}

}


// ("documentation" "=" documentation=STRING)?
protected class Class_Group_9 extends GroupToken {
	
	public Class_Group_9(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getClassAccess().getGroup_9();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_DocumentationAssignment_9_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "documentation"
protected class Class_DocumentationKeyword_9_0 extends KeywordToken  {
	
	public Class_DocumentationKeyword_9_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getDocumentationKeyword_9_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_Group_8(parent, this, 0, inst);
			case 1: return new Class_Group_7(parent, this, 1, inst);
			case 2: return new Class_LeftCurlyBracketKeyword_6(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// "="
protected class Class_EqualsSignKeyword_9_1 extends KeywordToken  {
	
	public Class_EqualsSignKeyword_9_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getEqualsSignKeyword_9_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_DocumentationKeyword_9_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// documentation=STRING
protected class Class_DocumentationAssignment_9_2 extends AssignmentToken  {
	
	public Class_DocumentationAssignment_9_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getDocumentationAssignment_9_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_EqualsSignKeyword_9_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("documentation",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("documentation");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getClassAccess().getDocumentationSTRINGTerminalRuleCall_9_2_0();
			return obj;
		}
		return null;
	}

}


// attributes+=Attribute*
protected class Class_AttributesAssignment_10 extends AssignmentToken  {
	
	public Class_AttributesAssignment_10(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getAttributesAssignment_10();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("attributes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("attributes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClassAccess().getAttributesAttributeParserRuleCall_10_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Class_AttributesAssignment_10(parent, next, actIndex, consumed);
			case 1: return new Class_Group_9(parent, next, actIndex, consumed);
			case 2: return new Class_Group_8(parent, next, actIndex, consumed);
			case 3: return new Class_Group_7(parent, next, actIndex, consumed);
			case 4: return new Class_LeftCurlyBracketKeyword_6(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// operations+=Operation*
protected class Class_OperationsAssignment_11 extends AssignmentToken  {
	
	public Class_OperationsAssignment_11(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getClassAccess().getOperationsAssignment_11();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operations",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operations");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOperationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getClassAccess().getOperationsOperationParserRuleCall_11_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Class_OperationsAssignment_11(parent, next, actIndex, consumed);
			case 1: return new Class_AttributesAssignment_10(parent, next, actIndex, consumed);
			case 2: return new Class_Group_9(parent, next, actIndex, consumed);
			case 3: return new Class_Group_8(parent, next, actIndex, consumed);
			case 4: return new Class_Group_7(parent, next, actIndex, consumed);
			case 5: return new Class_LeftCurlyBracketKeyword_6(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "}"
protected class Class_RightCurlyBracketKeyword_12 extends KeywordToken  {
	
	public Class_RightCurlyBracketKeyword_12(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getClassAccess().getRightCurlyBracketKeyword_12();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Class_OperationsAssignment_11(parent, this, 0, inst);
			case 1: return new Class_AttributesAssignment_10(parent, this, 1, inst);
			case 2: return new Class_Group_9(parent, this, 2, inst);
			case 3: return new Class_Group_8(parent, this, 3, inst);
			case 4: return new Class_Group_7(parent, this, 4, inst);
			case 5: return new Class_LeftCurlyBracketKeyword_6(parent, this, 5, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Class ****************/


/************ begin Rule Attribute ****************
 *
 * Attribute:
 *   visibility=Visibility? "attribute" name=ID;
 *
 **/

// visibility=Visibility? "attribute" name=ID
protected class Attribute_Group extends GroupToken {
	
	public Attribute_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_NameAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// visibility=Visibility?
protected class Attribute_VisibilityAssignment_0 extends AssignmentToken  {
	
	public Attribute_VisibilityAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getVisibilityAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("visibility",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("visibility");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getAttributeAccess().getVisibilityVisibilityEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "attribute"
protected class Attribute_AttributeKeyword_1 extends KeywordToken  {
	
	public Attribute_AttributeKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getAttributeAccess().getAttributeKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_VisibilityAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// name=ID
protected class Attribute_NameAssignment_2 extends AssignmentToken  {
	
	public Attribute_NameAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getNameAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_AttributeKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Attribute ****************/


/************ begin Rule Operation ****************
 *
 * Operation:
 *   visibility=Visibility? "operation" name=ID;
 *
 **/

// visibility=Visibility? "operation" name=ID
protected class Operation_Group extends GroupToken {
	
	public Operation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOperationAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_NameAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOperationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// visibility=Visibility?
protected class Operation_VisibilityAssignment_0 extends AssignmentToken  {
	
	public Operation_VisibilityAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationAccess().getVisibilityAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("visibility",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("visibility");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.ERC;
			element = grammarAccess.getOperationAccess().getVisibilityVisibilityEnumRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// "operation"
protected class Operation_OperationKeyword_1 extends KeywordToken  {
	
	public Operation_OperationKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getOperationAccess().getOperationKeyword_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_VisibilityAssignment_0(parent, this, 0, inst);
			default: return parent.createParentFollower(this, index, index - 1, inst);
		}	
	}	
		
}

// name=ID
protected class Operation_NameAssignment_2 extends AssignmentToken  {
	
	public Operation_NameAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOperationAccess().getNameAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Operation_OperationKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getOperationAccess().getNameIDTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Operation ****************/

}
