/*
* generated by Xtext
*/
package org.eclipse.xtext.parsetree.formatter.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.xtext.parsetree.formatter.services.FormatterTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class FormatterTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private FormatterTestLanguageGrammarAccess grammarAccess;
		
	public FormatterTestLanguageGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Root_Group(this, this, 0, inst);
			case 1: return new Line_Group(this, this, 1, inst);
			case 2: return new Decl_Group(this, this, 2, inst);
			case 3: return new Assign_Group(this, this, 3, inst);
			case 4: return new Meth_Group(this, this, 4, inst);
			case 5: return new Param_Group(this, this, 5, inst);
			case 6: return new TestLinewrap_Group(this, this, 6, inst);
			case 7: return new TestIndentation_Group(this, this, 7, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Root ****************
 *
 * Root:
 *   "test" (TestLinewrap|TestIndentation);
 *
 **/

// "test" (TestLinewrap|TestIndentation)
protected class Root_Group extends GroupToken {
	
	public Root_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getRootAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Root_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRootRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "test"
protected class Root_TestKeyword_0 extends KeywordToken  {
	
	public Root_TestKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getRootAccess().getTestKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// TestLinewrap|TestIndentation
protected class Root_Alternatives_1 extends AlternativesToken {

	public Root_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getRootAccess().getAlternatives_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Root_TestLinewrapParserRuleCall_1_0(parent, this, 0, inst);
			case 1: return new Root_TestIndentationParserRuleCall_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// TestLinewrap
protected class Root_TestLinewrapParserRuleCall_1_0 extends RuleCallToken {
	
	public Root_TestLinewrapParserRuleCall_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getRootAccess().getTestLinewrapParserRuleCall_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TestLinewrap_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TestLinewrap_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTestLinewrapRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Root_TestKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// TestIndentation
protected class Root_TestIndentationParserRuleCall_1_1 extends RuleCallToken {
	
	public Root_TestIndentationParserRuleCall_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getRootAccess().getTestIndentationParserRuleCall_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TestIndentation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TestIndentation_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTestIndentationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Root_TestKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}



/************ end Rule Root ****************/


/************ begin Rule Line ****************
 *
 * Line:
 *   (Decl|Assign|Meth) ";";
 *
 **/

// (Decl|Assign|Meth) ";"
protected class Line_Group extends GroupToken {
	
	public Line_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getLineAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Line_SemicolonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getLineRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Decl|Assign|Meth
protected class Line_Alternatives_0 extends AlternativesToken {

	public Line_Alternatives_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getLineAccess().getAlternatives_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Line_DeclParserRuleCall_0_0(parent, this, 0, inst);
			case 1: return new Line_AssignParserRuleCall_0_1(parent, this, 1, inst);
			case 2: return new Line_MethParserRuleCall_0_2(parent, this, 2, inst);
			default: return null;
		}	
	}	
		
}

// Decl
protected class Line_DeclParserRuleCall_0_0 extends RuleCallToken {
	
	public Line_DeclParserRuleCall_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getLineAccess().getDeclParserRuleCall_0_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Decl_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getDeclRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Assign
protected class Line_AssignParserRuleCall_0_1 extends RuleCallToken {
	
	public Line_AssignParserRuleCall_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getLineAccess().getAssignParserRuleCall_0_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assign_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Assign_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Meth
protected class Line_MethParserRuleCall_0_2 extends RuleCallToken {
	
	public Line_MethParserRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getLineAccess().getMethParserRuleCall_0_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Meth_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Meth_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMethRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


// ";"
protected class Line_SemicolonKeyword_1 extends KeywordToken  {
	
	public Line_SemicolonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getLineAccess().getSemicolonKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Line_Alternatives_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Line ****************/


/************ begin Rule Decl ****************
 *
 * Decl:
 *   type+=ID name+=ID;
 *
 **/

// type+=ID name+=ID
protected class Decl_Group extends GroupToken {
	
	public Decl_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getDeclAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getDeclRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// type+=ID
protected class Decl_TypeAssignment_0 extends AssignmentToken  {
	
	public Decl_TypeAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclAccess().getTypeAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getDeclAccess().getTypeIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// name+=ID
protected class Decl_NameAssignment_1 extends AssignmentToken  {
	
	public Decl_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getDeclAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Decl_TypeAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getDeclAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Decl ****************/


/************ begin Rule Assign ****************
 *
 * Assign:
 *   var=ID op=( "=" | "+=" ) "[" (val+=INT ("," val+=INT)*)? "]";
 *
 **/

// var=ID op=( "=" | "+=" ) "[" (val+=INT ("," val+=INT)*)? "]"
protected class Assign_Group extends GroupToken {
	
	public Assign_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAssignAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assign_RightSquareBracketKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAssignRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// var=ID
protected class Assign_VarAssignment_0 extends AssignmentToken  {
	
	public Assign_VarAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignAccess().getVarAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("var",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("var");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAssignAccess().getVarIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// op=( "=" | "+=" )
protected class Assign_OpAssignment_1 extends AssignmentToken  {
	
	public Assign_OpAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignAccess().getOpAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assign_VarAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("op",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("op");
		if("=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAssignAccess().getOpEqualsSignKeyword_1_0_0();
			return obj;
		}
		if("+=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAssignAccess().getOpPlusSignEqualsSignKeyword_1_0_1();
			return obj;
		}
		return null;
	}

}

// "["
protected class Assign_LeftSquareBracketKeyword_2 extends KeywordToken  {
	
	public Assign_LeftSquareBracketKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignAccess().getLeftSquareBracketKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assign_OpAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (val+=INT ("," val+=INT)*)?
protected class Assign_Group_3 extends GroupToken {
	
	public Assign_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAssignAccess().getGroup_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assign_Group_3_1(parent, this, 0, inst);
			case 1: return new Assign_ValAssignment_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// val+=INT
protected class Assign_ValAssignment_3_0 extends AssignmentToken  {
	
	public Assign_ValAssignment_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignAccess().getValAssignment_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assign_LeftSquareBracketKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("val",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("val");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAssignAccess().getValINTTerminalRuleCall_3_0_0();
			return obj;
		}
		return null;
	}

}

// ("," val+=INT)*
protected class Assign_Group_3_1 extends GroupToken {
	
	public Assign_Group_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAssignAccess().getGroup_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assign_ValAssignment_3_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Assign_CommaKeyword_3_1_0 extends KeywordToken  {
	
	public Assign_CommaKeyword_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignAccess().getCommaKeyword_3_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assign_Group_3_1(parent, this, 0, inst);
			case 1: return new Assign_ValAssignment_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// val+=INT
protected class Assign_ValAssignment_3_1_1 extends AssignmentToken  {
	
	public Assign_ValAssignment_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignAccess().getValAssignment_3_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assign_CommaKeyword_3_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("val",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("val");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAssignAccess().getValINTTerminalRuleCall_3_1_1_0();
			return obj;
		}
		return null;
	}

}



// "]"
protected class Assign_RightSquareBracketKeyword_4 extends KeywordToken  {
	
	public Assign_RightSquareBracketKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignAccess().getRightSquareBracketKeyword_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Assign_Group_3(parent, this, 0, inst);
			case 1: return new Assign_LeftSquareBracketKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Assign ****************/


/************ begin Rule Meth ****************
 *
 * Meth:
 *   "void" name=ID "(" (param+=Param ("," param+=Param)*)? ")";
 *
 **/

// "void" name=ID "(" (param+=Param ("," param+=Param)*)? ")"
protected class Meth_Group extends GroupToken {
	
	public Meth_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMethAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Meth_RightParenthesisKeyword_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMethRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "void"
protected class Meth_VoidKeyword_0 extends KeywordToken  {
	
	public Meth_VoidKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMethAccess().getVoidKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// name=ID
protected class Meth_NameAssignment_1 extends AssignmentToken  {
	
	public Meth_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMethAccess().getNameAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Meth_VoidKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getMethAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "("
protected class Meth_LeftParenthesisKeyword_2 extends KeywordToken  {
	
	public Meth_LeftParenthesisKeyword_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMethAccess().getLeftParenthesisKeyword_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Meth_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (param+=Param ("," param+=Param)*)?
protected class Meth_Group_3 extends GroupToken {
	
	public Meth_Group_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMethAccess().getGroup_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Meth_Group_3_1(parent, this, 0, inst);
			case 1: return new Meth_ParamAssignment_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// param+=Param
protected class Meth_ParamAssignment_3_0 extends AssignmentToken  {
	
	public Meth_ParamAssignment_3_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMethAccess().getParamAssignment_3_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Param_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("param",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("param");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParamRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMethAccess().getParamParamParserRuleCall_3_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Meth_LeftParenthesisKeyword_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ("," param+=Param)*
protected class Meth_Group_3_1 extends GroupToken {
	
	public Meth_Group_3_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMethAccess().getGroup_3_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Meth_ParamAssignment_3_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Meth_CommaKeyword_3_1_0 extends KeywordToken  {
	
	public Meth_CommaKeyword_3_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMethAccess().getCommaKeyword_3_1_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Meth_Group_3_1(parent, this, 0, inst);
			case 1: return new Meth_ParamAssignment_3_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// param+=Param
protected class Meth_ParamAssignment_3_1_1 extends AssignmentToken  {
	
	public Meth_ParamAssignment_3_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMethAccess().getParamAssignment_3_1_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Param_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("param",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("param");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParamRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMethAccess().getParamParamParserRuleCall_3_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Meth_CommaKeyword_3_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



// ")"
protected class Meth_RightParenthesisKeyword_4 extends KeywordToken  {
	
	public Meth_RightParenthesisKeyword_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMethAccess().getRightParenthesisKeyword_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Meth_Group_3(parent, this, 0, inst);
			case 1: return new Meth_LeftParenthesisKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Meth ****************/


/************ begin Rule Param ****************
 *
 * Param:
 *   name+=ID ":" type+=ID;
 *
 **/

// name+=ID ":" type+=ID
protected class Param_Group extends GroupToken {
	
	public Param_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getParamAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Param_TypeAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParamRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name+=ID
protected class Param_NameAssignment_0 extends AssignmentToken  {
	
	public Param_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getParamAccess().getNameAssignment_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getParamAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// ":"
protected class Param_ColonKeyword_1 extends KeywordToken  {
	
	public Param_ColonKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParamAccess().getColonKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Param_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// type+=ID
protected class Param_TypeAssignment_2 extends AssignmentToken  {
	
	public Param_TypeAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getParamAccess().getTypeAssignment_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Param_ColonKeyword_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("type",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getParamAccess().getTypeIDTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Param ****************/


/************ begin Rule TestLinewrap ****************
 *
 * TestLinewrap:
 *   "linewrap" items+=Line*;
 *
 **/

// "linewrap" items+=Line*
protected class TestLinewrap_Group extends GroupToken {
	
	public TestLinewrap_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTestLinewrapAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TestLinewrap_ItemsAssignment_1(parent, this, 0, inst);
			case 1: return new TestLinewrap_LinewrapKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTestLinewrapRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "linewrap"
protected class TestLinewrap_LinewrapKeyword_0 extends KeywordToken  {
	
	public TestLinewrap_LinewrapKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTestLinewrapAccess().getLinewrapKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// items+=Line*
protected class TestLinewrap_ItemsAssignment_1 extends AssignmentToken  {
	
	public TestLinewrap_ItemsAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTestLinewrapAccess().getItemsAssignment_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Line_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("items",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("items");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLineRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTestLinewrapAccess().getItemsLineParserRuleCall_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TestLinewrap_ItemsAssignment_1(parent, next, actIndex, consumed);
			case 1: return new TestLinewrap_LinewrapKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule TestLinewrap ****************/


/************ begin Rule TestIndentation ****************
 *
 * TestIndentation:
 *   "indentation" "{" (sub+=TestIndentation|items+=Line)* "}" semi?=";"?;
 *
 **/

// "indentation" "{" (sub+=TestIndentation|items+=Line)* "}" semi?=";"?
protected class TestIndentation_Group extends GroupToken {
	
	public TestIndentation_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTestIndentationAccess().getGroup();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TestIndentation_SemiAssignment_4(parent, this, 0, inst);
			case 1: return new TestIndentation_RightCurlyBracketKeyword_3(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTestIndentationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "indentation"
protected class TestIndentation_IndentationKeyword_0 extends KeywordToken  {
	
	public TestIndentation_IndentationKeyword_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTestIndentationAccess().getIndentationKeyword_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// "{"
protected class TestIndentation_LeftCurlyBracketKeyword_1 extends KeywordToken  {
	
	public TestIndentation_LeftCurlyBracketKeyword_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTestIndentationAccess().getLeftCurlyBracketKeyword_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TestIndentation_IndentationKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// (sub+=TestIndentation|items+=Line)*
protected class TestIndentation_Alternatives_2 extends AlternativesToken {

	public TestIndentation_Alternatives_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getTestIndentationAccess().getAlternatives_2();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TestIndentation_SubAssignment_2_0(parent, this, 0, inst);
			case 1: return new TestIndentation_ItemsAssignment_2_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// sub+=TestIndentation
protected class TestIndentation_SubAssignment_2_0 extends AssignmentToken  {
	
	public TestIndentation_SubAssignment_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTestIndentationAccess().getSubAssignment_2_0();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TestIndentation_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("sub",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("sub");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTestIndentationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTestIndentationAccess().getSubTestIndentationParserRuleCall_2_0_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TestIndentation_Alternatives_2(parent, next, actIndex, consumed);
			case 1: return new TestIndentation_LeftCurlyBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// items+=Line
protected class TestIndentation_ItemsAssignment_2_1 extends AssignmentToken  {
	
	public TestIndentation_ItemsAssignment_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTestIndentationAccess().getItemsAssignment_2_1();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Line_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("items",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("items");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getLineRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getTestIndentationAccess().getItemsLineParserRuleCall_2_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new TestIndentation_Alternatives_2(parent, next, actIndex, consumed);
			case 1: return new TestIndentation_LeftCurlyBracketKeyword_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "}"
protected class TestIndentation_RightCurlyBracketKeyword_3 extends KeywordToken  {
	
	public TestIndentation_RightCurlyBracketKeyword_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTestIndentationAccess().getRightCurlyBracketKeyword_3();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TestIndentation_Alternatives_2(parent, this, 0, inst);
			case 1: return new TestIndentation_LeftCurlyBracketKeyword_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// semi?=";"?
protected class TestIndentation_SemiAssignment_4 extends AssignmentToken  {
	
	public TestIndentation_SemiAssignment_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTestIndentationAccess().getSemiAssignment_4();
	}

	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TestIndentation_RightCurlyBracketKeyword_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("semi",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("semi");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getTestIndentationAccess().getSemiSemicolonKeyword_4_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule TestIndentation ****************/

}
