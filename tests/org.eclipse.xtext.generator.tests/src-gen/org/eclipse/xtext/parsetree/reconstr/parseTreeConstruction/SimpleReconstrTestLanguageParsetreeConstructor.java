/*
* generated by Xtext
*/
package org.eclipse.xtext.parsetree.reconstr.parseTreeConstruction;

//import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.AbstractToken.Solution;
import org.eclipse.xtext.parsetree.reconstr.services.SimpleReconstrTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class SimpleReconstrTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private SimpleReconstrTestLanguageGrammarAccess grammarAccess;
	
	@Override
	protected Solution internalSerialize(EObject obj) {
		IInstanceDescription inst = getDescr(obj);
		Solution s;
		if(inst.isInstanceOf(grammarAccess.getOpRule().getType().getClassifier()) && (s = new Op_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier()) && (s = new Term_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier()) && (s = new Atom_Assignment_name(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getParensRule().getType().getClassifier()) && (s = new Parens_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTwoNumbersRule().getType().getClassifier()) && (s = new TwoNumbers_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getManyStringsRule().getType().getClassifier()) && (s = new ManyStrings_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTypeRule().getType().getClassifier()) && (s = new Type_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getRef2Rule().getType().getClassifier()) && (s = new Ref2_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getSpareRule().getType().getClassifier()) && (s = new Spare_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getBooleanRule().getType().getClassifier()) && (s = new Boolean_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		return null;
	}
	

/************ begin Rule Op ****************
 *
 * Op returns Expression:
 *   Term ({Op.values+=current} values+=Term)*;
 *
 **/

// Term ({Op.values+=current} values+=Term)*
protected class Op_Group extends GroupToken {
	
	public Op_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOpAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Op_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Op_0_RuleCall_Term(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// Term
protected class Op_0_RuleCall_Term extends RuleCallToken {
	
	public Op_0_RuleCall_Term(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getOpAccess().getTermParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Term_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) return null;
		return new Term_Alternatives(current, this).firstSolution();
	}
}

// ({Op.values+=current} values+=Term)*
protected class Op_1_Group extends GroupToken {
	
	public Op_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getOpAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Op_1_1_Assignment_values(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Op_1_0_Action_Op_values(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// {Op.values+=current}
protected class Op_1_0_Action_Op_values extends ActionToken  {

	public Op_1_0_Action_Op_values(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getOpAccess().getOpvaluesAction_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.getOpAccess().getOpvaluesAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("values", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("values")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// values+=Term
protected class Op_1_1_Assignment_values extends AssignmentToken  {
	
	public Op_1_1_Assignment_values(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getOpAccess().getValuesAssignment_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("values",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("values");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) {
				Solution s = new Term_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



/************ end Rule Op ****************/


/************ begin Rule Term ****************
 *
 * Term returns Expression:
 *   Atom|TwoNumbers|ManyStrings|Parens|Type|Ref2|Spare|Boolean;
 *
 **/

// Atom|TwoNumbers|ManyStrings|Parens|Type|Ref2|Spare|Boolean
protected class Term_Alternatives extends AlternativesToken {

	public Term_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTermAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Term_0_RuleCall_Atom(current, this);
			case 1: return new Term_1_RuleCall_TwoNumbers(current, this);
			case 2: return new Term_2_RuleCall_ManyStrings(current, this);
			case 3: return new Term_3_RuleCall_Parens(current, this);
			case 4: return new Term_4_RuleCall_Type(current, this);
			case 5: return new Term_5_RuleCall_Ref2(current, this);
			case 6: return new Term_6_RuleCall_Spare(current, this);
			case 7: return new Term_7_RuleCall_Boolean(current, this);
			default: return null;
		}
	}
}

// Atom
protected class Term_0_RuleCall_Atom extends RuleCallToken {
	
	public Term_0_RuleCall_Atom(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getAtomParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Atom_Assignment_name.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) return null;
		return new Atom_Assignment_name(current, this).firstSolution();
	}
}

// TwoNumbers
protected class Term_1_RuleCall_TwoNumbers extends RuleCallToken {
	
	public Term_1_RuleCall_TwoNumbers(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getTwoNumbersParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TwoNumbers_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTwoNumbersRule().getType().getClassifier())) return null;
		return new TwoNumbers_Group(current, this).firstSolution();
	}
}

// ManyStrings
protected class Term_2_RuleCall_ManyStrings extends RuleCallToken {
	
	public Term_2_RuleCall_ManyStrings(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getManyStringsParserRuleCall_2();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ManyStrings_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getManyStringsRule().getType().getClassifier())) return null;
		return new ManyStrings_Group(current, this).firstSolution();
	}
}

// Parens
protected class Term_3_RuleCall_Parens extends RuleCallToken {
	
	public Term_3_RuleCall_Parens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getParensParserRuleCall_3();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Parens_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParensRule().getType().getClassifier())) return null;
		return new Parens_Group(current, this).firstSolution();
	}
}

// Type
protected class Term_4_RuleCall_Type extends RuleCallToken {
	
	public Term_4_RuleCall_Type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getTypeParserRuleCall_4();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Type_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypeRule().getType().getClassifier())) return null;
		return new Type_Group(current, this).firstSolution();
	}
}

// Ref2
protected class Term_5_RuleCall_Ref2 extends RuleCallToken {
	
	public Term_5_RuleCall_Ref2(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getRef2ParserRuleCall_5();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Ref2_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRef2Rule().getType().getClassifier())) return null;
		return new Ref2_Group(current, this).firstSolution();
	}
}

// Spare
protected class Term_6_RuleCall_Spare extends RuleCallToken {
	
	public Term_6_RuleCall_Spare(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getSpareParserRuleCall_6();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Spare_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSpareRule().getType().getClassifier())) return null;
		return new Spare_Group(current, this).firstSolution();
	}
}

// Boolean
protected class Term_7_RuleCall_Boolean extends RuleCallToken {
	
	public Term_7_RuleCall_Boolean(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getBooleanParserRuleCall_7();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Boolean_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanRule().getType().getClassifier())) return null;
		return new Boolean_Group(current, this).firstSolution();
	}
}


/************ end Rule Term ****************/


/************ begin Rule Atom ****************
 *
 * Atom:
 *   name=ID;
 *
 **/

// name=ID
protected class Atom_Assignment_name extends AssignmentToken  {
	
	public Atom_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAtomAccess().getNameAssignment();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAtomAccess().getNameIDTerminalRuleCall_0();
			return new Solution(obj);
		}
		return null;
	}
}

/************ end Rule Atom ****************/


/************ begin Rule Parens ****************
 *
 * Parens returns Expression:
 *   "(" Op ")" (em="!")?;
 *
 **/

// "(" Op ")" (em="!")?
protected class Parens_Group extends GroupToken {
	
	public Parens_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParensAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Parens_3_Assignment_em(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Parens_2_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Parens_1_RuleCall_Op(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Parens_0_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "("
protected class Parens_0_Keyword extends KeywordToken  {
	
	public Parens_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParensAccess().getLeftParenthesisKeyword_0();
	}	
}

// Op
protected class Parens_1_RuleCall_Op extends RuleCallToken {
	
	public Parens_1_RuleCall_Op(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParensAccess().getOpParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Op_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOpRule().getType().getClassifier())) return null;
		return new Op_Group(current, this).firstSolution();
	}
}

// ")"
protected class Parens_2_Keyword extends KeywordToken  {
	
	public Parens_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParensAccess().getRightParenthesisKeyword_2();
	}	
}

// (em="!")?
protected class Parens_3_Assignment_em extends AssignmentToken  {
	
	public Parens_3_Assignment_em(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParensAccess().getEmAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("em",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("em");

		if("!".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.getParensAccess().getEmExclamationMarkKeyword_3_0();
			return new Solution(obj);
		}

		return null;
	}
}


/************ end Rule Parens ****************/


/************ begin Rule TwoNumbers ****************
 *
 * TwoNumbers:
 *   num1=INT num2=INT ("#" num3+=INT)*;
 *
 **/

// num1=INT num2=INT ("#" num3+=INT)*
protected class TwoNumbers_Group extends GroupToken {
	
	public TwoNumbers_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TwoNumbers_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TwoNumbers_1_Assignment_num2(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new TwoNumbers_0_Assignment_num1(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// num1=INT
protected class TwoNumbers_0_Assignment_num1 extends AssignmentToken  {
	
	public TwoNumbers_0_Assignment_num1(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getNum1Assignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("num1",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("num1");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTwoNumbersAccess().getNum1INTTerminalRuleCall_0_0();
			return new Solution(obj);
		}
		return null;
	}
}

// num2=INT
protected class TwoNumbers_1_Assignment_num2 extends AssignmentToken  {
	
	public TwoNumbers_1_Assignment_num2(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getNum2Assignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("num2",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("num2");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTwoNumbersAccess().getNum2INTTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("#" num3+=INT)*
protected class TwoNumbers_2_Group extends GroupToken {
	
	public TwoNumbers_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TwoNumbers_2_1_Assignment_num3(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TwoNumbers_2_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "#"
protected class TwoNumbers_2_0_Keyword extends KeywordToken  {
	
	public TwoNumbers_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getNumberSignKeyword_2_0();
	}	
}

// num3+=INT
protected class TwoNumbers_2_1_Assignment_num3 extends AssignmentToken  {
	
	public TwoNumbers_2_1_Assignment_num3(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getNum3Assignment_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("num3",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("num3");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTwoNumbersAccess().getNum3INTTerminalRuleCall_2_1_0();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule TwoNumbers ****************/


/************ begin Rule ManyStrings ****************
 *
 * ManyStrings:
 *   "=" (str1+=STRING)* str2+=STRING;
 *
 **/

// "=" (str1+=STRING)* str2+=STRING
protected class ManyStrings_Group extends GroupToken {
	
	public ManyStrings_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getManyStringsAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ManyStrings_2_Assignment_str2(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ManyStrings_1_Assignment_str1(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ManyStrings_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "="
protected class ManyStrings_0_Keyword extends KeywordToken  {
	
	public ManyStrings_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getManyStringsAccess().getEqualsSignKeyword_0();
	}	
}

// (str1+=STRING)*
protected class ManyStrings_1_Assignment_str1 extends AssignmentToken  {
	
	public ManyStrings_1_Assignment_str1(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getManyStringsAccess().getStr1Assignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("str1",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("str1");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getManyStringsAccess().getStr1STRINGTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// str2+=STRING
protected class ManyStrings_2_Assignment_str2 extends AssignmentToken  {
	
	public ManyStrings_2_Assignment_str2(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getManyStringsAccess().getStr2Assignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("str2",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("str2");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getManyStringsAccess().getStr2STRINGTerminalRuleCall_2_0();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule ManyStrings ****************/


/************ begin Rule Type ****************
 *
 * Type:
 *   "type" name=ID "extends" extends=[Type];
 *
 **/

// "type" name=ID "extends" extends=[Type]
protected class Type_Group extends GroupToken {
	
	public Type_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Type_3_Assignment_extends(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Type_2_Keyword_extends(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Type_1_Assignment_name(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Type_0_Keyword_type(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "type"
protected class Type_0_Keyword_type extends KeywordToken  {
	
	public Type_0_Keyword_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeAccess().getTypeKeyword_0();
	}	
}

// name=ID
protected class Type_1_Assignment_name extends AssignmentToken  {
	
	public Type_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTypeAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "extends"
protected class Type_2_Keyword_extends extends KeywordToken  {
	
	public Type_2_Keyword_extends(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeAccess().getExtendsKeyword_2();
	}	
}

// extends=[Type]
protected class Type_3_Assignment_extends extends AssignmentToken  {
	
	public Type_3_Assignment_extends(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeAccess().getExtendsAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("extends",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeAccess().getExtendsTypeCrossReference_3_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getTypeAccess().getExtendsTypeCrossReference_3_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}


/************ end Rule Type ****************/


/************ begin Rule Ref2 ****************
 *
 * Ref2:
 *   "#2" ref2=( "mykeyword1" | STRING | "mykeyword2" );
 *
 **/

// "#2" ref2=( "mykeyword1" | STRING | "mykeyword2" )
protected class Ref2_Group extends GroupToken {
	
	public Ref2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getRef2Access().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Ref2_1_Assignment_ref2(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Ref2_0_Keyword_2(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "#2"
protected class Ref2_0_Keyword_2 extends KeywordToken  {
	
	public Ref2_0_Keyword_2(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getRef2Access().getNumberSignDigitTwoKeyword_0();
	}	
}

// ref2=( "mykeyword1" | STRING | "mykeyword2" )
protected class Ref2_1_Assignment_ref2 extends AssignmentToken  {
	
	public Ref2_1_Assignment_ref2(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRef2Access().getRef2Assignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("ref2",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ref2");

		if("mykeyword1".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.getRef2Access().getRef2Mykeyword1Keyword_1_0_0();
			return new Solution(obj);
		}


		if("mykeyword2".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.getRef2Access().getRef2Mykeyword2Keyword_1_0_2();
			return new Solution(obj);
		}

		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getRef2Access().getRef2STRINGTerminalRuleCall_1_0_1();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule Ref2 ****************/


/************ begin Rule Spare ****************
 *
 * Spare:
 *   "#3" id+=ID ("." id+=ID)*;
 *
 **/

// "#3" id+=ID ("." id+=ID)*
protected class Spare_Group extends GroupToken {
	
	public Spare_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSpareAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Spare_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Spare_1_Assignment_id(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Spare_0_Keyword_3(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "#3"
protected class Spare_0_Keyword_3 extends KeywordToken  {
	
	public Spare_0_Keyword_3(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSpareAccess().getNumberSignDigitThreeKeyword_0();
	}	
}

// id+=ID
protected class Spare_1_Assignment_id extends AssignmentToken  {
	
	public Spare_1_Assignment_id(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSpareAccess().getIdAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("id",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSpareAccess().getIdIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("." id+=ID)*
protected class Spare_2_Group extends GroupToken {
	
	public Spare_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSpareAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Spare_2_1_Assignment_id(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Spare_2_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "."
protected class Spare_2_0_Keyword extends KeywordToken  {
	
	public Spare_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSpareAccess().getFullStopKeyword_2_0();
	}	
}

// id+=ID
protected class Spare_2_1_Assignment_id extends AssignmentToken  {
	
	public Spare_2_1_Assignment_id(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSpareAccess().getIdAssignment_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("id",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSpareAccess().getIdIDTerminalRuleCall_2_1_0();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule Spare ****************/


/************ begin Rule Boolean ****************
 *
 * Boolean:
 *   "#4" (bool?="myoption")? "kw" value=ID;
 *
 **/

// "#4" (bool?="myoption")? "kw" value=ID
protected class Boolean_Group extends GroupToken {
	
	public Boolean_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBooleanAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Boolean_3_Assignment_value(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Boolean_2_Keyword_kw(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Boolean_1_Assignment_bool(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Boolean_0_Keyword_4(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "#4"
protected class Boolean_0_Keyword_4 extends KeywordToken  {
	
	public Boolean_0_Keyword_4(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanAccess().getNumberSignDigitFourKeyword_0();
	}	
}

// (bool?="myoption")?
protected class Boolean_1_Assignment_bool extends AssignmentToken  {
	
	public Boolean_1_Assignment_bool(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanAccess().getBoolAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("bool",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("bool");

		if(Boolean.TRUE.equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.getBooleanAccess().getBoolMyoptionKeyword_1_0();
			return new Solution(obj);
		}

		return null;
	}
}

// "kw"
protected class Boolean_2_Keyword_kw extends KeywordToken  {
	
	public Boolean_2_Keyword_kw(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanAccess().getKwKeyword_2();
	}	
}

// value=ID
protected class Boolean_3_Assignment_value extends AssignmentToken  {
	
	public Boolean_3_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanAccess().getValueAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getBooleanAccess().getValueIDTerminalRuleCall_3_0();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule Boolean ****************/

}
