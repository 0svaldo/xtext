/*
* generated by Xtext
*/
package org.eclipse.xtext.parsetree.reconstr.parseTreeConstruction;

//import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.AbstractToken.Solution;
import org.eclipse.xtext.parsetree.reconstr.services.SimpleReconstrTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class SimpleReconstrTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private SimpleReconstrTestLanguageGrammarAccess grammarAccess;
	
	@Override
	protected Solution internalSerialize(EObject obj) {
		IInstanceDescription inst = getDescr(obj);
		Solution s;
		if(inst.isInstanceOf(grammarAccess.prOp().getRule().getType().getClassifier()) && (s = new Op_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prTerm().getRule().getType().getClassifier()) && (s = new Term_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAtom().getRule().getType().getClassifier()) && (s = new Atom_Assignment_name(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prParens().getRule().getType().getClassifier()) && (s = new Parens_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prTwoNumbers().getRule().getType().getClassifier()) && (s = new TwoNumbers_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prManyStrings().getRule().getType().getClassifier()) && (s = new ManyStrings_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prType().getRule().getType().getClassifier()) && (s = new Type_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prRef2().getRule().getType().getClassifier()) && (s = new Ref2_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prSpare().getRule().getType().getClassifier()) && (s = new Spare_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prBoolean().getRule().getType().getClassifier()) && (s = new Boolean_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		return null;
	}
	

/************ begin Rule Op ****************
 *
 * not supported
 *
 **/


// not supported
protected class Op_Group extends GroupToken {
	
	public Op_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prOp().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Op_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Op_0_RuleCall_Term(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Op_0_RuleCall_Term extends RuleCallToken {
	
	public Op_0_RuleCall_Term(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prOp().ele0ParserRuleCallTerm();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Term_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prTerm().getRule().getType().getClassifier())) return null;
		return new Term_Alternatives(current, this).firstSolution();
	}
}

// not supported
protected class Op_1_Group extends GroupToken {
	
	public Op_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prOp().ele1Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Op_1_1_Assignment_values(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Op_1_0_Action_Op_values(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Op_1_0_Action_Op_values extends ActionToken  {

	public Op_1_0_Action_Op_values(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.prOp().ele10ActionOpvalues();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.prOp().ele10ActionOpvalues().getType().getClassifier())) return null;
		Object val = current.getConsumable("values", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("values")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// not supported
protected class Op_1_1_Assignment_values extends AssignmentToken  {
	
	public Op_1_1_Assignment_values(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prOp().ele11AssignmentValues();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("values",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("values");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTerm().getRule().getType().getClassifier())) {
				Solution s = new Term_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



/************ end Rule Op ****************/


/************ begin Rule Term ****************
 *
 * not supported
 *
 **/


// not supported
protected class Term_Alternatives extends AlternativesToken {

	public Term_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prTerm().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Term_0_RuleCall_Atom(current, this);
			case 1: return new Term_1_RuleCall_TwoNumbers(current, this);
			case 2: return new Term_2_RuleCall_ManyStrings(current, this);
			case 3: return new Term_3_RuleCall_Parens(current, this);
			case 4: return new Term_4_RuleCall_Type(current, this);
			case 5: return new Term_5_RuleCall_Ref2(current, this);
			case 6: return new Term_6_RuleCall_Spare(current, this);
			case 7: return new Term_7_RuleCall_Boolean(current, this);
			default: return null;
		}
	}
}

// not supported
protected class Term_0_RuleCall_Atom extends RuleCallToken {
	
	public Term_0_RuleCall_Atom(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerm().ele0ParserRuleCallAtom();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Atom_Assignment_name.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prAtom().getRule().getType().getClassifier())) return null;
		return new Atom_Assignment_name(current, this).firstSolution();
	}
}

// not supported
protected class Term_1_RuleCall_TwoNumbers extends RuleCallToken {
	
	public Term_1_RuleCall_TwoNumbers(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerm().ele1ParserRuleCallTwoNumbers();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TwoNumbers_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prTwoNumbers().getRule().getType().getClassifier())) return null;
		return new TwoNumbers_Group(current, this).firstSolution();
	}
}

// not supported
protected class Term_2_RuleCall_ManyStrings extends RuleCallToken {
	
	public Term_2_RuleCall_ManyStrings(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerm().ele2ParserRuleCallManyStrings();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ManyStrings_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prManyStrings().getRule().getType().getClassifier())) return null;
		return new ManyStrings_Group(current, this).firstSolution();
	}
}

// not supported
protected class Term_3_RuleCall_Parens extends RuleCallToken {
	
	public Term_3_RuleCall_Parens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerm().ele3ParserRuleCallParens();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Parens_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prParens().getRule().getType().getClassifier())) return null;
		return new Parens_Group(current, this).firstSolution();
	}
}

// not supported
protected class Term_4_RuleCall_Type extends RuleCallToken {
	
	public Term_4_RuleCall_Type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerm().ele4ParserRuleCallType();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Type_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prType().getRule().getType().getClassifier())) return null;
		return new Type_Group(current, this).firstSolution();
	}
}

// not supported
protected class Term_5_RuleCall_Ref2 extends RuleCallToken {
	
	public Term_5_RuleCall_Ref2(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerm().ele5ParserRuleCallRef2();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Ref2_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prRef2().getRule().getType().getClassifier())) return null;
		return new Ref2_Group(current, this).firstSolution();
	}
}

// not supported
protected class Term_6_RuleCall_Spare extends RuleCallToken {
	
	public Term_6_RuleCall_Spare(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerm().ele6ParserRuleCallSpare();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Spare_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prSpare().getRule().getType().getClassifier())) return null;
		return new Spare_Group(current, this).firstSolution();
	}
}

// not supported
protected class Term_7_RuleCall_Boolean extends RuleCallToken {
	
	public Term_7_RuleCall_Boolean(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerm().ele7ParserRuleCallBoolean();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Boolean_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prBoolean().getRule().getType().getClassifier())) return null;
		return new Boolean_Group(current, this).firstSolution();
	}
}


/************ end Rule Term ****************/


/************ begin Rule Atom ****************
 *
 * not supported
 *
 **/


// not supported
protected class Atom_Assignment_name extends AssignmentToken  {
	
	public Atom_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAtom().eleAssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prAtom().ele0TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

/************ end Rule Atom ****************/


/************ begin Rule Parens ****************
 *
 * not supported
 *
 **/


// not supported
protected class Parens_Group extends GroupToken {
	
	public Parens_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prParens().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Parens_3_Assignment_em(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Parens_2_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Parens_1_RuleCall_Op(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new Parens_0_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Parens_0_Keyword extends KeywordToken  {
	
	public Parens_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParens().ele0KeywordLeftParenthesis();
	}	
}

// not supported
protected class Parens_1_RuleCall_Op extends RuleCallToken {
	
	public Parens_1_RuleCall_Op(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prParens().ele1ParserRuleCallOp();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Op_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prOp().getRule().getType().getClassifier())) return null;
		return new Op_Group(current, this).firstSolution();
	}
}

// not supported
protected class Parens_2_Keyword extends KeywordToken  {
	
	public Parens_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParens().ele2KeywordRightParenthesis();
	}	
}

// not supported
protected class Parens_3_Assignment_em extends AssignmentToken  {
	
	public Parens_3_Assignment_em(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prParens().ele3AssignmentEm();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("em",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("em");

		if("!".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prParens().ele30KeywordExclamationMark();
			return new Solution(obj);
		}

		return null;
	}
}


/************ end Rule Parens ****************/


/************ begin Rule TwoNumbers ****************
 *
 * not supported
 *
 **/


// not supported
protected class TwoNumbers_Group extends GroupToken {
	
	public TwoNumbers_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTwoNumbers().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TwoNumbers_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TwoNumbers_1_Assignment_num2(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new TwoNumbers_0_Assignment_num1(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class TwoNumbers_0_Assignment_num1 extends AssignmentToken  {
	
	public TwoNumbers_0_Assignment_num1(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prTwoNumbers().ele0AssignmentNum1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("num1",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("num1");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prTwoNumbers().ele00TerminalRuleCallINT();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class TwoNumbers_1_Assignment_num2 extends AssignmentToken  {
	
	public TwoNumbers_1_Assignment_num2(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prTwoNumbers().ele1AssignmentNum2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("num2",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("num2");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prTwoNumbers().ele10TerminalRuleCallINT();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class TwoNumbers_2_Group extends GroupToken {
	
	public TwoNumbers_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTwoNumbers().ele2Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TwoNumbers_2_1_Assignment_num3(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TwoNumbers_2_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class TwoNumbers_2_0_Keyword extends KeywordToken  {
	
	public TwoNumbers_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prTwoNumbers().ele20KeywordNumberSign();
	}	
}

// not supported
protected class TwoNumbers_2_1_Assignment_num3 extends AssignmentToken  {
	
	public TwoNumbers_2_1_Assignment_num3(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prTwoNumbers().ele21AssignmentNum3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("num3",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("num3");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prTwoNumbers().ele210TerminalRuleCallINT();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule TwoNumbers ****************/


/************ begin Rule ManyStrings ****************
 *
 * not supported
 *
 **/


// not supported
protected class ManyStrings_Group extends GroupToken {
	
	public ManyStrings_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prManyStrings().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ManyStrings_2_Assignment_str2(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ManyStrings_1_Assignment_str1(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ManyStrings_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ManyStrings_0_Keyword extends KeywordToken  {
	
	public ManyStrings_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prManyStrings().ele0KeywordEqualsSign();
	}	
}

// not supported
protected class ManyStrings_1_Assignment_str1 extends AssignmentToken  {
	
	public ManyStrings_1_Assignment_str1(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prManyStrings().ele1AssignmentStr1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("str1",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("str1");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prManyStrings().ele10TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class ManyStrings_2_Assignment_str2 extends AssignmentToken  {
	
	public ManyStrings_2_Assignment_str2(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prManyStrings().ele2AssignmentStr2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("str2",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("str2");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prManyStrings().ele20TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule ManyStrings ****************/


/************ begin Rule Type ****************
 *
 * not supported
 *
 **/


// not supported
protected class Type_Group extends GroupToken {
	
	public Type_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prType().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Type_3_Assignment_extends(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Type_2_Keyword_extends(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Type_1_Assignment_name(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new Type_0_Keyword_type(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Type_0_Keyword_type extends KeywordToken  {
	
	public Type_0_Keyword_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prType().ele0KeywordType();
	}	
}

// not supported
protected class Type_1_Assignment_name extends AssignmentToken  {
	
	public Type_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prType().ele1AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prType().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class Type_2_Keyword_extends extends KeywordToken  {
	
	public Type_2_Keyword_extends(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prType().ele2KeywordExtends();
	}	
}

// not supported
protected class Type_3_Assignment_extends extends AssignmentToken  {
	
	public Type_3_Assignment_extends(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prType().ele3AssignmentExtends();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("extends",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prType().ele30CrossReferenceIDType().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.prType().ele30CrossReferenceIDType(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}


/************ end Rule Type ****************/


/************ begin Rule Ref2 ****************
 *
 * not supported
 *
 **/


// not supported
protected class Ref2_Group extends GroupToken {
	
	public Ref2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prRef2().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Ref2_1_Assignment_ref2(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Ref2_0_Keyword_2(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Ref2_0_Keyword_2 extends KeywordToken  {
	
	public Ref2_0_Keyword_2(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prRef2().ele0KeywordNumberSignDigitTwo();
	}	
}

// not supported
protected class Ref2_1_Assignment_ref2 extends AssignmentToken  {
	
	public Ref2_1_Assignment_ref2(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prRef2().ele1AssignmentRef2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("ref2",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ref2");

		if("mykeyword1".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prRef2().ele100KeywordMykeyword1();
			return new Solution(obj);
		}


		if("mykeyword2".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prRef2().ele102KeywordMykeyword2();
			return new Solution(obj);
		}

		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prRef2().ele101TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule Ref2 ****************/


/************ begin Rule Spare ****************
 *
 * not supported
 *
 **/


// not supported
protected class Spare_Group extends GroupToken {
	
	public Spare_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSpare().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Spare_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Spare_1_Assignment_id(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Spare_0_Keyword_3(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Spare_0_Keyword_3 extends KeywordToken  {
	
	public Spare_0_Keyword_3(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSpare().ele0KeywordNumberSignDigitThree();
	}	
}

// not supported
protected class Spare_1_Assignment_id extends AssignmentToken  {
	
	public Spare_1_Assignment_id(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSpare().ele1AssignmentId();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("id",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prSpare().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class Spare_2_Group extends GroupToken {
	
	public Spare_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSpare().ele2Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Spare_2_1_Assignment_id(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Spare_2_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Spare_2_0_Keyword extends KeywordToken  {
	
	public Spare_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSpare().ele20KeywordFullStop();
	}	
}

// not supported
protected class Spare_2_1_Assignment_id extends AssignmentToken  {
	
	public Spare_2_1_Assignment_id(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSpare().ele21AssignmentId();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("id",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prSpare().ele210TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule Spare ****************/


/************ begin Rule Boolean ****************
 *
 * not supported
 *
 **/


// not supported
protected class Boolean_Group extends GroupToken {
	
	public Boolean_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prBoolean().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Boolean_3_Assignment_value(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Boolean_2_Keyword_kw(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Boolean_1_Assignment_bool(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new Boolean_0_Keyword_4(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Boolean_0_Keyword_4 extends KeywordToken  {
	
	public Boolean_0_Keyword_4(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBoolean().ele0KeywordNumberSignDigitFour();
	}	
}

// not supported
protected class Boolean_1_Assignment_bool extends AssignmentToken  {
	
	public Boolean_1_Assignment_bool(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prBoolean().ele1AssignmentBool();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("bool",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("bool");

		if(Boolean.TRUE.equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prBoolean().ele10KeywordMyoption();
			return new Solution(obj);
		}

		return null;
	}
}

// not supported
protected class Boolean_2_Keyword_kw extends KeywordToken  {
	
	public Boolean_2_Keyword_kw(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBoolean().ele2KeywordKw();
	}	
}

// not supported
protected class Boolean_3_Assignment_value extends AssignmentToken  {
	
	public Boolean_3_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prBoolean().ele3AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prBoolean().ele30TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule Boolean ****************/

}
