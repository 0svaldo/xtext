/*
* generated by Xtext
*/
package org.eclipse.xtext.parsetree.reconstr.parseTreeConstruction;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor2;

import org.eclipse.xtext.parsetree.reconstr.services.SimpleReconstrTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class SimpleReconstrTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor2 {
		
	@Inject
	private SimpleReconstrTestLanguageGrammarAccess grammarAccess;
		
	public SimpleReconstrTestLanguageGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken2 getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Op_Group(this, this, 0, inst);
			case 1: return new Term_Alternatives(this, this, 1, inst);
			case 2: return new Atom_NameAssignment(this, this, 2, inst);
			case 3: return new Parens_Group(this, this, 3, inst);
			case 4: return new TwoNumbers_Group(this, this, 4, inst);
			case 5: return new ManyStrings_Group(this, this, 5, inst);
			case 6: return new Type_Group(this, this, 6, inst);
			case 7: return new Ref2_Group(this, this, 7, inst);
			case 8: return new Spare_Group(this, this, 8, inst);
			case 9: return new Boolean_Group(this, this, 9, inst);
			case 10: return new Transient1_Group(this, this, 10, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Op ****************
 *
 * Op returns Expression:
 *   Term ({Op.values+=current} values+=Term)*;
 *
 **/

// Term ({Op.values+=current} values+=Term)*
protected class Op_Group extends GroupToken {
	
	public Op_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOpAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Op_Group_1(parent, this, 0, inst);
			case 1: return new Op_TermParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOpRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// Term
protected class Op_TermParserRuleCall_0 extends RuleCallToken {
	
	public Op_TermParserRuleCall_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getOpAccess().getTermParserRuleCall_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Term_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Term_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// ({Op.values+=current} values+=Term)*
protected class Op_Group_1 extends GroupToken {
	
	public Op_Group_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOpAccess().getGroup_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Op_ValuesAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Op.values+=current}
protected class Op_OpValuesAction_1_0 extends ActionToken  {

	public Op_OpValuesAction_1_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getOpAccess().getOpValuesAction_1_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Op_Group_1(parent, this, 0, inst);
			case 1: return new Op_TermParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getOpAccess().getOpValuesAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("values", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("values")) return null;
		return getDescr((EObject) val);
	}
}

// values+=Term
protected class Op_ValuesAssignment_1_1 extends AssignmentToken  {
	
	public Op_ValuesAssignment_1_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOpAccess().getValuesAssignment_1_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Term_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("values",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("values");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new Op_OpValuesAction_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Op ****************/


/************ begin Rule Term ****************
 *
 * Term returns Expression:
 *   Atom|TwoNumbers|ManyStrings|Parens|Type|Ref2|Spare|Boolean|Transient1;
 *
 **/

// Atom|TwoNumbers|ManyStrings|Parens|Type|Ref2|Spare|Boolean|Transient1
protected class Term_Alternatives extends AlternativesToken {

	public Term_Alternatives(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getTermAccess().getAlternatives();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Term_AtomParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Term_TwoNumbersParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Term_ManyStringsParserRuleCall_2(parent, this, 2, inst);
			case 3: return new Term_ParensParserRuleCall_3(parent, this, 3, inst);
			case 4: return new Term_TypeParserRuleCall_4(parent, this, 4, inst);
			case 5: return new Term_Ref2ParserRuleCall_5(parent, this, 5, inst);
			case 6: return new Term_SpareParserRuleCall_6(parent, this, 6, inst);
			case 7: return new Term_BooleanParserRuleCall_7(parent, this, 7, inst);
			case 8: return new Term_Transient1ParserRuleCall_8(parent, this, 8, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// Atom
protected class Term_AtomParserRuleCall_0 extends RuleCallToken {
	
	public Term_AtomParserRuleCall_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getAtomParserRuleCall_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Atom_NameAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// TwoNumbers
protected class Term_TwoNumbersParserRuleCall_1 extends RuleCallToken {
	
	public Term_TwoNumbersParserRuleCall_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getTwoNumbersParserRuleCall_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TwoNumbers_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(TwoNumbers_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTwoNumbersRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// ManyStrings
protected class Term_ManyStringsParserRuleCall_2 extends RuleCallToken {
	
	public Term_ManyStringsParserRuleCall_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getManyStringsParserRuleCall_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ManyStrings_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(ManyStrings_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getManyStringsRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// Parens
protected class Term_ParensParserRuleCall_3 extends RuleCallToken {
	
	public Term_ParensParserRuleCall_3(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getParensParserRuleCall_3();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parens_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Parens_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParensRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// Type
protected class Term_TypeParserRuleCall_4 extends RuleCallToken {
	
	public Term_TypeParserRuleCall_4(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getTypeParserRuleCall_4();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Type_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Type_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTypeRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// Ref2
protected class Term_Ref2ParserRuleCall_5 extends RuleCallToken {
	
	public Term_Ref2ParserRuleCall_5(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getRef2ParserRuleCall_5();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Ref2_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Ref2_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRef2Rule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// Spare
protected class Term_SpareParserRuleCall_6 extends RuleCallToken {
	
	public Term_SpareParserRuleCall_6(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getSpareParserRuleCall_6();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Spare_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Spare_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSpareRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// Boolean
protected class Term_BooleanParserRuleCall_7 extends RuleCallToken {
	
	public Term_BooleanParserRuleCall_7(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getBooleanParserRuleCall_7();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Boolean_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Boolean_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBooleanRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}

// Transient1
protected class Term_Transient1ParserRuleCall_8 extends RuleCallToken {
	
	public Term_Transient1ParserRuleCall_8(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getTransient1ParserRuleCall_8();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transient1_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Transient1_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTransient1Rule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(next,actIndex , index - 0, inst) : null;
			default: return parent.createParentFollower(next,actIndex , index - 0, inst);
		}	
	}	
}


/************ end Rule Term ****************/


/************ begin Rule Atom ****************
 *
 * Atom:
 *   name=ID;
 *
 **/

// name=ID
protected class Atom_NameAssignment extends AssignmentToken  {
	
	public Atom_NameAssignment(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAtomAccess().getNameAssignment();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAtomAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Atom ****************/


/************ begin Rule Parens ****************
 *
 * Parens returns Expression:
 *   "(" Op ")" em="!"?;
 *
 **/

// "(" Op ")" em="!"?
protected class Parens_Group extends GroupToken {
	
	public Parens_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getParensAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parens_EmAssignment_3(parent, this, 0, inst);
			case 1: return new Parens_RightParenthesisKeyword_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParensRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "("
protected class Parens_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public Parens_LeftParenthesisKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParensAccess().getLeftParenthesisKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// Op
protected class Parens_OpParserRuleCall_1 extends RuleCallToken {
	
	public Parens_OpParserRuleCall_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getParensAccess().getOpParserRuleCall_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Op_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Op_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getOpRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new Parens_LeftParenthesisKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class Parens_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public Parens_RightParenthesisKeyword_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParensAccess().getRightParenthesisKeyword_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parens_OpParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// em="!"?
protected class Parens_EmAssignment_3 extends AssignmentToken  {
	
	public Parens_EmAssignment_3(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getParensAccess().getEmAssignment_3();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parens_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("em",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("em");
		if("!".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getParensAccess().getEmExclamationMarkKeyword_3_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Parens ****************/


/************ begin Rule TwoNumbers ****************
 *
 * TwoNumbers:
 *   num1=INT num2=INT ("#" num3+=INT)*;
 *
 **/

// num1=INT num2=INT ("#" num3+=INT)*
protected class TwoNumbers_Group extends GroupToken {
	
	public TwoNumbers_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TwoNumbers_Group_2(parent, this, 0, inst);
			case 1: return new TwoNumbers_Num2Assignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTwoNumbersRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// num1=INT
protected class TwoNumbers_Num1Assignment_0 extends AssignmentToken  {
	
	public TwoNumbers_Num1Assignment_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getNum1Assignment_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("num1",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("num1");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTwoNumbersAccess().getNum1INTTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// num2=INT
protected class TwoNumbers_Num2Assignment_1 extends AssignmentToken  {
	
	public TwoNumbers_Num2Assignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getNum2Assignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TwoNumbers_Num1Assignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("num2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("num2");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTwoNumbersAccess().getNum2INTTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("#" num3+=INT)*
protected class TwoNumbers_Group_2 extends GroupToken {
	
	public TwoNumbers_Group_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getGroup_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TwoNumbers_Num3Assignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "#"
protected class TwoNumbers_NumberSignKeyword_2_0 extends KeywordToken  {
	
	public TwoNumbers_NumberSignKeyword_2_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getNumberSignKeyword_2_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TwoNumbers_Group_2(parent, this, 0, inst);
			case 1: return new TwoNumbers_Num2Assignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// num3+=INT
protected class TwoNumbers_Num3Assignment_2_1 extends AssignmentToken  {
	
	public TwoNumbers_Num3Assignment_2_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTwoNumbersAccess().getNum3Assignment_2_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new TwoNumbers_NumberSignKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("num3",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("num3");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTwoNumbersAccess().getNum3INTTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule TwoNumbers ****************/


/************ begin Rule ManyStrings ****************
 *
 * ManyStrings:
 *   "=" str1+=STRING* str2+=STRING;
 *
 **/

// "=" str1+=STRING* str2+=STRING
protected class ManyStrings_Group extends GroupToken {
	
	public ManyStrings_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getManyStringsAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ManyStrings_Str2Assignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getManyStringsRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "="
protected class ManyStrings_EqualsSignKeyword_0 extends KeywordToken  {
	
	public ManyStrings_EqualsSignKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getManyStringsAccess().getEqualsSignKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// str1+=STRING*
protected class ManyStrings_Str1Assignment_1 extends AssignmentToken  {
	
	public ManyStrings_Str1Assignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getManyStringsAccess().getStr1Assignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ManyStrings_Str1Assignment_1(parent, this, 0, inst);
			case 1: return new ManyStrings_EqualsSignKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("str1",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("str1");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getManyStringsAccess().getStr1STRINGTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// str2+=STRING
protected class ManyStrings_Str2Assignment_2 extends AssignmentToken  {
	
	public ManyStrings_Str2Assignment_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getManyStringsAccess().getStr2Assignment_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ManyStrings_Str1Assignment_1(parent, this, 0, inst);
			case 1: return new ManyStrings_EqualsSignKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("str2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("str2");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getManyStringsAccess().getStr2STRINGTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule ManyStrings ****************/


/************ begin Rule Type ****************
 *
 * Type:
 *   "type" name=ID "extends" extends=[Type];
 *
 **/

// "type" name=ID "extends" extends=[Type]
protected class Type_Group extends GroupToken {
	
	public Type_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTypeAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Type_ExtendsAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTypeRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "type"
protected class Type_TypeKeyword_0 extends KeywordToken  {
	
	public Type_TypeKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeAccess().getTypeKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// name=ID
protected class Type_NameAssignment_1 extends AssignmentToken  {
	
	public Type_NameAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeAccess().getNameAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Type_TypeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTypeAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// "extends"
protected class Type_ExtendsKeyword_2 extends KeywordToken  {
	
	public Type_ExtendsKeyword_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeAccess().getExtendsKeyword_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Type_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// extends=[Type]
protected class Type_ExtendsAssignment_3 extends AssignmentToken  {
	
	public Type_ExtendsAssignment_3(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeAccess().getExtendsAssignment_3();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Type_ExtendsKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("extends",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("extends");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeAccess().getExtendsTypeCrossReference_3_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getTypeAccess().getExtendsTypeCrossReference_3_0(); 
				return obj;
			}
		}
		return null;
	}

}


/************ end Rule Type ****************/


/************ begin Rule Ref2 ****************
 *
 * Ref2:
 *   "#2" ref2=( "mykeyword1" | STRING | "mykeyword2" );
 *
 **/

// "#2" ref2=( "mykeyword1" | STRING | "mykeyword2" )
protected class Ref2_Group extends GroupToken {
	
	public Ref2_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getRef2Access().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Ref2_Ref2Assignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getRef2Rule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "#2"
protected class Ref2_NumberSignDigitTwoKeyword_0 extends KeywordToken  {
	
	public Ref2_NumberSignDigitTwoKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getRef2Access().getNumberSignDigitTwoKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// ref2=( "mykeyword1" | STRING | "mykeyword2" )
protected class Ref2_Ref2Assignment_1 extends AssignmentToken  {
	
	public Ref2_Ref2Assignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getRef2Access().getRef2Assignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Ref2_NumberSignDigitTwoKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("ref2",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ref2");
		if("mykeyword1".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRef2Access().getRef2Mykeyword1Keyword_1_0_0();
			return obj;
		}
		if("mykeyword2".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getRef2Access().getRef2Mykeyword2Keyword_1_0_2();
			return obj;
		}
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getRef2Access().getRef2STRINGTerminalRuleCall_1_0_1();
			return obj;
		}
		return null;
	}

}


/************ end Rule Ref2 ****************/


/************ begin Rule Spare ****************
 *
 * Spare:
 *   "#3" id+=ID ("." id+=ID)*;
 *
 **/

// "#3" id+=ID ("." id+=ID)*
protected class Spare_Group extends GroupToken {
	
	public Spare_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSpareAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Spare_Group_2(parent, this, 0, inst);
			case 1: return new Spare_IdAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSpareRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "#3"
protected class Spare_NumberSignDigitThreeKeyword_0 extends KeywordToken  {
	
	public Spare_NumberSignDigitThreeKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSpareAccess().getNumberSignDigitThreeKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// id+=ID
protected class Spare_IdAssignment_1 extends AssignmentToken  {
	
	public Spare_IdAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSpareAccess().getIdAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Spare_NumberSignDigitThreeKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSpareAccess().getIdIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}

// ("." id+=ID)*
protected class Spare_Group_2 extends GroupToken {
	
	public Spare_Group_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSpareAccess().getGroup_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Spare_IdAssignment_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// "."
protected class Spare_FullStopKeyword_2_0 extends KeywordToken  {
	
	public Spare_FullStopKeyword_2_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSpareAccess().getFullStopKeyword_2_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Spare_Group_2(parent, this, 0, inst);
			case 1: return new Spare_IdAssignment_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// id+=ID
protected class Spare_IdAssignment_2_1 extends AssignmentToken  {
	
	public Spare_IdAssignment_2_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSpareAccess().getIdAssignment_2_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Spare_FullStopKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("id",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("id");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSpareAccess().getIdIDTerminalRuleCall_2_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule Spare ****************/


/************ begin Rule Boolean ****************
 *
 * Boolean:
 *   "#4" bool?="myoption"? "kw" value=ID;
 *
 **/

// "#4" bool?="myoption"? "kw" value=ID
protected class Boolean_Group extends GroupToken {
	
	public Boolean_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getBooleanAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Boolean_ValueAssignment_3(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getBooleanRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "#4"
protected class Boolean_NumberSignDigitFourKeyword_0 extends KeywordToken  {
	
	public Boolean_NumberSignDigitFourKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanAccess().getNumberSignDigitFourKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// bool?="myoption"?
protected class Boolean_BoolAssignment_1 extends AssignmentToken  {
	
	public Boolean_BoolAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanAccess().getBoolAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Boolean_NumberSignDigitFourKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("bool",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("bool");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getBooleanAccess().getBoolMyoptionKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// "kw"
protected class Boolean_KwKeyword_2 extends KeywordToken  {
	
	public Boolean_KwKeyword_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBooleanAccess().getKwKeyword_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Boolean_BoolAssignment_1(parent, this, 0, inst);
			case 1: return new Boolean_NumberSignDigitFourKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// value=ID
protected class Boolean_ValueAssignment_3 extends AssignmentToken  {
	
	public Boolean_ValueAssignment_3(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getBooleanAccess().getValueAssignment_3();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Boolean_KwKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getBooleanAccess().getValueIDTerminalRuleCall_3_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Boolean ****************/


/************ begin Rule Transient1 ****************
 *
 * Transient1:
 *   "#5" (precStar?="*"|prec=INT) ("," (scaleStar?="*"|scale=INT))?;
 *
 **/

// "#5" (precStar?="*"|prec=INT) ("," (scaleStar?="*"|scale=INT))?
protected class Transient1_Group extends GroupToken {
	
	public Transient1_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTransient1Access().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transient1_Group_2(parent, this, 0, inst);
			case 1: return new Transient1_Alternatives_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTransient1Rule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "#5"
protected class Transient1_NumberSignDigitFiveKeyword_0 extends KeywordToken  {
	
	public Transient1_NumberSignDigitFiveKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTransient1Access().getNumberSignDigitFiveKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// precStar?="*"|prec=INT
protected class Transient1_Alternatives_1 extends AlternativesToken {

	public Transient1_Alternatives_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getTransient1Access().getAlternatives_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transient1_PrecStarAssignment_1_0(parent, this, 0, inst);
			case 1: return new Transient1_PrecAssignment_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// precStar?="*"
protected class Transient1_PrecStarAssignment_1_0 extends AssignmentToken  {
	
	public Transient1_PrecStarAssignment_1_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTransient1Access().getPrecStarAssignment_1_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transient1_NumberSignDigitFiveKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("precStar",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("precStar");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getTransient1Access().getPrecStarAsteriskKeyword_1_0_0();
			return obj;
		}
		return null;
	}

}

// prec=INT
protected class Transient1_PrecAssignment_1_1 extends AssignmentToken  {
	
	public Transient1_PrecAssignment_1_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTransient1Access().getPrecAssignment_1_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transient1_NumberSignDigitFiveKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("prec",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("prec");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTransient1Access().getPrecINTTerminalRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}


// ("," (scaleStar?="*"|scale=INT))?
protected class Transient1_Group_2 extends GroupToken {
	
	public Transient1_Group_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getTransient1Access().getGroup_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transient1_Alternatives_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// ","
protected class Transient1_CommaKeyword_2_0 extends KeywordToken  {
	
	public Transient1_CommaKeyword_2_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTransient1Access().getCommaKeyword_2_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transient1_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// scaleStar?="*"|scale=INT
protected class Transient1_Alternatives_2_1 extends AlternativesToken {

	public Transient1_Alternatives_2_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getTransient1Access().getAlternatives_2_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transient1_ScaleStarAssignment_2_1_0(parent, this, 0, inst);
			case 1: return new Transient1_ScaleAssignment_2_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// scaleStar?="*"
protected class Transient1_ScaleStarAssignment_2_1_0 extends AssignmentToken  {
	
	public Transient1_ScaleStarAssignment_2_1_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTransient1Access().getScaleStarAssignment_2_1_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transient1_CommaKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("scaleStar",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("scaleStar");
		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getTransient1Access().getScaleStarAsteriskKeyword_2_1_0_0();
			return obj;
		}
		return null;
	}

}

// scale=INT
protected class Transient1_ScaleAssignment_2_1_1 extends AssignmentToken  {
	
	public Transient1_ScaleAssignment_2_1_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getTransient1Access().getScaleAssignment_2_1_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Transient1_CommaKeyword_2_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("scale",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("scale");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTransient1Access().getScaleINTTerminalRuleCall_2_1_1_0();
			return obj;
		}
		return null;
	}

}




/************ end Rule Transient1 ****************/

}
