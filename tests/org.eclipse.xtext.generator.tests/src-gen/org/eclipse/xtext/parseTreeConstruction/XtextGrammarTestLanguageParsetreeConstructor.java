/*
* generated by Xtext
*/
package org.eclipse.xtext.parseTreeConstruction;

//import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.AbstractToken.Solution;
import org.eclipse.xtext.services.XtextGrammarTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class XtextGrammarTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private XtextGrammarTestLanguageGrammarAccess grammarAccess;
	
	@Override
	protected Solution internalSerialize(EObject obj) {
		IInstanceDescription inst = getDescr(obj);
		Solution s;
		if(inst.isInstanceOf(grammarAccess.prGrammar().getRule().getType().getType()) && (s = new Grammar_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAbstractRule().getRule().getType().getType()) && (s = new AbstractRule_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAbstractMetamodelDeclaration().getRule().getType().getType()) && (s = new AbstractMetamodelDeclaration_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prGeneratedMetamodel().getRule().getType().getType()) && (s = new GeneratedMetamodel_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prReferencedMetamodel().getRule().getType().getType()) && (s = new ReferencedMetamodel_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prParserRule().getRule().getType().getType()) && (s = new ParserRule_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prTerminalRule().getRule().getType().getType()) && (s = new TerminalRule_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prTypeRef().getRule().getType().getType()) && (s = new TypeRef_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAlternatives().getRule().getType().getType()) && (s = new Alternatives_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prTerminalAlternatives().getRule().getType().getType()) && (s = new TerminalAlternatives_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prGroup().getRule().getType().getType()) && (s = new Group_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prTerminalGroup().getRule().getType().getType()) && (s = new TerminalGroup_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAbstractToken().getRule().getType().getType()) && (s = new AbstractToken_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prTerminalToken().getRule().getType().getType()) && (s = new TerminalToken_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAssignment().getRule().getType().getType()) && (s = new Assignment_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAction().getRule().getType().getType()) && (s = new Action_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAbstractTerminal().getRule().getType().getType()) && (s = new AbstractTerminal_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prTerminalTokenElement().getRule().getType().getType()) && (s = new TerminalTokenElement_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAbstractNegatedToken().getRule().getType().getType()) && (s = new AbstractNegatedToken_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prNegatedToken().getRule().getType().getType()) && (s = new NegatedToken_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prUntilToken().getRule().getType().getType()) && (s = new UntilToken_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prWildcard().getRule().getType().getType()) && (s = new Wildcard_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prCharacterRange().getRule().getType().getType()) && (s = new CharacterRange_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prCrossReference().getRule().getType().getType()) && (s = new CrossReference_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prParenthesizedElement().getRule().getType().getType()) && (s = new ParenthesizedElement_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prParenthesizedTerminalElement().getRule().getType().getType()) && (s = new ParenthesizedTerminalElement_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prKeyword().getRule().getType().getType()) && (s = new Keyword_Assignment_value(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prRuleCall().getRule().getType().getType()) && (s = new RuleCall_Assignment_rule(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		return null;
	}
	

/************ begin Rule Grammar ****************
 *
 * not supported
 *
 **/


// not supported
protected class Grammar_Group extends GroupToken {
	
	public Grammar_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGrammar().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_5_Assignment_rules(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_4_Assignment_metamodelDeclarations(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Grammar_3_Group(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new Grammar_2_Group(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new Grammar_1_Assignment_name(s4.getCurrent(), s4.getPredecessor()).firstSolution();
		while(s5 != null) {
			Solution s6 = new Grammar_0_Keyword_grammar(s5.getCurrent(), s5.getPredecessor()).firstSolution();
			if(s6 != null) {
				last = s6.getPredecessor();
				return s6;
			} else {
				s5 = s5.getPredecessor().nextSolution(this,s5);
			}
		}
			s4 = s4.getPredecessor().nextSolution(this,s4);
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Grammar_0_Keyword_grammar extends KeywordToken  {
	
	public Grammar_0_Keyword_grammar(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prGrammar().ele0KeywordGrammar();
	}	
}

// not supported
protected class Grammar_1_Assignment_name extends AssignmentToken  {
	
	public Grammar_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGrammar().ele1AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");

		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for datatype rule
			type = AssignmentType.PRC;
			element = grammarAccess.prGrammar().ele10ParserRuleCallGrammarID();
			return new Solution(obj);
		}

		return null;
	}
}

// not supported
protected class Grammar_2_Group extends GroupToken {
	
	public Grammar_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGrammar().ele2Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_2_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_2_1_Assignment_usedGrammars(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Grammar_2_0_Keyword_with(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Grammar_2_0_Keyword_with extends KeywordToken  {
	
	public Grammar_2_0_Keyword_with(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prGrammar().ele20KeywordWith();
	}	
}

// not supported
protected class Grammar_2_1_Assignment_usedGrammars extends AssignmentToken  {
	
	public Grammar_2_1_Assignment_usedGrammars(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGrammar().ele21AssignmentUsedGrammars();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("usedGrammars",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("usedGrammars");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prGrammar().ele210CrossReferenceEStringGrammar().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prGrammar().ele210CrossReferenceEStringGrammar(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class Grammar_2_2_Group extends GroupToken {
	
	public Grammar_2_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGrammar().ele22Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_2_2_1_Assignment_usedGrammars(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_2_2_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Grammar_2_2_0_Keyword extends KeywordToken  {
	
	public Grammar_2_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prGrammar().ele220KeywordComma();
	}	
}

// not supported
protected class Grammar_2_2_1_Assignment_usedGrammars extends AssignmentToken  {
	
	public Grammar_2_2_1_Assignment_usedGrammars(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGrammar().ele221AssignmentUsedGrammars();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("usedGrammars",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("usedGrammars");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prGrammar().ele2210CrossReferenceEStringGrammar().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prGrammar().ele2210CrossReferenceEStringGrammar(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}



// not supported
protected class Grammar_3_Group extends GroupToken {
	
	public Grammar_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGrammar().ele3Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_3_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_3_2_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Grammar_3_1_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new Grammar_3_0_Assignment_definesHiddenTokens(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Grammar_3_0_Assignment_definesHiddenTokens extends AssignmentToken  {
	
	public Grammar_3_0_Assignment_definesHiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGrammar().ele30AssignmentDefinesHiddenTokens();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("definesHiddenTokens",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("definesHiddenTokens");

		if(Boolean.TRUE.equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prGrammar().ele300KeywordHidden();
			return new Solution(obj);
		}

		return null;
	}
}

// not supported
protected class Grammar_3_1_Keyword extends KeywordToken  {
	
	public Grammar_3_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prGrammar().ele31KeywordLeftParenthesis();
	}	
}

// not supported
protected class Grammar_3_2_Group extends GroupToken {
	
	public Grammar_3_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGrammar().ele32Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_3_2_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_3_2_0_Assignment_hiddenTokens(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Grammar_3_2_0_Assignment_hiddenTokens extends AssignmentToken  {
	
	public Grammar_3_2_0_Assignment_hiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGrammar().ele320AssignmentHiddenTokens();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("hiddenTokens",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prGrammar().ele3200CrossReferenceEStringAbstractRule().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prGrammar().ele3200CrossReferenceEStringAbstractRule(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class Grammar_3_2_1_Group extends GroupToken {
	
	public Grammar_3_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGrammar().ele321Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_3_2_1_1_Assignment_hiddenTokens(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_3_2_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Grammar_3_2_1_0_Keyword extends KeywordToken  {
	
	public Grammar_3_2_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prGrammar().ele3210KeywordComma();
	}	
}

// not supported
protected class Grammar_3_2_1_1_Assignment_hiddenTokens extends AssignmentToken  {
	
	public Grammar_3_2_1_1_Assignment_hiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGrammar().ele3211AssignmentHiddenTokens();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("hiddenTokens",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prGrammar().ele32110CrossReferenceEStringAbstractRule().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prGrammar().ele32110CrossReferenceEStringAbstractRule(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}



// not supported
protected class Grammar_3_3_Keyword extends KeywordToken  {
	
	public Grammar_3_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prGrammar().ele33KeywordRightParenthesis();
	}	
}


// not supported
protected class Grammar_4_Assignment_metamodelDeclarations extends AssignmentToken  {
	
	public Grammar_4_Assignment_metamodelDeclarations(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGrammar().ele4AssignmentMetamodelDeclarations();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("metamodelDeclarations",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("metamodelDeclarations");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAbstractMetamodelDeclaration().getRule().getType().getType())) {
				Solution s = new AbstractMetamodelDeclaration_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class Grammar_5_Assignment_rules extends AssignmentToken  {
	
	public Grammar_5_Assignment_rules(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGrammar().ele5AssignmentRules();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rules",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rules");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAbstractRule().getRule().getType().getType())) {
				Solution s = new AbstractRule_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule Grammar ****************/



/************ begin Rule AbstractRule ****************
 *
 * not supported
 *
 **/


// not supported
protected class AbstractRule_Alternatives extends AlternativesToken {

	public AbstractRule_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prAbstractRule().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractRule_0_RuleCall_ParserRule(current, this);
			case 1: return new AbstractRule_1_RuleCall_TerminalRule(current, this);
			default: return null;
		}
	}
}

// not supported
protected class AbstractRule_0_RuleCall_ParserRule extends RuleCallToken {
	
	public AbstractRule_0_RuleCall_ParserRule(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractRule().ele0ParserRuleCallParserRule();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ParserRule_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prParserRule().getRule().getType().getType())) return null;
		return new ParserRule_Group(current, this).firstSolution();
	}
}

// not supported
protected class AbstractRule_1_RuleCall_TerminalRule extends RuleCallToken {
	
	public AbstractRule_1_RuleCall_TerminalRule(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractRule().ele1ParserRuleCallTerminalRule();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TerminalRule_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prTerminalRule().getRule().getType().getType())) return null;
		return new TerminalRule_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractRule ****************/


/************ begin Rule AbstractMetamodelDeclaration ****************
 *
 * not supported
 *
 **/


// not supported
protected class AbstractMetamodelDeclaration_Alternatives extends AlternativesToken {

	public AbstractMetamodelDeclaration_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prAbstractMetamodelDeclaration().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractMetamodelDeclaration_0_RuleCall_GeneratedMetamodel(current, this);
			case 1: return new AbstractMetamodelDeclaration_1_RuleCall_ReferencedMetamodel(current, this);
			default: return null;
		}
	}
}

// not supported
protected class AbstractMetamodelDeclaration_0_RuleCall_GeneratedMetamodel extends RuleCallToken {
	
	public AbstractMetamodelDeclaration_0_RuleCall_GeneratedMetamodel(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractMetamodelDeclaration().ele0ParserRuleCallGeneratedMetamodel();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(GeneratedMetamodel_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prGeneratedMetamodel().getRule().getType().getType())) return null;
		return new GeneratedMetamodel_Group(current, this).firstSolution();
	}
}

// not supported
protected class AbstractMetamodelDeclaration_1_RuleCall_ReferencedMetamodel extends RuleCallToken {
	
	public AbstractMetamodelDeclaration_1_RuleCall_ReferencedMetamodel(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractMetamodelDeclaration().ele1ParserRuleCallReferencedMetamodel();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ReferencedMetamodel_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prReferencedMetamodel().getRule().getType().getType())) return null;
		return new ReferencedMetamodel_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractMetamodelDeclaration ****************/


/************ begin Rule GeneratedMetamodel ****************
 *
 * not supported
 *
 **/


// not supported
protected class GeneratedMetamodel_Group extends GroupToken {
	
	public GeneratedMetamodel_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGeneratedMetamodel().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new GeneratedMetamodel_3_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new GeneratedMetamodel_2_Assignment_ePackage(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new GeneratedMetamodel_1_Assignment_name(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new GeneratedMetamodel_0_Keyword_generate(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class GeneratedMetamodel_0_Keyword_generate extends KeywordToken  {
	
	public GeneratedMetamodel_0_Keyword_generate(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prGeneratedMetamodel().ele0KeywordGenerate();
	}	
}

// not supported
protected class GeneratedMetamodel_1_Assignment_name extends AssignmentToken  {
	
	public GeneratedMetamodel_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGeneratedMetamodel().ele1AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prGeneratedMetamodel().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class GeneratedMetamodel_2_Assignment_ePackage extends AssignmentToken  {
	
	public GeneratedMetamodel_2_Assignment_ePackage(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGeneratedMetamodel().ele2AssignmentEPackage();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("ePackage",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ePackage");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prGeneratedMetamodel().ele20CrossReferenceEStringEPackage().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prGeneratedMetamodel().ele20CrossReferenceEStringEPackage(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class GeneratedMetamodel_3_Group extends GroupToken {
	
	public GeneratedMetamodel_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGeneratedMetamodel().ele3Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new GeneratedMetamodel_3_1_Assignment_alias(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new GeneratedMetamodel_3_0_Keyword_as(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class GeneratedMetamodel_3_0_Keyword_as extends KeywordToken  {
	
	public GeneratedMetamodel_3_0_Keyword_as(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prGeneratedMetamodel().ele30KeywordAs();
	}	
}

// not supported
protected class GeneratedMetamodel_3_1_Assignment_alias extends AssignmentToken  {
	
	public GeneratedMetamodel_3_1_Assignment_alias(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGeneratedMetamodel().ele31AssignmentAlias();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("alias",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prGeneratedMetamodel().ele310TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule GeneratedMetamodel ****************/


/************ begin Rule ReferencedMetamodel ****************
 *
 * not supported
 *
 **/


// not supported
protected class ReferencedMetamodel_Group extends GroupToken {
	
	public ReferencedMetamodel_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prReferencedMetamodel().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ReferencedMetamodel_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ReferencedMetamodel_1_Assignment_ePackage(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ReferencedMetamodel_0_Keyword_import(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ReferencedMetamodel_0_Keyword_import extends KeywordToken  {
	
	public ReferencedMetamodel_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prReferencedMetamodel().ele0KeywordImport();
	}	
}

// not supported
protected class ReferencedMetamodel_1_Assignment_ePackage extends AssignmentToken  {
	
	public ReferencedMetamodel_1_Assignment_ePackage(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prReferencedMetamodel().ele1AssignmentEPackage();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("ePackage",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ePackage");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prReferencedMetamodel().ele10CrossReferenceEStringEPackage().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prReferencedMetamodel().ele10CrossReferenceEStringEPackage(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class ReferencedMetamodel_2_Group extends GroupToken {
	
	public ReferencedMetamodel_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prReferencedMetamodel().ele2Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ReferencedMetamodel_2_1_Assignment_alias(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ReferencedMetamodel_2_0_Keyword_as(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class ReferencedMetamodel_2_0_Keyword_as extends KeywordToken  {
	
	public ReferencedMetamodel_2_0_Keyword_as(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prReferencedMetamodel().ele20KeywordAs();
	}	
}

// not supported
protected class ReferencedMetamodel_2_1_Assignment_alias extends AssignmentToken  {
	
	public ReferencedMetamodel_2_1_Assignment_alias(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prReferencedMetamodel().ele21AssignmentAlias();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("alias",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prReferencedMetamodel().ele210TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule ReferencedMetamodel ****************/


/************ begin Rule ParserRule ****************
 *
 * not supported
 *
 **/


// not supported
protected class ParserRule_Group extends GroupToken {
	
	public ParserRule_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prParserRule().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParserRule_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParserRule_4_Assignment_alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ParserRule_3_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new ParserRule_2_Group(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new ParserRule_1_Group(s4.getCurrent(), s4.getPredecessor()).firstSolution();
		while(s5 != null) {
			Solution s6 = new ParserRule_0_Assignment_name(s5.getCurrent(), s5.getPredecessor()).firstSolution();
			if(s6 != null) {
				last = s6.getPredecessor();
				return s6;
			} else {
				s5 = s5.getPredecessor().nextSolution(this,s5);
			}
		}
			s4 = s4.getPredecessor().nextSolution(this,s4);
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ParserRule_0_Assignment_name extends AssignmentToken  {
	
	public ParserRule_0_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prParserRule().ele0AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prParserRule().ele00TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class ParserRule_1_Group extends GroupToken {
	
	public ParserRule_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prParserRule().ele1Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParserRule_1_1_Assignment_type(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParserRule_1_0_Keyword_returns(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class ParserRule_1_0_Keyword_returns extends KeywordToken  {
	
	public ParserRule_1_0_Keyword_returns(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParserRule().ele10KeywordReturns();
	}	
}

// not supported
protected class ParserRule_1_1_Assignment_type extends AssignmentToken  {
	
	public ParserRule_1_1_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prParserRule().ele11AssignmentType();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTypeRef().getRule().getType().getType())) {
				Solution s = new TypeRef_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class ParserRule_2_Group extends GroupToken {
	
	public ParserRule_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prParserRule().ele2Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParserRule_2_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParserRule_2_2_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ParserRule_2_1_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new ParserRule_2_0_Assignment_definesHiddenTokens(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ParserRule_2_0_Assignment_definesHiddenTokens extends AssignmentToken  {
	
	public ParserRule_2_0_Assignment_definesHiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prParserRule().ele20AssignmentDefinesHiddenTokens();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("definesHiddenTokens",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("definesHiddenTokens");

		if(Boolean.TRUE.equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prParserRule().ele200KeywordHidden();
			return new Solution(obj);
		}

		return null;
	}
}

// not supported
protected class ParserRule_2_1_Keyword extends KeywordToken  {
	
	public ParserRule_2_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParserRule().ele21KeywordLeftParenthesis();
	}	
}

// not supported
protected class ParserRule_2_2_Group extends GroupToken {
	
	public ParserRule_2_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prParserRule().ele22Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParserRule_2_2_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParserRule_2_2_0_Assignment_hiddenTokens(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class ParserRule_2_2_0_Assignment_hiddenTokens extends AssignmentToken  {
	
	public ParserRule_2_2_0_Assignment_hiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prParserRule().ele220AssignmentHiddenTokens();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("hiddenTokens",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prParserRule().ele2200CrossReferenceEStringAbstractRule().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prParserRule().ele2200CrossReferenceEStringAbstractRule(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class ParserRule_2_2_1_Group extends GroupToken {
	
	public ParserRule_2_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prParserRule().ele221Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParserRule_2_2_1_1_Assignment_hiddenTokens(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParserRule_2_2_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class ParserRule_2_2_1_0_Keyword extends KeywordToken  {
	
	public ParserRule_2_2_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParserRule().ele2210KeywordComma();
	}	
}

// not supported
protected class ParserRule_2_2_1_1_Assignment_hiddenTokens extends AssignmentToken  {
	
	public ParserRule_2_2_1_1_Assignment_hiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prParserRule().ele2211AssignmentHiddenTokens();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("hiddenTokens",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prParserRule().ele22110CrossReferenceEStringAbstractRule().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prParserRule().ele22110CrossReferenceEStringAbstractRule(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}



// not supported
protected class ParserRule_2_3_Keyword extends KeywordToken  {
	
	public ParserRule_2_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParserRule().ele23KeywordRightParenthesis();
	}	
}


// not supported
protected class ParserRule_3_Keyword extends KeywordToken  {
	
	public ParserRule_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParserRule().ele3KeywordColon();
	}	
}

// not supported
protected class ParserRule_4_Assignment_alternatives extends AssignmentToken  {
	
	public ParserRule_4_Assignment_alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prParserRule().ele4AssignmentAlternatives();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("alternatives",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alternatives");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAlternatives().getRule().getType().getType())) {
				Solution s = new Alternatives_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class ParserRule_5_Keyword extends KeywordToken  {
	
	public ParserRule_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParserRule().ele5KeywordSemicolon();
	}	
}


/************ end Rule ParserRule ****************/


/************ begin Rule TerminalRule ****************
 *
 * not supported
 *
 **/


// not supported
protected class TerminalRule_Group extends GroupToken {
	
	public TerminalRule_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTerminalRule().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalRule_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalRule_4_Assignment_alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new TerminalRule_3_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new TerminalRule_2_Group(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new TerminalRule_1_Assignment_name(s4.getCurrent(), s4.getPredecessor()).firstSolution();
		while(s5 != null) {
			Solution s6 = new TerminalRule_0_Keyword_terminal(s5.getCurrent(), s5.getPredecessor()).firstSolution();
			if(s6 != null) {
				last = s6.getPredecessor();
				return s6;
			} else {
				s5 = s5.getPredecessor().nextSolution(this,s5);
			}
		}
			s4 = s4.getPredecessor().nextSolution(this,s4);
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class TerminalRule_0_Keyword_terminal extends KeywordToken  {
	
	public TerminalRule_0_Keyword_terminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prTerminalRule().ele0KeywordTerminal();
	}	
}

// not supported
protected class TerminalRule_1_Assignment_name extends AssignmentToken  {
	
	public TerminalRule_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prTerminalRule().ele1AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prTerminalRule().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class TerminalRule_2_Group extends GroupToken {
	
	public TerminalRule_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTerminalRule().ele2Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalRule_2_1_Assignment_type(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalRule_2_0_Keyword_returns(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class TerminalRule_2_0_Keyword_returns extends KeywordToken  {
	
	public TerminalRule_2_0_Keyword_returns(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prTerminalRule().ele20KeywordReturns();
	}	
}

// not supported
protected class TerminalRule_2_1_Assignment_type extends AssignmentToken  {
	
	public TerminalRule_2_1_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prTerminalRule().ele21AssignmentType();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTypeRef().getRule().getType().getType())) {
				Solution s = new TypeRef_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class TerminalRule_3_Keyword extends KeywordToken  {
	
	public TerminalRule_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prTerminalRule().ele3KeywordColon();
	}	
}

// not supported
protected class TerminalRule_4_Assignment_alternatives extends AssignmentToken  {
	
	public TerminalRule_4_Assignment_alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prTerminalRule().ele4AssignmentAlternatives();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("alternatives",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alternatives");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTerminalAlternatives().getRule().getType().getType())) {
				Solution s = new TerminalAlternatives_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class TerminalRule_5_Keyword extends KeywordToken  {
	
	public TerminalRule_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prTerminalRule().ele5KeywordSemicolon();
	}	
}


/************ end Rule TerminalRule ****************/


/************ begin Rule TypeRef ****************
 *
 * not supported
 *
 **/


// not supported
protected class TypeRef_Group extends GroupToken {
	
	public TypeRef_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTypeRef().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TypeRef_1_Assignment_type(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TypeRef_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class TypeRef_0_Group extends GroupToken {
	
	public TypeRef_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTypeRef().ele0Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TypeRef_0_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TypeRef_0_0_Assignment_metamodel(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class TypeRef_0_0_Assignment_metamodel extends AssignmentToken  {
	
	public TypeRef_0_0_Assignment_metamodel(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prTypeRef().ele00AssignmentMetamodel();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("metamodel",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("metamodel");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTypeRef().ele000CrossReferenceEStringAbstractMetamodelDeclaration().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prTypeRef().ele000CrossReferenceEStringAbstractMetamodelDeclaration(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class TypeRef_0_1_Keyword extends KeywordToken  {
	
	public TypeRef_0_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prTypeRef().ele01KeywordColonColon();
	}	
}


// not supported
protected class TypeRef_1_Assignment_type extends AssignmentToken  {
	
	public TypeRef_1_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prTypeRef().ele1AssignmentType();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTypeRef().ele10CrossReferenceEStringEClassifier().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prTypeRef().ele10CrossReferenceEStringEClassifier(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}


/************ end Rule TypeRef ****************/


/************ begin Rule Alternatives ****************
 *
 * not supported
 *
 **/


// not supported
protected class Alternatives_Group extends GroupToken {
	
	public Alternatives_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAlternatives().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Alternatives_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Alternatives_0_RuleCall_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Alternatives_0_RuleCall_Group extends RuleCallToken {
	
	public Alternatives_0_RuleCall_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAlternatives().ele0ParserRuleCallGroup();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Group_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prGroup().getRule().getType().getType())) return null;
		return new Group_Group(current, this).firstSolution();
	}
}

// not supported
protected class Alternatives_1_Group extends GroupToken {
	
	public Alternatives_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAlternatives().ele1Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Alternatives_1_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Alternatives_1_0_Action_Alternatives_groups(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Alternatives_1_0_Action_Alternatives_groups extends ActionToken  {

	public Alternatives_1_0_Action_Alternatives_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.prAlternatives().ele10ActionAlternativesgroups();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.prAlternatives().ele10ActionAlternativesgroups().getTypeName().getType())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// not supported
protected class Alternatives_1_1_Group extends GroupToken {
	
	public Alternatives_1_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAlternatives().ele11Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Alternatives_1_1_1_Assignment_groups(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Alternatives_1_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Alternatives_1_1_0_Keyword extends KeywordToken  {
	
	public Alternatives_1_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAlternatives().ele110KeywordVerticalLine();
	}	
}

// not supported
protected class Alternatives_1_1_1_Assignment_groups extends AssignmentToken  {
	
	public Alternatives_1_1_1_Assignment_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAlternatives().ele111AssignmentGroups();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("groups",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prGroup().getRule().getType().getType())) {
				Solution s = new Group_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}




/************ end Rule Alternatives ****************/


/************ begin Rule TerminalAlternatives ****************
 *
 * not supported
 *
 **/


// not supported
protected class TerminalAlternatives_Group extends GroupToken {
	
	public TerminalAlternatives_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTerminalAlternatives().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalAlternatives_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalAlternatives_0_RuleCall_TerminalGroup(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class TerminalAlternatives_0_RuleCall_TerminalGroup extends RuleCallToken {
	
	public TerminalAlternatives_0_RuleCall_TerminalGroup(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerminalAlternatives().ele0ParserRuleCallTerminalGroup();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TerminalGroup_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prTerminalGroup().getRule().getType().getType())) return null;
		return new TerminalGroup_Group(current, this).firstSolution();
	}
}

// not supported
protected class TerminalAlternatives_1_Group extends GroupToken {
	
	public TerminalAlternatives_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTerminalAlternatives().ele1Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalAlternatives_1_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalAlternatives_1_0_Action_Alternatives_groups(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class TerminalAlternatives_1_0_Action_Alternatives_groups extends ActionToken  {

	public TerminalAlternatives_1_0_Action_Alternatives_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.prTerminalAlternatives().ele10ActionAlternativesgroups();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.prTerminalAlternatives().ele10ActionAlternativesgroups().getTypeName().getType())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// not supported
protected class TerminalAlternatives_1_1_Group extends GroupToken {
	
	public TerminalAlternatives_1_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTerminalAlternatives().ele11Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalAlternatives_1_1_1_Assignment_groups(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalAlternatives_1_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class TerminalAlternatives_1_1_0_Keyword extends KeywordToken  {
	
	public TerminalAlternatives_1_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prTerminalAlternatives().ele110KeywordVerticalLine();
	}	
}

// not supported
protected class TerminalAlternatives_1_1_1_Assignment_groups extends AssignmentToken  {
	
	public TerminalAlternatives_1_1_1_Assignment_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prTerminalAlternatives().ele111AssignmentGroups();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("groups",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTerminalGroup().getRule().getType().getType())) {
				Solution s = new TerminalGroup_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}




/************ end Rule TerminalAlternatives ****************/


/************ begin Rule Group ****************
 *
 * not supported
 *
 **/


// not supported
protected class Group_Group extends GroupToken {
	
	public Group_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGroup().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Group_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Group_0_RuleCall_AbstractToken(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Group_0_RuleCall_AbstractToken extends RuleCallToken {
	
	public Group_0_RuleCall_AbstractToken(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prGroup().ele0ParserRuleCallAbstractToken();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AbstractToken_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prAbstractToken().getRule().getType().getType())) return null;
		return new AbstractToken_Group(current, this).firstSolution();
	}
}

// not supported
protected class Group_1_Group extends GroupToken {
	
	public Group_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prGroup().ele1Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Group_1_1_Assignment_abstractTokens(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Group_1_0_Action_Group_abstractTokens(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Group_1_0_Action_Group_abstractTokens extends ActionToken  {

	public Group_1_0_Action_Group_abstractTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.prGroup().ele10ActionGroupabstractTokens();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.prGroup().ele10ActionGroupabstractTokens().getTypeName().getType())) return null;
		Object val = current.getConsumable("abstractTokens", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("abstractTokens")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// not supported
protected class Group_1_1_Assignment_abstractTokens extends AssignmentToken  {
	
	public Group_1_1_Assignment_abstractTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prGroup().ele11AssignmentAbstractTokens();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("abstractTokens",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("abstractTokens");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAbstractToken().getRule().getType().getType())) {
				Solution s = new AbstractToken_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



/************ end Rule Group ****************/


/************ begin Rule TerminalGroup ****************
 *
 * not supported
 *
 **/


// not supported
protected class TerminalGroup_Group extends GroupToken {
	
	public TerminalGroup_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTerminalGroup().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalGroup_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalGroup_0_RuleCall_TerminalToken(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class TerminalGroup_0_RuleCall_TerminalToken extends RuleCallToken {
	
	public TerminalGroup_0_RuleCall_TerminalToken(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerminalGroup().ele0ParserRuleCallTerminalToken();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TerminalToken_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prTerminalToken().getRule().getType().getType())) return null;
		return new TerminalToken_Group(current, this).firstSolution();
	}
}

// not supported
protected class TerminalGroup_1_Group extends GroupToken {
	
	public TerminalGroup_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTerminalGroup().ele1Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalGroup_1_1_Assignment_abstractTokens(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalGroup_1_0_Action_Group_abstractTokens(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class TerminalGroup_1_0_Action_Group_abstractTokens extends ActionToken  {

	public TerminalGroup_1_0_Action_Group_abstractTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.prTerminalGroup().ele10ActionGroupabstractTokens();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.prTerminalGroup().ele10ActionGroupabstractTokens().getTypeName().getType())) return null;
		Object val = current.getConsumable("abstractTokens", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("abstractTokens")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// not supported
protected class TerminalGroup_1_1_Assignment_abstractTokens extends AssignmentToken  {
	
	public TerminalGroup_1_1_Assignment_abstractTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prTerminalGroup().ele11AssignmentAbstractTokens();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("abstractTokens",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("abstractTokens");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTerminalToken().getRule().getType().getType())) {
				Solution s = new TerminalToken_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



/************ end Rule TerminalGroup ****************/


/************ begin Rule AbstractToken ****************
 *
 * not supported
 *
 **/


// not supported
protected class AbstractToken_Group extends GroupToken {
	
	public AbstractToken_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAbstractToken().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AbstractToken_1_Assignment_cardinality(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AbstractToken_0_Alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class AbstractToken_0_Alternatives extends AlternativesToken {

	public AbstractToken_0_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prAbstractToken().ele0Alternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractToken_0_0_RuleCall_Assignment(current, this);
			case 1: return new AbstractToken_0_1_RuleCall_Action(current, this);
			case 2: return new AbstractToken_0_2_RuleCall_AbstractTerminal(current, this);
			default: return null;
		}
	}
}

// not supported
protected class AbstractToken_0_0_RuleCall_Assignment extends RuleCallToken {
	
	public AbstractToken_0_0_RuleCall_Assignment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractToken().ele00ParserRuleCallAssignment();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Assignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prAssignment().getRule().getType().getType())) return null;
		return new Assignment_Group(current, this).firstSolution();
	}
}

// not supported
protected class AbstractToken_0_1_RuleCall_Action extends RuleCallToken {
	
	public AbstractToken_0_1_RuleCall_Action(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractToken().ele01ParserRuleCallAction();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Action_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prAction().getRule().getType().getType())) return null;
		return new Action_Group(current, this).firstSolution();
	}
}

// not supported
protected class AbstractToken_0_2_RuleCall_AbstractTerminal extends RuleCallToken {
	
	public AbstractToken_0_2_RuleCall_AbstractTerminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractToken().ele02ParserRuleCallAbstractTerminal();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AbstractTerminal_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prAbstractTerminal().getRule().getType().getType())) return null;
		return new AbstractTerminal_Alternatives(current, this).firstSolution();
	}
}


// not supported
protected class AbstractToken_1_Assignment_cardinality extends AssignmentToken  {
	
	public AbstractToken_1_Assignment_cardinality(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAbstractToken().ele1AssignmentCardinality();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("cardinality",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("cardinality");

		if("?".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prAbstractToken().ele100KeywordQuestionMark();
			return new Solution(obj);
		}


		if("*".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prAbstractToken().ele101KeywordAsterisk();
			return new Solution(obj);
		}


		if("+".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prAbstractToken().ele102KeywordPlusSign();
			return new Solution(obj);
		}

		return null;
	}
}


/************ end Rule AbstractToken ****************/


/************ begin Rule TerminalToken ****************
 *
 * not supported
 *
 **/


// not supported
protected class TerminalToken_Group extends GroupToken {
	
	public TerminalToken_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prTerminalToken().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalToken_1_Assignment_cardinality(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalToken_0_RuleCall_TerminalTokenElement(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class TerminalToken_0_RuleCall_TerminalTokenElement extends RuleCallToken {
	
	public TerminalToken_0_RuleCall_TerminalTokenElement(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerminalToken().ele0ParserRuleCallTerminalTokenElement();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TerminalTokenElement_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prTerminalTokenElement().getRule().getType().getType())) return null;
		return new TerminalTokenElement_Alternatives(current, this).firstSolution();
	}
}

// not supported
protected class TerminalToken_1_Assignment_cardinality extends AssignmentToken  {
	
	public TerminalToken_1_Assignment_cardinality(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prTerminalToken().ele1AssignmentCardinality();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("cardinality",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("cardinality");

		if("?".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prTerminalToken().ele100KeywordQuestionMark();
			return new Solution(obj);
		}


		if("*".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prTerminalToken().ele101KeywordAsterisk();
			return new Solution(obj);
		}


		if("+".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prTerminalToken().ele102KeywordPlusSign();
			return new Solution(obj);
		}

		return null;
	}
}


/************ end Rule TerminalToken ****************/


/************ begin Rule Assignment ****************
 *
 * not supported
 *
 **/


// not supported
protected class Assignment_Group extends GroupToken {
	
	public Assignment_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAssignment().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Assignment_2_Assignment_terminal(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Assignment_1_Assignment_operator(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Assignment_0_Assignment_feature(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Assignment_0_Assignment_feature extends AssignmentToken  {
	
	public Assignment_0_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignment().ele0AssignmentFeature();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prAssignment().ele00TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class Assignment_1_Assignment_operator extends AssignmentToken  {
	
	public Assignment_1_Assignment_operator(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignment().ele1AssignmentOperator();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("operator",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");

		if("+=".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prAssignment().ele100KeywordPlusSignEqualsSign();
			return new Solution(obj);
		}


		if("=".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prAssignment().ele101KeywordEqualsSign();
			return new Solution(obj);
		}


		if("?=".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prAssignment().ele102KeywordQuestionMarkEqualsSign();
			return new Solution(obj);
		}

		return null;
	}
}

// not supported
protected class Assignment_2_Assignment_terminal extends AssignmentToken  {
	
	public Assignment_2_Assignment_terminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignment().ele2AssignmentTerminal();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("terminal",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("terminal");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAbstractTerminal().getRule().getType().getType())) {
				Solution s = new AbstractTerminal_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule Assignment ****************/


/************ begin Rule Action ****************
 *
 * not supported
 *
 **/


// not supported
protected class Action_Group extends GroupToken {
	
	public Action_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAction().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Action_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Action_2_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Action_1_Assignment_typeName(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new Action_0_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Action_0_Keyword extends KeywordToken  {
	
	public Action_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAction().ele0KeywordLeftCurlyBracket();
	}	
}

// not supported
protected class Action_1_Assignment_typeName extends AssignmentToken  {
	
	public Action_1_Assignment_typeName(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAction().ele1AssignmentTypeName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("typeName",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("typeName");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTypeRef().getRule().getType().getType())) {
				Solution s = new TypeRef_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class Action_2_Group extends GroupToken {
	
	public Action_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAction().ele2Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Action_2_3_Keyword_current(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Action_2_2_Assignment_operator(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Action_2_1_Assignment_feature(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new Action_2_0_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Action_2_0_Keyword extends KeywordToken  {
	
	public Action_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAction().ele20KeywordFullStop();
	}	
}

// not supported
protected class Action_2_1_Assignment_feature extends AssignmentToken  {
	
	public Action_2_1_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAction().ele21AssignmentFeature();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prAction().ele210TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class Action_2_2_Assignment_operator extends AssignmentToken  {
	
	public Action_2_2_Assignment_operator(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAction().ele22AssignmentOperator();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("operator",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");

		if("=".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prAction().ele2200KeywordEqualsSign();
			return new Solution(obj);
		}


		if("+=".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prAction().ele2201KeywordPlusSignEqualsSign();
			return new Solution(obj);
		}

		return null;
	}
}

// not supported
protected class Action_2_3_Keyword_current extends KeywordToken  {
	
	public Action_2_3_Keyword_current(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAction().ele23KeywordCurrent();
	}	
}


// not supported
protected class Action_3_Keyword extends KeywordToken  {
	
	public Action_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAction().ele3KeywordRightCurlyBracket();
	}	
}


/************ end Rule Action ****************/


/************ begin Rule AbstractTerminal ****************
 *
 * not supported
 *
 **/


// not supported
protected class AbstractTerminal_Alternatives extends AlternativesToken {

	public AbstractTerminal_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prAbstractTerminal().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractTerminal_0_RuleCall_Keyword(current, this);
			case 1: return new AbstractTerminal_1_RuleCall_RuleCall(current, this);
			case 2: return new AbstractTerminal_2_RuleCall_ParenthesizedElement(current, this);
			case 3: return new AbstractTerminal_3_RuleCall_CrossReference(current, this);
			default: return null;
		}
	}
}

// not supported
protected class AbstractTerminal_0_RuleCall_Keyword extends RuleCallToken {
	
	public AbstractTerminal_0_RuleCall_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractTerminal().ele0ParserRuleCallKeyword();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Keyword_Assignment_value.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prKeyword().getRule().getType().getType())) return null;
		return new Keyword_Assignment_value(current, this).firstSolution();
	}
}

// not supported
protected class AbstractTerminal_1_RuleCall_RuleCall extends RuleCallToken {
	
	public AbstractTerminal_1_RuleCall_RuleCall(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractTerminal().ele1ParserRuleCallRuleCall();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(RuleCall_Assignment_rule.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prRuleCall().getRule().getType().getType())) return null;
		return new RuleCall_Assignment_rule(current, this).firstSolution();
	}
}

// not supported
protected class AbstractTerminal_2_RuleCall_ParenthesizedElement extends RuleCallToken {
	
	public AbstractTerminal_2_RuleCall_ParenthesizedElement(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractTerminal().ele2ParserRuleCallParenthesizedElement();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ParenthesizedElement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prParenthesizedElement().getRule().getType().getType())) return null;
		return new ParenthesizedElement_Group(current, this).firstSolution();
	}
}

// not supported
protected class AbstractTerminal_3_RuleCall_CrossReference extends RuleCallToken {
	
	public AbstractTerminal_3_RuleCall_CrossReference(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractTerminal().ele3ParserRuleCallCrossReference();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(CrossReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prCrossReference().getRule().getType().getType())) return null;
		return new CrossReference_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractTerminal ****************/


/************ begin Rule TerminalTokenElement ****************
 *
 * not supported
 *
 **/


// not supported
protected class TerminalTokenElement_Alternatives extends AlternativesToken {

	public TerminalTokenElement_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prTerminalTokenElement().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new TerminalTokenElement_0_RuleCall_CharacterRange(current, this);
			case 1: return new TerminalTokenElement_1_RuleCall_RuleCall(current, this);
			case 2: return new TerminalTokenElement_2_RuleCall_ParenthesizedTerminalElement(current, this);
			case 3: return new TerminalTokenElement_3_RuleCall_AbstractNegatedToken(current, this);
			case 4: return new TerminalTokenElement_4_RuleCall_Wildcard(current, this);
			default: return null;
		}
	}
}

// not supported
protected class TerminalTokenElement_0_RuleCall_CharacterRange extends RuleCallToken {
	
	public TerminalTokenElement_0_RuleCall_CharacterRange(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerminalTokenElement().ele0ParserRuleCallCharacterRange();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(CharacterRange_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prCharacterRange().getRule().getType().getType())) return null;
		return new CharacterRange_Group(current, this).firstSolution();
	}
}

// not supported
protected class TerminalTokenElement_1_RuleCall_RuleCall extends RuleCallToken {
	
	public TerminalTokenElement_1_RuleCall_RuleCall(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerminalTokenElement().ele1ParserRuleCallRuleCall();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(RuleCall_Assignment_rule.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prRuleCall().getRule().getType().getType())) return null;
		return new RuleCall_Assignment_rule(current, this).firstSolution();
	}
}

// not supported
protected class TerminalTokenElement_2_RuleCall_ParenthesizedTerminalElement extends RuleCallToken {
	
	public TerminalTokenElement_2_RuleCall_ParenthesizedTerminalElement(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerminalTokenElement().ele2ParserRuleCallParenthesizedTerminalElement();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ParenthesizedTerminalElement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prParenthesizedTerminalElement().getRule().getType().getType())) return null;
		return new ParenthesizedTerminalElement_Group(current, this).firstSolution();
	}
}

// not supported
protected class TerminalTokenElement_3_RuleCall_AbstractNegatedToken extends RuleCallToken {
	
	public TerminalTokenElement_3_RuleCall_AbstractNegatedToken(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerminalTokenElement().ele3ParserRuleCallAbstractNegatedToken();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AbstractNegatedToken_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prAbstractNegatedToken().getRule().getType().getType())) return null;
		return new AbstractNegatedToken_Alternatives(current, this).firstSolution();
	}
}

// not supported
protected class TerminalTokenElement_4_RuleCall_Wildcard extends RuleCallToken {
	
	public TerminalTokenElement_4_RuleCall_Wildcard(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prTerminalTokenElement().ele4ParserRuleCallWildcard();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Wildcard_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prWildcard().getRule().getType().getType())) return null;
		return new Wildcard_Group(current, this).firstSolution();
	}
}


/************ end Rule TerminalTokenElement ****************/


/************ begin Rule AbstractNegatedToken ****************
 *
 * not supported
 *
 **/


// not supported
protected class AbstractNegatedToken_Alternatives extends AlternativesToken {

	public AbstractNegatedToken_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prAbstractNegatedToken().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractNegatedToken_0_RuleCall_NegatedToken(current, this);
			case 1: return new AbstractNegatedToken_1_RuleCall_UntilToken(current, this);
			default: return null;
		}
	}
}

// not supported
protected class AbstractNegatedToken_0_RuleCall_NegatedToken extends RuleCallToken {
	
	public AbstractNegatedToken_0_RuleCall_NegatedToken(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractNegatedToken().ele0ParserRuleCallNegatedToken();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(NegatedToken_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prNegatedToken().getRule().getType().getType())) return null;
		return new NegatedToken_Group(current, this).firstSolution();
	}
}

// not supported
protected class AbstractNegatedToken_1_RuleCall_UntilToken extends RuleCallToken {
	
	public AbstractNegatedToken_1_RuleCall_UntilToken(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractNegatedToken().ele1ParserRuleCallUntilToken();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(UntilToken_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prUntilToken().getRule().getType().getType())) return null;
		return new UntilToken_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractNegatedToken ****************/


/************ begin Rule NegatedToken ****************
 *
 * not supported
 *
 **/


// not supported
protected class NegatedToken_Group extends GroupToken {
	
	public NegatedToken_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prNegatedToken().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new NegatedToken_1_Assignment_terminal(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new NegatedToken_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class NegatedToken_0_Keyword extends KeywordToken  {
	
	public NegatedToken_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNegatedToken().ele0KeywordExclamationMark();
	}	
}

// not supported
protected class NegatedToken_1_Assignment_terminal extends AssignmentToken  {
	
	public NegatedToken_1_Assignment_terminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prNegatedToken().ele1AssignmentTerminal();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("terminal",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("terminal");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTerminalTokenElement().getRule().getType().getType())) {
				Solution s = new TerminalTokenElement_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule NegatedToken ****************/


/************ begin Rule UntilToken ****************
 *
 * not supported
 *
 **/


// not supported
protected class UntilToken_Group extends GroupToken {
	
	public UntilToken_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prUntilToken().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new UntilToken_1_Assignment_terminal(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new UntilToken_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class UntilToken_0_Keyword extends KeywordToken  {
	
	public UntilToken_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prUntilToken().ele0KeywordHyphenMinusGreaterThanSign();
	}	
}

// not supported
protected class UntilToken_1_Assignment_terminal extends AssignmentToken  {
	
	public UntilToken_1_Assignment_terminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prUntilToken().ele1AssignmentTerminal();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("terminal",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("terminal");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTerminalTokenElement().getRule().getType().getType())) {
				Solution s = new TerminalTokenElement_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule UntilToken ****************/


/************ begin Rule Wildcard ****************
 *
 * not supported
 *
 **/


// not supported
protected class Wildcard_Group extends GroupToken {
	
	public Wildcard_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prWildcard().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Wildcard_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Wildcard_0_Action_Wildcard_null(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Wildcard_0_Action_Wildcard_null extends ActionToken  {

	public Wildcard_0_Action_Wildcard_null(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.prWildcard().ele0ActionWildcardnull();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.prWildcard().ele0ActionWildcardnull().getTypeName().getType())) return null;
		Object val = current.getConsumable("", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// not supported
protected class Wildcard_1_Keyword extends KeywordToken  {
	
	public Wildcard_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prWildcard().ele1KeywordFullStop();
	}	
}


/************ end Rule Wildcard ****************/


/************ begin Rule CharacterRange ****************
 *
 * not supported
 *
 **/


// not supported
protected class CharacterRange_Group extends GroupToken {
	
	public CharacterRange_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prCharacterRange().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CharacterRange_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CharacterRange_0_RuleCall_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class CharacterRange_0_RuleCall_Keyword extends RuleCallToken {
	
	public CharacterRange_0_RuleCall_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prCharacterRange().ele0ParserRuleCallKeyword();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Keyword_Assignment_value.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prKeyword().getRule().getType().getType())) return null;
		return new Keyword_Assignment_value(current, this).firstSolution();
	}
}

// not supported
protected class CharacterRange_1_Group extends GroupToken {
	
	public CharacterRange_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prCharacterRange().ele1Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CharacterRange_1_2_Assignment_right(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CharacterRange_1_1_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new CharacterRange_1_0_Action_CharacterRange_left(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class CharacterRange_1_0_Action_CharacterRange_left extends ActionToken  {

	public CharacterRange_1_0_Action_CharacterRange_left(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.prCharacterRange().ele10ActionCharacterRangeleft();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.prCharacterRange().ele10ActionCharacterRangeleft().getTypeName().getType())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// not supported
protected class CharacterRange_1_1_Keyword extends KeywordToken  {
	
	public CharacterRange_1_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prCharacterRange().ele11KeywordFullStopFullStop();
	}	
}

// not supported
protected class CharacterRange_1_2_Assignment_right extends AssignmentToken  {
	
	public CharacterRange_1_2_Assignment_right(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prCharacterRange().ele12AssignmentRight();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("right",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prKeyword().getRule().getType().getType())) {
				Solution s = new Keyword_Assignment_value(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



/************ end Rule CharacterRange ****************/


/************ begin Rule CrossReference ****************
 *
 * not supported
 *
 **/


// not supported
protected class CrossReference_Group extends GroupToken {
	
	public CrossReference_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prCrossReference().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CrossReference_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CrossReference_2_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new CrossReference_1_Assignment_type(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new CrossReference_0_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class CrossReference_0_Keyword extends KeywordToken  {
	
	public CrossReference_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prCrossReference().ele0KeywordLeftSquareBracket();
	}	
}

// not supported
protected class CrossReference_1_Assignment_type extends AssignmentToken  {
	
	public CrossReference_1_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prCrossReference().ele1AssignmentType();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prTypeRef().getRule().getType().getType())) {
				Solution s = new TypeRef_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class CrossReference_2_Group extends GroupToken {
	
	public CrossReference_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prCrossReference().ele2Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CrossReference_2_1_Assignment_rule(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CrossReference_2_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class CrossReference_2_0_Keyword extends KeywordToken  {
	
	public CrossReference_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prCrossReference().ele20KeywordVerticalLine();
	}	
}

// not supported
protected class CrossReference_2_1_Assignment_rule extends AssignmentToken  {
	
	public CrossReference_2_1_Assignment_rule(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prCrossReference().ele21AssignmentRule();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rule",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rule");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prCrossReference().ele210CrossReferenceEStringAbstractRule().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prCrossReference().ele210CrossReferenceEStringAbstractRule(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}


// not supported
protected class CrossReference_3_Keyword extends KeywordToken  {
	
	public CrossReference_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prCrossReference().ele3KeywordRightSquareBracket();
	}	
}


/************ end Rule CrossReference ****************/


/************ begin Rule ParenthesizedElement ****************
 *
 * not supported
 *
 **/


// not supported
protected class ParenthesizedElement_Group extends GroupToken {
	
	public ParenthesizedElement_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prParenthesizedElement().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParenthesizedElement_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParenthesizedElement_1_RuleCall_Alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ParenthesizedElement_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ParenthesizedElement_0_Keyword extends KeywordToken  {
	
	public ParenthesizedElement_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParenthesizedElement().ele0KeywordLeftParenthesis();
	}	
}

// not supported
protected class ParenthesizedElement_1_RuleCall_Alternatives extends RuleCallToken {
	
	public ParenthesizedElement_1_RuleCall_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prParenthesizedElement().ele1ParserRuleCallAlternatives();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Alternatives_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prAlternatives().getRule().getType().getType())) return null;
		return new Alternatives_Group(current, this).firstSolution();
	}
}

// not supported
protected class ParenthesizedElement_2_Keyword extends KeywordToken  {
	
	public ParenthesizedElement_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParenthesizedElement().ele2KeywordRightParenthesis();
	}	
}


/************ end Rule ParenthesizedElement ****************/


/************ begin Rule ParenthesizedTerminalElement ****************
 *
 * not supported
 *
 **/


// not supported
protected class ParenthesizedTerminalElement_Group extends GroupToken {
	
	public ParenthesizedTerminalElement_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prParenthesizedTerminalElement().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParenthesizedTerminalElement_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParenthesizedTerminalElement_1_RuleCall_TerminalAlternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ParenthesizedTerminalElement_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ParenthesizedTerminalElement_0_Keyword extends KeywordToken  {
	
	public ParenthesizedTerminalElement_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParenthesizedTerminalElement().ele0KeywordLeftParenthesis();
	}	
}

// not supported
protected class ParenthesizedTerminalElement_1_RuleCall_TerminalAlternatives extends RuleCallToken {
	
	public ParenthesizedTerminalElement_1_RuleCall_TerminalAlternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prParenthesizedTerminalElement().ele1ParserRuleCallTerminalAlternatives();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TerminalAlternatives_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prTerminalAlternatives().getRule().getType().getType())) return null;
		return new TerminalAlternatives_Group(current, this).firstSolution();
	}
}

// not supported
protected class ParenthesizedTerminalElement_2_Keyword extends KeywordToken  {
	
	public ParenthesizedTerminalElement_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prParenthesizedTerminalElement().ele2KeywordRightParenthesis();
	}	
}


/************ end Rule ParenthesizedTerminalElement ****************/


/************ begin Rule Keyword ****************
 *
 * not supported
 *
 **/


// not supported
protected class Keyword_Assignment_value extends AssignmentToken  {
	
	public Keyword_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prKeyword().eleAssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prKeyword().ele0TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}

/************ end Rule Keyword ****************/


/************ begin Rule RuleCall ****************
 *
 * not supported
 *
 **/


// not supported
protected class RuleCall_Assignment_rule extends AssignmentToken  {
	
	public RuleCall_Assignment_rule(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prRuleCall().eleAssignmentRule();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rule",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rule");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prRuleCall().ele0CrossReferenceEStringAbstractRule().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prRuleCall().ele0CrossReferenceEStringAbstractRule(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

/************ end Rule RuleCall ****************/

}
