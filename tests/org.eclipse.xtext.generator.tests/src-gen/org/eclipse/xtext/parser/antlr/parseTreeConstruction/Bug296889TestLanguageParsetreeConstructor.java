/*
* generated by Xtext
*/
package org.eclipse.xtext.parser.antlr.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.xtext.parser.antlr.services.Bug296889TestLanguageGrammarAccess;

import com.google.inject.Inject;

public class Bug296889TestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private Bug296889TestLanguageGrammarAccess grammarAccess;
	
	@Override	
	public Bug296889TestLanguageGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_Alternatives(this, this, 0, inst);
			case 1: return new Expression_Alternatives(this, this, 1, inst);
			case 2: return new Preop_Group(this, this, 2, inst);
			case 3: return new Postop_Group(this, this, 3, inst);
			case 4: return new Variable_Group(this, this, 4, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Model ****************
 *
 * Model:
 *   "Model" expressions+=Expression*|"DataType" values+=DataTypeExpression*;
 *
 **/

// "Model" expressions+=Expression*|"DataType" values+=DataTypeExpression*
protected class Model_Alternatives extends AlternativesToken {

	public Model_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getModelAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_Group_0(parent, this, 0, inst);
			case 1: return new Model_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getModelRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "Model" expressions+=Expression*
protected class Model_Group_0 extends GroupToken {
	
	public Model_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getModelAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_ExpressionsAssignment_0_1(parent, this, 0, inst);
			case 1: return new Model_ModelKeyword_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "Model"
protected class Model_ModelKeyword_0_0 extends KeywordToken  {
	
	public Model_ModelKeyword_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getModelAccess().getModelKeyword_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// expressions+=Expression*
protected class Model_ExpressionsAssignment_0_1 extends AssignmentToken  {
	
	public Model_ExpressionsAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getExpressionsAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getModelAccess().getExpressionsExpressionParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Model_ExpressionsAssignment_0_1(parent, next, actIndex, consumed);
			case 1: return new Model_ModelKeyword_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


// "DataType" values+=DataTypeExpression*
protected class Model_Group_1 extends GroupToken {
	
	public Model_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getModelAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_ValuesAssignment_1_1(parent, this, 0, inst);
			case 1: return new Model_DataTypeKeyword_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// "DataType"
protected class Model_DataTypeKeyword_1_0 extends KeywordToken  {
	
	public Model_DataTypeKeyword_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getModelAccess().getDataTypeKeyword_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// values+=DataTypeExpression*
protected class Model_ValuesAssignment_1_1 extends AssignmentToken  {
	
	public Model_ValuesAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getModelAccess().getValuesAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Model_ValuesAssignment_1_1(parent, this, 0, inst);
			case 1: return new Model_DataTypeKeyword_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("values",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("values");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.DRC;
			element = grammarAccess.getModelAccess().getValuesDataTypeExpressionParserRuleCall_1_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule Model ****************/


/************ begin Rule Expression ****************
 *
 * Expression:
 *   Postop|Preop;
 *
 **/

// Postop|Preop
protected class Expression_Alternatives extends AlternativesToken {

	public Expression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_PostopParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Expression_PreopParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Postop
protected class Expression_PostopParserRuleCall_0 extends RuleCallToken {
	
	public Expression_PostopParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getPostopParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Postop_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Postop_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPostopRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Preop
protected class Expression_PreopParserRuleCall_1 extends RuleCallToken {
	
	public Expression_PreopParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getPreopParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Preop_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Preop_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getPreopRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Expression ****************/


/************ begin Rule Preop ****************
 *
 * Preop returns Expression:
 *   {Preop} functionName="--" expr=Variable;
 *
 **/

// {Preop} functionName="--" expr=Variable
protected class Preop_Group extends GroupToken {
	
	public Preop_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPreopAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Preop_ExprAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPreopRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Preop}
protected class Preop_PreopAction_0 extends ActionToken  {

	public Preop_PreopAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPreopAccess().getPreopAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPreopAccess().getPreopAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// functionName="--"
protected class Preop_FunctionNameAssignment_1 extends AssignmentToken  {
	
	public Preop_FunctionNameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPreopAccess().getFunctionNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Preop_PreopAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functionName",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functionName");
		if("--".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPreopAccess().getFunctionNameHyphenMinusHyphenMinusKeyword_1_0();
			return obj;
		}
		return null;
	}

}

// expr=Variable
protected class Preop_ExprAssignment_2 extends AssignmentToken  {
	
	public Preop_ExprAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPreopAccess().getExprAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expr",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expr");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getPreopAccess().getExprVariableParserRuleCall_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Preop_FunctionNameAssignment_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule Preop ****************/


/************ begin Rule Postop ****************
 *
 * Postop returns Expression:
 *   Variable ({Postop.expr=current} functionName="--")?;
 *
 **/

// Variable ({Postop.expr=current} functionName="--")?
protected class Postop_Group extends GroupToken {
	
	public Postop_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPostopAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Postop_Group_1(parent, this, 0, inst);
			case 1: return new Postop_VariableParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getPostopRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Variable
protected class Postop_VariableParserRuleCall_0 extends RuleCallToken {
	
	public Postop_VariableParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getPostopAccess().getVariableParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Variable_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Postop.expr=current} functionName="--")?
protected class Postop_Group_1 extends GroupToken {
	
	public Postop_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getPostopAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Postop_FunctionNameAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Postop.expr=current}
protected class Postop_PostopExprAction_1_0 extends ActionToken  {

	public Postop_PostopExprAction_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getPostopAccess().getPostopExprAction_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Postop_VariableParserRuleCall_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getPostopAccess().getPostopExprAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("expr", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("expr")) return null;
		return getDescr((EObject) val);
	}
}

// functionName="--"
protected class Postop_FunctionNameAssignment_1_1 extends AssignmentToken  {
	
	public Postop_FunctionNameAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getPostopAccess().getFunctionNameAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Postop_PostopExprAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("functionName",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("functionName");
		if("--".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getPostopAccess().getFunctionNameHyphenMinusHyphenMinusKeyword_1_1_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule Postop ****************/


/************ begin Rule Variable ****************
 *
 * Variable returns Expression:
 *   {Variable} name=ID;
 *
 **/

// {Variable} name=ID
protected class Variable_Group extends GroupToken {
	
	public Variable_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getVariableAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getVariableRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// {Variable}
protected class Variable_VariableAction_0 extends ActionToken  {

	public Variable_VariableAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getVariableAccess().getVariableAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	
    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getVariableAccess().getVariableAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return current;
	}
}

// name=ID
protected class Variable_NameAssignment_1 extends AssignmentToken  {
	
	public Variable_NameAssignment_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getVariableAccess().getNameAssignment_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Variable_VariableAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Variable ****************/





}
