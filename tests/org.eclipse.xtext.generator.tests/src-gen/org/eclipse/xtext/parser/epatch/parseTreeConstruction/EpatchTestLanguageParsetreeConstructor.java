/*
* generated by Xtext
*/
package org.eclipse.xtext.parser.epatch.parseTreeConstruction;

//import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.AbstractToken.Solution;
import org.eclipse.xtext.parser.epatch.services.EpatchTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class EpatchTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private EpatchTestLanguageGrammarAccess grammarAccess;
	
	@Override
	protected Solution internalSerialize(EObject obj) {
		IInstanceDescription inst = getDescr(obj);
		if(inst.isInstanceOf(grammarAccess.getEPatchRule().getType().getClassifier())) {
			final AbstractToken t = new EPatch_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getImportRule().getType().getClassifier())) {
			final AbstractToken t = new Import_Alternatives(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getModelImportRule().getType().getClassifier())) {
			final AbstractToken t = new ModelImport_Alternatives(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getResourceImportRule().getType().getClassifier())) {
			final AbstractToken t = new ResourceImport_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getEPackageImportRule().getType().getClassifier())) {
			final AbstractToken t = new EPackageImport_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getJavaImportRule().getType().getClassifier())) {
			final AbstractToken t = new JavaImport_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getExtensionImportRule().getType().getClassifier())) {
			final AbstractToken t = new ExtensionImport_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getNamedResourceRule().getType().getClassifier())) {
			final AbstractToken t = new NamedResource_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getNamedObjectRule().getType().getClassifier())) {
			final AbstractToken t = new NamedObject_Alternatives(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getObjectRefRule().getType().getClassifier())) {
			final AbstractToken t = new ObjectRef_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) {
			final AbstractToken t = new Assignment_Alternatives(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getBiSingleAssignmentRule().getType().getClassifier())) {
			final AbstractToken t = new BiSingleAssignment_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getBiListAssignmentRule().getType().getClassifier())) {
			final AbstractToken t = new BiListAssignment_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getMonoSingleAssignmentRule().getType().getClassifier())) {
			final AbstractToken t = new MonoSingleAssignment_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getMonoListAssignmentRule().getType().getClassifier())) {
			final AbstractToken t = new MonoListAssignment_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getAssignmentValueRule().getType().getClassifier())) {
			final AbstractToken t = new AssignmentValue_Alternatives(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getListAssignmentValueRule().getType().getClassifier())) {
			final AbstractToken t = new ListAssignmentValue_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getSingleAssignmentValueRule().getType().getClassifier())) {
			final AbstractToken t = new SingleAssignmentValue_Alternatives(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getCreatedObjectRule().getType().getClassifier())) {
			final AbstractToken t = new CreatedObject_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getObjectNewRule().getType().getClassifier())) {
			final AbstractToken t = new ObjectNew_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getObjectCopyRule().getType().getClassifier())) {
			final AbstractToken t = new ObjectCopy_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getMigrationRule().getType().getClassifier())) {
			final AbstractToken t = new Migration_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getExecutableRule().getType().getClassifier())) {
			final AbstractToken t = new Executable_Alternatives(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getJavaExecutableRule().getType().getClassifier())) {
			final AbstractToken t = new JavaExecutable_Group(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		if(inst.isInstanceOf(grammarAccess.getExpressionExecutableRule().getType().getClassifier())) {
			final AbstractToken t = new ExpressionExecutable_Assignment_exprstr(inst, null);
			Solution s = t.firstSolution();
			while(s != null && !isConsumed(s, t)) s = s.getPredecessor().nextSolution(null, s);
			if(s != null) return s;
		}
		return null;
	}
	

/************ begin Rule EPatch ****************
 *
 * EPatch:
 *   "epatch" name=ID "{" (imports+=Import)* (resources+=NamedResource)* (objects+=ObjectRef)* "}";
 *
 **/

// "epatch" name=ID "{" (imports+=Import)* (resources+=NamedResource)* (objects+=ObjectRef)* "}"
protected class EPatch_Group extends GroupToken {
	
	public EPatch_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEPatchAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new EPatch_6_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new EPatch_5_Assignment_objects(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new EPatch_4_Assignment_resources(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new EPatch_3_Assignment_imports(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new EPatch_2_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new EPatch_1_Assignment_name(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							while(s6 != null) {
								Solution s7 = new EPatch_0_Keyword_epatch(s6.getCurrent(), s6.getPredecessor()).firstSolution();
								if(s7 != null) {
									last = s7.getPredecessor();
									return s7;
								} else {
									s6 = s6.getPredecessor().nextSolution(this,s6);
								}
							}
							s5 = s5.getPredecessor().nextSolution(this,s5);
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "epatch"
protected class EPatch_0_Keyword_epatch extends KeywordToken  {
	
	public EPatch_0_Keyword_epatch(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEPatchAccess().getEpatchKeyword_0();
	}	
}

// name=ID
protected class EPatch_1_Assignment_name extends AssignmentToken  {
	
	public EPatch_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEPatchAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEPatchAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "{"
protected class EPatch_2_Keyword extends KeywordToken  {
	
	public EPatch_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEPatchAccess().getLeftCurlyBracketKeyword_2();
	}	
}

// (imports+=Import)*
protected class EPatch_3_Assignment_imports extends AssignmentToken  {
	
	public EPatch_3_Assignment_imports(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEPatchAccess().getImportsAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("imports",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("imports");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getImportRule().getType().getClassifier())) {
				Solution s = new Import_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// (resources+=NamedResource)*
protected class EPatch_4_Assignment_resources extends AssignmentToken  {
	
	public EPatch_4_Assignment_resources(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEPatchAccess().getResourcesAssignment_4();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("resources",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("resources");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNamedResourceRule().getType().getClassifier())) {
				Solution s = new NamedResource_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// (objects+=ObjectRef)*
protected class EPatch_5_Assignment_objects extends AssignmentToken  {
	
	public EPatch_5_Assignment_objects(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEPatchAccess().getObjectsAssignment_5();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("objects",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("objects");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getObjectRefRule().getType().getClassifier())) {
				Solution s = new ObjectRef_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// "}"
protected class EPatch_6_Keyword extends KeywordToken  {
	
	public EPatch_6_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEPatchAccess().getRightCurlyBracketKeyword_6();
	}	
}


/************ end Rule EPatch ****************/


/************ begin Rule Import ****************
 *
 * Import:
 *   ModelImport|JavaImport|ExtensionImport;
 *
 **/

// ModelImport|JavaImport|ExtensionImport
protected class Import_Alternatives extends AlternativesToken {

	public Import_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getImportAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Import_0_RuleCall_ModelImport(current, this);
			case 1: return new Import_1_RuleCall_JavaImport(current, this);
			case 2: return new Import_2_RuleCall_ExtensionImport(current, this);
			default: return null;
		}
	}
}

// ModelImport
protected class Import_0_RuleCall_ModelImport extends RuleCallToken {
	
	public Import_0_RuleCall_ModelImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getImportAccess().getModelImportParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ModelImport_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getModelImportRule().getType().getClassifier())) return null;
		return new ModelImport_Alternatives(current, this).firstSolution();
	}
}

// JavaImport
protected class Import_1_RuleCall_JavaImport extends RuleCallToken {
	
	public Import_1_RuleCall_JavaImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getImportAccess().getJavaImportParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(JavaImport_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getJavaImportRule().getType().getClassifier())) return null;
		return new JavaImport_Group(current, this).firstSolution();
	}
}

// ExtensionImport
protected class Import_2_RuleCall_ExtensionImport extends RuleCallToken {
	
	public Import_2_RuleCall_ExtensionImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getImportAccess().getExtensionImportParserRuleCall_2();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ExtensionImport_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExtensionImportRule().getType().getClassifier())) return null;
		return new ExtensionImport_Group(current, this).firstSolution();
	}
}


/************ end Rule Import ****************/


/************ begin Rule ModelImport ****************
 *
 * ModelImport:
 *   ResourceImport|EPackageImport;
 *
 **/

// ResourceImport|EPackageImport
protected class ModelImport_Alternatives extends AlternativesToken {

	public ModelImport_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getModelImportAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new ModelImport_0_RuleCall_ResourceImport(current, this);
			case 1: return new ModelImport_1_RuleCall_EPackageImport(current, this);
			default: return null;
		}
	}
}

// ResourceImport
protected class ModelImport_0_RuleCall_ResourceImport extends RuleCallToken {
	
	public ModelImport_0_RuleCall_ResourceImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getModelImportAccess().getResourceImportParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ResourceImport_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getResourceImportRule().getType().getClassifier())) return null;
		return new ResourceImport_Group(current, this).firstSolution();
	}
}

// EPackageImport
protected class ModelImport_1_RuleCall_EPackageImport extends RuleCallToken {
	
	public ModelImport_1_RuleCall_EPackageImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getModelImportAccess().getEPackageImportParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(EPackageImport_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEPackageImportRule().getType().getClassifier())) return null;
		return new EPackageImport_Group(current, this).firstSolution();
	}
}


/************ end Rule ModelImport ****************/


/************ begin Rule ResourceImport ****************
 *
 * ResourceImport:
 *   "import" name=ID "uri" uri=STRING;
 *
 **/

// "import" name=ID "uri" uri=STRING
protected class ResourceImport_Group extends GroupToken {
	
	public ResourceImport_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getResourceImportAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ResourceImport_3_Assignment_uri(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ResourceImport_2_Keyword_uri(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ResourceImport_1_Assignment_name(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new ResourceImport_0_Keyword_import(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "import"
protected class ResourceImport_0_Keyword_import extends KeywordToken  {
	
	public ResourceImport_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getResourceImportAccess().getImportKeyword_0();
	}	
}

// name=ID
protected class ResourceImport_1_Assignment_name extends AssignmentToken  {
	
	public ResourceImport_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getResourceImportAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getResourceImportAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "uri"
protected class ResourceImport_2_Keyword_uri extends KeywordToken  {
	
	public ResourceImport_2_Keyword_uri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getResourceImportAccess().getUriKeyword_2();
	}	
}

// uri=STRING
protected class ResourceImport_3_Assignment_uri extends AssignmentToken  {
	
	public ResourceImport_3_Assignment_uri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getResourceImportAccess().getUriAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("uri",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("uri");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getResourceImportAccess().getUriSTRINGTerminalRuleCall_3_0();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule ResourceImport ****************/


/************ begin Rule EPackageImport ****************
 *
 * EPackageImport:
 *   "import" name=ID "ns" nsURI=STRING;
 *
 **/

// "import" name=ID "ns" nsURI=STRING
protected class EPackageImport_Group extends GroupToken {
	
	public EPackageImport_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEPackageImportAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new EPackageImport_3_Assignment_nsURI(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new EPackageImport_2_Keyword_ns(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new EPackageImport_1_Assignment_name(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new EPackageImport_0_Keyword_import(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "import"
protected class EPackageImport_0_Keyword_import extends KeywordToken  {
	
	public EPackageImport_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEPackageImportAccess().getImportKeyword_0();
	}	
}

// name=ID
protected class EPackageImport_1_Assignment_name extends AssignmentToken  {
	
	public EPackageImport_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEPackageImportAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEPackageImportAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "ns"
protected class EPackageImport_2_Keyword_ns extends KeywordToken  {
	
	public EPackageImport_2_Keyword_ns(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEPackageImportAccess().getNsKeyword_2();
	}	
}

// nsURI=STRING
protected class EPackageImport_3_Assignment_nsURI extends AssignmentToken  {
	
	public EPackageImport_3_Assignment_nsURI(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEPackageImportAccess().getNsURIAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("nsURI",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nsURI");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEPackageImportAccess().getNsURISTRINGTerminalRuleCall_3_0();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule EPackageImport ****************/


/************ begin Rule JavaImport ****************
 *
 * JavaImport:
 *   "import" "java" path+=ID ("." path+=ID)*;
 *
 **/

// "import" "java" path+=ID ("." path+=ID)*
protected class JavaImport_Group extends GroupToken {
	
	public JavaImport_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getJavaImportAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new JavaImport_3_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new JavaImport_2_Assignment_path(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new JavaImport_1_Keyword_java(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new JavaImport_0_Keyword_import(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "import"
protected class JavaImport_0_Keyword_import extends KeywordToken  {
	
	public JavaImport_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getJavaImportAccess().getImportKeyword_0();
	}	
}

// "java"
protected class JavaImport_1_Keyword_java extends KeywordToken  {
	
	public JavaImport_1_Keyword_java(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getJavaImportAccess().getJavaKeyword_1();
	}	
}

// path+=ID
protected class JavaImport_2_Assignment_path extends AssignmentToken  {
	
	public JavaImport_2_Assignment_path(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getJavaImportAccess().getPathAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("path",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("path");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getJavaImportAccess().getPathIDTerminalRuleCall_2_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("." path+=ID)*
protected class JavaImport_3_Group extends GroupToken {
	
	public JavaImport_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getJavaImportAccess().getGroup_3();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new JavaImport_3_1_Assignment_path(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new JavaImport_3_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "."
protected class JavaImport_3_0_Keyword extends KeywordToken  {
	
	public JavaImport_3_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getJavaImportAccess().getFullStopKeyword_3_0();
	}	
}

// path+=ID
protected class JavaImport_3_1_Assignment_path extends AssignmentToken  {
	
	public JavaImport_3_1_Assignment_path(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getJavaImportAccess().getPathAssignment_3_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("path",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("path");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getJavaImportAccess().getPathIDTerminalRuleCall_3_1_0();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule JavaImport ****************/


/************ begin Rule ExtensionImport ****************
 *
 * ExtensionImport:
 *   "import" "extension" path+=ID ("::" path+=ID)*;
 *
 **/

// "import" "extension" path+=ID ("::" path+=ID)*
protected class ExtensionImport_Group extends GroupToken {
	
	public ExtensionImport_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExtensionImportAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ExtensionImport_3_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ExtensionImport_2_Assignment_path(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ExtensionImport_1_Keyword_extension(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new ExtensionImport_0_Keyword_import(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "import"
protected class ExtensionImport_0_Keyword_import extends KeywordToken  {
	
	public ExtensionImport_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getExtensionImportAccess().getImportKeyword_0();
	}	
}

// "extension"
protected class ExtensionImport_1_Keyword_extension extends KeywordToken  {
	
	public ExtensionImport_1_Keyword_extension(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getExtensionImportAccess().getExtensionKeyword_1();
	}	
}

// path+=ID
protected class ExtensionImport_2_Assignment_path extends AssignmentToken  {
	
	public ExtensionImport_2_Assignment_path(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExtensionImportAccess().getPathAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("path",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("path");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getExtensionImportAccess().getPathIDTerminalRuleCall_2_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("::" path+=ID)*
protected class ExtensionImport_3_Group extends GroupToken {
	
	public ExtensionImport_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExtensionImportAccess().getGroup_3();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ExtensionImport_3_1_Assignment_path(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ExtensionImport_3_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "::"
protected class ExtensionImport_3_0_Keyword extends KeywordToken  {
	
	public ExtensionImport_3_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getExtensionImportAccess().getColonColonKeyword_3_0();
	}	
}

// path+=ID
protected class ExtensionImport_3_1_Assignment_path extends AssignmentToken  {
	
	public ExtensionImport_3_1_Assignment_path(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExtensionImportAccess().getPathAssignment_3_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("path",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("path");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getExtensionImportAccess().getPathIDTerminalRuleCall_3_1_0();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule ExtensionImport ****************/


/************ begin Rule NamedResource ****************
 *
 * NamedResource:
 *   "resource" name=ID "{" "left" ("uri" leftUri=STRING|leftRoot=CreatedObject) ";" "right" ("uri" rightUri=STRING|rightRoot=CreatedObject) ";" "}";
 *
 **/

// "resource" name=ID "{" "left" ("uri" leftUri=STRING|leftRoot=CreatedObject) ";" "right" ("uri" rightUri=STRING|rightRoot=CreatedObject) ";" "}"
protected class NamedResource_Group extends GroupToken {
	
	public NamedResource_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new NamedResource_9_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new NamedResource_8_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new NamedResource_7_Alternatives(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new NamedResource_6_Keyword_right(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new NamedResource_5_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new NamedResource_4_Alternatives(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							while(s6 != null) {
								Solution s7 = new NamedResource_3_Keyword_left(s6.getCurrent(), s6.getPredecessor()).firstSolution();
								while(s7 != null) {
									Solution s8 = new NamedResource_2_Keyword(s7.getCurrent(), s7.getPredecessor()).firstSolution();
									while(s8 != null) {
										Solution s9 = new NamedResource_1_Assignment_name(s8.getCurrent(), s8.getPredecessor()).firstSolution();
										while(s9 != null) {
											Solution s10 = new NamedResource_0_Keyword_resource(s9.getCurrent(), s9.getPredecessor()).firstSolution();
											if(s10 != null) {
												last = s10.getPredecessor();
												return s10;
											} else {
												s9 = s9.getPredecessor().nextSolution(this,s9);
											}
										}
										s8 = s8.getPredecessor().nextSolution(this,s8);
									}
									s7 = s7.getPredecessor().nextSolution(this,s7);
								}
								s6 = s6.getPredecessor().nextSolution(this,s6);
							}
							s5 = s5.getPredecessor().nextSolution(this,s5);
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "resource"
protected class NamedResource_0_Keyword_resource extends KeywordToken  {
	
	public NamedResource_0_Keyword_resource(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getResourceKeyword_0();
	}	
}

// name=ID
protected class NamedResource_1_Assignment_name extends AssignmentToken  {
	
	public NamedResource_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getNamedResourceAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "{"
protected class NamedResource_2_Keyword extends KeywordToken  {
	
	public NamedResource_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getLeftCurlyBracketKeyword_2();
	}	
}

// "left"
protected class NamedResource_3_Keyword_left extends KeywordToken  {
	
	public NamedResource_3_Keyword_left(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getLeftKeyword_3();
	}	
}

// "uri" leftUri=STRING|leftRoot=CreatedObject
protected class NamedResource_4_Alternatives extends AlternativesToken {

	public NamedResource_4_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getAlternatives_4();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new NamedResource_4_0_Group(current, this);
			case 1: return new NamedResource_4_1_Assignment_leftRoot(current, this);
			default: return null;
		}
	}
}

// "uri" leftUri=STRING
protected class NamedResource_4_0_Group extends GroupToken {
	
	public NamedResource_4_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getGroup_4_0();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new NamedResource_4_0_1_Assignment_leftUri(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new NamedResource_4_0_0_Keyword_uri(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "uri"
protected class NamedResource_4_0_0_Keyword_uri extends KeywordToken  {
	
	public NamedResource_4_0_0_Keyword_uri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getUriKeyword_4_0_0();
	}	
}

// leftUri=STRING
protected class NamedResource_4_0_1_Assignment_leftUri extends AssignmentToken  {
	
	public NamedResource_4_0_1_Assignment_leftUri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getLeftUriAssignment_4_0_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftUri",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftUri");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getNamedResourceAccess().getLeftUriSTRINGTerminalRuleCall_4_0_1_0();
			return new Solution(obj);
		}
		return null;
	}
}


// leftRoot=CreatedObject
protected class NamedResource_4_1_Assignment_leftRoot extends AssignmentToken  {
	
	public NamedResource_4_1_Assignment_leftRoot(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getLeftRootAssignment_4_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftRoot",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftRoot");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCreatedObjectRule().getType().getClassifier())) {
				Solution s = new CreatedObject_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// ";"
protected class NamedResource_5_Keyword extends KeywordToken  {
	
	public NamedResource_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getSemicolonKeyword_5();
	}	
}

// "right"
protected class NamedResource_6_Keyword_right extends KeywordToken  {
	
	public NamedResource_6_Keyword_right(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getRightKeyword_6();
	}	
}

// "uri" rightUri=STRING|rightRoot=CreatedObject
protected class NamedResource_7_Alternatives extends AlternativesToken {

	public NamedResource_7_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getAlternatives_7();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new NamedResource_7_0_Group(current, this);
			case 1: return new NamedResource_7_1_Assignment_rightRoot(current, this);
			default: return null;
		}
	}
}

// "uri" rightUri=STRING
protected class NamedResource_7_0_Group extends GroupToken {
	
	public NamedResource_7_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getGroup_7_0();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new NamedResource_7_0_1_Assignment_rightUri(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new NamedResource_7_0_0_Keyword_uri(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "uri"
protected class NamedResource_7_0_0_Keyword_uri extends KeywordToken  {
	
	public NamedResource_7_0_0_Keyword_uri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getUriKeyword_7_0_0();
	}	
}

// rightUri=STRING
protected class NamedResource_7_0_1_Assignment_rightUri extends AssignmentToken  {
	
	public NamedResource_7_0_1_Assignment_rightUri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getRightUriAssignment_7_0_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightUri",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightUri");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getNamedResourceAccess().getRightUriSTRINGTerminalRuleCall_7_0_1_0();
			return new Solution(obj);
		}
		return null;
	}
}


// rightRoot=CreatedObject
protected class NamedResource_7_1_Assignment_rightRoot extends AssignmentToken  {
	
	public NamedResource_7_1_Assignment_rightRoot(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getRightRootAssignment_7_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightRoot",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightRoot");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCreatedObjectRule().getType().getClassifier())) {
				Solution s = new CreatedObject_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// ";"
protected class NamedResource_8_Keyword extends KeywordToken  {
	
	public NamedResource_8_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getSemicolonKeyword_8();
	}	
}

// "}"
protected class NamedResource_9_Keyword extends KeywordToken  {
	
	public NamedResource_9_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNamedResourceAccess().getRightCurlyBracketKeyword_9();
	}	
}


/************ end Rule NamedResource ****************/


/************ begin Rule NamedObject ****************
 *
 * NamedObject:
 *   ObjectRef|CreatedObject;
 *
 **/

// ObjectRef|CreatedObject
protected class NamedObject_Alternatives extends AlternativesToken {

	public NamedObject_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getNamedObjectAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new NamedObject_0_RuleCall_ObjectRef(current, this);
			case 1: return new NamedObject_1_RuleCall_CreatedObject(current, this);
			default: return null;
		}
	}
}

// ObjectRef
protected class NamedObject_0_RuleCall_ObjectRef extends RuleCallToken {
	
	public NamedObject_0_RuleCall_ObjectRef(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNamedObjectAccess().getObjectRefParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ObjectRef_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getObjectRefRule().getType().getClassifier())) return null;
		return new ObjectRef_Group(current, this).firstSolution();
	}
}

// CreatedObject
protected class NamedObject_1_RuleCall_CreatedObject extends RuleCallToken {
	
	public NamedObject_1_RuleCall_CreatedObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getNamedObjectAccess().getCreatedObjectParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(CreatedObject_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCreatedObjectRule().getType().getClassifier())) return null;
		return new CreatedObject_Group(current, this).firstSolution();
	}
}


/************ end Rule NamedObject ****************/


/************ begin Rule ObjectRef ****************
 *
 * ObjectRef:
 *   "object" (name=ID)? (leftRes=[NamedResource] leftFrag=FRAGMENT|"left" leftRes=[NamedResource] leftFrag=FRAGMENT "right" rightRes=[NamedResource] rightFrag=FRAGMENT) ("{" (assignments+=BiSingleAssignment|assignments+=BiListAssignment)+ ("left" leftMig=Migration)? ("right" rightMig=Migration)? "}")?;
 *
 **/

// "object" (name=ID)? (leftRes=[NamedResource] leftFrag=FRAGMENT|"left" leftRes=[NamedResource] leftFrag=FRAGMENT "right" rightRes=[NamedResource] rightFrag=FRAGMENT) ("{" (assignments+=BiSingleAssignment|assignments+=BiListAssignment)+ ("left" leftMig=Migration)? ("right" rightMig=Migration)? "}")?
protected class ObjectRef_Group extends GroupToken {
	
	public ObjectRef_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_3_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_2_Alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ObjectRef_1_Assignment_name(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new ObjectRef_0_Keyword_object(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "object"
protected class ObjectRef_0_Keyword_object extends KeywordToken  {
	
	public ObjectRef_0_Keyword_object(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getObjectKeyword_0();
	}	
}

// (name=ID)?
protected class ObjectRef_1_Assignment_name extends AssignmentToken  {
	
	public ObjectRef_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getObjectRefAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// leftRes=[NamedResource] leftFrag=FRAGMENT|"left" leftRes=[NamedResource] leftFrag=FRAGMENT "right" rightRes=[NamedResource] rightFrag=FRAGMENT
protected class ObjectRef_2_Alternatives extends AlternativesToken {

	public ObjectRef_2_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getAlternatives_2();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new ObjectRef_2_0_Group(current, this);
			case 1: return new ObjectRef_2_1_Group(current, this);
			default: return null;
		}
	}
}

// leftRes=[NamedResource] leftFrag=FRAGMENT
protected class ObjectRef_2_0_Group extends GroupToken {
	
	public ObjectRef_2_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getGroup_2_0();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_2_0_1_Assignment_leftFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_2_0_0_Assignment_leftRes(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// leftRes=[NamedResource]
protected class ObjectRef_2_0_0_Assignment_leftRes extends AssignmentToken  {
	
	public ObjectRef_2_0_0_Assignment_leftRes(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getLeftResAssignment_2_0_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftRes",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftRes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getObjectRefAccess().getLeftResNamedResourceCrossReference_2_0_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getObjectRefAccess().getLeftResNamedResourceCrossReference_2_0_0_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// leftFrag=FRAGMENT
protected class ObjectRef_2_0_1_Assignment_leftFrag extends AssignmentToken  {
	
	public ObjectRef_2_0_1_Assignment_leftFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getLeftFragAssignment_2_0_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftFrag");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getObjectRefAccess().getLeftFragFRAGMENTTerminalRuleCall_2_0_1_0();
			return new Solution(obj);
		}
		return null;
	}
}


// "left" leftRes=[NamedResource] leftFrag=FRAGMENT "right" rightRes=[NamedResource] rightFrag=FRAGMENT
protected class ObjectRef_2_1_Group extends GroupToken {
	
	public ObjectRef_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getGroup_2_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_2_1_5_Assignment_rightFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_2_1_4_Assignment_rightRes(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ObjectRef_2_1_3_Keyword_right(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new ObjectRef_2_1_2_Assignment_leftFrag(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new ObjectRef_2_1_1_Assignment_leftRes(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new ObjectRef_2_1_0_Keyword_left(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							if(s6 != null) {
								last = s6.getPredecessor();
								return s6;
							} else {
								s5 = s5.getPredecessor().nextSolution(this,s5);
							}
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "left"
protected class ObjectRef_2_1_0_Keyword_left extends KeywordToken  {
	
	public ObjectRef_2_1_0_Keyword_left(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getLeftKeyword_2_1_0();
	}	
}

// leftRes=[NamedResource]
protected class ObjectRef_2_1_1_Assignment_leftRes extends AssignmentToken  {
	
	public ObjectRef_2_1_1_Assignment_leftRes(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getLeftResAssignment_2_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftRes",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftRes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getObjectRefAccess().getLeftResNamedResourceCrossReference_2_1_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getObjectRefAccess().getLeftResNamedResourceCrossReference_2_1_1_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// leftFrag=FRAGMENT
protected class ObjectRef_2_1_2_Assignment_leftFrag extends AssignmentToken  {
	
	public ObjectRef_2_1_2_Assignment_leftFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getLeftFragAssignment_2_1_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftFrag");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getObjectRefAccess().getLeftFragFRAGMENTTerminalRuleCall_2_1_2_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "right"
protected class ObjectRef_2_1_3_Keyword_right extends KeywordToken  {
	
	public ObjectRef_2_1_3_Keyword_right(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getRightKeyword_2_1_3();
	}	
}

// rightRes=[NamedResource]
protected class ObjectRef_2_1_4_Assignment_rightRes extends AssignmentToken  {
	
	public ObjectRef_2_1_4_Assignment_rightRes(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getRightResAssignment_2_1_4();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightRes",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightRes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getObjectRefAccess().getRightResNamedResourceCrossReference_2_1_4_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getObjectRefAccess().getRightResNamedResourceCrossReference_2_1_4_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// rightFrag=FRAGMENT
protected class ObjectRef_2_1_5_Assignment_rightFrag extends AssignmentToken  {
	
	public ObjectRef_2_1_5_Assignment_rightFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getRightFragAssignment_2_1_5();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightFrag");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getObjectRefAccess().getRightFragFRAGMENTTerminalRuleCall_2_1_5_0();
			return new Solution(obj);
		}
		return null;
	}
}



// ("{" (assignments+=BiSingleAssignment|assignments+=BiListAssignment)+ ("left" leftMig=Migration)? ("right" rightMig=Migration)? "}")?
protected class ObjectRef_3_Group extends GroupToken {
	
	public ObjectRef_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getGroup_3();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_3_4_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_3_3_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ObjectRef_3_2_Group(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new ObjectRef_3_1_Alternatives(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new ObjectRef_3_0_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						if(s5 != null) {
							last = s5.getPredecessor();
							return s5;
						} else {
							s4 = s4.getPredecessor().nextSolution(this,s4);
						}
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "{"
protected class ObjectRef_3_0_Keyword extends KeywordToken  {
	
	public ObjectRef_3_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getLeftCurlyBracketKeyword_3_0();
	}	
}

// (assignments+=BiSingleAssignment|assignments+=BiListAssignment)+
protected class ObjectRef_3_1_Alternatives extends AlternativesToken {

	public ObjectRef_3_1_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getAlternatives_3_1();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new ObjectRef_3_1_0_Assignment_assignments(current, this);
			case 1: return new ObjectRef_3_1_1_Assignment_assignments(current, this);
			default: return null;
		}
	}
}

// assignments+=BiSingleAssignment
protected class ObjectRef_3_1_0_Assignment_assignments extends AssignmentToken  {
	
	public ObjectRef_3_1_0_Assignment_assignments(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getAssignmentsAssignment_3_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("assignments",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("assignments");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBiSingleAssignmentRule().getType().getClassifier())) {
				Solution s = new BiSingleAssignment_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// assignments+=BiListAssignment
protected class ObjectRef_3_1_1_Assignment_assignments extends AssignmentToken  {
	
	public ObjectRef_3_1_1_Assignment_assignments(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getAssignmentsAssignment_3_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("assignments",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("assignments");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getBiListAssignmentRule().getType().getClassifier())) {
				Solution s = new BiListAssignment_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// ("left" leftMig=Migration)?
protected class ObjectRef_3_2_Group extends GroupToken {
	
	public ObjectRef_3_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getGroup_3_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_3_2_1_Assignment_leftMig(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_3_2_0_Keyword_left(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "left"
protected class ObjectRef_3_2_0_Keyword_left extends KeywordToken  {
	
	public ObjectRef_3_2_0_Keyword_left(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getLeftKeyword_3_2_0();
	}	
}

// leftMig=Migration
protected class ObjectRef_3_2_1_Assignment_leftMig extends AssignmentToken  {
	
	public ObjectRef_3_2_1_Assignment_leftMig(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getLeftMigAssignment_3_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftMig",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftMig");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMigrationRule().getType().getClassifier())) {
				Solution s = new Migration_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// ("right" rightMig=Migration)?
protected class ObjectRef_3_3_Group extends GroupToken {
	
	public ObjectRef_3_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getGroup_3_3();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_3_3_1_Assignment_rightMig(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_3_3_0_Keyword_right(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "right"
protected class ObjectRef_3_3_0_Keyword_right extends KeywordToken  {
	
	public ObjectRef_3_3_0_Keyword_right(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getRightKeyword_3_3_0();
	}	
}

// rightMig=Migration
protected class ObjectRef_3_3_1_Assignment_rightMig extends AssignmentToken  {
	
	public ObjectRef_3_3_1_Assignment_rightMig(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getRightMigAssignment_3_3_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightMig",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightMig");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMigrationRule().getType().getClassifier())) {
				Solution s = new Migration_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// "}"
protected class ObjectRef_3_4_Keyword extends KeywordToken  {
	
	public ObjectRef_3_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getObjectRefAccess().getRightCurlyBracketKeyword_3_4();
	}	
}



/************ end Rule ObjectRef ****************/


/************ begin Rule Assignment ****************
 *
 * Assignment:
 *   BiSingleAssignment|BiListAssignment|MonoSingleAssignment|MonoListAssignment;
 *
 **/

// BiSingleAssignment|BiListAssignment|MonoSingleAssignment|MonoListAssignment
protected class Assignment_Alternatives extends AlternativesToken {

	public Assignment_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Assignment_0_RuleCall_BiSingleAssignment(current, this);
			case 1: return new Assignment_1_RuleCall_BiListAssignment(current, this);
			case 2: return new Assignment_2_RuleCall_MonoSingleAssignment(current, this);
			case 3: return new Assignment_3_RuleCall_MonoListAssignment(current, this);
			default: return null;
		}
	}
}

// BiSingleAssignment
protected class Assignment_0_RuleCall_BiSingleAssignment extends RuleCallToken {
	
	public Assignment_0_RuleCall_BiSingleAssignment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getBiSingleAssignmentParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(BiSingleAssignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBiSingleAssignmentRule().getType().getClassifier())) return null;
		return new BiSingleAssignment_Group(current, this).firstSolution();
	}
}

// BiListAssignment
protected class Assignment_1_RuleCall_BiListAssignment extends RuleCallToken {
	
	public Assignment_1_RuleCall_BiListAssignment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getBiListAssignmentParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(BiListAssignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getBiListAssignmentRule().getType().getClassifier())) return null;
		return new BiListAssignment_Group(current, this).firstSolution();
	}
}

// MonoSingleAssignment
protected class Assignment_2_RuleCall_MonoSingleAssignment extends RuleCallToken {
	
	public Assignment_2_RuleCall_MonoSingleAssignment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getMonoSingleAssignmentParserRuleCall_2();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(MonoSingleAssignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMonoSingleAssignmentRule().getType().getClassifier())) return null;
		return new MonoSingleAssignment_Group(current, this).firstSolution();
	}
}

// MonoListAssignment
protected class Assignment_3_RuleCall_MonoListAssignment extends RuleCallToken {
	
	public Assignment_3_RuleCall_MonoListAssignment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getMonoListAssignmentParserRuleCall_3();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(MonoListAssignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMonoListAssignmentRule().getType().getClassifier())) return null;
		return new MonoListAssignment_Group(current, this).firstSolution();
	}
}


/************ end Rule Assignment ****************/


/************ begin Rule BiSingleAssignment ****************
 *
 * BiSingleAssignment returns SingleAssignment:
 *   feature=ID "=" leftValue=SingleAssignmentValue "|" rightValue=SingleAssignmentValue ";";
 *
 **/

// feature=ID "=" leftValue=SingleAssignmentValue "|" rightValue=SingleAssignmentValue ";"
protected class BiSingleAssignment_Group extends GroupToken {
	
	public BiSingleAssignment_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBiSingleAssignmentAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiSingleAssignment_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiSingleAssignment_4_Assignment_rightValue(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new BiSingleAssignment_3_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new BiSingleAssignment_2_Assignment_leftValue(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new BiSingleAssignment_1_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new BiSingleAssignment_0_Assignment_feature(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							if(s6 != null) {
								last = s6.getPredecessor();
								return s6;
							} else {
								s5 = s5.getPredecessor().nextSolution(this,s5);
							}
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// feature=ID
protected class BiSingleAssignment_0_Assignment_feature extends AssignmentToken  {
	
	public BiSingleAssignment_0_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBiSingleAssignmentAccess().getFeatureAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getBiSingleAssignmentAccess().getFeatureIDTerminalRuleCall_0_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "="
protected class BiSingleAssignment_1_Keyword extends KeywordToken  {
	
	public BiSingleAssignment_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBiSingleAssignmentAccess().getEqualsSignKeyword_1();
	}	
}

// leftValue=SingleAssignmentValue
protected class BiSingleAssignment_2_Assignment_leftValue extends AssignmentToken  {
	
	public BiSingleAssignment_2_Assignment_leftValue(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBiSingleAssignmentAccess().getLeftValueAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValue",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValue");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSingleAssignmentValueRule().getType().getClassifier())) {
				Solution s = new SingleAssignmentValue_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// "|"
protected class BiSingleAssignment_3_Keyword extends KeywordToken  {
	
	public BiSingleAssignment_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBiSingleAssignmentAccess().getVerticalLineKeyword_3();
	}	
}

// rightValue=SingleAssignmentValue
protected class BiSingleAssignment_4_Assignment_rightValue extends AssignmentToken  {
	
	public BiSingleAssignment_4_Assignment_rightValue(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBiSingleAssignmentAccess().getRightValueAssignment_4();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightValue",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightValue");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSingleAssignmentValueRule().getType().getClassifier())) {
				Solution s = new SingleAssignmentValue_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ";"
protected class BiSingleAssignment_5_Keyword extends KeywordToken  {
	
	public BiSingleAssignment_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBiSingleAssignmentAccess().getSemicolonKeyword_5();
	}	
}


/************ end Rule BiSingleAssignment ****************/


/************ begin Rule BiListAssignment ****************
 *
 * BiListAssignment returns ListAssignment:
 *   feature=ID "=" "[" (leftValues+=ListAssignmentValue ("," leftValues+=ListAssignmentValue)*)? "|" (rightValues+=ListAssignmentValue ("," rightValues+=ListAssignmentValue)*)? "]" ";";
 *
 **/

// feature=ID "=" "[" (leftValues+=ListAssignmentValue ("," leftValues+=ListAssignmentValue)*)? "|" (rightValues+=ListAssignmentValue ("," rightValues+=ListAssignmentValue)*)? "]" ";"
protected class BiListAssignment_Group extends GroupToken {
	
	public BiListAssignment_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiListAssignment_7_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiListAssignment_6_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new BiListAssignment_5_Group(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new BiListAssignment_4_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new BiListAssignment_3_Group(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new BiListAssignment_2_Keyword(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							while(s6 != null) {
								Solution s7 = new BiListAssignment_1_Keyword(s6.getCurrent(), s6.getPredecessor()).firstSolution();
								while(s7 != null) {
									Solution s8 = new BiListAssignment_0_Assignment_feature(s7.getCurrent(), s7.getPredecessor()).firstSolution();
									if(s8 != null) {
										last = s8.getPredecessor();
										return s8;
									} else {
										s7 = s7.getPredecessor().nextSolution(this,s7);
									}
								}
								s6 = s6.getPredecessor().nextSolution(this,s6);
							}
							s5 = s5.getPredecessor().nextSolution(this,s5);
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// feature=ID
protected class BiListAssignment_0_Assignment_feature extends AssignmentToken  {
	
	public BiListAssignment_0_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getFeatureAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getBiListAssignmentAccess().getFeatureIDTerminalRuleCall_0_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "="
protected class BiListAssignment_1_Keyword extends KeywordToken  {
	
	public BiListAssignment_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getEqualsSignKeyword_1();
	}	
}

// "["
protected class BiListAssignment_2_Keyword extends KeywordToken  {
	
	public BiListAssignment_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getLeftSquareBracketKeyword_2();
	}	
}

// (leftValues+=ListAssignmentValue ("," leftValues+=ListAssignmentValue)*)?
protected class BiListAssignment_3_Group extends GroupToken {
	
	public BiListAssignment_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getGroup_3();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiListAssignment_3_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiListAssignment_3_0_Assignment_leftValues(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// leftValues+=ListAssignmentValue
protected class BiListAssignment_3_0_Assignment_leftValues extends AssignmentToken  {
	
	public BiListAssignment_3_0_Assignment_leftValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getLeftValuesAssignment_3_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValues",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValues");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getListAssignmentValueRule().getType().getClassifier())) {
				Solution s = new ListAssignmentValue_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ("," leftValues+=ListAssignmentValue)*
protected class BiListAssignment_3_1_Group extends GroupToken {
	
	public BiListAssignment_3_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getGroup_3_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiListAssignment_3_1_1_Assignment_leftValues(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiListAssignment_3_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// ","
protected class BiListAssignment_3_1_0_Keyword extends KeywordToken  {
	
	public BiListAssignment_3_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getCommaKeyword_3_1_0();
	}	
}

// leftValues+=ListAssignmentValue
protected class BiListAssignment_3_1_1_Assignment_leftValues extends AssignmentToken  {
	
	public BiListAssignment_3_1_1_Assignment_leftValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getLeftValuesAssignment_3_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValues",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValues");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getListAssignmentValueRule().getType().getClassifier())) {
				Solution s = new ListAssignmentValue_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// "|"
protected class BiListAssignment_4_Keyword extends KeywordToken  {
	
	public BiListAssignment_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getVerticalLineKeyword_4();
	}	
}

// (rightValues+=ListAssignmentValue ("," rightValues+=ListAssignmentValue)*)?
protected class BiListAssignment_5_Group extends GroupToken {
	
	public BiListAssignment_5_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getGroup_5();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiListAssignment_5_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiListAssignment_5_0_Assignment_rightValues(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// rightValues+=ListAssignmentValue
protected class BiListAssignment_5_0_Assignment_rightValues extends AssignmentToken  {
	
	public BiListAssignment_5_0_Assignment_rightValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getRightValuesAssignment_5_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightValues",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightValues");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getListAssignmentValueRule().getType().getClassifier())) {
				Solution s = new ListAssignmentValue_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ("," rightValues+=ListAssignmentValue)*
protected class BiListAssignment_5_1_Group extends GroupToken {
	
	public BiListAssignment_5_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getGroup_5_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiListAssignment_5_1_1_Assignment_rightValues(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiListAssignment_5_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// ","
protected class BiListAssignment_5_1_0_Keyword extends KeywordToken  {
	
	public BiListAssignment_5_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getCommaKeyword_5_1_0();
	}	
}

// rightValues+=ListAssignmentValue
protected class BiListAssignment_5_1_1_Assignment_rightValues extends AssignmentToken  {
	
	public BiListAssignment_5_1_1_Assignment_rightValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getRightValuesAssignment_5_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightValues",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightValues");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getListAssignmentValueRule().getType().getClassifier())) {
				Solution s = new ListAssignmentValue_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// "]"
protected class BiListAssignment_6_Keyword extends KeywordToken  {
	
	public BiListAssignment_6_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getRightSquareBracketKeyword_6();
	}	
}

// ";"
protected class BiListAssignment_7_Keyword extends KeywordToken  {
	
	public BiListAssignment_7_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getBiListAssignmentAccess().getSemicolonKeyword_7();
	}	
}


/************ end Rule BiListAssignment ****************/


/************ begin Rule MonoSingleAssignment ****************
 *
 * MonoSingleAssignment returns SingleAssignment:
 *   feature=ID "=" leftValue=SingleAssignmentValue ";";
 *
 **/

// feature=ID "=" leftValue=SingleAssignmentValue ";"
protected class MonoSingleAssignment_Group extends GroupToken {
	
	public MonoSingleAssignment_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMonoSingleAssignmentAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new MonoSingleAssignment_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new MonoSingleAssignment_2_Assignment_leftValue(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new MonoSingleAssignment_1_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new MonoSingleAssignment_0_Assignment_feature(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// feature=ID
protected class MonoSingleAssignment_0_Assignment_feature extends AssignmentToken  {
	
	public MonoSingleAssignment_0_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMonoSingleAssignmentAccess().getFeatureAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getMonoSingleAssignmentAccess().getFeatureIDTerminalRuleCall_0_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "="
protected class MonoSingleAssignment_1_Keyword extends KeywordToken  {
	
	public MonoSingleAssignment_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMonoSingleAssignmentAccess().getEqualsSignKeyword_1();
	}	
}

// leftValue=SingleAssignmentValue
protected class MonoSingleAssignment_2_Assignment_leftValue extends AssignmentToken  {
	
	public MonoSingleAssignment_2_Assignment_leftValue(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMonoSingleAssignmentAccess().getLeftValueAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValue",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValue");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSingleAssignmentValueRule().getType().getClassifier())) {
				Solution s = new SingleAssignmentValue_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ";"
protected class MonoSingleAssignment_3_Keyword extends KeywordToken  {
	
	public MonoSingleAssignment_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMonoSingleAssignmentAccess().getSemicolonKeyword_3();
	}	
}


/************ end Rule MonoSingleAssignment ****************/


/************ begin Rule MonoListAssignment ****************
 *
 * MonoListAssignment returns ListAssignment:
 *   feature=ID "=" "[" (leftValues+=AssignmentValue ("," leftValues+=AssignmentValue)*)? "]" ";";
 *
 **/

// feature=ID "=" "[" (leftValues+=AssignmentValue ("," leftValues+=AssignmentValue)*)? "]" ";"
protected class MonoListAssignment_Group extends GroupToken {
	
	public MonoListAssignment_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMonoListAssignmentAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new MonoListAssignment_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new MonoListAssignment_4_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new MonoListAssignment_3_Group(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new MonoListAssignment_2_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new MonoListAssignment_1_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new MonoListAssignment_0_Assignment_feature(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							if(s6 != null) {
								last = s6.getPredecessor();
								return s6;
							} else {
								s5 = s5.getPredecessor().nextSolution(this,s5);
							}
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// feature=ID
protected class MonoListAssignment_0_Assignment_feature extends AssignmentToken  {
	
	public MonoListAssignment_0_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMonoListAssignmentAccess().getFeatureAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getMonoListAssignmentAccess().getFeatureIDTerminalRuleCall_0_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "="
protected class MonoListAssignment_1_Keyword extends KeywordToken  {
	
	public MonoListAssignment_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMonoListAssignmentAccess().getEqualsSignKeyword_1();
	}	
}

// "["
protected class MonoListAssignment_2_Keyword extends KeywordToken  {
	
	public MonoListAssignment_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMonoListAssignmentAccess().getLeftSquareBracketKeyword_2();
	}	
}

// (leftValues+=AssignmentValue ("," leftValues+=AssignmentValue)*)?
protected class MonoListAssignment_3_Group extends GroupToken {
	
	public MonoListAssignment_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMonoListAssignmentAccess().getGroup_3();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new MonoListAssignment_3_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new MonoListAssignment_3_0_Assignment_leftValues(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// leftValues+=AssignmentValue
protected class MonoListAssignment_3_0_Assignment_leftValues extends AssignmentToken  {
	
	public MonoListAssignment_3_0_Assignment_leftValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMonoListAssignmentAccess().getLeftValuesAssignment_3_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValues",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValues");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignmentValueRule().getType().getClassifier())) {
				Solution s = new AssignmentValue_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ("," leftValues+=AssignmentValue)*
protected class MonoListAssignment_3_1_Group extends GroupToken {
	
	public MonoListAssignment_3_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMonoListAssignmentAccess().getGroup_3_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new MonoListAssignment_3_1_1_Assignment_leftValues(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new MonoListAssignment_3_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// ","
protected class MonoListAssignment_3_1_0_Keyword extends KeywordToken  {
	
	public MonoListAssignment_3_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMonoListAssignmentAccess().getCommaKeyword_3_1_0();
	}	
}

// leftValues+=AssignmentValue
protected class MonoListAssignment_3_1_1_Assignment_leftValues extends AssignmentToken  {
	
	public MonoListAssignment_3_1_1_Assignment_leftValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMonoListAssignmentAccess().getLeftValuesAssignment_3_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValues",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValues");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignmentValueRule().getType().getClassifier())) {
				Solution s = new AssignmentValue_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// "]"
protected class MonoListAssignment_4_Keyword extends KeywordToken  {
	
	public MonoListAssignment_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMonoListAssignmentAccess().getRightSquareBracketKeyword_4();
	}	
}

// ";"
protected class MonoListAssignment_5_Keyword extends KeywordToken  {
	
	public MonoListAssignment_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMonoListAssignmentAccess().getSemicolonKeyword_5();
	}	
}


/************ end Rule MonoListAssignment ****************/


/************ begin Rule AssignmentValue ****************
 *
 * AssignmentValue:
 *   value=STRING|refObject=[NamedObject] ("." refFeature=ID ("[" refIndex=INT "]")?)?|newObject=CreatedObject|^import=[Import] impFrag=FRAGMENT;
 *
 **/

// value=STRING|refObject=[NamedObject] ("." refFeature=ID ("[" refIndex=INT "]")?)?|newObject=CreatedObject|^import=[Import] impFrag=FRAGMENT
protected class AssignmentValue_Alternatives extends AlternativesToken {

	public AssignmentValue_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AssignmentValue_0_Assignment_value(current, this);
			case 1: return new AssignmentValue_1_Group(current, this);
			case 2: return new AssignmentValue_2_Assignment_newObject(current, this);
			case 3: return new AssignmentValue_3_Group(current, this);
			default: return null;
		}
	}
}

// value=STRING
protected class AssignmentValue_0_Assignment_value extends AssignmentToken  {
	
	public AssignmentValue_0_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getValueAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAssignmentValueAccess().getValueSTRINGTerminalRuleCall_0_0();
			return new Solution(obj);
		}
		return null;
	}
}

// refObject=[NamedObject] ("." refFeature=ID ("[" refIndex=INT "]")?)?
protected class AssignmentValue_1_Group extends GroupToken {
	
	public AssignmentValue_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AssignmentValue_1_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AssignmentValue_1_0_Assignment_refObject(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// refObject=[NamedObject]
protected class AssignmentValue_1_0_Assignment_refObject extends AssignmentToken  {
	
	public AssignmentValue_1_0_Assignment_refObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getRefObjectAssignment_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refObject");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignmentValueAccess().getRefObjectNamedObjectCrossReference_1_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getAssignmentValueAccess().getRefObjectNamedObjectCrossReference_1_0_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// ("." refFeature=ID ("[" refIndex=INT "]")?)?
protected class AssignmentValue_1_1_Group extends GroupToken {
	
	public AssignmentValue_1_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getGroup_1_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AssignmentValue_1_1_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AssignmentValue_1_1_1_Assignment_refFeature(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new AssignmentValue_1_1_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "."
protected class AssignmentValue_1_1_0_Keyword extends KeywordToken  {
	
	public AssignmentValue_1_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getFullStopKeyword_1_1_0();
	}	
}

// refFeature=ID
protected class AssignmentValue_1_1_1_Assignment_refFeature extends AssignmentToken  {
	
	public AssignmentValue_1_1_1_Assignment_refFeature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getRefFeatureAssignment_1_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refFeature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refFeature");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAssignmentValueAccess().getRefFeatureIDTerminalRuleCall_1_1_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("[" refIndex=INT "]")?
protected class AssignmentValue_1_1_2_Group extends GroupToken {
	
	public AssignmentValue_1_1_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getGroup_1_1_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AssignmentValue_1_1_2_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AssignmentValue_1_1_2_1_Assignment_refIndex(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new AssignmentValue_1_1_2_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "["
protected class AssignmentValue_1_1_2_0_Keyword extends KeywordToken  {
	
	public AssignmentValue_1_1_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getLeftSquareBracketKeyword_1_1_2_0();
	}	
}

// refIndex=INT
protected class AssignmentValue_1_1_2_1_Assignment_refIndex extends AssignmentToken  {
	
	public AssignmentValue_1_1_2_1_Assignment_refIndex(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getRefIndexAssignment_1_1_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refIndex",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refIndex");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAssignmentValueAccess().getRefIndexINTTerminalRuleCall_1_1_2_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "]"
protected class AssignmentValue_1_1_2_2_Keyword extends KeywordToken  {
	
	public AssignmentValue_1_1_2_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getRightSquareBracketKeyword_1_1_2_2();
	}	
}




// newObject=CreatedObject
protected class AssignmentValue_2_Assignment_newObject extends AssignmentToken  {
	
	public AssignmentValue_2_Assignment_newObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getNewObjectAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("newObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("newObject");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCreatedObjectRule().getType().getClassifier())) {
				Solution s = new CreatedObject_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ^import=[Import] impFrag=FRAGMENT
protected class AssignmentValue_3_Group extends GroupToken {
	
	public AssignmentValue_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getGroup_3();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AssignmentValue_3_1_Assignment_impFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AssignmentValue_3_0_Assignment_import(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// ^import=[Import]
protected class AssignmentValue_3_0_Assignment_import extends AssignmentToken  {
	
	public AssignmentValue_3_0_Assignment_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getImportAssignment_3_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("import",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("import");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignmentValueAccess().getImportImportCrossReference_3_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getAssignmentValueAccess().getImportImportCrossReference_3_0_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// impFrag=FRAGMENT
protected class AssignmentValue_3_1_Assignment_impFrag extends AssignmentToken  {
	
	public AssignmentValue_3_1_Assignment_impFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentValueAccess().getImpFragAssignment_3_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("impFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("impFrag");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAssignmentValueAccess().getImpFragFRAGMENTTerminalRuleCall_3_1_0();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule AssignmentValue ****************/


/************ begin Rule ListAssignmentValue ****************
 *
 * ListAssignmentValue returns AssignmentValue:
 *   index=INT ":" ("[" refIndex=INT "]"|value=STRING|refObject=[NamedObject] ("." refFeature=ID ("[" refIndex=INT "]")?)?|newObject=CreatedObject|^import=[Import] impFrag=FRAGMENT);
 *
 **/

// index=INT ":" ("[" refIndex=INT "]"|value=STRING|refObject=[NamedObject] ("." refFeature=ID ("[" refIndex=INT "]")?)?|newObject=CreatedObject|^import=[Import] impFrag=FRAGMENT)
protected class ListAssignmentValue_Group extends GroupToken {
	
	public ListAssignmentValue_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_Alternatives(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_1_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ListAssignmentValue_0_Assignment_index(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// index=INT
protected class ListAssignmentValue_0_Assignment_index extends AssignmentToken  {
	
	public ListAssignmentValue_0_Assignment_index(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getIndexAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("index",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("index");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getListAssignmentValueAccess().getIndexINTTerminalRuleCall_0_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ":"
protected class ListAssignmentValue_1_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getColonKeyword_1();
	}	
}

// "[" refIndex=INT "]"|value=STRING|refObject=[NamedObject] ("." refFeature=ID ("[" refIndex=INT "]")?)?|newObject=CreatedObject|^import=[Import] impFrag=FRAGMENT
protected class ListAssignmentValue_2_Alternatives extends AlternativesToken {

	public ListAssignmentValue_2_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getAlternatives_2();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new ListAssignmentValue_2_0_Group(current, this);
			case 1: return new ListAssignmentValue_2_1_Assignment_value(current, this);
			case 2: return new ListAssignmentValue_2_2_Group(current, this);
			case 3: return new ListAssignmentValue_2_3_Assignment_newObject(current, this);
			case 4: return new ListAssignmentValue_2_4_Group(current, this);
			default: return null;
		}
	}
}

// "[" refIndex=INT "]"
protected class ListAssignmentValue_2_0_Group extends GroupToken {
	
	public ListAssignmentValue_2_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getGroup_2_0();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_0_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_2_0_1_Assignment_refIndex(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ListAssignmentValue_2_0_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "["
protected class ListAssignmentValue_2_0_0_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_2_0_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getLeftSquareBracketKeyword_2_0_0();
	}	
}

// refIndex=INT
protected class ListAssignmentValue_2_0_1_Assignment_refIndex extends AssignmentToken  {
	
	public ListAssignmentValue_2_0_1_Assignment_refIndex(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getRefIndexAssignment_2_0_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refIndex",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refIndex");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getListAssignmentValueAccess().getRefIndexINTTerminalRuleCall_2_0_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "]"
protected class ListAssignmentValue_2_0_2_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_2_0_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getRightSquareBracketKeyword_2_0_2();
	}	
}


// value=STRING
protected class ListAssignmentValue_2_1_Assignment_value extends AssignmentToken  {
	
	public ListAssignmentValue_2_1_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getValueAssignment_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getListAssignmentValueAccess().getValueSTRINGTerminalRuleCall_2_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// refObject=[NamedObject] ("." refFeature=ID ("[" refIndex=INT "]")?)?
protected class ListAssignmentValue_2_2_Group extends GroupToken {
	
	public ListAssignmentValue_2_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getGroup_2_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_2_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_2_2_0_Assignment_refObject(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// refObject=[NamedObject]
protected class ListAssignmentValue_2_2_0_Assignment_refObject extends AssignmentToken  {
	
	public ListAssignmentValue_2_2_0_Assignment_refObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getRefObjectAssignment_2_2_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refObject");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getListAssignmentValueAccess().getRefObjectNamedObjectCrossReference_2_2_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getListAssignmentValueAccess().getRefObjectNamedObjectCrossReference_2_2_0_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// ("." refFeature=ID ("[" refIndex=INT "]")?)?
protected class ListAssignmentValue_2_2_1_Group extends GroupToken {
	
	public ListAssignmentValue_2_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getGroup_2_2_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_2_1_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_2_2_1_1_Assignment_refFeature(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ListAssignmentValue_2_2_1_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "."
protected class ListAssignmentValue_2_2_1_0_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_2_2_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getFullStopKeyword_2_2_1_0();
	}	
}

// refFeature=ID
protected class ListAssignmentValue_2_2_1_1_Assignment_refFeature extends AssignmentToken  {
	
	public ListAssignmentValue_2_2_1_1_Assignment_refFeature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getRefFeatureAssignment_2_2_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refFeature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refFeature");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getListAssignmentValueAccess().getRefFeatureIDTerminalRuleCall_2_2_1_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("[" refIndex=INT "]")?
protected class ListAssignmentValue_2_2_1_2_Group extends GroupToken {
	
	public ListAssignmentValue_2_2_1_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getGroup_2_2_1_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_2_1_2_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_2_2_1_2_1_Assignment_refIndex(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ListAssignmentValue_2_2_1_2_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "["
protected class ListAssignmentValue_2_2_1_2_0_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_2_2_1_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getLeftSquareBracketKeyword_2_2_1_2_0();
	}	
}

// refIndex=INT
protected class ListAssignmentValue_2_2_1_2_1_Assignment_refIndex extends AssignmentToken  {
	
	public ListAssignmentValue_2_2_1_2_1_Assignment_refIndex(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getRefIndexAssignment_2_2_1_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refIndex",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refIndex");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getListAssignmentValueAccess().getRefIndexINTTerminalRuleCall_2_2_1_2_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "]"
protected class ListAssignmentValue_2_2_1_2_2_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_2_2_1_2_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getRightSquareBracketKeyword_2_2_1_2_2();
	}	
}




// newObject=CreatedObject
protected class ListAssignmentValue_2_3_Assignment_newObject extends AssignmentToken  {
	
	public ListAssignmentValue_2_3_Assignment_newObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getNewObjectAssignment_2_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("newObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("newObject");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCreatedObjectRule().getType().getClassifier())) {
				Solution s = new CreatedObject_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ^import=[Import] impFrag=FRAGMENT
protected class ListAssignmentValue_2_4_Group extends GroupToken {
	
	public ListAssignmentValue_2_4_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getGroup_2_4();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_4_1_Assignment_impFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_2_4_0_Assignment_import(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// ^import=[Import]
protected class ListAssignmentValue_2_4_0_Assignment_import extends AssignmentToken  {
	
	public ListAssignmentValue_2_4_0_Assignment_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getImportAssignment_2_4_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("import",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("import");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getListAssignmentValueAccess().getImportImportCrossReference_2_4_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getListAssignmentValueAccess().getImportImportCrossReference_2_4_0_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// impFrag=FRAGMENT
protected class ListAssignmentValue_2_4_1_Assignment_impFrag extends AssignmentToken  {
	
	public ListAssignmentValue_2_4_1_Assignment_impFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getListAssignmentValueAccess().getImpFragAssignment_2_4_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("impFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("impFrag");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getListAssignmentValueAccess().getImpFragFRAGMENTTerminalRuleCall_2_4_1_0();
			return new Solution(obj);
		}
		return null;
	}
}




/************ end Rule ListAssignmentValue ****************/


/************ begin Rule SingleAssignmentValue ****************
 *
 * SingleAssignmentValue returns AssignmentValue:
 *   keyword="null"|value=STRING|refObject=[NamedObject] ("." refFeature=ID ("[" refIndex=INT "]")?)?|newObject=CreatedObject|^import=[Import] impFrag=FRAGMENT;
 *
 **/

// keyword="null"|value=STRING|refObject=[NamedObject] ("." refFeature=ID ("[" refIndex=INT "]")?)?|newObject=CreatedObject|^import=[Import] impFrag=FRAGMENT
protected class SingleAssignmentValue_Alternatives extends AlternativesToken {

	public SingleAssignmentValue_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new SingleAssignmentValue_0_Assignment_keyword(current, this);
			case 1: return new SingleAssignmentValue_1_Assignment_value(current, this);
			case 2: return new SingleAssignmentValue_2_Group(current, this);
			case 3: return new SingleAssignmentValue_3_Assignment_newObject(current, this);
			case 4: return new SingleAssignmentValue_4_Group(current, this);
			default: return null;
		}
	}
}

// keyword="null"
protected class SingleAssignmentValue_0_Assignment_keyword extends AssignmentToken  {
	
	public SingleAssignmentValue_0_Assignment_keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getKeywordAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("keyword",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("keyword");

		if("null".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getSingleAssignmentValueAccess().getKeywordNullKeyword_0_0();
			return new Solution(obj);
		}

		return null;
	}
}

// value=STRING
protected class SingleAssignmentValue_1_Assignment_value extends AssignmentToken  {
	
	public SingleAssignmentValue_1_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getValueAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSingleAssignmentValueAccess().getValueSTRINGTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// refObject=[NamedObject] ("." refFeature=ID ("[" refIndex=INT "]")?)?
protected class SingleAssignmentValue_2_Group extends GroupToken {
	
	public SingleAssignmentValue_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SingleAssignmentValue_2_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SingleAssignmentValue_2_0_Assignment_refObject(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// refObject=[NamedObject]
protected class SingleAssignmentValue_2_0_Assignment_refObject extends AssignmentToken  {
	
	public SingleAssignmentValue_2_0_Assignment_refObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getRefObjectAssignment_2_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refObject");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSingleAssignmentValueAccess().getRefObjectNamedObjectCrossReference_2_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSingleAssignmentValueAccess().getRefObjectNamedObjectCrossReference_2_0_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// ("." refFeature=ID ("[" refIndex=INT "]")?)?
protected class SingleAssignmentValue_2_1_Group extends GroupToken {
	
	public SingleAssignmentValue_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getGroup_2_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SingleAssignmentValue_2_1_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SingleAssignmentValue_2_1_1_Assignment_refFeature(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new SingleAssignmentValue_2_1_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "."
protected class SingleAssignmentValue_2_1_0_Keyword extends KeywordToken  {
	
	public SingleAssignmentValue_2_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getFullStopKeyword_2_1_0();
	}	
}

// refFeature=ID
protected class SingleAssignmentValue_2_1_1_Assignment_refFeature extends AssignmentToken  {
	
	public SingleAssignmentValue_2_1_1_Assignment_refFeature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getRefFeatureAssignment_2_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refFeature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refFeature");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSingleAssignmentValueAccess().getRefFeatureIDTerminalRuleCall_2_1_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("[" refIndex=INT "]")?
protected class SingleAssignmentValue_2_1_2_Group extends GroupToken {
	
	public SingleAssignmentValue_2_1_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getGroup_2_1_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SingleAssignmentValue_2_1_2_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SingleAssignmentValue_2_1_2_1_Assignment_refIndex(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new SingleAssignmentValue_2_1_2_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "["
protected class SingleAssignmentValue_2_1_2_0_Keyword extends KeywordToken  {
	
	public SingleAssignmentValue_2_1_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getLeftSquareBracketKeyword_2_1_2_0();
	}	
}

// refIndex=INT
protected class SingleAssignmentValue_2_1_2_1_Assignment_refIndex extends AssignmentToken  {
	
	public SingleAssignmentValue_2_1_2_1_Assignment_refIndex(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getRefIndexAssignment_2_1_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refIndex",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refIndex");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSingleAssignmentValueAccess().getRefIndexINTTerminalRuleCall_2_1_2_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "]"
protected class SingleAssignmentValue_2_1_2_2_Keyword extends KeywordToken  {
	
	public SingleAssignmentValue_2_1_2_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getRightSquareBracketKeyword_2_1_2_2();
	}	
}




// newObject=CreatedObject
protected class SingleAssignmentValue_3_Assignment_newObject extends AssignmentToken  {
	
	public SingleAssignmentValue_3_Assignment_newObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getNewObjectAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("newObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("newObject");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCreatedObjectRule().getType().getClassifier())) {
				Solution s = new CreatedObject_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ^import=[Import] impFrag=FRAGMENT
protected class SingleAssignmentValue_4_Group extends GroupToken {
	
	public SingleAssignmentValue_4_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getGroup_4();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SingleAssignmentValue_4_1_Assignment_impFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SingleAssignmentValue_4_0_Assignment_import(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// ^import=[Import]
protected class SingleAssignmentValue_4_0_Assignment_import extends AssignmentToken  {
	
	public SingleAssignmentValue_4_0_Assignment_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getImportAssignment_4_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("import",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("import");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSingleAssignmentValueAccess().getImportImportCrossReference_4_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSingleAssignmentValueAccess().getImportImportCrossReference_4_0_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// impFrag=FRAGMENT
protected class SingleAssignmentValue_4_1_Assignment_impFrag extends AssignmentToken  {
	
	public SingleAssignmentValue_4_1_Assignment_impFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSingleAssignmentValueAccess().getImpFragAssignment_4_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("impFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("impFrag");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSingleAssignmentValueAccess().getImpFragFRAGMENTTerminalRuleCall_4_1_0();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule SingleAssignmentValue ****************/


/************ begin Rule CreatedObject ****************
 *
 * CreatedObject:
 *   (ObjectNew|ObjectCopy) (name=ID)? ("{" (assignments+=MonoSingleAssignment|assignments+=MonoListAssignment)+ (leftMig=Migration)? "}")?;
 *
 **/

// (ObjectNew|ObjectCopy) (name=ID)? ("{" (assignments+=MonoSingleAssignment|assignments+=MonoListAssignment)+ (leftMig=Migration)? "}")?
protected class CreatedObject_Group extends GroupToken {
	
	public CreatedObject_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CreatedObject_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CreatedObject_1_Assignment_name(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new CreatedObject_0_Alternatives(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// ObjectNew|ObjectCopy
protected class CreatedObject_0_Alternatives extends AlternativesToken {

	public CreatedObject_0_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getAlternatives_0();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new CreatedObject_0_0_RuleCall_ObjectNew(current, this);
			case 1: return new CreatedObject_0_1_RuleCall_ObjectCopy(current, this);
			default: return null;
		}
	}
}

// ObjectNew
protected class CreatedObject_0_0_RuleCall_ObjectNew extends RuleCallToken {
	
	public CreatedObject_0_0_RuleCall_ObjectNew(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getObjectNewParserRuleCall_0_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ObjectNew_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getObjectNewRule().getType().getClassifier())) return null;
		return new ObjectNew_Group(current, this).firstSolution();
	}
}

// ObjectCopy
protected class CreatedObject_0_1_RuleCall_ObjectCopy extends RuleCallToken {
	
	public CreatedObject_0_1_RuleCall_ObjectCopy(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getObjectCopyParserRuleCall_0_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ObjectCopy_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getObjectCopyRule().getType().getClassifier())) return null;
		return new ObjectCopy_Group(current, this).firstSolution();
	}
}


// (name=ID)?
protected class CreatedObject_1_Assignment_name extends AssignmentToken  {
	
	public CreatedObject_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getCreatedObjectAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("{" (assignments+=MonoSingleAssignment|assignments+=MonoListAssignment)+ (leftMig=Migration)? "}")?
protected class CreatedObject_2_Group extends GroupToken {
	
	public CreatedObject_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CreatedObject_2_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CreatedObject_2_2_Assignment_leftMig(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new CreatedObject_2_1_Alternatives(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new CreatedObject_2_0_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "{"
protected class CreatedObject_2_0_Keyword extends KeywordToken  {
	
	public CreatedObject_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getLeftCurlyBracketKeyword_2_0();
	}	
}

// (assignments+=MonoSingleAssignment|assignments+=MonoListAssignment)+
protected class CreatedObject_2_1_Alternatives extends AlternativesToken {

	public CreatedObject_2_1_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getAlternatives_2_1();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new CreatedObject_2_1_0_Assignment_assignments(current, this);
			case 1: return new CreatedObject_2_1_1_Assignment_assignments(current, this);
			default: return null;
		}
	}
}

// assignments+=MonoSingleAssignment
protected class CreatedObject_2_1_0_Assignment_assignments extends AssignmentToken  {
	
	public CreatedObject_2_1_0_Assignment_assignments(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getAssignmentsAssignment_2_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("assignments",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("assignments");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMonoSingleAssignmentRule().getType().getClassifier())) {
				Solution s = new MonoSingleAssignment_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// assignments+=MonoListAssignment
protected class CreatedObject_2_1_1_Assignment_assignments extends AssignmentToken  {
	
	public CreatedObject_2_1_1_Assignment_assignments(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getAssignmentsAssignment_2_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("assignments",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("assignments");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMonoListAssignmentRule().getType().getClassifier())) {
				Solution s = new MonoListAssignment_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// (leftMig=Migration)?
protected class CreatedObject_2_2_Assignment_leftMig extends AssignmentToken  {
	
	public CreatedObject_2_2_Assignment_leftMig(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getLeftMigAssignment_2_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftMig",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftMig");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMigrationRule().getType().getClassifier())) {
				Solution s = new Migration_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// "}"
protected class CreatedObject_2_3_Keyword extends KeywordToken  {
	
	public CreatedObject_2_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getCreatedObjectAccess().getRightCurlyBracketKeyword_2_3();
	}	
}



/************ end Rule CreatedObject ****************/


/************ begin Rule ObjectNew ****************
 *
 * ObjectNew:
 *   "new" ^import=[Import] impFrag=FRAGMENT;
 *
 **/

// "new" ^import=[Import] impFrag=FRAGMENT
protected class ObjectNew_Group extends GroupToken {
	
	public ObjectNew_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getObjectNewAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectNew_2_Assignment_impFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectNew_1_Assignment_import(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ObjectNew_0_Keyword_new(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "new"
protected class ObjectNew_0_Keyword_new extends KeywordToken  {
	
	public ObjectNew_0_Keyword_new(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getObjectNewAccess().getNewKeyword_0();
	}	
}

// ^import=[Import]
protected class ObjectNew_1_Assignment_import extends AssignmentToken  {
	
	public ObjectNew_1_Assignment_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectNewAccess().getImportAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("import",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("import");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getObjectNewAccess().getImportImportCrossReference_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getObjectNewAccess().getImportImportCrossReference_1_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// impFrag=FRAGMENT
protected class ObjectNew_2_Assignment_impFrag extends AssignmentToken  {
	
	public ObjectNew_2_Assignment_impFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectNewAccess().getImpFragAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("impFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("impFrag");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getObjectNewAccess().getImpFragFRAGMENTTerminalRuleCall_2_0();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule ObjectNew ****************/


/************ begin Rule ObjectCopy ****************
 *
 * ObjectCopy:
 *   "copy" resource=[NamedResource] fragment=FRAGMENT;
 *
 **/

// "copy" resource=[NamedResource] fragment=FRAGMENT
protected class ObjectCopy_Group extends GroupToken {
	
	public ObjectCopy_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getObjectCopyAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectCopy_2_Assignment_fragment(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectCopy_1_Assignment_resource(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ObjectCopy_0_Keyword_copy(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "copy"
protected class ObjectCopy_0_Keyword_copy extends KeywordToken  {
	
	public ObjectCopy_0_Keyword_copy(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getObjectCopyAccess().getCopyKeyword_0();
	}	
}

// resource=[NamedResource]
protected class ObjectCopy_1_Assignment_resource extends AssignmentToken  {
	
	public ObjectCopy_1_Assignment_resource(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectCopyAccess().getResourceAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("resource",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("resource");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getObjectCopyAccess().getResourceNamedResourceCrossReference_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getObjectCopyAccess().getResourceNamedResourceCrossReference_1_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// fragment=FRAGMENT
protected class ObjectCopy_2_Assignment_fragment extends AssignmentToken  {
	
	public ObjectCopy_2_Assignment_fragment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getObjectCopyAccess().getFragmentAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("fragment",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fragment");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getObjectCopyAccess().getFragmentFRAGMENTTerminalRuleCall_2_0();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule ObjectCopy ****************/


/************ begin Rule Migration ****************
 *
 * Migration:
 *   "migrate" (first=Executable)? ("as" asOp=Executable|"each" eachOp=Executable)? ";";
 *
 **/

// "migrate" (first=Executable)? ("as" asOp=Executable|"each" eachOp=Executable)? ";"
protected class Migration_Group extends GroupToken {
	
	public Migration_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMigrationAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Migration_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Migration_2_Alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Migration_1_Assignment_first(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Migration_0_Keyword_migrate(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "migrate"
protected class Migration_0_Keyword_migrate extends KeywordToken  {
	
	public Migration_0_Keyword_migrate(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMigrationAccess().getMigrateKeyword_0();
	}	
}

// (first=Executable)?
protected class Migration_1_Assignment_first extends AssignmentToken  {
	
	public Migration_1_Assignment_first(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMigrationAccess().getFirstAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("first",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("first");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExecutableRule().getType().getClassifier())) {
				Solution s = new Executable_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ("as" asOp=Executable|"each" eachOp=Executable)?
protected class Migration_2_Alternatives extends AlternativesToken {

	public Migration_2_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getMigrationAccess().getAlternatives_2();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Migration_2_0_Group(current, this);
			case 1: return new Migration_2_1_Group(current, this);
			default: return null;
		}
	}
}

// "as" asOp=Executable
protected class Migration_2_0_Group extends GroupToken {
	
	public Migration_2_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMigrationAccess().getGroup_2_0();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Migration_2_0_1_Assignment_asOp(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Migration_2_0_0_Keyword_as(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "as"
protected class Migration_2_0_0_Keyword_as extends KeywordToken  {
	
	public Migration_2_0_0_Keyword_as(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMigrationAccess().getAsKeyword_2_0_0();
	}	
}

// asOp=Executable
protected class Migration_2_0_1_Assignment_asOp extends AssignmentToken  {
	
	public Migration_2_0_1_Assignment_asOp(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMigrationAccess().getAsOpAssignment_2_0_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("asOp",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("asOp");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExecutableRule().getType().getClassifier())) {
				Solution s = new Executable_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// "each" eachOp=Executable
protected class Migration_2_1_Group extends GroupToken {
	
	public Migration_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getMigrationAccess().getGroup_2_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Migration_2_1_1_Assignment_eachOp(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Migration_2_1_0_Keyword_each(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "each"
protected class Migration_2_1_0_Keyword_each extends KeywordToken  {
	
	public Migration_2_1_0_Keyword_each(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMigrationAccess().getEachKeyword_2_1_0();
	}	
}

// eachOp=Executable
protected class Migration_2_1_1_Assignment_eachOp extends AssignmentToken  {
	
	public Migration_2_1_1_Assignment_eachOp(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getMigrationAccess().getEachOpAssignment_2_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("eachOp",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("eachOp");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExecutableRule().getType().getClassifier())) {
				Solution s = new Executable_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// ";"
protected class Migration_3_Keyword extends KeywordToken  {
	
	public Migration_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getMigrationAccess().getSemicolonKeyword_3();
	}	
}


/************ end Rule Migration ****************/


/************ begin Rule Executable ****************
 *
 * Executable:
 *   JavaExecutable|ExpressionExecutable;
 *
 **/

// JavaExecutable|ExpressionExecutable
protected class Executable_Alternatives extends AlternativesToken {

	public Executable_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getExecutableAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Executable_0_RuleCall_JavaExecutable(current, this);
			case 1: return new Executable_1_RuleCall_ExpressionExecutable(current, this);
			default: return null;
		}
	}
}

// JavaExecutable
protected class Executable_0_RuleCall_JavaExecutable extends RuleCallToken {
	
	public Executable_0_RuleCall_JavaExecutable(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExecutableAccess().getJavaExecutableParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(JavaExecutable_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getJavaExecutableRule().getType().getClassifier())) return null;
		return new JavaExecutable_Group(current, this).firstSolution();
	}
}

// ExpressionExecutable
protected class Executable_1_RuleCall_ExpressionExecutable extends RuleCallToken {
	
	public Executable_1_RuleCall_ExpressionExecutable(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExecutableAccess().getExpressionExecutableParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ExpressionExecutable_Assignment_exprstr.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getExpressionExecutableRule().getType().getClassifier())) return null;
		return new ExpressionExecutable_Assignment_exprstr(current, this).firstSolution();
	}
}


/************ end Rule Executable ****************/


/************ begin Rule JavaExecutable ****************
 *
 * JavaExecutable:
 *   "java" method=ID "(" ")";
 *
 **/

// "java" method=ID "(" ")"
protected class JavaExecutable_Group extends GroupToken {
	
	public JavaExecutable_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getJavaExecutableAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new JavaExecutable_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new JavaExecutable_2_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new JavaExecutable_1_Assignment_method(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new JavaExecutable_0_Keyword_java(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "java"
protected class JavaExecutable_0_Keyword_java extends KeywordToken  {
	
	public JavaExecutable_0_Keyword_java(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getJavaExecutableAccess().getJavaKeyword_0();
	}	
}

// method=ID
protected class JavaExecutable_1_Assignment_method extends AssignmentToken  {
	
	public JavaExecutable_1_Assignment_method(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getJavaExecutableAccess().getMethodAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("method",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("method");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getJavaExecutableAccess().getMethodIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "("
protected class JavaExecutable_2_Keyword extends KeywordToken  {
	
	public JavaExecutable_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getJavaExecutableAccess().getLeftParenthesisKeyword_2();
	}	
}

// ")"
protected class JavaExecutable_3_Keyword extends KeywordToken  {
	
	public JavaExecutable_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getJavaExecutableAccess().getRightParenthesisKeyword_3();
	}	
}


/************ end Rule JavaExecutable ****************/


/************ begin Rule ExpressionExecutable ****************
 *
 * ExpressionExecutable:
 *   exprstr=STRING;
 *
 **/

// exprstr=STRING
protected class ExpressionExecutable_Assignment_exprstr extends AssignmentToken  {
	
	public ExpressionExecutable_Assignment_exprstr(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getExpressionExecutableAccess().getExprstrAssignment();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("exprstr",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("exprstr");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getExpressionExecutableAccess().getExprstrSTRINGTerminalRuleCall_0();
			return new Solution(obj);
		}
		return null;
	}
}

/************ end Rule ExpressionExecutable ****************/

}
