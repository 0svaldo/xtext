/*
* generated by Xtext
*/
package org.eclipse.xtext.parser.epatch.parseTreeConstruction;

//import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.AbstractToken.Solution;
import org.eclipse.xtext.parser.epatch.services.EpatchTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class EpatchTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private EpatchTestLanguageGrammarAccess grammarAccess;
	
	@Override
	protected Solution internalSerialize(EObject obj) {
		IInstanceDescription inst = getDescr(obj);
		Solution s;
		if(inst.isInstanceOf(grammarAccess.prEPatch().getRule().getType().getType()) && (s = new EPatch_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prImport().getRule().getType().getType()) && (s = new Import_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prModelImport().getRule().getType().getType()) && (s = new ModelImport_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prResourceImport().getRule().getType().getType()) && (s = new ResourceImport_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prEPackageImport().getRule().getType().getType()) && (s = new EPackageImport_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prJavaImport().getRule().getType().getType()) && (s = new JavaImport_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prExtensionImport().getRule().getType().getType()) && (s = new ExtensionImport_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prNamedResource().getRule().getType().getType()) && (s = new NamedResource_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prNamedObject().getRule().getType().getType()) && (s = new NamedObject_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prObjectRef().getRule().getType().getType()) && (s = new ObjectRef_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAssignment().getRule().getType().getType()) && (s = new Assignment_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prBiSingleAssignment().getRule().getType().getType()) && (s = new BiSingleAssignment_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prBiListAssignment().getRule().getType().getType()) && (s = new BiListAssignment_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prMonoSingleAssignment().getRule().getType().getType()) && (s = new MonoSingleAssignment_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prMonoListAssignment().getRule().getType().getType()) && (s = new MonoListAssignment_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAssignmentValue().getRule().getType().getType()) && (s = new AssignmentValue_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prListAssignmentValue().getRule().getType().getType()) && (s = new ListAssignmentValue_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prSingleAssignmentValue().getRule().getType().getType()) && (s = new SingleAssignmentValue_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prCreatedObject().getRule().getType().getType()) && (s = new CreatedObject_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prObjectNew().getRule().getType().getType()) && (s = new ObjectNew_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prObjectCopy().getRule().getType().getType()) && (s = new ObjectCopy_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prMigration().getRule().getType().getType()) && (s = new Migration_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prExecutable().getRule().getType().getType()) && (s = new Executable_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prJavaExecutable().getRule().getType().getType()) && (s = new JavaExecutable_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prExpressionExecutable().getRule().getType().getType()) && (s = new ExpressionExecutable_Assignment_exprstr(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		return null;
	}
	

/************ begin Rule EPatch ****************
 *
 * not supported
 *
 **/


// not supported
protected class EPatch_Group extends GroupToken {
	
	public EPatch_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prEPatch().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new EPatch_6_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new EPatch_5_Assignment_objects(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new EPatch_4_Assignment_resources(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new EPatch_3_Assignment_imports(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new EPatch_2_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
		while(s5 != null) {
			Solution s6 = new EPatch_1_Assignment_name(s5.getCurrent(), s5.getPredecessor()).firstSolution();
		while(s6 != null) {
			Solution s7 = new EPatch_0_Keyword_epatch(s6.getCurrent(), s6.getPredecessor()).firstSolution();
			if(s7 != null) {
				last = s7.getPredecessor();
				return s7;
			} else {
				s6 = s6.getPredecessor().nextSolution(this,s6);
			}
		}
			s5 = s5.getPredecessor().nextSolution(this,s5);
		}
			s4 = s4.getPredecessor().nextSolution(this,s4);
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class EPatch_0_Keyword_epatch extends KeywordToken  {
	
	public EPatch_0_Keyword_epatch(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prEPatch().ele0KeywordEpatch();
	}	
}

// not supported
protected class EPatch_1_Assignment_name extends AssignmentToken  {
	
	public EPatch_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prEPatch().ele1AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prEPatch().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class EPatch_2_Keyword extends KeywordToken  {
	
	public EPatch_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prEPatch().ele2KeywordLeftCurlyBracket();
	}	
}

// not supported
protected class EPatch_3_Assignment_imports extends AssignmentToken  {
	
	public EPatch_3_Assignment_imports(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prEPatch().ele3AssignmentImports();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("imports",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("imports");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prImport().getRule().getType().getType())) {
				Solution s = new Import_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class EPatch_4_Assignment_resources extends AssignmentToken  {
	
	public EPatch_4_Assignment_resources(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prEPatch().ele4AssignmentResources();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("resources",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("resources");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prNamedResource().getRule().getType().getType())) {
				Solution s = new NamedResource_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class EPatch_5_Assignment_objects extends AssignmentToken  {
	
	public EPatch_5_Assignment_objects(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prEPatch().ele5AssignmentObjects();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("objects",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("objects");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prObjectRef().getRule().getType().getType())) {
				Solution s = new ObjectRef_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class EPatch_6_Keyword extends KeywordToken  {
	
	public EPatch_6_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prEPatch().ele6KeywordRightCurlyBracket();
	}	
}


/************ end Rule EPatch ****************/


/************ begin Rule Import ****************
 *
 * not supported
 *
 **/


// not supported
protected class Import_Alternatives extends AlternativesToken {

	public Import_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prImport().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Import_0_RuleCall_ModelImport(current, this);
			case 1: return new Import_1_RuleCall_JavaImport(current, this);
			case 2: return new Import_2_RuleCall_ExtensionImport(current, this);
			default: return null;
		}
	}
}

// not supported
protected class Import_0_RuleCall_ModelImport extends RuleCallToken {
	
	public Import_0_RuleCall_ModelImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prImport().ele0ParserRuleCallModelImport();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ModelImport_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prModelImport().getRule().getType().getType())) return null;
		return new ModelImport_Alternatives(current, this).firstSolution();
	}
}

// not supported
protected class Import_1_RuleCall_JavaImport extends RuleCallToken {
	
	public Import_1_RuleCall_JavaImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prImport().ele1ParserRuleCallJavaImport();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(JavaImport_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prJavaImport().getRule().getType().getType())) return null;
		return new JavaImport_Group(current, this).firstSolution();
	}
}

// not supported
protected class Import_2_RuleCall_ExtensionImport extends RuleCallToken {
	
	public Import_2_RuleCall_ExtensionImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prImport().ele2ParserRuleCallExtensionImport();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ExtensionImport_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prExtensionImport().getRule().getType().getType())) return null;
		return new ExtensionImport_Group(current, this).firstSolution();
	}
}


/************ end Rule Import ****************/


/************ begin Rule ModelImport ****************
 *
 * not supported
 *
 **/


// not supported
protected class ModelImport_Alternatives extends AlternativesToken {

	public ModelImport_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prModelImport().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new ModelImport_0_RuleCall_ResourceImport(current, this);
			case 1: return new ModelImport_1_RuleCall_EPackageImport(current, this);
			default: return null;
		}
	}
}

// not supported
protected class ModelImport_0_RuleCall_ResourceImport extends RuleCallToken {
	
	public ModelImport_0_RuleCall_ResourceImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prModelImport().ele0ParserRuleCallResourceImport();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ResourceImport_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prResourceImport().getRule().getType().getType())) return null;
		return new ResourceImport_Group(current, this).firstSolution();
	}
}

// not supported
protected class ModelImport_1_RuleCall_EPackageImport extends RuleCallToken {
	
	public ModelImport_1_RuleCall_EPackageImport(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prModelImport().ele1ParserRuleCallEPackageImport();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(EPackageImport_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prEPackageImport().getRule().getType().getType())) return null;
		return new EPackageImport_Group(current, this).firstSolution();
	}
}


/************ end Rule ModelImport ****************/


/************ begin Rule ResourceImport ****************
 *
 * not supported
 *
 **/


// not supported
protected class ResourceImport_Group extends GroupToken {
	
	public ResourceImport_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prResourceImport().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ResourceImport_3_Assignment_uri(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ResourceImport_2_Keyword_uri(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ResourceImport_1_Assignment_name(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new ResourceImport_0_Keyword_import(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ResourceImport_0_Keyword_import extends KeywordToken  {
	
	public ResourceImport_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prResourceImport().ele0KeywordImport();
	}	
}

// not supported
protected class ResourceImport_1_Assignment_name extends AssignmentToken  {
	
	public ResourceImport_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prResourceImport().ele1AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prResourceImport().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class ResourceImport_2_Keyword_uri extends KeywordToken  {
	
	public ResourceImport_2_Keyword_uri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prResourceImport().ele2KeywordUri();
	}	
}

// not supported
protected class ResourceImport_3_Assignment_uri extends AssignmentToken  {
	
	public ResourceImport_3_Assignment_uri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prResourceImport().ele3AssignmentUri();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("uri",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("uri");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prResourceImport().ele30TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule ResourceImport ****************/


/************ begin Rule EPackageImport ****************
 *
 * not supported
 *
 **/


// not supported
protected class EPackageImport_Group extends GroupToken {
	
	public EPackageImport_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prEPackageImport().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new EPackageImport_3_Assignment_nsURI(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new EPackageImport_2_Keyword_ns(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new EPackageImport_1_Assignment_name(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new EPackageImport_0_Keyword_import(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class EPackageImport_0_Keyword_import extends KeywordToken  {
	
	public EPackageImport_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prEPackageImport().ele0KeywordImport();
	}	
}

// not supported
protected class EPackageImport_1_Assignment_name extends AssignmentToken  {
	
	public EPackageImport_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prEPackageImport().ele1AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prEPackageImport().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class EPackageImport_2_Keyword_ns extends KeywordToken  {
	
	public EPackageImport_2_Keyword_ns(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prEPackageImport().ele2KeywordNs();
	}	
}

// not supported
protected class EPackageImport_3_Assignment_nsURI extends AssignmentToken  {
	
	public EPackageImport_3_Assignment_nsURI(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prEPackageImport().ele3AssignmentNsURI();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("nsURI",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nsURI");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prEPackageImport().ele30TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule EPackageImport ****************/


/************ begin Rule JavaImport ****************
 *
 * not supported
 *
 **/


// not supported
protected class JavaImport_Group extends GroupToken {
	
	public JavaImport_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prJavaImport().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new JavaImport_3_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new JavaImport_2_Assignment_path(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new JavaImport_1_Keyword_java(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new JavaImport_0_Keyword_import(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class JavaImport_0_Keyword_import extends KeywordToken  {
	
	public JavaImport_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prJavaImport().ele0KeywordImport();
	}	
}

// not supported
protected class JavaImport_1_Keyword_java extends KeywordToken  {
	
	public JavaImport_1_Keyword_java(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prJavaImport().ele1KeywordJava();
	}	
}

// not supported
protected class JavaImport_2_Assignment_path extends AssignmentToken  {
	
	public JavaImport_2_Assignment_path(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prJavaImport().ele2AssignmentPath();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("path",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("path");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prJavaImport().ele20TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class JavaImport_3_Group extends GroupToken {
	
	public JavaImport_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prJavaImport().ele3Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new JavaImport_3_1_Assignment_path(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new JavaImport_3_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class JavaImport_3_0_Keyword extends KeywordToken  {
	
	public JavaImport_3_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prJavaImport().ele30KeywordFullStop();
	}	
}

// not supported
protected class JavaImport_3_1_Assignment_path extends AssignmentToken  {
	
	public JavaImport_3_1_Assignment_path(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prJavaImport().ele31AssignmentPath();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("path",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("path");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prJavaImport().ele310TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule JavaImport ****************/


/************ begin Rule ExtensionImport ****************
 *
 * not supported
 *
 **/


// not supported
protected class ExtensionImport_Group extends GroupToken {
	
	public ExtensionImport_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prExtensionImport().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ExtensionImport_3_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ExtensionImport_2_Assignment_path(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ExtensionImport_1_Keyword_extension(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new ExtensionImport_0_Keyword_import(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ExtensionImport_0_Keyword_import extends KeywordToken  {
	
	public ExtensionImport_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prExtensionImport().ele0KeywordImport();
	}	
}

// not supported
protected class ExtensionImport_1_Keyword_extension extends KeywordToken  {
	
	public ExtensionImport_1_Keyword_extension(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prExtensionImport().ele1KeywordExtension();
	}	
}

// not supported
protected class ExtensionImport_2_Assignment_path extends AssignmentToken  {
	
	public ExtensionImport_2_Assignment_path(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prExtensionImport().ele2AssignmentPath();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("path",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("path");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prExtensionImport().ele20TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class ExtensionImport_3_Group extends GroupToken {
	
	public ExtensionImport_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prExtensionImport().ele3Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ExtensionImport_3_1_Assignment_path(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ExtensionImport_3_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class ExtensionImport_3_0_Keyword extends KeywordToken  {
	
	public ExtensionImport_3_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prExtensionImport().ele30KeywordColonColon();
	}	
}

// not supported
protected class ExtensionImport_3_1_Assignment_path extends AssignmentToken  {
	
	public ExtensionImport_3_1_Assignment_path(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prExtensionImport().ele31AssignmentPath();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("path",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("path");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prExtensionImport().ele310TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule ExtensionImport ****************/


/************ begin Rule NamedResource ****************
 *
 * not supported
 *
 **/


// not supported
protected class NamedResource_Group extends GroupToken {
	
	public NamedResource_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prNamedResource().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new NamedResource_9_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new NamedResource_8_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new NamedResource_7_Alternatives(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new NamedResource_6_Keyword_right(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new NamedResource_5_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
		while(s5 != null) {
			Solution s6 = new NamedResource_4_Alternatives(s5.getCurrent(), s5.getPredecessor()).firstSolution();
		while(s6 != null) {
			Solution s7 = new NamedResource_3_Keyword_left(s6.getCurrent(), s6.getPredecessor()).firstSolution();
		while(s7 != null) {
			Solution s8 = new NamedResource_2_Keyword(s7.getCurrent(), s7.getPredecessor()).firstSolution();
		while(s8 != null) {
			Solution s9 = new NamedResource_1_Assignment_name(s8.getCurrent(), s8.getPredecessor()).firstSolution();
		while(s9 != null) {
			Solution s10 = new NamedResource_0_Keyword_resource(s9.getCurrent(), s9.getPredecessor()).firstSolution();
			if(s10 != null) {
				last = s10.getPredecessor();
				return s10;
			} else {
				s9 = s9.getPredecessor().nextSolution(this,s9);
			}
		}
			s8 = s8.getPredecessor().nextSolution(this,s8);
		}
			s7 = s7.getPredecessor().nextSolution(this,s7);
		}
			s6 = s6.getPredecessor().nextSolution(this,s6);
		}
			s5 = s5.getPredecessor().nextSolution(this,s5);
		}
			s4 = s4.getPredecessor().nextSolution(this,s4);
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class NamedResource_0_Keyword_resource extends KeywordToken  {
	
	public NamedResource_0_Keyword_resource(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNamedResource().ele0KeywordResource();
	}	
}

// not supported
protected class NamedResource_1_Assignment_name extends AssignmentToken  {
	
	public NamedResource_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prNamedResource().ele1AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prNamedResource().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class NamedResource_2_Keyword extends KeywordToken  {
	
	public NamedResource_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNamedResource().ele2KeywordLeftCurlyBracket();
	}	
}

// not supported
protected class NamedResource_3_Keyword_left extends KeywordToken  {
	
	public NamedResource_3_Keyword_left(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNamedResource().ele3KeywordLeft();
	}	
}

// not supported
protected class NamedResource_4_Alternatives extends AlternativesToken {

	public NamedResource_4_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prNamedResource().ele4Alternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new NamedResource_4_0_Group(current, this);
			case 1: return new NamedResource_4_1_Assignment_leftRoot(current, this);
			default: return null;
		}
	}
}

// not supported
protected class NamedResource_4_0_Group extends GroupToken {
	
	public NamedResource_4_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prNamedResource().ele40Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new NamedResource_4_0_1_Assignment_leftUri(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new NamedResource_4_0_0_Keyword_uri(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class NamedResource_4_0_0_Keyword_uri extends KeywordToken  {
	
	public NamedResource_4_0_0_Keyword_uri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNamedResource().ele400KeywordUri();
	}	
}

// not supported
protected class NamedResource_4_0_1_Assignment_leftUri extends AssignmentToken  {
	
	public NamedResource_4_0_1_Assignment_leftUri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prNamedResource().ele401AssignmentLeftUri();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftUri",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftUri");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prNamedResource().ele4010TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}


// not supported
protected class NamedResource_4_1_Assignment_leftRoot extends AssignmentToken  {
	
	public NamedResource_4_1_Assignment_leftRoot(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prNamedResource().ele41AssignmentLeftRoot();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftRoot",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftRoot");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prCreatedObject().getRule().getType().getType())) {
				Solution s = new CreatedObject_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class NamedResource_5_Keyword extends KeywordToken  {
	
	public NamedResource_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNamedResource().ele5KeywordSemicolon();
	}	
}

// not supported
protected class NamedResource_6_Keyword_right extends KeywordToken  {
	
	public NamedResource_6_Keyword_right(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNamedResource().ele6KeywordRight();
	}	
}

// not supported
protected class NamedResource_7_Alternatives extends AlternativesToken {

	public NamedResource_7_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prNamedResource().ele7Alternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new NamedResource_7_0_Group(current, this);
			case 1: return new NamedResource_7_1_Assignment_rightRoot(current, this);
			default: return null;
		}
	}
}

// not supported
protected class NamedResource_7_0_Group extends GroupToken {
	
	public NamedResource_7_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prNamedResource().ele70Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new NamedResource_7_0_1_Assignment_rightUri(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new NamedResource_7_0_0_Keyword_uri(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class NamedResource_7_0_0_Keyword_uri extends KeywordToken  {
	
	public NamedResource_7_0_0_Keyword_uri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNamedResource().ele700KeywordUri();
	}	
}

// not supported
protected class NamedResource_7_0_1_Assignment_rightUri extends AssignmentToken  {
	
	public NamedResource_7_0_1_Assignment_rightUri(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prNamedResource().ele701AssignmentRightUri();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightUri",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightUri");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prNamedResource().ele7010TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}


// not supported
protected class NamedResource_7_1_Assignment_rightRoot extends AssignmentToken  {
	
	public NamedResource_7_1_Assignment_rightRoot(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prNamedResource().ele71AssignmentRightRoot();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightRoot",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightRoot");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prCreatedObject().getRule().getType().getType())) {
				Solution s = new CreatedObject_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class NamedResource_8_Keyword extends KeywordToken  {
	
	public NamedResource_8_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNamedResource().ele8KeywordSemicolon();
	}	
}

// not supported
protected class NamedResource_9_Keyword extends KeywordToken  {
	
	public NamedResource_9_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNamedResource().ele9KeywordRightCurlyBracket();
	}	
}


/************ end Rule NamedResource ****************/


/************ begin Rule NamedObject ****************
 *
 * not supported
 *
 **/


// not supported
protected class NamedObject_Alternatives extends AlternativesToken {

	public NamedObject_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prNamedObject().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new NamedObject_0_RuleCall_ObjectRef(current, this);
			case 1: return new NamedObject_1_RuleCall_CreatedObject(current, this);
			default: return null;
		}
	}
}

// not supported
protected class NamedObject_0_RuleCall_ObjectRef extends RuleCallToken {
	
	public NamedObject_0_RuleCall_ObjectRef(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prNamedObject().ele0ParserRuleCallObjectRef();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ObjectRef_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prObjectRef().getRule().getType().getType())) return null;
		return new ObjectRef_Group(current, this).firstSolution();
	}
}

// not supported
protected class NamedObject_1_RuleCall_CreatedObject extends RuleCallToken {
	
	public NamedObject_1_RuleCall_CreatedObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prNamedObject().ele1ParserRuleCallCreatedObject();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(CreatedObject_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prCreatedObject().getRule().getType().getType())) return null;
		return new CreatedObject_Group(current, this).firstSolution();
	}
}


/************ end Rule NamedObject ****************/


/************ begin Rule ObjectRef ****************
 *
 * not supported
 *
 **/


// not supported
protected class ObjectRef_Group extends GroupToken {
	
	public ObjectRef_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prObjectRef().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_3_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_2_Alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ObjectRef_1_Assignment_name(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new ObjectRef_0_Keyword_object(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ObjectRef_0_Keyword_object extends KeywordToken  {
	
	public ObjectRef_0_Keyword_object(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prObjectRef().ele0KeywordObject();
	}	
}

// not supported
protected class ObjectRef_1_Assignment_name extends AssignmentToken  {
	
	public ObjectRef_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectRef().ele1AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prObjectRef().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class ObjectRef_2_Alternatives extends AlternativesToken {

	public ObjectRef_2_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prObjectRef().ele2Alternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new ObjectRef_2_0_Group(current, this);
			case 1: return new ObjectRef_2_1_Group(current, this);
			default: return null;
		}
	}
}

// not supported
protected class ObjectRef_2_0_Group extends GroupToken {
	
	public ObjectRef_2_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prObjectRef().ele20Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_2_0_1_Assignment_leftFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_2_0_0_Assignment_leftRes(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class ObjectRef_2_0_0_Assignment_leftRes extends AssignmentToken  {
	
	public ObjectRef_2_0_0_Assignment_leftRes(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectRef().ele200AssignmentLeftRes();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftRes",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftRes");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prObjectRef().ele2000CrossReferenceEStringNamedResource().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prObjectRef().ele2000CrossReferenceEStringNamedResource(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class ObjectRef_2_0_1_Assignment_leftFrag extends AssignmentToken  {
	
	public ObjectRef_2_0_1_Assignment_leftFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectRef().ele201AssignmentLeftFrag();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftFrag");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prObjectRef().ele2010TerminalRuleCallFRAGMENT();
			return new Solution(obj);
		}
		return null;
	}
}


// not supported
protected class ObjectRef_2_1_Group extends GroupToken {
	
	public ObjectRef_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prObjectRef().ele21Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_2_1_5_Assignment_rightFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_2_1_4_Assignment_rightRes(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ObjectRef_2_1_3_Keyword_right(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new ObjectRef_2_1_2_Assignment_leftFrag(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new ObjectRef_2_1_1_Assignment_leftRes(s4.getCurrent(), s4.getPredecessor()).firstSolution();
		while(s5 != null) {
			Solution s6 = new ObjectRef_2_1_0_Keyword_left(s5.getCurrent(), s5.getPredecessor()).firstSolution();
			if(s6 != null) {
				last = s6.getPredecessor();
				return s6;
			} else {
				s5 = s5.getPredecessor().nextSolution(this,s5);
			}
		}
			s4 = s4.getPredecessor().nextSolution(this,s4);
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ObjectRef_2_1_0_Keyword_left extends KeywordToken  {
	
	public ObjectRef_2_1_0_Keyword_left(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prObjectRef().ele210KeywordLeft();
	}	
}

// not supported
protected class ObjectRef_2_1_1_Assignment_leftRes extends AssignmentToken  {
	
	public ObjectRef_2_1_1_Assignment_leftRes(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectRef().ele211AssignmentLeftRes();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftRes",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftRes");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prObjectRef().ele2110CrossReferenceEStringNamedResource().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prObjectRef().ele2110CrossReferenceEStringNamedResource(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class ObjectRef_2_1_2_Assignment_leftFrag extends AssignmentToken  {
	
	public ObjectRef_2_1_2_Assignment_leftFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectRef().ele212AssignmentLeftFrag();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftFrag");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prObjectRef().ele2120TerminalRuleCallFRAGMENT();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class ObjectRef_2_1_3_Keyword_right extends KeywordToken  {
	
	public ObjectRef_2_1_3_Keyword_right(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prObjectRef().ele213KeywordRight();
	}	
}

// not supported
protected class ObjectRef_2_1_4_Assignment_rightRes extends AssignmentToken  {
	
	public ObjectRef_2_1_4_Assignment_rightRes(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectRef().ele214AssignmentRightRes();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightRes",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightRes");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prObjectRef().ele2140CrossReferenceEStringNamedResource().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prObjectRef().ele2140CrossReferenceEStringNamedResource(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class ObjectRef_2_1_5_Assignment_rightFrag extends AssignmentToken  {
	
	public ObjectRef_2_1_5_Assignment_rightFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectRef().ele215AssignmentRightFrag();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightFrag");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prObjectRef().ele2150TerminalRuleCallFRAGMENT();
			return new Solution(obj);
		}
		return null;
	}
}



// not supported
protected class ObjectRef_3_Group extends GroupToken {
	
	public ObjectRef_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prObjectRef().ele3Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_3_4_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_3_3_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ObjectRef_3_2_Group(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new ObjectRef_3_1_Alternatives(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new ObjectRef_3_0_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
			if(s5 != null) {
				last = s5.getPredecessor();
				return s5;
			} else {
				s4 = s4.getPredecessor().nextSolution(this,s4);
			}
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ObjectRef_3_0_Keyword extends KeywordToken  {
	
	public ObjectRef_3_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prObjectRef().ele30KeywordLeftCurlyBracket();
	}	
}

// not supported
protected class ObjectRef_3_1_Alternatives extends AlternativesToken {

	public ObjectRef_3_1_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prObjectRef().ele31Alternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new ObjectRef_3_1_0_Assignment_assignments(current, this);
			case 1: return new ObjectRef_3_1_1_Assignment_assignments(current, this);
			default: return null;
		}
	}
}

// not supported
protected class ObjectRef_3_1_0_Assignment_assignments extends AssignmentToken  {
	
	public ObjectRef_3_1_0_Assignment_assignments(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectRef().ele310AssignmentAssignments();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("assignments",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("assignments");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prBiSingleAssignment().getRule().getType().getType())) {
				Solution s = new BiSingleAssignment_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class ObjectRef_3_1_1_Assignment_assignments extends AssignmentToken  {
	
	public ObjectRef_3_1_1_Assignment_assignments(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectRef().ele311AssignmentAssignments();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("assignments",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("assignments");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prBiListAssignment().getRule().getType().getType())) {
				Solution s = new BiListAssignment_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class ObjectRef_3_2_Group extends GroupToken {
	
	public ObjectRef_3_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prObjectRef().ele32Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_3_2_1_Assignment_leftMig(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_3_2_0_Keyword_left(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class ObjectRef_3_2_0_Keyword_left extends KeywordToken  {
	
	public ObjectRef_3_2_0_Keyword_left(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prObjectRef().ele320KeywordLeft();
	}	
}

// not supported
protected class ObjectRef_3_2_1_Assignment_leftMig extends AssignmentToken  {
	
	public ObjectRef_3_2_1_Assignment_leftMig(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectRef().ele321AssignmentLeftMig();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftMig",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftMig");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prMigration().getRule().getType().getType())) {
				Solution s = new Migration_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class ObjectRef_3_3_Group extends GroupToken {
	
	public ObjectRef_3_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prObjectRef().ele33Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectRef_3_3_1_Assignment_rightMig(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectRef_3_3_0_Keyword_right(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class ObjectRef_3_3_0_Keyword_right extends KeywordToken  {
	
	public ObjectRef_3_3_0_Keyword_right(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prObjectRef().ele330KeywordRight();
	}	
}

// not supported
protected class ObjectRef_3_3_1_Assignment_rightMig extends AssignmentToken  {
	
	public ObjectRef_3_3_1_Assignment_rightMig(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectRef().ele331AssignmentRightMig();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightMig",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightMig");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prMigration().getRule().getType().getType())) {
				Solution s = new Migration_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class ObjectRef_3_4_Keyword extends KeywordToken  {
	
	public ObjectRef_3_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prObjectRef().ele34KeywordRightCurlyBracket();
	}	
}



/************ end Rule ObjectRef ****************/


/************ begin Rule Assignment ****************
 *
 * not supported
 *
 **/


// not supported
protected class Assignment_Alternatives extends AlternativesToken {

	public Assignment_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prAssignment().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Assignment_0_RuleCall_BiSingleAssignment(current, this);
			case 1: return new Assignment_1_RuleCall_BiListAssignment(current, this);
			case 2: return new Assignment_2_RuleCall_MonoSingleAssignment(current, this);
			case 3: return new Assignment_3_RuleCall_MonoListAssignment(current, this);
			default: return null;
		}
	}
}

// not supported
protected class Assignment_0_RuleCall_BiSingleAssignment extends RuleCallToken {
	
	public Assignment_0_RuleCall_BiSingleAssignment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAssignment().ele0ParserRuleCallBiSingleAssignment();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(BiSingleAssignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prBiSingleAssignment().getRule().getType().getType())) return null;
		return new BiSingleAssignment_Group(current, this).firstSolution();
	}
}

// not supported
protected class Assignment_1_RuleCall_BiListAssignment extends RuleCallToken {
	
	public Assignment_1_RuleCall_BiListAssignment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAssignment().ele1ParserRuleCallBiListAssignment();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(BiListAssignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prBiListAssignment().getRule().getType().getType())) return null;
		return new BiListAssignment_Group(current, this).firstSolution();
	}
}

// not supported
protected class Assignment_2_RuleCall_MonoSingleAssignment extends RuleCallToken {
	
	public Assignment_2_RuleCall_MonoSingleAssignment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAssignment().ele2ParserRuleCallMonoSingleAssignment();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(MonoSingleAssignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prMonoSingleAssignment().getRule().getType().getType())) return null;
		return new MonoSingleAssignment_Group(current, this).firstSolution();
	}
}

// not supported
protected class Assignment_3_RuleCall_MonoListAssignment extends RuleCallToken {
	
	public Assignment_3_RuleCall_MonoListAssignment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAssignment().ele3ParserRuleCallMonoListAssignment();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(MonoListAssignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prMonoListAssignment().getRule().getType().getType())) return null;
		return new MonoListAssignment_Group(current, this).firstSolution();
	}
}


/************ end Rule Assignment ****************/


/************ begin Rule BiSingleAssignment ****************
 *
 * not supported
 *
 **/


// not supported
protected class BiSingleAssignment_Group extends GroupToken {
	
	public BiSingleAssignment_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prBiSingleAssignment().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiSingleAssignment_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiSingleAssignment_4_Assignment_rightValue(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new BiSingleAssignment_3_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new BiSingleAssignment_2_Assignment_leftValue(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new BiSingleAssignment_1_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
		while(s5 != null) {
			Solution s6 = new BiSingleAssignment_0_Assignment_feature(s5.getCurrent(), s5.getPredecessor()).firstSolution();
			if(s6 != null) {
				last = s6.getPredecessor();
				return s6;
			} else {
				s5 = s5.getPredecessor().nextSolution(this,s5);
			}
		}
			s4 = s4.getPredecessor().nextSolution(this,s4);
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class BiSingleAssignment_0_Assignment_feature extends AssignmentToken  {
	
	public BiSingleAssignment_0_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prBiSingleAssignment().ele0AssignmentFeature();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prBiSingleAssignment().ele00TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class BiSingleAssignment_1_Keyword extends KeywordToken  {
	
	public BiSingleAssignment_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBiSingleAssignment().ele1KeywordEqualsSign();
	}	
}

// not supported
protected class BiSingleAssignment_2_Assignment_leftValue extends AssignmentToken  {
	
	public BiSingleAssignment_2_Assignment_leftValue(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prBiSingleAssignment().ele2AssignmentLeftValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValue",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValue");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prSingleAssignmentValue().getRule().getType().getType())) {
				Solution s = new SingleAssignmentValue_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class BiSingleAssignment_3_Keyword extends KeywordToken  {
	
	public BiSingleAssignment_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBiSingleAssignment().ele3KeywordVerticalLine();
	}	
}

// not supported
protected class BiSingleAssignment_4_Assignment_rightValue extends AssignmentToken  {
	
	public BiSingleAssignment_4_Assignment_rightValue(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prBiSingleAssignment().ele4AssignmentRightValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightValue",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightValue");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prSingleAssignmentValue().getRule().getType().getType())) {
				Solution s = new SingleAssignmentValue_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class BiSingleAssignment_5_Keyword extends KeywordToken  {
	
	public BiSingleAssignment_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBiSingleAssignment().ele5KeywordSemicolon();
	}	
}


/************ end Rule BiSingleAssignment ****************/


/************ begin Rule BiListAssignment ****************
 *
 * not supported
 *
 **/


// not supported
protected class BiListAssignment_Group extends GroupToken {
	
	public BiListAssignment_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prBiListAssignment().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiListAssignment_7_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiListAssignment_6_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new BiListAssignment_5_Group(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new BiListAssignment_4_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new BiListAssignment_3_Group(s4.getCurrent(), s4.getPredecessor()).firstSolution();
		while(s5 != null) {
			Solution s6 = new BiListAssignment_2_Keyword(s5.getCurrent(), s5.getPredecessor()).firstSolution();
		while(s6 != null) {
			Solution s7 = new BiListAssignment_1_Keyword(s6.getCurrent(), s6.getPredecessor()).firstSolution();
		while(s7 != null) {
			Solution s8 = new BiListAssignment_0_Assignment_feature(s7.getCurrent(), s7.getPredecessor()).firstSolution();
			if(s8 != null) {
				last = s8.getPredecessor();
				return s8;
			} else {
				s7 = s7.getPredecessor().nextSolution(this,s7);
			}
		}
			s6 = s6.getPredecessor().nextSolution(this,s6);
		}
			s5 = s5.getPredecessor().nextSolution(this,s5);
		}
			s4 = s4.getPredecessor().nextSolution(this,s4);
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class BiListAssignment_0_Assignment_feature extends AssignmentToken  {
	
	public BiListAssignment_0_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele0AssignmentFeature();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prBiListAssignment().ele00TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class BiListAssignment_1_Keyword extends KeywordToken  {
	
	public BiListAssignment_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele1KeywordEqualsSign();
	}	
}

// not supported
protected class BiListAssignment_2_Keyword extends KeywordToken  {
	
	public BiListAssignment_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele2KeywordLeftSquareBracket();
	}	
}

// not supported
protected class BiListAssignment_3_Group extends GroupToken {
	
	public BiListAssignment_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele3Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiListAssignment_3_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiListAssignment_3_0_Assignment_leftValues(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class BiListAssignment_3_0_Assignment_leftValues extends AssignmentToken  {
	
	public BiListAssignment_3_0_Assignment_leftValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele30AssignmentLeftValues();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValues",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValues");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prListAssignmentValue().getRule().getType().getType())) {
				Solution s = new ListAssignmentValue_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class BiListAssignment_3_1_Group extends GroupToken {
	
	public BiListAssignment_3_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele31Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiListAssignment_3_1_1_Assignment_leftValues(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiListAssignment_3_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class BiListAssignment_3_1_0_Keyword extends KeywordToken  {
	
	public BiListAssignment_3_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele310KeywordComma();
	}	
}

// not supported
protected class BiListAssignment_3_1_1_Assignment_leftValues extends AssignmentToken  {
	
	public BiListAssignment_3_1_1_Assignment_leftValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele311AssignmentLeftValues();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValues",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValues");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prListAssignmentValue().getRule().getType().getType())) {
				Solution s = new ListAssignmentValue_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// not supported
protected class BiListAssignment_4_Keyword extends KeywordToken  {
	
	public BiListAssignment_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele4KeywordVerticalLine();
	}	
}

// not supported
protected class BiListAssignment_5_Group extends GroupToken {
	
	public BiListAssignment_5_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele5Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiListAssignment_5_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiListAssignment_5_0_Assignment_rightValues(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class BiListAssignment_5_0_Assignment_rightValues extends AssignmentToken  {
	
	public BiListAssignment_5_0_Assignment_rightValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele50AssignmentRightValues();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightValues",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightValues");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prListAssignmentValue().getRule().getType().getType())) {
				Solution s = new ListAssignmentValue_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class BiListAssignment_5_1_Group extends GroupToken {
	
	public BiListAssignment_5_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele51Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new BiListAssignment_5_1_1_Assignment_rightValues(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new BiListAssignment_5_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class BiListAssignment_5_1_0_Keyword extends KeywordToken  {
	
	public BiListAssignment_5_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele510KeywordComma();
	}	
}

// not supported
protected class BiListAssignment_5_1_1_Assignment_rightValues extends AssignmentToken  {
	
	public BiListAssignment_5_1_1_Assignment_rightValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele511AssignmentRightValues();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rightValues",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rightValues");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prListAssignmentValue().getRule().getType().getType())) {
				Solution s = new ListAssignmentValue_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// not supported
protected class BiListAssignment_6_Keyword extends KeywordToken  {
	
	public BiListAssignment_6_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele6KeywordRightSquareBracket();
	}	
}

// not supported
protected class BiListAssignment_7_Keyword extends KeywordToken  {
	
	public BiListAssignment_7_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prBiListAssignment().ele7KeywordSemicolon();
	}	
}


/************ end Rule BiListAssignment ****************/


/************ begin Rule MonoSingleAssignment ****************
 *
 * not supported
 *
 **/


// not supported
protected class MonoSingleAssignment_Group extends GroupToken {
	
	public MonoSingleAssignment_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prMonoSingleAssignment().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new MonoSingleAssignment_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new MonoSingleAssignment_2_Assignment_leftValue(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new MonoSingleAssignment_1_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new MonoSingleAssignment_0_Assignment_feature(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class MonoSingleAssignment_0_Assignment_feature extends AssignmentToken  {
	
	public MonoSingleAssignment_0_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prMonoSingleAssignment().ele0AssignmentFeature();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prMonoSingleAssignment().ele00TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class MonoSingleAssignment_1_Keyword extends KeywordToken  {
	
	public MonoSingleAssignment_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prMonoSingleAssignment().ele1KeywordEqualsSign();
	}	
}

// not supported
protected class MonoSingleAssignment_2_Assignment_leftValue extends AssignmentToken  {
	
	public MonoSingleAssignment_2_Assignment_leftValue(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prMonoSingleAssignment().ele2AssignmentLeftValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValue",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValue");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prSingleAssignmentValue().getRule().getType().getType())) {
				Solution s = new SingleAssignmentValue_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class MonoSingleAssignment_3_Keyword extends KeywordToken  {
	
	public MonoSingleAssignment_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prMonoSingleAssignment().ele3KeywordSemicolon();
	}	
}


/************ end Rule MonoSingleAssignment ****************/


/************ begin Rule MonoListAssignment ****************
 *
 * not supported
 *
 **/


// not supported
protected class MonoListAssignment_Group extends GroupToken {
	
	public MonoListAssignment_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prMonoListAssignment().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new MonoListAssignment_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new MonoListAssignment_4_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new MonoListAssignment_3_Group(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new MonoListAssignment_2_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new MonoListAssignment_1_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
		while(s5 != null) {
			Solution s6 = new MonoListAssignment_0_Assignment_feature(s5.getCurrent(), s5.getPredecessor()).firstSolution();
			if(s6 != null) {
				last = s6.getPredecessor();
				return s6;
			} else {
				s5 = s5.getPredecessor().nextSolution(this,s5);
			}
		}
			s4 = s4.getPredecessor().nextSolution(this,s4);
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class MonoListAssignment_0_Assignment_feature extends AssignmentToken  {
	
	public MonoListAssignment_0_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prMonoListAssignment().ele0AssignmentFeature();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prMonoListAssignment().ele00TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class MonoListAssignment_1_Keyword extends KeywordToken  {
	
	public MonoListAssignment_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prMonoListAssignment().ele1KeywordEqualsSign();
	}	
}

// not supported
protected class MonoListAssignment_2_Keyword extends KeywordToken  {
	
	public MonoListAssignment_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prMonoListAssignment().ele2KeywordLeftSquareBracket();
	}	
}

// not supported
protected class MonoListAssignment_3_Group extends GroupToken {
	
	public MonoListAssignment_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prMonoListAssignment().ele3Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new MonoListAssignment_3_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new MonoListAssignment_3_0_Assignment_leftValues(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class MonoListAssignment_3_0_Assignment_leftValues extends AssignmentToken  {
	
	public MonoListAssignment_3_0_Assignment_leftValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prMonoListAssignment().ele30AssignmentLeftValues();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValues",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValues");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAssignmentValue().getRule().getType().getType())) {
				Solution s = new AssignmentValue_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class MonoListAssignment_3_1_Group extends GroupToken {
	
	public MonoListAssignment_3_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prMonoListAssignment().ele31Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new MonoListAssignment_3_1_1_Assignment_leftValues(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new MonoListAssignment_3_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class MonoListAssignment_3_1_0_Keyword extends KeywordToken  {
	
	public MonoListAssignment_3_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prMonoListAssignment().ele310KeywordComma();
	}	
}

// not supported
protected class MonoListAssignment_3_1_1_Assignment_leftValues extends AssignmentToken  {
	
	public MonoListAssignment_3_1_1_Assignment_leftValues(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prMonoListAssignment().ele311AssignmentLeftValues();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftValues",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftValues");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAssignmentValue().getRule().getType().getType())) {
				Solution s = new AssignmentValue_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// not supported
protected class MonoListAssignment_4_Keyword extends KeywordToken  {
	
	public MonoListAssignment_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prMonoListAssignment().ele4KeywordRightSquareBracket();
	}	
}

// not supported
protected class MonoListAssignment_5_Keyword extends KeywordToken  {
	
	public MonoListAssignment_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prMonoListAssignment().ele5KeywordSemicolon();
	}	
}


/************ end Rule MonoListAssignment ****************/


/************ begin Rule AssignmentValue ****************
 *
 * not supported
 *
 **/


// not supported
protected class AssignmentValue_Alternatives extends AlternativesToken {

	public AssignmentValue_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prAssignmentValue().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AssignmentValue_0_Assignment_value(current, this);
			case 1: return new AssignmentValue_1_Group(current, this);
			case 2: return new AssignmentValue_2_Assignment_newObject(current, this);
			case 3: return new AssignmentValue_3_Group(current, this);
			default: return null;
		}
	}
}

// not supported
protected class AssignmentValue_0_Assignment_value extends AssignmentToken  {
	
	public AssignmentValue_0_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele0AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prAssignmentValue().ele00TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class AssignmentValue_1_Group extends GroupToken {
	
	public AssignmentValue_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele1Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AssignmentValue_1_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AssignmentValue_1_0_Assignment_refObject(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class AssignmentValue_1_0_Assignment_refObject extends AssignmentToken  {
	
	public AssignmentValue_1_0_Assignment_refObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele10AssignmentRefObject();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refObject");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAssignmentValue().ele100CrossReferenceEStringNamedObject().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prAssignmentValue().ele100CrossReferenceEStringNamedObject(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class AssignmentValue_1_1_Group extends GroupToken {
	
	public AssignmentValue_1_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele11Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AssignmentValue_1_1_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AssignmentValue_1_1_1_Assignment_refFeature(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new AssignmentValue_1_1_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class AssignmentValue_1_1_0_Keyword extends KeywordToken  {
	
	public AssignmentValue_1_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele110KeywordFullStop();
	}	
}

// not supported
protected class AssignmentValue_1_1_1_Assignment_refFeature extends AssignmentToken  {
	
	public AssignmentValue_1_1_1_Assignment_refFeature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele111AssignmentRefFeature();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refFeature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refFeature");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prAssignmentValue().ele1110TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class AssignmentValue_1_1_2_Group extends GroupToken {
	
	public AssignmentValue_1_1_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele112Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AssignmentValue_1_1_2_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AssignmentValue_1_1_2_1_Assignment_refIndex(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new AssignmentValue_1_1_2_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class AssignmentValue_1_1_2_0_Keyword extends KeywordToken  {
	
	public AssignmentValue_1_1_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele1120KeywordLeftSquareBracket();
	}	
}

// not supported
protected class AssignmentValue_1_1_2_1_Assignment_refIndex extends AssignmentToken  {
	
	public AssignmentValue_1_1_2_1_Assignment_refIndex(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele1121AssignmentRefIndex();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refIndex",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refIndex");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prAssignmentValue().ele11210TerminalRuleCallINT();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class AssignmentValue_1_1_2_2_Keyword extends KeywordToken  {
	
	public AssignmentValue_1_1_2_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele1122KeywordRightSquareBracket();
	}	
}




// not supported
protected class AssignmentValue_2_Assignment_newObject extends AssignmentToken  {
	
	public AssignmentValue_2_Assignment_newObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele2AssignmentNewObject();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("newObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("newObject");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prCreatedObject().getRule().getType().getType())) {
				Solution s = new CreatedObject_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class AssignmentValue_3_Group extends GroupToken {
	
	public AssignmentValue_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele3Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AssignmentValue_3_1_Assignment_impFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AssignmentValue_3_0_Assignment_import(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class AssignmentValue_3_0_Assignment_import extends AssignmentToken  {
	
	public AssignmentValue_3_0_Assignment_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele30AssignmentImport();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("import",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("import");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAssignmentValue().ele300CrossReferenceEStringImport().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prAssignmentValue().ele300CrossReferenceEStringImport(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class AssignmentValue_3_1_Assignment_impFrag extends AssignmentToken  {
	
	public AssignmentValue_3_1_Assignment_impFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAssignmentValue().ele31AssignmentImpFrag();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("impFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("impFrag");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prAssignmentValue().ele310TerminalRuleCallFRAGMENT();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule AssignmentValue ****************/


/************ begin Rule ListAssignmentValue ****************
 *
 * not supported
 *
 **/


// not supported
protected class ListAssignmentValue_Group extends GroupToken {
	
	public ListAssignmentValue_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prListAssignmentValue().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_Alternatives(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_1_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ListAssignmentValue_0_Assignment_index(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_0_Assignment_index extends AssignmentToken  {
	
	public ListAssignmentValue_0_Assignment_index(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele0AssignmentIndex();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("index",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("index");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prListAssignmentValue().ele00TerminalRuleCallINT();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_1_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele1KeywordColon();
	}	
}

// not supported
protected class ListAssignmentValue_2_Alternatives extends AlternativesToken {

	public ListAssignmentValue_2_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele2Alternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new ListAssignmentValue_2_0_Group(current, this);
			case 1: return new ListAssignmentValue_2_1_Assignment_value(current, this);
			case 2: return new ListAssignmentValue_2_2_Group(current, this);
			case 3: return new ListAssignmentValue_2_3_Assignment_newObject(current, this);
			case 4: return new ListAssignmentValue_2_4_Group(current, this);
			default: return null;
		}
	}
}

// not supported
protected class ListAssignmentValue_2_0_Group extends GroupToken {
	
	public ListAssignmentValue_2_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele20Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_0_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_2_0_1_Assignment_refIndex(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ListAssignmentValue_2_0_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_0_0_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_2_0_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele200KeywordLeftSquareBracket();
	}	
}

// not supported
protected class ListAssignmentValue_2_0_1_Assignment_refIndex extends AssignmentToken  {
	
	public ListAssignmentValue_2_0_1_Assignment_refIndex(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele201AssignmentRefIndex();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refIndex",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refIndex");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prListAssignmentValue().ele2010TerminalRuleCallINT();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_0_2_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_2_0_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele202KeywordRightSquareBracket();
	}	
}


// not supported
protected class ListAssignmentValue_2_1_Assignment_value extends AssignmentToken  {
	
	public ListAssignmentValue_2_1_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele21AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prListAssignmentValue().ele210TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_2_Group extends GroupToken {
	
	public ListAssignmentValue_2_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele22Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_2_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_2_2_0_Assignment_refObject(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_2_0_Assignment_refObject extends AssignmentToken  {
	
	public ListAssignmentValue_2_2_0_Assignment_refObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele220AssignmentRefObject();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refObject");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prListAssignmentValue().ele2200CrossReferenceEStringNamedObject().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prListAssignmentValue().ele2200CrossReferenceEStringNamedObject(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_2_1_Group extends GroupToken {
	
	public ListAssignmentValue_2_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele221Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_2_1_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_2_2_1_1_Assignment_refFeature(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ListAssignmentValue_2_2_1_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_2_1_0_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_2_2_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele2210KeywordFullStop();
	}	
}

// not supported
protected class ListAssignmentValue_2_2_1_1_Assignment_refFeature extends AssignmentToken  {
	
	public ListAssignmentValue_2_2_1_1_Assignment_refFeature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele2211AssignmentRefFeature();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refFeature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refFeature");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prListAssignmentValue().ele22110TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_2_1_2_Group extends GroupToken {
	
	public ListAssignmentValue_2_2_1_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele2212Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_2_1_2_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_2_2_1_2_1_Assignment_refIndex(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ListAssignmentValue_2_2_1_2_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_2_1_2_0_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_2_2_1_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele22120KeywordLeftSquareBracket();
	}	
}

// not supported
protected class ListAssignmentValue_2_2_1_2_1_Assignment_refIndex extends AssignmentToken  {
	
	public ListAssignmentValue_2_2_1_2_1_Assignment_refIndex(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele22121AssignmentRefIndex();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refIndex",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refIndex");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prListAssignmentValue().ele221210TerminalRuleCallINT();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_2_1_2_2_Keyword extends KeywordToken  {
	
	public ListAssignmentValue_2_2_1_2_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele22122KeywordRightSquareBracket();
	}	
}




// not supported
protected class ListAssignmentValue_2_3_Assignment_newObject extends AssignmentToken  {
	
	public ListAssignmentValue_2_3_Assignment_newObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele23AssignmentNewObject();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("newObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("newObject");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prCreatedObject().getRule().getType().getType())) {
				Solution s = new CreatedObject_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_4_Group extends GroupToken {
	
	public ListAssignmentValue_2_4_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele24Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ListAssignmentValue_2_4_1_Assignment_impFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ListAssignmentValue_2_4_0_Assignment_import(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_4_0_Assignment_import extends AssignmentToken  {
	
	public ListAssignmentValue_2_4_0_Assignment_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele240AssignmentImport();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("import",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("import");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prListAssignmentValue().ele2400CrossReferenceEStringImport().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prListAssignmentValue().ele2400CrossReferenceEStringImport(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class ListAssignmentValue_2_4_1_Assignment_impFrag extends AssignmentToken  {
	
	public ListAssignmentValue_2_4_1_Assignment_impFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prListAssignmentValue().ele241AssignmentImpFrag();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("impFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("impFrag");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prListAssignmentValue().ele2410TerminalRuleCallFRAGMENT();
			return new Solution(obj);
		}
		return null;
	}
}




/************ end Rule ListAssignmentValue ****************/


/************ begin Rule SingleAssignmentValue ****************
 *
 * not supported
 *
 **/


// not supported
protected class SingleAssignmentValue_Alternatives extends AlternativesToken {

	public SingleAssignmentValue_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new SingleAssignmentValue_0_Assignment_keyword(current, this);
			case 1: return new SingleAssignmentValue_1_Assignment_value(current, this);
			case 2: return new SingleAssignmentValue_2_Group(current, this);
			case 3: return new SingleAssignmentValue_3_Assignment_newObject(current, this);
			case 4: return new SingleAssignmentValue_4_Group(current, this);
			default: return null;
		}
	}
}

// not supported
protected class SingleAssignmentValue_0_Assignment_keyword extends AssignmentToken  {
	
	public SingleAssignmentValue_0_Assignment_keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele0AssignmentKeyword();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("keyword",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("keyword");

		if("null".equals(value)) { // xtext::Keyword
			type = AssignmentType.KW;
			element = grammarAccess.prSingleAssignmentValue().ele00KeywordNull();
			return new Solution(obj);
		}

		return null;
	}
}

// not supported
protected class SingleAssignmentValue_1_Assignment_value extends AssignmentToken  {
	
	public SingleAssignmentValue_1_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele1AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prSingleAssignmentValue().ele10TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class SingleAssignmentValue_2_Group extends GroupToken {
	
	public SingleAssignmentValue_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele2Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SingleAssignmentValue_2_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SingleAssignmentValue_2_0_Assignment_refObject(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class SingleAssignmentValue_2_0_Assignment_refObject extends AssignmentToken  {
	
	public SingleAssignmentValue_2_0_Assignment_refObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele20AssignmentRefObject();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refObject");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prSingleAssignmentValue().ele200CrossReferenceEStringNamedObject().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prSingleAssignmentValue().ele200CrossReferenceEStringNamedObject(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class SingleAssignmentValue_2_1_Group extends GroupToken {
	
	public SingleAssignmentValue_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele21Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SingleAssignmentValue_2_1_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SingleAssignmentValue_2_1_1_Assignment_refFeature(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new SingleAssignmentValue_2_1_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class SingleAssignmentValue_2_1_0_Keyword extends KeywordToken  {
	
	public SingleAssignmentValue_2_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele210KeywordFullStop();
	}	
}

// not supported
protected class SingleAssignmentValue_2_1_1_Assignment_refFeature extends AssignmentToken  {
	
	public SingleAssignmentValue_2_1_1_Assignment_refFeature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele211AssignmentRefFeature();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refFeature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refFeature");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prSingleAssignmentValue().ele2110TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class SingleAssignmentValue_2_1_2_Group extends GroupToken {
	
	public SingleAssignmentValue_2_1_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele212Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SingleAssignmentValue_2_1_2_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SingleAssignmentValue_2_1_2_1_Assignment_refIndex(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new SingleAssignmentValue_2_1_2_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class SingleAssignmentValue_2_1_2_0_Keyword extends KeywordToken  {
	
	public SingleAssignmentValue_2_1_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele2120KeywordLeftSquareBracket();
	}	
}

// not supported
protected class SingleAssignmentValue_2_1_2_1_Assignment_refIndex extends AssignmentToken  {
	
	public SingleAssignmentValue_2_1_2_1_Assignment_refIndex(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele2121AssignmentRefIndex();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("refIndex",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("refIndex");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prSingleAssignmentValue().ele21210TerminalRuleCallINT();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class SingleAssignmentValue_2_1_2_2_Keyword extends KeywordToken  {
	
	public SingleAssignmentValue_2_1_2_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele2122KeywordRightSquareBracket();
	}	
}




// not supported
protected class SingleAssignmentValue_3_Assignment_newObject extends AssignmentToken  {
	
	public SingleAssignmentValue_3_Assignment_newObject(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele3AssignmentNewObject();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("newObject",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("newObject");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prCreatedObject().getRule().getType().getType())) {
				Solution s = new CreatedObject_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class SingleAssignmentValue_4_Group extends GroupToken {
	
	public SingleAssignmentValue_4_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele4Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SingleAssignmentValue_4_1_Assignment_impFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SingleAssignmentValue_4_0_Assignment_import(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class SingleAssignmentValue_4_0_Assignment_import extends AssignmentToken  {
	
	public SingleAssignmentValue_4_0_Assignment_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele40AssignmentImport();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("import",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("import");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prSingleAssignmentValue().ele400CrossReferenceEStringImport().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prSingleAssignmentValue().ele400CrossReferenceEStringImport(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class SingleAssignmentValue_4_1_Assignment_impFrag extends AssignmentToken  {
	
	public SingleAssignmentValue_4_1_Assignment_impFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSingleAssignmentValue().ele41AssignmentImpFrag();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("impFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("impFrag");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prSingleAssignmentValue().ele410TerminalRuleCallFRAGMENT();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule SingleAssignmentValue ****************/


/************ begin Rule CreatedObject ****************
 *
 * not supported
 *
 **/


// not supported
protected class CreatedObject_Group extends GroupToken {
	
	public CreatedObject_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prCreatedObject().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CreatedObject_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CreatedObject_1_Assignment_name(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new CreatedObject_0_Alternatives(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class CreatedObject_0_Alternatives extends AlternativesToken {

	public CreatedObject_0_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prCreatedObject().ele0Alternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new CreatedObject_0_0_RuleCall_ObjectNew(current, this);
			case 1: return new CreatedObject_0_1_RuleCall_ObjectCopy(current, this);
			default: return null;
		}
	}
}

// not supported
protected class CreatedObject_0_0_RuleCall_ObjectNew extends RuleCallToken {
	
	public CreatedObject_0_0_RuleCall_ObjectNew(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prCreatedObject().ele00ParserRuleCallObjectNew();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ObjectNew_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prObjectNew().getRule().getType().getType())) return null;
		return new ObjectNew_Group(current, this).firstSolution();
	}
}

// not supported
protected class CreatedObject_0_1_RuleCall_ObjectCopy extends RuleCallToken {
	
	public CreatedObject_0_1_RuleCall_ObjectCopy(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prCreatedObject().ele01ParserRuleCallObjectCopy();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ObjectCopy_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prObjectCopy().getRule().getType().getType())) return null;
		return new ObjectCopy_Group(current, this).firstSolution();
	}
}


// not supported
protected class CreatedObject_1_Assignment_name extends AssignmentToken  {
	
	public CreatedObject_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prCreatedObject().ele1AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prCreatedObject().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class CreatedObject_2_Group extends GroupToken {
	
	public CreatedObject_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prCreatedObject().ele2Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CreatedObject_2_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CreatedObject_2_2_Assignment_leftMig(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new CreatedObject_2_1_Alternatives(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new CreatedObject_2_0_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class CreatedObject_2_0_Keyword extends KeywordToken  {
	
	public CreatedObject_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prCreatedObject().ele20KeywordLeftCurlyBracket();
	}	
}

// not supported
protected class CreatedObject_2_1_Alternatives extends AlternativesToken {

	public CreatedObject_2_1_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prCreatedObject().ele21Alternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new CreatedObject_2_1_0_Assignment_assignments(current, this);
			case 1: return new CreatedObject_2_1_1_Assignment_assignments(current, this);
			default: return null;
		}
	}
}

// not supported
protected class CreatedObject_2_1_0_Assignment_assignments extends AssignmentToken  {
	
	public CreatedObject_2_1_0_Assignment_assignments(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prCreatedObject().ele210AssignmentAssignments();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("assignments",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("assignments");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prMonoSingleAssignment().getRule().getType().getType())) {
				Solution s = new MonoSingleAssignment_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class CreatedObject_2_1_1_Assignment_assignments extends AssignmentToken  {
	
	public CreatedObject_2_1_1_Assignment_assignments(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prCreatedObject().ele211AssignmentAssignments();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("assignments",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("assignments");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prMonoListAssignment().getRule().getType().getType())) {
				Solution s = new MonoListAssignment_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class CreatedObject_2_2_Assignment_leftMig extends AssignmentToken  {
	
	public CreatedObject_2_2_Assignment_leftMig(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prCreatedObject().ele22AssignmentLeftMig();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("leftMig",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("leftMig");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prMigration().getRule().getType().getType())) {
				Solution s = new Migration_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class CreatedObject_2_3_Keyword extends KeywordToken  {
	
	public CreatedObject_2_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prCreatedObject().ele23KeywordRightCurlyBracket();
	}	
}



/************ end Rule CreatedObject ****************/


/************ begin Rule ObjectNew ****************
 *
 * not supported
 *
 **/


// not supported
protected class ObjectNew_Group extends GroupToken {
	
	public ObjectNew_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prObjectNew().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectNew_2_Assignment_impFrag(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectNew_1_Assignment_import(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ObjectNew_0_Keyword_new(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ObjectNew_0_Keyword_new extends KeywordToken  {
	
	public ObjectNew_0_Keyword_new(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prObjectNew().ele0KeywordNew();
	}	
}

// not supported
protected class ObjectNew_1_Assignment_import extends AssignmentToken  {
	
	public ObjectNew_1_Assignment_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectNew().ele1AssignmentImport();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("import",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("import");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prObjectNew().ele10CrossReferenceEStringImport().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prObjectNew().ele10CrossReferenceEStringImport(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class ObjectNew_2_Assignment_impFrag extends AssignmentToken  {
	
	public ObjectNew_2_Assignment_impFrag(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectNew().ele2AssignmentImpFrag();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("impFrag",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("impFrag");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prObjectNew().ele20TerminalRuleCallFRAGMENT();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule ObjectNew ****************/


/************ begin Rule ObjectCopy ****************
 *
 * not supported
 *
 **/


// not supported
protected class ObjectCopy_Group extends GroupToken {
	
	public ObjectCopy_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prObjectCopy().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ObjectCopy_2_Assignment_fragment(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ObjectCopy_1_Assignment_resource(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new ObjectCopy_0_Keyword_copy(s2.getCurrent(), s2.getPredecessor()).firstSolution();
			if(s3 != null) {
				last = s3.getPredecessor();
				return s3;
			} else {
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class ObjectCopy_0_Keyword_copy extends KeywordToken  {
	
	public ObjectCopy_0_Keyword_copy(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prObjectCopy().ele0KeywordCopy();
	}	
}

// not supported
protected class ObjectCopy_1_Assignment_resource extends AssignmentToken  {
	
	public ObjectCopy_1_Assignment_resource(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectCopy().ele1AssignmentResource();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("resource",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("resource");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prObjectCopy().ele10CrossReferenceEStringNamedResource().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prObjectCopy().ele10CrossReferenceEStringNamedResource(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class ObjectCopy_2_Assignment_fragment extends AssignmentToken  {
	
	public ObjectCopy_2_Assignment_fragment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prObjectCopy().ele2AssignmentFragment();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("fragment",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("fragment");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prObjectCopy().ele20TerminalRuleCallFRAGMENT();
			return new Solution(obj);
		}
		return null;
	}
}


/************ end Rule ObjectCopy ****************/


/************ begin Rule Migration ****************
 *
 * not supported
 *
 **/


// not supported
protected class Migration_Group extends GroupToken {
	
	public Migration_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prMigration().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Migration_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Migration_2_Alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Migration_1_Assignment_first(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new Migration_0_Keyword_migrate(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Migration_0_Keyword_migrate extends KeywordToken  {
	
	public Migration_0_Keyword_migrate(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prMigration().ele0KeywordMigrate();
	}	
}

// not supported
protected class Migration_1_Assignment_first extends AssignmentToken  {
	
	public Migration_1_Assignment_first(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prMigration().ele1AssignmentFirst();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("first",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("first");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prExecutable().getRule().getType().getType())) {
				Solution s = new Executable_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class Migration_2_Alternatives extends AlternativesToken {

	public Migration_2_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prMigration().ele2Alternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Migration_2_0_Group(current, this);
			case 1: return new Migration_2_1_Group(current, this);
			default: return null;
		}
	}
}

// not supported
protected class Migration_2_0_Group extends GroupToken {
	
	public Migration_2_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prMigration().ele20Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Migration_2_0_1_Assignment_asOp(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Migration_2_0_0_Keyword_as(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Migration_2_0_0_Keyword_as extends KeywordToken  {
	
	public Migration_2_0_0_Keyword_as(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prMigration().ele200KeywordAs();
	}	
}

// not supported
protected class Migration_2_0_1_Assignment_asOp extends AssignmentToken  {
	
	public Migration_2_0_1_Assignment_asOp(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prMigration().ele201AssignmentAsOp();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("asOp",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("asOp");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prExecutable().getRule().getType().getType())) {
				Solution s = new Executable_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class Migration_2_1_Group extends GroupToken {
	
	public Migration_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prMigration().ele21Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Migration_2_1_1_Assignment_eachOp(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Migration_2_1_0_Keyword_each(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Migration_2_1_0_Keyword_each extends KeywordToken  {
	
	public Migration_2_1_0_Keyword_each(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prMigration().ele210KeywordEach();
	}	
}

// not supported
protected class Migration_2_1_1_Assignment_eachOp extends AssignmentToken  {
	
	public Migration_2_1_1_Assignment_eachOp(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prMigration().ele211AssignmentEachOp();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("eachOp",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("eachOp");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prExecutable().getRule().getType().getType())) {
				Solution s = new Executable_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// not supported
protected class Migration_3_Keyword extends KeywordToken  {
	
	public Migration_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prMigration().ele3KeywordSemicolon();
	}	
}


/************ end Rule Migration ****************/


/************ begin Rule Executable ****************
 *
 * not supported
 *
 **/


// not supported
protected class Executable_Alternatives extends AlternativesToken {

	public Executable_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prExecutable().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Executable_0_RuleCall_JavaExecutable(current, this);
			case 1: return new Executable_1_RuleCall_ExpressionExecutable(current, this);
			default: return null;
		}
	}
}

// not supported
protected class Executable_0_RuleCall_JavaExecutable extends RuleCallToken {
	
	public Executable_0_RuleCall_JavaExecutable(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prExecutable().ele0ParserRuleCallJavaExecutable();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(JavaExecutable_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prJavaExecutable().getRule().getType().getType())) return null;
		return new JavaExecutable_Group(current, this).firstSolution();
	}
}

// not supported
protected class Executable_1_RuleCall_ExpressionExecutable extends RuleCallToken {
	
	public Executable_1_RuleCall_ExpressionExecutable(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prExecutable().ele1ParserRuleCallExpressionExecutable();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ExpressionExecutable_Assignment_exprstr.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prExpressionExecutable().getRule().getType().getType())) return null;
		return new ExpressionExecutable_Assignment_exprstr(current, this).firstSolution();
	}
}


/************ end Rule Executable ****************/


/************ begin Rule JavaExecutable ****************
 *
 * not supported
 *
 **/


// not supported
protected class JavaExecutable_Group extends GroupToken {
	
	public JavaExecutable_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prJavaExecutable().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new JavaExecutable_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new JavaExecutable_2_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new JavaExecutable_1_Assignment_method(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new JavaExecutable_0_Keyword_java(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class JavaExecutable_0_Keyword_java extends KeywordToken  {
	
	public JavaExecutable_0_Keyword_java(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prJavaExecutable().ele0KeywordJava();
	}	
}

// not supported
protected class JavaExecutable_1_Assignment_method extends AssignmentToken  {
	
	public JavaExecutable_1_Assignment_method(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prJavaExecutable().ele1AssignmentMethod();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("method",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("method");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prJavaExecutable().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class JavaExecutable_2_Keyword extends KeywordToken  {
	
	public JavaExecutable_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prJavaExecutable().ele2KeywordLeftParenthesis();
	}	
}

// not supported
protected class JavaExecutable_3_Keyword extends KeywordToken  {
	
	public JavaExecutable_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prJavaExecutable().ele3KeywordRightParenthesis();
	}	
}


/************ end Rule JavaExecutable ****************/


/************ begin Rule ExpressionExecutable ****************
 *
 * not supported
 *
 **/


// not supported
protected class ExpressionExecutable_Assignment_exprstr extends AssignmentToken  {
	
	public ExpressionExecutable_Assignment_exprstr(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prExpressionExecutable().eleAssignmentExprstr();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("exprstr",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("exprstr");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prExpressionExecutable().ele0TerminalRuleCallSTRING();
			return new Solution(obj);
		}
		return null;
	}
}

/************ end Rule ExpressionExecutable ****************/

}
