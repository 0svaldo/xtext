/*
* generated by Xtext
*/
package org.eclipse.xtext.parser.terminalrules.parseTreeConstruction;

//import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.AbstractToken.Solution;
import org.eclipse.xtext.parser.terminalrules.services.XtextTerminalsTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class XtextTerminalsTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private XtextTerminalsTestLanguageGrammarAccess grammarAccess;
	
	@Override
	protected Solution internalSerialize(EObject obj) {
		IInstanceDescription inst = getDescr(obj);
		Solution s;
		if(inst.isInstanceOf(grammarAccess.getGrammarRule().getType().getClassifier()) && (s = new Grammar_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAbstractRuleRule().getType().getClassifier()) && (s = new AbstractRule_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAbstractMetamodelDeclarationRule().getType().getClassifier()) && (s = new AbstractMetamodelDeclaration_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getGeneratedMetamodelRule().getType().getClassifier()) && (s = new GeneratedMetamodel_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getReferencedMetamodelRule().getType().getClassifier()) && (s = new ReferencedMetamodel_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getParserRuleRule().getType().getClassifier()) && (s = new ParserRule_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier()) && (s = new TypeRef_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAlternativesRule().getType().getClassifier()) && (s = new Alternatives_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getGroupRule().getType().getClassifier()) && (s = new Group_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAbstractTokenRule().getType().getClassifier()) && (s = new AbstractToken_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAbstractTokenWithCardinalityRule().getType().getClassifier()) && (s = new AbstractTokenWithCardinality_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getActionRule().getType().getClassifier()) && (s = new Action_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAbstractTerminalRule().getType().getClassifier()) && (s = new AbstractTerminal_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier()) && (s = new Keyword_Assignment_value(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getRuleCallRule().getType().getClassifier()) && (s = new RuleCall_Assignment_rule(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier()) && (s = new Assignment_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAssignableTerminalRule().getType().getClassifier()) && (s = new AssignableTerminal_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getParenthesizedAssignableElementRule().getType().getClassifier()) && (s = new ParenthesizedAssignableElement_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAssignableAlternativesRule().getType().getClassifier()) && (s = new AssignableAlternatives_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getCrossReferenceRule().getType().getClassifier()) && (s = new CrossReference_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getCrossReferenceableTerminalRule().getType().getClassifier()) && (s = new CrossReferenceableTerminal_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getParenthesizedCrossReferenceableElementRule().getType().getClassifier()) && (s = new ParenthesizedCrossReferenceableElement_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getCrossReferenceableAlternativesRule().getType().getClassifier()) && (s = new CrossReferenceableAlternatives_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getParenthesizedElementRule().getType().getClassifier()) && (s = new ParenthesizedElement_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTerminalRuleRule().getType().getClassifier()) && (s = new TerminalRule_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTerminalAlternativesRule().getType().getClassifier()) && (s = new TerminalAlternatives_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTerminalGroupRule().getType().getClassifier()) && (s = new TerminalGroup_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTerminalTokenRule().getType().getClassifier()) && (s = new TerminalToken_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getTerminalTokenElementRule().getType().getClassifier()) && (s = new TerminalTokenElement_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getParenthesizedTerminalElementRule().getType().getClassifier()) && (s = new ParenthesizedTerminalElement_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAbstractNegatedTokenRule().getType().getClassifier()) && (s = new AbstractNegatedToken_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getNegatedTokenRule().getType().getClassifier()) && (s = new NegatedToken_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getUntilTokenRule().getType().getClassifier()) && (s = new UntilToken_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getWildcardRule().getType().getClassifier()) && (s = new Wildcard_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getCharacterRangeRule().getType().getClassifier()) && (s = new CharacterRange_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getEnumRuleRule().getType().getClassifier()) && (s = new EnumRule_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getEnumLiteralsRule().getType().getClassifier()) && (s = new EnumLiterals_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getEnumLiteralDeclarationRule().getType().getClassifier()) && (s = new EnumLiteralDeclaration_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		return null;
	}
	

/************ begin Rule Grammar ****************
 *
 * Grammar:
 *   "grammar" name=GrammarID ("with" usedGrammars+=[Grammar|GrammarID] ("," usedGrammars+=[Grammar|GrammarID])*)? (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=[AbstractRule])*)? ")")? (metamodelDeclarations+=AbstractMetamodelDeclaration)* (rules+=AbstractRule)+;
 *
 **/

// "grammar" name=GrammarID ("with" usedGrammars+=[Grammar|GrammarID] ("," usedGrammars+=[Grammar|GrammarID])*)? (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=[AbstractRule])*)? ")")? (metamodelDeclarations+=AbstractMetamodelDeclaration)* (rules+=AbstractRule)+
protected class Grammar_Group extends GroupToken {
	
	public Grammar_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_5_Assignment_rules(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_4_Assignment_metamodelDeclarations(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Grammar_3_Group(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Grammar_2_Group(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new Grammar_1_Assignment_name(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new Grammar_0_Keyword_grammar(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							if(s6 != null) {
								last = s6.getPredecessor();
								return s6;
							} else {
								s5 = s5.getPredecessor().nextSolution(this,s5);
							}
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "grammar"
protected class Grammar_0_Keyword_grammar extends KeywordToken  {
	
	public Grammar_0_Keyword_grammar(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGrammarKeyword_0();
	}	
}

// name=GrammarID
protected class Grammar_1_Assignment_name extends AssignmentToken  {
	
	public Grammar_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");

		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for datatype rule
			type = AssignmentType.PRC;
			element = grammarAccess.getGrammarAccess().getNameGrammarIDParserRuleCall_1_0();
			return new Solution(obj);
		}

		return null;
	}
}

// ("with" usedGrammars+=[Grammar|GrammarID] ("," usedGrammars+=[Grammar|GrammarID])*)?
protected class Grammar_2_Group extends GroupToken {
	
	public Grammar_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_2_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_2_1_Assignment_usedGrammars(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Grammar_2_0_Keyword_with(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "with"
protected class Grammar_2_0_Keyword_with extends KeywordToken  {
	
	public Grammar_2_0_Keyword_with(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getWithKeyword_2_0();
	}	
}

// usedGrammars+=[Grammar|GrammarID]
protected class Grammar_2_1_Assignment_usedGrammars extends AssignmentToken  {
	
	public Grammar_2_1_Assignment_usedGrammars(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getUsedGrammarsAssignment_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("usedGrammars",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("usedGrammars");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGrammarAccess().getUsedGrammarsGrammarCrossReference_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getGrammarAccess().getUsedGrammarsGrammarCrossReference_2_1_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// ("," usedGrammars+=[Grammar|GrammarID])*
protected class Grammar_2_2_Group extends GroupToken {
	
	public Grammar_2_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup_2_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_2_2_1_Assignment_usedGrammars(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_2_2_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// ","
protected class Grammar_2_2_0_Keyword extends KeywordToken  {
	
	public Grammar_2_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getCommaKeyword_2_2_0();
	}	
}

// usedGrammars+=[Grammar|GrammarID]
protected class Grammar_2_2_1_Assignment_usedGrammars extends AssignmentToken  {
	
	public Grammar_2_2_1_Assignment_usedGrammars(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getUsedGrammarsAssignment_2_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("usedGrammars",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("usedGrammars");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGrammarAccess().getUsedGrammarsGrammarCrossReference_2_2_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getGrammarAccess().getUsedGrammarsGrammarCrossReference_2_2_1_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}



// (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=[AbstractRule])*)? ")")?
protected class Grammar_3_Group extends GroupToken {
	
	public Grammar_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup_3();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_3_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_3_2_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Grammar_3_1_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Grammar_3_0_Assignment_definesHiddenTokens(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// definesHiddenTokens?="hidden"
protected class Grammar_3_0_Assignment_definesHiddenTokens extends AssignmentToken  {
	
	public Grammar_3_0_Assignment_definesHiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getDefinesHiddenTokensAssignment_3_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("definesHiddenTokens",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("definesHiddenTokens");

		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getGrammarAccess().getDefinesHiddenTokensHiddenKeyword_3_0_0();
			return new Solution(obj);
		}

		return null;
	}
}

// "("
protected class Grammar_3_1_Keyword extends KeywordToken  {
	
	public Grammar_3_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getLeftParenthesisKeyword_3_1();
	}	
}

// (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=[AbstractRule])*)?
protected class Grammar_3_2_Group extends GroupToken {
	
	public Grammar_3_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup_3_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_3_2_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_3_2_0_Assignment_hiddenTokens(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// hiddenTokens+=[AbstractRule]
protected class Grammar_3_2_0_Assignment_hiddenTokens extends AssignmentToken  {
	
	public Grammar_3_2_0_Assignment_hiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getHiddenTokensAssignment_3_2_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("hiddenTokens",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGrammarAccess().getHiddenTokensAbstractRuleCrossReference_3_2_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getGrammarAccess().getHiddenTokensAbstractRuleCrossReference_3_2_0_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// ("," hiddenTokens+=[AbstractRule])*
protected class Grammar_3_2_1_Group extends GroupToken {
	
	public Grammar_3_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGrammarAccess().getGroup_3_2_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Grammar_3_2_1_1_Assignment_hiddenTokens(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Grammar_3_2_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// ","
protected class Grammar_3_2_1_0_Keyword extends KeywordToken  {
	
	public Grammar_3_2_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getCommaKeyword_3_2_1_0();
	}	
}

// hiddenTokens+=[AbstractRule]
protected class Grammar_3_2_1_1_Assignment_hiddenTokens extends AssignmentToken  {
	
	public Grammar_3_2_1_1_Assignment_hiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getHiddenTokensAssignment_3_2_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("hiddenTokens",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGrammarAccess().getHiddenTokensAbstractRuleCrossReference_3_2_1_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getGrammarAccess().getHiddenTokensAbstractRuleCrossReference_3_2_1_1_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}



// ")"
protected class Grammar_3_3_Keyword extends KeywordToken  {
	
	public Grammar_3_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getGrammarAccess().getRightParenthesisKeyword_3_3();
	}	
}


// (metamodelDeclarations+=AbstractMetamodelDeclaration)*
protected class Grammar_4_Assignment_metamodelDeclarations extends AssignmentToken  {
	
	public Grammar_4_Assignment_metamodelDeclarations(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getMetamodelDeclarationsAssignment_4();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("metamodelDeclarations",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("metamodelDeclarations");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractMetamodelDeclarationRule().getType().getClassifier())) {
				Solution s = new AbstractMetamodelDeclaration_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// (rules+=AbstractRule)+
protected class Grammar_5_Assignment_rules extends AssignmentToken  {
	
	public Grammar_5_Assignment_rules(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGrammarAccess().getRulesAssignment_5();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rules",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rules");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractRuleRule().getType().getClassifier())) {
				Solution s = new AbstractRule_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule Grammar ****************/



/************ begin Rule AbstractRule ****************
 *
 * AbstractRule:
 *   ParserRule|TerminalRule|EnumRule;
 *
 **/

// ParserRule|TerminalRule|EnumRule
protected class AbstractRule_Alternatives extends AlternativesToken {

	public AbstractRule_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractRuleAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractRule_0_RuleCall_ParserRule(current, this);
			case 1: return new AbstractRule_1_RuleCall_TerminalRule(current, this);
			case 2: return new AbstractRule_2_RuleCall_EnumRule(current, this);
			default: return null;
		}
	}
}

// ParserRule
protected class AbstractRule_0_RuleCall_ParserRule extends RuleCallToken {
	
	public AbstractRule_0_RuleCall_ParserRule(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractRuleAccess().getParserRuleParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ParserRule_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParserRuleRule().getType().getClassifier())) return null;
		return new ParserRule_Group(current, this).firstSolution();
	}
}

// TerminalRule
protected class AbstractRule_1_RuleCall_TerminalRule extends RuleCallToken {
	
	public AbstractRule_1_RuleCall_TerminalRule(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractRuleAccess().getTerminalRuleParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TerminalRule_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTerminalRuleRule().getType().getClassifier())) return null;
		return new TerminalRule_Group(current, this).firstSolution();
	}
}

// EnumRule
protected class AbstractRule_2_RuleCall_EnumRule extends RuleCallToken {
	
	public AbstractRule_2_RuleCall_EnumRule(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractRuleAccess().getEnumRuleParserRuleCall_2();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(EnumRule_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumRuleRule().getType().getClassifier())) return null;
		return new EnumRule_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractRule ****************/


/************ begin Rule AbstractMetamodelDeclaration ****************
 *
 * AbstractMetamodelDeclaration:
 *   GeneratedMetamodel|ReferencedMetamodel;
 *
 **/

// GeneratedMetamodel|ReferencedMetamodel
protected class AbstractMetamodelDeclaration_Alternatives extends AlternativesToken {

	public AbstractMetamodelDeclaration_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractMetamodelDeclarationAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractMetamodelDeclaration_0_RuleCall_GeneratedMetamodel(current, this);
			case 1: return new AbstractMetamodelDeclaration_1_RuleCall_ReferencedMetamodel(current, this);
			default: return null;
		}
	}
}

// GeneratedMetamodel
protected class AbstractMetamodelDeclaration_0_RuleCall_GeneratedMetamodel extends RuleCallToken {
	
	public AbstractMetamodelDeclaration_0_RuleCall_GeneratedMetamodel(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractMetamodelDeclarationAccess().getGeneratedMetamodelParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(GeneratedMetamodel_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getGeneratedMetamodelRule().getType().getClassifier())) return null;
		return new GeneratedMetamodel_Group(current, this).firstSolution();
	}
}

// ReferencedMetamodel
protected class AbstractMetamodelDeclaration_1_RuleCall_ReferencedMetamodel extends RuleCallToken {
	
	public AbstractMetamodelDeclaration_1_RuleCall_ReferencedMetamodel(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractMetamodelDeclarationAccess().getReferencedMetamodelParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ReferencedMetamodel_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getReferencedMetamodelRule().getType().getClassifier())) return null;
		return new ReferencedMetamodel_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractMetamodelDeclaration ****************/


/************ begin Rule GeneratedMetamodel ****************
 *
 * GeneratedMetamodel:
 *   "generate" name=ID ePackage=[ecore::EPackage|STRING] ("as" alias=ID)?;
 *
 **/

// "generate" name=ID ePackage=[ecore::EPackage|STRING] ("as" alias=ID)?
protected class GeneratedMetamodel_Group extends GroupToken {
	
	public GeneratedMetamodel_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new GeneratedMetamodel_3_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new GeneratedMetamodel_2_Assignment_ePackage(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new GeneratedMetamodel_1_Assignment_name(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new GeneratedMetamodel_0_Keyword_generate(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "generate"
protected class GeneratedMetamodel_0_Keyword_generate extends KeywordToken  {
	
	public GeneratedMetamodel_0_Keyword_generate(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getGenerateKeyword_0();
	}	
}

// name=ID
protected class GeneratedMetamodel_1_Assignment_name extends AssignmentToken  {
	
	public GeneratedMetamodel_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getGeneratedMetamodelAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ePackage=[ecore::EPackage|STRING]
protected class GeneratedMetamodel_2_Assignment_ePackage extends AssignmentToken  {
	
	public GeneratedMetamodel_2_Assignment_ePackage(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getEPackageAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("ePackage",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ePackage");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGeneratedMetamodelAccess().getEPackageEPackageCrossReference_2_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getGeneratedMetamodelAccess().getEPackageEPackageCrossReference_2_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// ("as" alias=ID)?
protected class GeneratedMetamodel_3_Group extends GroupToken {
	
	public GeneratedMetamodel_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getGroup_3();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new GeneratedMetamodel_3_1_Assignment_alias(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new GeneratedMetamodel_3_0_Keyword_as(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "as"
protected class GeneratedMetamodel_3_0_Keyword_as extends KeywordToken  {
	
	public GeneratedMetamodel_3_0_Keyword_as(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getAsKeyword_3_0();
	}	
}

// alias=ID
protected class GeneratedMetamodel_3_1_Assignment_alias extends AssignmentToken  {
	
	public GeneratedMetamodel_3_1_Assignment_alias(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGeneratedMetamodelAccess().getAliasAssignment_3_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("alias",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getGeneratedMetamodelAccess().getAliasIDTerminalRuleCall_3_1_0();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule GeneratedMetamodel ****************/


/************ begin Rule ReferencedMetamodel ****************
 *
 * ReferencedMetamodel:
 *   "import" ePackage=[ecore::EPackage|STRING] ("as" alias=ID)?;
 *
 **/

// "import" ePackage=[ecore::EPackage|STRING] ("as" alias=ID)?
protected class ReferencedMetamodel_Group extends GroupToken {
	
	public ReferencedMetamodel_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ReferencedMetamodel_2_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ReferencedMetamodel_1_Assignment_ePackage(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ReferencedMetamodel_0_Keyword_import(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "import"
protected class ReferencedMetamodel_0_Keyword_import extends KeywordToken  {
	
	public ReferencedMetamodel_0_Keyword_import(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getImportKeyword_0();
	}	
}

// ePackage=[ecore::EPackage|STRING]
protected class ReferencedMetamodel_1_Assignment_ePackage extends AssignmentToken  {
	
	public ReferencedMetamodel_1_Assignment_ePackage(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getEPackageAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("ePackage",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("ePackage");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getReferencedMetamodelAccess().getEPackageEPackageCrossReference_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getReferencedMetamodelAccess().getEPackageEPackageCrossReference_1_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// ("as" alias=ID)?
protected class ReferencedMetamodel_2_Group extends GroupToken {
	
	public ReferencedMetamodel_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ReferencedMetamodel_2_1_Assignment_alias(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ReferencedMetamodel_2_0_Keyword_as(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "as"
protected class ReferencedMetamodel_2_0_Keyword_as extends KeywordToken  {
	
	public ReferencedMetamodel_2_0_Keyword_as(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getAsKeyword_2_0();
	}	
}

// alias=ID
protected class ReferencedMetamodel_2_1_Assignment_alias extends AssignmentToken  {
	
	public ReferencedMetamodel_2_1_Assignment_alias(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getReferencedMetamodelAccess().getAliasAssignment_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("alias",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alias");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getReferencedMetamodelAccess().getAliasIDTerminalRuleCall_2_1_0();
			return new Solution(obj);
		}
		return null;
	}
}



/************ end Rule ReferencedMetamodel ****************/


/************ begin Rule ParserRule ****************
 *
 * ParserRule:
 *   name=ID ("returns" type=TypeRef)? (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=[AbstractRule])*)? ")")? ":" alternatives=Alternatives ";";
 *
 **/

// name=ID ("returns" type=TypeRef)? (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=[AbstractRule])*)? ")")? ":" alternatives=Alternatives ";"
protected class ParserRule_Group extends GroupToken {
	
	public ParserRule_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParserRule_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParserRule_4_Assignment_alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ParserRule_3_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new ParserRule_2_Group(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new ParserRule_1_Group(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new ParserRule_0_Assignment_name(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							if(s6 != null) {
								last = s6.getPredecessor();
								return s6;
							} else {
								s5 = s5.getPredecessor().nextSolution(this,s5);
							}
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// name=ID
protected class ParserRule_0_Assignment_name extends AssignmentToken  {
	
	public ParserRule_0_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getNameAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getParserRuleAccess().getNameIDTerminalRuleCall_0_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("returns" type=TypeRef)?
protected class ParserRule_1_Group extends GroupToken {
	
	public ParserRule_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParserRule_1_1_Assignment_type(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParserRule_1_0_Keyword_returns(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "returns"
protected class ParserRule_1_0_Keyword_returns extends KeywordToken  {
	
	public ParserRule_1_0_Keyword_returns(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getReturnsKeyword_1_0();
	}	
}

// type=TypeRef
protected class ParserRule_1_1_Assignment_type extends AssignmentToken  {
	
	public ParserRule_1_1_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getTypeAssignment_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				Solution s = new TypeRef_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// (definesHiddenTokens?="hidden" "(" (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=[AbstractRule])*)? ")")?
protected class ParserRule_2_Group extends GroupToken {
	
	public ParserRule_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParserRule_2_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParserRule_2_2_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ParserRule_2_1_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new ParserRule_2_0_Assignment_definesHiddenTokens(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// definesHiddenTokens?="hidden"
protected class ParserRule_2_0_Assignment_definesHiddenTokens extends AssignmentToken  {
	
	public ParserRule_2_0_Assignment_definesHiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getDefinesHiddenTokensAssignment_2_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("definesHiddenTokens",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("definesHiddenTokens");

		if(Boolean.TRUE.equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getParserRuleAccess().getDefinesHiddenTokensHiddenKeyword_2_0_0();
			return new Solution(obj);
		}

		return null;
	}
}

// "("
protected class ParserRule_2_1_Keyword extends KeywordToken  {
	
	public ParserRule_2_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getLeftParenthesisKeyword_2_1();
	}	
}

// (hiddenTokens+=[AbstractRule] ("," hiddenTokens+=[AbstractRule])*)?
protected class ParserRule_2_2_Group extends GroupToken {
	
	public ParserRule_2_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getGroup_2_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParserRule_2_2_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParserRule_2_2_0_Assignment_hiddenTokens(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// hiddenTokens+=[AbstractRule]
protected class ParserRule_2_2_0_Assignment_hiddenTokens extends AssignmentToken  {
	
	public ParserRule_2_2_0_Assignment_hiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getHiddenTokensAssignment_2_2_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("hiddenTokens",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParserRuleAccess().getHiddenTokensAbstractRuleCrossReference_2_2_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getParserRuleAccess().getHiddenTokensAbstractRuleCrossReference_2_2_0_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// ("," hiddenTokens+=[AbstractRule])*
protected class ParserRule_2_2_1_Group extends GroupToken {
	
	public ParserRule_2_2_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getGroup_2_2_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParserRule_2_2_1_1_Assignment_hiddenTokens(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParserRule_2_2_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// ","
protected class ParserRule_2_2_1_0_Keyword extends KeywordToken  {
	
	public ParserRule_2_2_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getCommaKeyword_2_2_1_0();
	}	
}

// hiddenTokens+=[AbstractRule]
protected class ParserRule_2_2_1_1_Assignment_hiddenTokens extends AssignmentToken  {
	
	public ParserRule_2_2_1_1_Assignment_hiddenTokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getHiddenTokensAssignment_2_2_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("hiddenTokens",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("hiddenTokens");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getParserRuleAccess().getHiddenTokensAbstractRuleCrossReference_2_2_1_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getParserRuleAccess().getHiddenTokensAbstractRuleCrossReference_2_2_1_1_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}



// ")"
protected class ParserRule_2_3_Keyword extends KeywordToken  {
	
	public ParserRule_2_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getRightParenthesisKeyword_2_3();
	}	
}


// ":"
protected class ParserRule_3_Keyword extends KeywordToken  {
	
	public ParserRule_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getColonKeyword_3();
	}	
}

// alternatives=Alternatives
protected class ParserRule_4_Assignment_alternatives extends AssignmentToken  {
	
	public ParserRule_4_Assignment_alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getAlternativesAssignment_4();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("alternatives",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alternatives");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAlternativesRule().getType().getClassifier())) {
				Solution s = new Alternatives_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ";"
protected class ParserRule_5_Keyword extends KeywordToken  {
	
	public ParserRule_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParserRuleAccess().getSemicolonKeyword_5();
	}	
}


/************ end Rule ParserRule ****************/


/************ begin Rule TypeRef ****************
 *
 * TypeRef:
 *   (metamodel=[AbstractMetamodelDeclaration] "::")? classifier=[ecore::EClassifier];
 *
 **/

// (metamodel=[AbstractMetamodelDeclaration] "::")? classifier=[ecore::EClassifier]
protected class TypeRef_Group extends GroupToken {
	
	public TypeRef_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TypeRef_1_Assignment_classifier(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TypeRef_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// (metamodel=[AbstractMetamodelDeclaration] "::")?
protected class TypeRef_0_Group extends GroupToken {
	
	public TypeRef_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getGroup_0();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TypeRef_0_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TypeRef_0_0_Assignment_metamodel(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// metamodel=[AbstractMetamodelDeclaration]
protected class TypeRef_0_0_Assignment_metamodel extends AssignmentToken  {
	
	public TypeRef_0_0_Assignment_metamodel(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getMetamodelAssignment_0_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("metamodel",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("metamodel");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefAccess().getMetamodelAbstractMetamodelDeclarationCrossReference_0_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getTypeRefAccess().getMetamodelAbstractMetamodelDeclarationCrossReference_0_0_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// "::"
protected class TypeRef_0_1_Keyword extends KeywordToken  {
	
	public TypeRef_0_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getColonColonKeyword_0_1();
	}	
}


// classifier=[ecore::EClassifier]
protected class TypeRef_1_Assignment_classifier extends AssignmentToken  {
	
	public TypeRef_1_Assignment_classifier(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTypeRefAccess().getClassifierAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("classifier",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("classifier");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefAccess().getClassifierEClassifierCrossReference_1_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getTypeRefAccess().getClassifierEClassifierCrossReference_1_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}


/************ end Rule TypeRef ****************/


/************ begin Rule Alternatives ****************
 *
 * Alternatives returns AbstractElement:
 *   Group ({Alternatives.groups+=current} ("|" groups+=Group)+)?;
 *
 **/

// Group ({Alternatives.groups+=current} ("|" groups+=Group)+)?
protected class Alternatives_Group extends GroupToken {
	
	public Alternatives_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Alternatives_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Alternatives_0_RuleCall_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// Group
protected class Alternatives_0_RuleCall_Group extends RuleCallToken {
	
	public Alternatives_0_RuleCall_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getGroupParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Group_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getGroupRule().getType().getClassifier())) return null;
		return new Group_Group(current, this).firstSolution();
	}
}

// ({Alternatives.groups+=current} ("|" groups+=Group)+)?
protected class Alternatives_1_Group extends GroupToken {
	
	public Alternatives_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Alternatives_1_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Alternatives_1_0_Action_Alternatives_groups(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// {Alternatives.groups+=current}
protected class Alternatives_1_0_Action_Alternatives_groups extends ActionToken  {

	public Alternatives_1_0_Action_Alternatives_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getAlternativesGroupsAction_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.getAlternativesAccess().getAlternativesGroupsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// ("|" groups+=Group)+
protected class Alternatives_1_1_Group extends GroupToken {
	
	public Alternatives_1_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getGroup_1_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Alternatives_1_1_1_Assignment_groups(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Alternatives_1_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "|"
protected class Alternatives_1_1_0_Keyword extends KeywordToken  {
	
	public Alternatives_1_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getVerticalLineKeyword_1_1_0();
	}	
}

// groups+=Group
protected class Alternatives_1_1_1_Assignment_groups extends AssignmentToken  {
	
	public Alternatives_1_1_1_Assignment_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAlternativesAccess().getGroupsAssignment_1_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("groups",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getGroupRule().getType().getClassifier())) {
				Solution s = new Group_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}




/************ end Rule Alternatives ****************/


/************ begin Rule Group ****************
 *
 * Group returns AbstractElement:
 *   AbstractToken ({Group.tokens+=current} (tokens+=AbstractToken)+)?;
 *
 **/

// AbstractToken ({Group.tokens+=current} (tokens+=AbstractToken)+)?
protected class Group_Group extends GroupToken {
	
	public Group_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGroupAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Group_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Group_0_RuleCall_AbstractToken(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// AbstractToken
protected class Group_0_RuleCall_AbstractToken extends RuleCallToken {
	
	public Group_0_RuleCall_AbstractToken(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getGroupAccess().getAbstractTokenParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AbstractToken_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAbstractTokenRule().getType().getClassifier())) return null;
		return new AbstractToken_Alternatives(current, this).firstSolution();
	}
}

// ({Group.tokens+=current} (tokens+=AbstractToken)+)?
protected class Group_1_Group extends GroupToken {
	
	public Group_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getGroupAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Group_1_1_Assignment_tokens(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Group_1_0_Action_Group_tokens(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// {Group.tokens+=current}
protected class Group_1_0_Action_Group_tokens extends ActionToken  {

	public Group_1_0_Action_Group_tokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getGroupAccess().getGroupTokensAction_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.getGroupAccess().getGroupTokensAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("tokens", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("tokens")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// (tokens+=AbstractToken)+
protected class Group_1_1_Assignment_tokens extends AssignmentToken  {
	
	public Group_1_1_Assignment_tokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getGroupAccess().getTokensAssignment_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("tokens",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("tokens");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractTokenRule().getType().getClassifier())) {
				Solution s = new AbstractToken_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



/************ end Rule Group ****************/


/************ begin Rule AbstractToken ****************
 *
 * AbstractToken returns AbstractElement:
 *   AbstractTokenWithCardinality|Action;
 *
 **/

// AbstractTokenWithCardinality|Action
protected class AbstractToken_Alternatives extends AlternativesToken {

	public AbstractToken_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractTokenAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractToken_0_RuleCall_AbstractTokenWithCardinality(current, this);
			case 1: return new AbstractToken_1_RuleCall_Action(current, this);
			default: return null;
		}
	}
}

// AbstractTokenWithCardinality
protected class AbstractToken_0_RuleCall_AbstractTokenWithCardinality extends RuleCallToken {
	
	public AbstractToken_0_RuleCall_AbstractTokenWithCardinality(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTokenAccess().getAbstractTokenWithCardinalityParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AbstractTokenWithCardinality_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAbstractTokenWithCardinalityRule().getType().getClassifier())) return null;
		return new AbstractTokenWithCardinality_Group(current, this).firstSolution();
	}
}

// Action
protected class AbstractToken_1_RuleCall_Action extends RuleCallToken {
	
	public AbstractToken_1_RuleCall_Action(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTokenAccess().getActionParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Action_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getActionRule().getType().getClassifier())) return null;
		return new Action_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractToken ****************/


/************ begin Rule AbstractTokenWithCardinality ****************
 *
 * AbstractTokenWithCardinality returns AbstractElement:
 *   (Assignment|AbstractTerminal) (cardinality=( "?" | "*" | "+" ))?;
 *
 **/

// (Assignment|AbstractTerminal) (cardinality=( "?" | "*" | "+" ))?
protected class AbstractTokenWithCardinality_Group extends GroupToken {
	
	public AbstractTokenWithCardinality_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAbstractTokenWithCardinalityAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AbstractTokenWithCardinality_1_Assignment_cardinality(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AbstractTokenWithCardinality_0_Alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// Assignment|AbstractTerminal
protected class AbstractTokenWithCardinality_0_Alternatives extends AlternativesToken {

	public AbstractTokenWithCardinality_0_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractTokenWithCardinalityAccess().getAlternatives_0();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractTokenWithCardinality_0_0_RuleCall_Assignment(current, this);
			case 1: return new AbstractTokenWithCardinality_0_1_RuleCall_AbstractTerminal(current, this);
			default: return null;
		}
	}
}

// Assignment
protected class AbstractTokenWithCardinality_0_0_RuleCall_Assignment extends RuleCallToken {
	
	public AbstractTokenWithCardinality_0_0_RuleCall_Assignment(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTokenWithCardinalityAccess().getAssignmentParserRuleCall_0_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Assignment_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignmentRule().getType().getClassifier())) return null;
		return new Assignment_Group(current, this).firstSolution();
	}
}

// AbstractTerminal
protected class AbstractTokenWithCardinality_0_1_RuleCall_AbstractTerminal extends RuleCallToken {
	
	public AbstractTokenWithCardinality_0_1_RuleCall_AbstractTerminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTokenWithCardinalityAccess().getAbstractTerminalParserRuleCall_0_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AbstractTerminal_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAbstractTerminalRule().getType().getClassifier())) return null;
		return new AbstractTerminal_Alternatives(current, this).firstSolution();
	}
}


// (cardinality=( "?" | "*" | "+" ))?
protected class AbstractTokenWithCardinality_1_Assignment_cardinality extends AssignmentToken  {
	
	public AbstractTokenWithCardinality_1_Assignment_cardinality(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAbstractTokenWithCardinalityAccess().getCardinalityAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("cardinality",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("cardinality");

		if("?".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAbstractTokenWithCardinalityAccess().getCardinalityQuestionMarkKeyword_1_0_0();
			return new Solution(obj);
		}


		if("*".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAbstractTokenWithCardinalityAccess().getCardinalityAsteriskKeyword_1_0_1();
			return new Solution(obj);
		}


		if("+".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAbstractTokenWithCardinalityAccess().getCardinalityPlusSignKeyword_1_0_2();
			return new Solution(obj);
		}

		return null;
	}
}


/************ end Rule AbstractTokenWithCardinality ****************/


/************ begin Rule Action ****************
 *
 * Action:
 *   "{" type=TypeRef ("." feature=ID operator=( "=" | "+=" ) "current")? "}";
 *
 **/

// "{" type=TypeRef ("." feature=ID operator=( "=" | "+=" ) "current")? "}"
protected class Action_Group extends GroupToken {
	
	public Action_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Action_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Action_2_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Action_1_Assignment_type(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Action_0_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "{"
protected class Action_0_Keyword extends KeywordToken  {
	
	public Action_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getLeftCurlyBracketKeyword_0();
	}	
}

// type=TypeRef
protected class Action_1_Assignment_type extends AssignmentToken  {
	
	public Action_1_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getTypeAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				Solution s = new TypeRef_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ("." feature=ID operator=( "=" | "+=" ) "current")?
protected class Action_2_Group extends GroupToken {
	
	public Action_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getActionAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Action_2_3_Keyword_current(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Action_2_2_Assignment_operator(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Action_2_1_Assignment_feature(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Action_2_0_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "."
protected class Action_2_0_Keyword extends KeywordToken  {
	
	public Action_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getFullStopKeyword_2_0();
	}	
}

// feature=ID
protected class Action_2_1_Assignment_feature extends AssignmentToken  {
	
	public Action_2_1_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getFeatureAssignment_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getActionAccess().getFeatureIDTerminalRuleCall_2_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// operator=( "=" | "+=" )
protected class Action_2_2_Assignment_operator extends AssignmentToken  {
	
	public Action_2_2_Assignment_operator(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getActionAccess().getOperatorAssignment_2_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("operator",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");

		if("=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getActionAccess().getOperatorEqualsSignKeyword_2_2_0_0();
			return new Solution(obj);
		}


		if("+=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getActionAccess().getOperatorPlusSignEqualsSignKeyword_2_2_0_1();
			return new Solution(obj);
		}

		return null;
	}
}

// "current"
protected class Action_2_3_Keyword_current extends KeywordToken  {
	
	public Action_2_3_Keyword_current(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getCurrentKeyword_2_3();
	}	
}


// "}"
protected class Action_3_Keyword extends KeywordToken  {
	
	public Action_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getActionAccess().getRightCurlyBracketKeyword_3();
	}	
}


/************ end Rule Action ****************/


/************ begin Rule AbstractTerminal ****************
 *
 * AbstractTerminal returns AbstractElement:
 *   Keyword|RuleCall|ParenthesizedElement;
 *
 **/

// Keyword|RuleCall|ParenthesizedElement
protected class AbstractTerminal_Alternatives extends AlternativesToken {

	public AbstractTerminal_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractTerminalAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractTerminal_0_RuleCall_Keyword(current, this);
			case 1: return new AbstractTerminal_1_RuleCall_RuleCall(current, this);
			case 2: return new AbstractTerminal_2_RuleCall_ParenthesizedElement(current, this);
			default: return null;
		}
	}
}

// Keyword
protected class AbstractTerminal_0_RuleCall_Keyword extends RuleCallToken {
	
	public AbstractTerminal_0_RuleCall_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTerminalAccess().getKeywordParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Keyword_Assignment_value.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) return null;
		return new Keyword_Assignment_value(current, this).firstSolution();
	}
}

// RuleCall
protected class AbstractTerminal_1_RuleCall_RuleCall extends RuleCallToken {
	
	public AbstractTerminal_1_RuleCall_RuleCall(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTerminalAccess().getRuleCallParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(RuleCall_Assignment_rule.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRuleCallRule().getType().getClassifier())) return null;
		return new RuleCall_Assignment_rule(current, this).firstSolution();
	}
}

// ParenthesizedElement
protected class AbstractTerminal_2_RuleCall_ParenthesizedElement extends RuleCallToken {
	
	public AbstractTerminal_2_RuleCall_ParenthesizedElement(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractTerminalAccess().getParenthesizedElementParserRuleCall_2();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ParenthesizedElement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParenthesizedElementRule().getType().getClassifier())) return null;
		return new ParenthesizedElement_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractTerminal ****************/


/************ begin Rule Keyword ****************
 *
 * Keyword:
 *   value=STRING;
 *
 **/

// value=STRING
protected class Keyword_Assignment_value extends AssignmentToken  {
	
	public Keyword_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getKeywordAccess().getValueAssignment();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getKeywordAccess().getValueSTRINGTerminalRuleCall_0();
			return new Solution(obj);
		}
		return null;
	}
}

/************ end Rule Keyword ****************/


/************ begin Rule RuleCall ****************
 *
 * RuleCall:
 *   rule=[AbstractRule];
 *
 **/

// rule=[AbstractRule]
protected class RuleCall_Assignment_rule extends AssignmentToken  {
	
	public RuleCall_Assignment_rule(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getRuleCallAccess().getRuleAssignment();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("rule",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("rule");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getRuleCallAccess().getRuleAbstractRuleCrossReference_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getRuleCallAccess().getRuleAbstractRuleCrossReference_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

/************ end Rule RuleCall ****************/


/************ begin Rule Assignment ****************
 *
 * Assignment:
 *   feature=ID operator=( "+=" | "=" | "?=" ) ^terminal=AssignableTerminal;
 *
 **/

// feature=ID operator=( "+=" | "=" | "?=" ) ^terminal=AssignableTerminal
protected class Assignment_Group extends GroupToken {
	
	public Assignment_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Assignment_2_Assignment_terminal(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Assignment_1_Assignment_operator(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Assignment_0_Assignment_feature(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// feature=ID
protected class Assignment_0_Assignment_feature extends AssignmentToken  {
	
	public Assignment_0_Assignment_feature(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getFeatureAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("feature",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("feature");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAssignmentAccess().getFeatureIDTerminalRuleCall_0_0();
			return new Solution(obj);
		}
		return null;
	}
}

// operator=( "+=" | "=" | "?=" )
protected class Assignment_1_Assignment_operator extends AssignmentToken  {
	
	public Assignment_1_Assignment_operator(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getOperatorAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("operator",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");

		if("+=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAssignmentAccess().getOperatorPlusSignEqualsSignKeyword_1_0_0();
			return new Solution(obj);
		}


		if("=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAssignmentAccess().getOperatorEqualsSignKeyword_1_0_1();
			return new Solution(obj);
		}


		if("?=".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAssignmentAccess().getOperatorQuestionMarkEqualsSignKeyword_1_0_2();
			return new Solution(obj);
		}

		return null;
	}
}

// ^terminal=AssignableTerminal
protected class Assignment_2_Assignment_terminal extends AssignmentToken  {
	
	public Assignment_2_Assignment_terminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignmentAccess().getTerminalAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("terminal",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("terminal");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignableTerminalRule().getType().getClassifier())) {
				Solution s = new AssignableTerminal_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule Assignment ****************/


/************ begin Rule AssignableTerminal ****************
 *
 * AssignableTerminal returns AbstractElement:
 *   Keyword|RuleCall|ParenthesizedAssignableElement|CrossReference;
 *
 **/

// Keyword|RuleCall|ParenthesizedAssignableElement|CrossReference
protected class AssignableTerminal_Alternatives extends AlternativesToken {

	public AssignableTerminal_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAssignableTerminalAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AssignableTerminal_0_RuleCall_Keyword(current, this);
			case 1: return new AssignableTerminal_1_RuleCall_RuleCall(current, this);
			case 2: return new AssignableTerminal_2_RuleCall_ParenthesizedAssignableElement(current, this);
			case 3: return new AssignableTerminal_3_RuleCall_CrossReference(current, this);
			default: return null;
		}
	}
}

// Keyword
protected class AssignableTerminal_0_RuleCall_Keyword extends RuleCallToken {
	
	public AssignableTerminal_0_RuleCall_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignableTerminalAccess().getKeywordParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Keyword_Assignment_value.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) return null;
		return new Keyword_Assignment_value(current, this).firstSolution();
	}
}

// RuleCall
protected class AssignableTerminal_1_RuleCall_RuleCall extends RuleCallToken {
	
	public AssignableTerminal_1_RuleCall_RuleCall(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignableTerminalAccess().getRuleCallParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(RuleCall_Assignment_rule.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRuleCallRule().getType().getClassifier())) return null;
		return new RuleCall_Assignment_rule(current, this).firstSolution();
	}
}

// ParenthesizedAssignableElement
protected class AssignableTerminal_2_RuleCall_ParenthesizedAssignableElement extends RuleCallToken {
	
	public AssignableTerminal_2_RuleCall_ParenthesizedAssignableElement(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignableTerminalAccess().getParenthesizedAssignableElementParserRuleCall_2();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ParenthesizedAssignableElement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParenthesizedAssignableElementRule().getType().getClassifier())) return null;
		return new ParenthesizedAssignableElement_Group(current, this).firstSolution();
	}
}

// CrossReference
protected class AssignableTerminal_3_RuleCall_CrossReference extends RuleCallToken {
	
	public AssignableTerminal_3_RuleCall_CrossReference(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignableTerminalAccess().getCrossReferenceParserRuleCall_3();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(CrossReference_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCrossReferenceRule().getType().getClassifier())) return null;
		return new CrossReference_Group(current, this).firstSolution();
	}
}


/************ end Rule AssignableTerminal ****************/


/************ begin Rule ParenthesizedAssignableElement ****************
 *
 * ParenthesizedAssignableElement returns AbstractElement:
 *   "(" AssignableAlternatives ")";
 *
 **/

// "(" AssignableAlternatives ")"
protected class ParenthesizedAssignableElement_Group extends GroupToken {
	
	public ParenthesizedAssignableElement_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParenthesizedAssignableElementAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParenthesizedAssignableElement_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParenthesizedAssignableElement_1_RuleCall_AssignableAlternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ParenthesizedAssignableElement_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "("
protected class ParenthesizedAssignableElement_0_Keyword extends KeywordToken  {
	
	public ParenthesizedAssignableElement_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedAssignableElementAccess().getLeftParenthesisKeyword_0();
	}	
}

// AssignableAlternatives
protected class ParenthesizedAssignableElement_1_RuleCall_AssignableAlternatives extends RuleCallToken {
	
	public ParenthesizedAssignableElement_1_RuleCall_AssignableAlternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParenthesizedAssignableElementAccess().getAssignableAlternativesParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AssignableAlternatives_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignableAlternativesRule().getType().getClassifier())) return null;
		return new AssignableAlternatives_Group(current, this).firstSolution();
	}
}

// ")"
protected class ParenthesizedAssignableElement_2_Keyword extends KeywordToken  {
	
	public ParenthesizedAssignableElement_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedAssignableElementAccess().getRightParenthesisKeyword_2();
	}	
}


/************ end Rule ParenthesizedAssignableElement ****************/


/************ begin Rule AssignableAlternatives ****************
 *
 * AssignableAlternatives returns AbstractElement:
 *   AssignableTerminal ({Alternatives.groups+=current} ("|" groups+=AssignableTerminal)+)?;
 *
 **/

// AssignableTerminal ({Alternatives.groups+=current} ("|" groups+=AssignableTerminal)+)?
protected class AssignableAlternatives_Group extends GroupToken {
	
	public AssignableAlternatives_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AssignableAlternatives_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AssignableAlternatives_0_RuleCall_AssignableTerminal(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// AssignableTerminal
protected class AssignableAlternatives_0_RuleCall_AssignableTerminal extends RuleCallToken {
	
	public AssignableAlternatives_0_RuleCall_AssignableTerminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getAssignableTerminalParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AssignableTerminal_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAssignableTerminalRule().getType().getClassifier())) return null;
		return new AssignableTerminal_Alternatives(current, this).firstSolution();
	}
}

// ({Alternatives.groups+=current} ("|" groups+=AssignableTerminal)+)?
protected class AssignableAlternatives_1_Group extends GroupToken {
	
	public AssignableAlternatives_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AssignableAlternatives_1_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AssignableAlternatives_1_0_Action_Alternatives_groups(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// {Alternatives.groups+=current}
protected class AssignableAlternatives_1_0_Action_Alternatives_groups extends ActionToken  {

	public AssignableAlternatives_1_0_Action_Alternatives_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getAlternativesGroupsAction_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.getAssignableAlternativesAccess().getAlternativesGroupsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// ("|" groups+=AssignableTerminal)+
protected class AssignableAlternatives_1_1_Group extends GroupToken {
	
	public AssignableAlternatives_1_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getGroup_1_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AssignableAlternatives_1_1_1_Assignment_groups(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AssignableAlternatives_1_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "|"
protected class AssignableAlternatives_1_1_0_Keyword extends KeywordToken  {
	
	public AssignableAlternatives_1_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getVerticalLineKeyword_1_1_0();
	}	
}

// groups+=AssignableTerminal
protected class AssignableAlternatives_1_1_1_Assignment_groups extends AssignmentToken  {
	
	public AssignableAlternatives_1_1_1_Assignment_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAssignableAlternativesAccess().getGroupsAssignment_1_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("groups",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAssignableTerminalRule().getType().getClassifier())) {
				Solution s = new AssignableTerminal_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}




/************ end Rule AssignableAlternatives ****************/


/************ begin Rule CrossReference ****************
 *
 * CrossReference:
 *   "[" type=TypeRef ("|" ^terminal=CrossReferenceableTerminal)? "]";
 *
 **/

// "[" type=TypeRef ("|" ^terminal=CrossReferenceableTerminal)? "]"
protected class CrossReference_Group extends GroupToken {
	
	public CrossReference_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CrossReference_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CrossReference_2_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new CrossReference_1_Assignment_type(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new CrossReference_0_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "["
protected class CrossReference_0_Keyword extends KeywordToken  {
	
	public CrossReference_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getLeftSquareBracketKeyword_0();
	}	
}

// type=TypeRef
protected class CrossReference_1_Assignment_type extends AssignmentToken  {
	
	public CrossReference_1_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getTypeAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				Solution s = new TypeRef_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ("|" ^terminal=CrossReferenceableTerminal)?
protected class CrossReference_2_Group extends GroupToken {
	
	public CrossReference_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CrossReference_2_1_Assignment_terminal(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CrossReference_2_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "|"
protected class CrossReference_2_0_Keyword extends KeywordToken  {
	
	public CrossReference_2_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getVerticalLineKeyword_2_0();
	}	
}

// ^terminal=CrossReferenceableTerminal
protected class CrossReference_2_1_Assignment_terminal extends AssignmentToken  {
	
	public CrossReference_2_1_Assignment_terminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getTerminalAssignment_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("terminal",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("terminal");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCrossReferenceableTerminalRule().getType().getClassifier())) {
				Solution s = new CrossReferenceableTerminal_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// "]"
protected class CrossReference_3_Keyword extends KeywordToken  {
	
	public CrossReference_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getCrossReferenceAccess().getRightSquareBracketKeyword_3();
	}	
}


/************ end Rule CrossReference ****************/


/************ begin Rule CrossReferenceableTerminal ****************
 *
 * CrossReferenceableTerminal returns AbstractElement:
 *   Keyword|RuleCall|ParenthesizedCrossReferenceableElement;
 *
 **/

// Keyword|RuleCall|ParenthesizedCrossReferenceableElement
protected class CrossReferenceableTerminal_Alternatives extends AlternativesToken {

	public CrossReferenceableTerminal_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getCrossReferenceableTerminalAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new CrossReferenceableTerminal_0_RuleCall_Keyword(current, this);
			case 1: return new CrossReferenceableTerminal_1_RuleCall_RuleCall(current, this);
			case 2: return new CrossReferenceableTerminal_2_RuleCall_ParenthesizedCrossReferenceableElement(current, this);
			default: return null;
		}
	}
}

// Keyword
protected class CrossReferenceableTerminal_0_RuleCall_Keyword extends RuleCallToken {
	
	public CrossReferenceableTerminal_0_RuleCall_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCrossReferenceableTerminalAccess().getKeywordParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Keyword_Assignment_value.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) return null;
		return new Keyword_Assignment_value(current, this).firstSolution();
	}
}

// RuleCall
protected class CrossReferenceableTerminal_1_RuleCall_RuleCall extends RuleCallToken {
	
	public CrossReferenceableTerminal_1_RuleCall_RuleCall(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCrossReferenceableTerminalAccess().getRuleCallParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(RuleCall_Assignment_rule.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRuleCallRule().getType().getClassifier())) return null;
		return new RuleCall_Assignment_rule(current, this).firstSolution();
	}
}

// ParenthesizedCrossReferenceableElement
protected class CrossReferenceableTerminal_2_RuleCall_ParenthesizedCrossReferenceableElement extends RuleCallToken {
	
	public CrossReferenceableTerminal_2_RuleCall_ParenthesizedCrossReferenceableElement(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCrossReferenceableTerminalAccess().getParenthesizedCrossReferenceableElementParserRuleCall_2();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ParenthesizedCrossReferenceableElement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParenthesizedCrossReferenceableElementRule().getType().getClassifier())) return null;
		return new ParenthesizedCrossReferenceableElement_Group(current, this).firstSolution();
	}
}


/************ end Rule CrossReferenceableTerminal ****************/


/************ begin Rule ParenthesizedCrossReferenceableElement ****************
 *
 * ParenthesizedCrossReferenceableElement returns AbstractElement:
 *   "(" CrossReferenceableAlternatives ")";
 *
 **/

// "(" CrossReferenceableAlternatives ")"
protected class ParenthesizedCrossReferenceableElement_Group extends GroupToken {
	
	public ParenthesizedCrossReferenceableElement_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParenthesizedCrossReferenceableElementAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParenthesizedCrossReferenceableElement_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParenthesizedCrossReferenceableElement_1_RuleCall_CrossReferenceableAlternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ParenthesizedCrossReferenceableElement_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "("
protected class ParenthesizedCrossReferenceableElement_0_Keyword extends KeywordToken  {
	
	public ParenthesizedCrossReferenceableElement_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedCrossReferenceableElementAccess().getLeftParenthesisKeyword_0();
	}	
}

// CrossReferenceableAlternatives
protected class ParenthesizedCrossReferenceableElement_1_RuleCall_CrossReferenceableAlternatives extends RuleCallToken {
	
	public ParenthesizedCrossReferenceableElement_1_RuleCall_CrossReferenceableAlternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParenthesizedCrossReferenceableElementAccess().getCrossReferenceableAlternativesParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(CrossReferenceableAlternatives_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCrossReferenceableAlternativesRule().getType().getClassifier())) return null;
		return new CrossReferenceableAlternatives_Group(current, this).firstSolution();
	}
}

// ")"
protected class ParenthesizedCrossReferenceableElement_2_Keyword extends KeywordToken  {
	
	public ParenthesizedCrossReferenceableElement_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedCrossReferenceableElementAccess().getRightParenthesisKeyword_2();
	}	
}


/************ end Rule ParenthesizedCrossReferenceableElement ****************/


/************ begin Rule CrossReferenceableAlternatives ****************
 *
 * CrossReferenceableAlternatives returns AbstractElement:
 *   CrossReferenceableTerminal ({Alternatives.groups+=current} ("|" groups+=CrossReferenceableTerminal)+)?;
 *
 **/

// CrossReferenceableTerminal ({Alternatives.groups+=current} ("|" groups+=CrossReferenceableTerminal)+)?
protected class CrossReferenceableAlternatives_Group extends GroupToken {
	
	public CrossReferenceableAlternatives_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CrossReferenceableAlternatives_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CrossReferenceableAlternatives_0_RuleCall_CrossReferenceableTerminal(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// CrossReferenceableTerminal
protected class CrossReferenceableAlternatives_0_RuleCall_CrossReferenceableTerminal extends RuleCallToken {
	
	public CrossReferenceableAlternatives_0_RuleCall_CrossReferenceableTerminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getCrossReferenceableTerminalParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(CrossReferenceableTerminal_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCrossReferenceableTerminalRule().getType().getClassifier())) return null;
		return new CrossReferenceableTerminal_Alternatives(current, this).firstSolution();
	}
}

// ({Alternatives.groups+=current} ("|" groups+=CrossReferenceableTerminal)+)?
protected class CrossReferenceableAlternatives_1_Group extends GroupToken {
	
	public CrossReferenceableAlternatives_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CrossReferenceableAlternatives_1_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CrossReferenceableAlternatives_1_0_Action_Alternatives_groups(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// {Alternatives.groups+=current}
protected class CrossReferenceableAlternatives_1_0_Action_Alternatives_groups extends ActionToken  {

	public CrossReferenceableAlternatives_1_0_Action_Alternatives_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getAlternativesGroupsAction_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.getCrossReferenceableAlternativesAccess().getAlternativesGroupsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// ("|" groups+=CrossReferenceableTerminal)+
protected class CrossReferenceableAlternatives_1_1_Group extends GroupToken {
	
	public CrossReferenceableAlternatives_1_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getGroup_1_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CrossReferenceableAlternatives_1_1_1_Assignment_groups(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CrossReferenceableAlternatives_1_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "|"
protected class CrossReferenceableAlternatives_1_1_0_Keyword extends KeywordToken  {
	
	public CrossReferenceableAlternatives_1_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getVerticalLineKeyword_1_1_0();
	}	
}

// groups+=CrossReferenceableTerminal
protected class CrossReferenceableAlternatives_1_1_1_Assignment_groups extends AssignmentToken  {
	
	public CrossReferenceableAlternatives_1_1_1_Assignment_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCrossReferenceableAlternativesAccess().getGroupsAssignment_1_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("groups",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getCrossReferenceableTerminalRule().getType().getClassifier())) {
				Solution s = new CrossReferenceableTerminal_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}




/************ end Rule CrossReferenceableAlternatives ****************/


/************ begin Rule ParenthesizedElement ****************
 *
 * ParenthesizedElement returns AbstractElement:
 *   "(" Alternatives ")";
 *
 **/

// "(" Alternatives ")"
protected class ParenthesizedElement_Group extends GroupToken {
	
	public ParenthesizedElement_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParenthesizedElementAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParenthesizedElement_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParenthesizedElement_1_RuleCall_Alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ParenthesizedElement_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "("
protected class ParenthesizedElement_0_Keyword extends KeywordToken  {
	
	public ParenthesizedElement_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedElementAccess().getLeftParenthesisKeyword_0();
	}	
}

// Alternatives
protected class ParenthesizedElement_1_RuleCall_Alternatives extends RuleCallToken {
	
	public ParenthesizedElement_1_RuleCall_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParenthesizedElementAccess().getAlternativesParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Alternatives_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAlternativesRule().getType().getClassifier())) return null;
		return new Alternatives_Group(current, this).firstSolution();
	}
}

// ")"
protected class ParenthesizedElement_2_Keyword extends KeywordToken  {
	
	public ParenthesizedElement_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedElementAccess().getRightParenthesisKeyword_2();
	}	
}


/************ end Rule ParenthesizedElement ****************/


/************ begin Rule TerminalRule ****************
 *
 * TerminalRule:
 *   "terminal" name=ID ("returns" type=TypeRef)? ":" alternatives=TerminalAlternatives ";";
 *
 **/

// "terminal" name=ID ("returns" type=TypeRef)? ":" alternatives=TerminalAlternatives ";"
protected class TerminalRule_Group extends GroupToken {
	
	public TerminalRule_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalRule_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalRule_4_Assignment_alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new TerminalRule_3_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new TerminalRule_2_Group(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new TerminalRule_1_Assignment_name(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new TerminalRule_0_Keyword_terminal(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							if(s6 != null) {
								last = s6.getPredecessor();
								return s6;
							} else {
								s5 = s5.getPredecessor().nextSolution(this,s5);
							}
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "terminal"
protected class TerminalRule_0_Keyword_terminal extends KeywordToken  {
	
	public TerminalRule_0_Keyword_terminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getTerminalKeyword_0();
	}	
}

// name=ID
protected class TerminalRule_1_Assignment_name extends AssignmentToken  {
	
	public TerminalRule_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getTerminalRuleAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("returns" type=TypeRef)?
protected class TerminalRule_2_Group extends GroupToken {
	
	public TerminalRule_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalRule_2_1_Assignment_type(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalRule_2_0_Keyword_returns(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "returns"
protected class TerminalRule_2_0_Keyword_returns extends KeywordToken  {
	
	public TerminalRule_2_0_Keyword_returns(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getReturnsKeyword_2_0();
	}	
}

// type=TypeRef
protected class TerminalRule_2_1_Assignment_type extends AssignmentToken  {
	
	public TerminalRule_2_1_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getTypeAssignment_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				Solution s = new TypeRef_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// ":"
protected class TerminalRule_3_Keyword extends KeywordToken  {
	
	public TerminalRule_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getColonKeyword_3();
	}	
}

// alternatives=TerminalAlternatives
protected class TerminalRule_4_Assignment_alternatives extends AssignmentToken  {
	
	public TerminalRule_4_Assignment_alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getAlternativesAssignment_4();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("alternatives",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alternatives");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTerminalAlternativesRule().getType().getClassifier())) {
				Solution s = new TerminalAlternatives_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ";"
protected class TerminalRule_5_Keyword extends KeywordToken  {
	
	public TerminalRule_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalRuleAccess().getSemicolonKeyword_5();
	}	
}


/************ end Rule TerminalRule ****************/


/************ begin Rule TerminalAlternatives ****************
 *
 * TerminalAlternatives returns AbstractElement:
 *   TerminalGroup ({Alternatives.groups+=current} ("|" groups+=TerminalGroup)+)?;
 *
 **/

// TerminalGroup ({Alternatives.groups+=current} ("|" groups+=TerminalGroup)+)?
protected class TerminalAlternatives_Group extends GroupToken {
	
	public TerminalAlternatives_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalAlternatives_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalAlternatives_0_RuleCall_TerminalGroup(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// TerminalGroup
protected class TerminalAlternatives_0_RuleCall_TerminalGroup extends RuleCallToken {
	
	public TerminalAlternatives_0_RuleCall_TerminalGroup(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getTerminalGroupParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TerminalGroup_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTerminalGroupRule().getType().getClassifier())) return null;
		return new TerminalGroup_Group(current, this).firstSolution();
	}
}

// ({Alternatives.groups+=current} ("|" groups+=TerminalGroup)+)?
protected class TerminalAlternatives_1_Group extends GroupToken {
	
	public TerminalAlternatives_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalAlternatives_1_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalAlternatives_1_0_Action_Alternatives_groups(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// {Alternatives.groups+=current}
protected class TerminalAlternatives_1_0_Action_Alternatives_groups extends ActionToken  {

	public TerminalAlternatives_1_0_Action_Alternatives_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getAlternativesGroupsAction_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.getTerminalAlternativesAccess().getAlternativesGroupsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// ("|" groups+=TerminalGroup)+
protected class TerminalAlternatives_1_1_Group extends GroupToken {
	
	public TerminalAlternatives_1_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getGroup_1_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalAlternatives_1_1_1_Assignment_groups(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalAlternatives_1_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "|"
protected class TerminalAlternatives_1_1_0_Keyword extends KeywordToken  {
	
	public TerminalAlternatives_1_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getVerticalLineKeyword_1_1_0();
	}	
}

// groups+=TerminalGroup
protected class TerminalAlternatives_1_1_1_Assignment_groups extends AssignmentToken  {
	
	public TerminalAlternatives_1_1_1_Assignment_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalAlternativesAccess().getGroupsAssignment_1_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("groups",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTerminalGroupRule().getType().getClassifier())) {
				Solution s = new TerminalGroup_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}




/************ end Rule TerminalAlternatives ****************/


/************ begin Rule TerminalGroup ****************
 *
 * TerminalGroup returns AbstractElement:
 *   TerminalToken ({Group.tokens+=current} (tokens+=TerminalToken)+)?;
 *
 **/

// TerminalToken ({Group.tokens+=current} (tokens+=TerminalToken)+)?
protected class TerminalGroup_Group extends GroupToken {
	
	public TerminalGroup_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalGroupAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalGroup_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalGroup_0_RuleCall_TerminalToken(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// TerminalToken
protected class TerminalGroup_0_RuleCall_TerminalToken extends RuleCallToken {
	
	public TerminalGroup_0_RuleCall_TerminalToken(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalGroupAccess().getTerminalTokenParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TerminalToken_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTerminalTokenRule().getType().getClassifier())) return null;
		return new TerminalToken_Group(current, this).firstSolution();
	}
}

// ({Group.tokens+=current} (tokens+=TerminalToken)+)?
protected class TerminalGroup_1_Group extends GroupToken {
	
	public TerminalGroup_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalGroupAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalGroup_1_1_Assignment_tokens(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalGroup_1_0_Action_Group_tokens(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// {Group.tokens+=current}
protected class TerminalGroup_1_0_Action_Group_tokens extends ActionToken  {

	public TerminalGroup_1_0_Action_Group_tokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getTerminalGroupAccess().getGroupTokensAction_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.getTerminalGroupAccess().getGroupTokensAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("tokens", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("tokens")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// (tokens+=TerminalToken)+
protected class TerminalGroup_1_1_Assignment_tokens extends AssignmentToken  {
	
	public TerminalGroup_1_1_Assignment_tokens(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalGroupAccess().getTokensAssignment_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("tokens",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("tokens");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTerminalTokenRule().getType().getClassifier())) {
				Solution s = new TerminalToken_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



/************ end Rule TerminalGroup ****************/


/************ begin Rule TerminalToken ****************
 *
 * TerminalToken returns AbstractElement:
 *   TerminalTokenElement (cardinality=( "?" | "*" | "+" ))?;
 *
 **/

// TerminalTokenElement (cardinality=( "?" | "*" | "+" ))?
protected class TerminalToken_Group extends GroupToken {
	
	public TerminalToken_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getTerminalTokenAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new TerminalToken_1_Assignment_cardinality(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new TerminalToken_0_RuleCall_TerminalTokenElement(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// TerminalTokenElement
protected class TerminalToken_0_RuleCall_TerminalTokenElement extends RuleCallToken {
	
	public TerminalToken_0_RuleCall_TerminalTokenElement(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenAccess().getTerminalTokenElementParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TerminalTokenElement_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTerminalTokenElementRule().getType().getClassifier())) return null;
		return new TerminalTokenElement_Alternatives(current, this).firstSolution();
	}
}

// (cardinality=( "?" | "*" | "+" ))?
protected class TerminalToken_1_Assignment_cardinality extends AssignmentToken  {
	
	public TerminalToken_1_Assignment_cardinality(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getTerminalTokenAccess().getCardinalityAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("cardinality",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("cardinality");

		if("?".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getTerminalTokenAccess().getCardinalityQuestionMarkKeyword_1_0_0();
			return new Solution(obj);
		}


		if("*".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getTerminalTokenAccess().getCardinalityAsteriskKeyword_1_0_1();
			return new Solution(obj);
		}


		if("+".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getTerminalTokenAccess().getCardinalityPlusSignKeyword_1_0_2();
			return new Solution(obj);
		}

		return null;
	}
}


/************ end Rule TerminalToken ****************/


/************ begin Rule TerminalTokenElement ****************
 *
 * TerminalTokenElement returns AbstractElement:
 *   CharacterRange|RuleCall|ParenthesizedTerminalElement|AbstractNegatedToken|Wildcard;
 *
 **/

// CharacterRange|RuleCall|ParenthesizedTerminalElement|AbstractNegatedToken|Wildcard
protected class TerminalTokenElement_Alternatives extends AlternativesToken {

	public TerminalTokenElement_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new TerminalTokenElement_0_RuleCall_CharacterRange(current, this);
			case 1: return new TerminalTokenElement_1_RuleCall_RuleCall(current, this);
			case 2: return new TerminalTokenElement_2_RuleCall_ParenthesizedTerminalElement(current, this);
			case 3: return new TerminalTokenElement_3_RuleCall_AbstractNegatedToken(current, this);
			case 4: return new TerminalTokenElement_4_RuleCall_Wildcard(current, this);
			default: return null;
		}
	}
}

// CharacterRange
protected class TerminalTokenElement_0_RuleCall_CharacterRange extends RuleCallToken {
	
	public TerminalTokenElement_0_RuleCall_CharacterRange(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getCharacterRangeParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(CharacterRange_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getCharacterRangeRule().getType().getClassifier())) return null;
		return new CharacterRange_Group(current, this).firstSolution();
	}
}

// RuleCall
protected class TerminalTokenElement_1_RuleCall_RuleCall extends RuleCallToken {
	
	public TerminalTokenElement_1_RuleCall_RuleCall(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getRuleCallParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(RuleCall_Assignment_rule.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getRuleCallRule().getType().getClassifier())) return null;
		return new RuleCall_Assignment_rule(current, this).firstSolution();
	}
}

// ParenthesizedTerminalElement
protected class TerminalTokenElement_2_RuleCall_ParenthesizedTerminalElement extends RuleCallToken {
	
	public TerminalTokenElement_2_RuleCall_ParenthesizedTerminalElement(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getParenthesizedTerminalElementParserRuleCall_2();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(ParenthesizedTerminalElement_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParenthesizedTerminalElementRule().getType().getClassifier())) return null;
		return new ParenthesizedTerminalElement_Group(current, this).firstSolution();
	}
}

// AbstractNegatedToken
protected class TerminalTokenElement_3_RuleCall_AbstractNegatedToken extends RuleCallToken {
	
	public TerminalTokenElement_3_RuleCall_AbstractNegatedToken(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getAbstractNegatedTokenParserRuleCall_3();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AbstractNegatedToken_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAbstractNegatedTokenRule().getType().getClassifier())) return null;
		return new AbstractNegatedToken_Alternatives(current, this).firstSolution();
	}
}

// Wildcard
protected class TerminalTokenElement_4_RuleCall_Wildcard extends RuleCallToken {
	
	public TerminalTokenElement_4_RuleCall_Wildcard(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getTerminalTokenElementAccess().getWildcardParserRuleCall_4();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Wildcard_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getWildcardRule().getType().getClassifier())) return null;
		return new Wildcard_Group(current, this).firstSolution();
	}
}


/************ end Rule TerminalTokenElement ****************/


/************ begin Rule ParenthesizedTerminalElement ****************
 *
 * ParenthesizedTerminalElement returns AbstractElement:
 *   "(" TerminalAlternatives ")";
 *
 **/

// "(" TerminalAlternatives ")"
protected class ParenthesizedTerminalElement_Group extends GroupToken {
	
	public ParenthesizedTerminalElement_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getParenthesizedTerminalElementAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new ParenthesizedTerminalElement_2_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new ParenthesizedTerminalElement_1_RuleCall_TerminalAlternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new ParenthesizedTerminalElement_0_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "("
protected class ParenthesizedTerminalElement_0_Keyword extends KeywordToken  {
	
	public ParenthesizedTerminalElement_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedTerminalElementAccess().getLeftParenthesisKeyword_0();
	}	
}

// TerminalAlternatives
protected class ParenthesizedTerminalElement_1_RuleCall_TerminalAlternatives extends RuleCallToken {
	
	public ParenthesizedTerminalElement_1_RuleCall_TerminalAlternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getParenthesizedTerminalElementAccess().getTerminalAlternativesParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(TerminalAlternatives_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTerminalAlternativesRule().getType().getClassifier())) return null;
		return new TerminalAlternatives_Group(current, this).firstSolution();
	}
}

// ")"
protected class ParenthesizedTerminalElement_2_Keyword extends KeywordToken  {
	
	public ParenthesizedTerminalElement_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParenthesizedTerminalElementAccess().getRightParenthesisKeyword_2();
	}	
}


/************ end Rule ParenthesizedTerminalElement ****************/


/************ begin Rule AbstractNegatedToken ****************
 *
 * AbstractNegatedToken:
 *   NegatedToken|UntilToken;
 *
 **/

// NegatedToken|UntilToken
protected class AbstractNegatedToken_Alternatives extends AlternativesToken {

	public AbstractNegatedToken_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractNegatedTokenAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractNegatedToken_0_RuleCall_NegatedToken(current, this);
			case 1: return new AbstractNegatedToken_1_RuleCall_UntilToken(current, this);
			default: return null;
		}
	}
}

// NegatedToken
protected class AbstractNegatedToken_0_RuleCall_NegatedToken extends RuleCallToken {
	
	public AbstractNegatedToken_0_RuleCall_NegatedToken(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractNegatedTokenAccess().getNegatedTokenParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(NegatedToken_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getNegatedTokenRule().getType().getClassifier())) return null;
		return new NegatedToken_Group(current, this).firstSolution();
	}
}

// UntilToken
protected class AbstractNegatedToken_1_RuleCall_UntilToken extends RuleCallToken {
	
	public AbstractNegatedToken_1_RuleCall_UntilToken(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractNegatedTokenAccess().getUntilTokenParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(UntilToken_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getUntilTokenRule().getType().getClassifier())) return null;
		return new UntilToken_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractNegatedToken ****************/


/************ begin Rule NegatedToken ****************
 *
 * NegatedToken:
 *   "!" ^terminal=TerminalTokenElement;
 *
 **/

// "!" ^terminal=TerminalTokenElement
protected class NegatedToken_Group extends GroupToken {
	
	public NegatedToken_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNegatedTokenAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new NegatedToken_1_Assignment_terminal(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new NegatedToken_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "!"
protected class NegatedToken_0_Keyword extends KeywordToken  {
	
	public NegatedToken_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNegatedTokenAccess().getExclamationMarkKeyword_0();
	}	
}

// ^terminal=TerminalTokenElement
protected class NegatedToken_1_Assignment_terminal extends AssignmentToken  {
	
	public NegatedToken_1_Assignment_terminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNegatedTokenAccess().getTerminalAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("terminal",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("terminal");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTerminalTokenElementRule().getType().getClassifier())) {
				Solution s = new TerminalTokenElement_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule NegatedToken ****************/


/************ begin Rule UntilToken ****************
 *
 * UntilToken:
 *   "->" ^terminal=TerminalTokenElement;
 *
 **/

// "->" ^terminal=TerminalTokenElement
protected class UntilToken_Group extends GroupToken {
	
	public UntilToken_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getUntilTokenAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new UntilToken_1_Assignment_terminal(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new UntilToken_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "->"
protected class UntilToken_0_Keyword extends KeywordToken  {
	
	public UntilToken_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getUntilTokenAccess().getHyphenMinusGreaterThanSignKeyword_0();
	}	
}

// ^terminal=TerminalTokenElement
protected class UntilToken_1_Assignment_terminal extends AssignmentToken  {
	
	public UntilToken_1_Assignment_terminal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getUntilTokenAccess().getTerminalAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("terminal",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("terminal");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTerminalTokenElementRule().getType().getClassifier())) {
				Solution s = new TerminalTokenElement_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


/************ end Rule UntilToken ****************/


/************ begin Rule Wildcard ****************
 *
 * Wildcard:
 *   {Wildcard} ".";
 *
 **/

// {Wildcard} "."
protected class Wildcard_Group extends GroupToken {
	
	public Wildcard_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWildcardAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Wildcard_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Wildcard_0_Action_Wildcard(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// {Wildcard}
protected class Wildcard_0_Action_Wildcard extends ActionToken  {

	public Wildcard_0_Action_Wildcard(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getWildcardAccess().getWildcardAction_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.getWildcardAccess().getWildcardAction_0().getType().getClassifier())) return null;
		if(!current.isConsumed()) return null;
		return new Solution(current);
	}
}

// "."
protected class Wildcard_1_Keyword extends KeywordToken  {
	
	public Wildcard_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getWildcardAccess().getFullStopKeyword_1();
	}	
}


/************ end Rule Wildcard ****************/


/************ begin Rule CharacterRange ****************
 *
 * CharacterRange returns AbstractElement:
 *   Keyword ({CharacterRange.left=current} ".." right=Keyword)?;
 *
 **/

// Keyword ({CharacterRange.left=current} ".." right=Keyword)?
protected class CharacterRange_Group extends GroupToken {
	
	public CharacterRange_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CharacterRange_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CharacterRange_0_RuleCall_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// Keyword
protected class CharacterRange_0_RuleCall_Keyword extends RuleCallToken {
	
	public CharacterRange_0_RuleCall_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getKeywordParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Keyword_Assignment_value.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) return null;
		return new Keyword_Assignment_value(current, this).firstSolution();
	}
}

// ({CharacterRange.left=current} ".." right=Keyword)?
protected class CharacterRange_1_Group extends GroupToken {
	
	public CharacterRange_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new CharacterRange_1_2_Assignment_right(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new CharacterRange_1_1_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new CharacterRange_1_0_Action_CharacterRange_left(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				if(s3 != null) {
					last = s3.getPredecessor();
					return s3;
				} else {
					s2 = s2.getPredecessor().nextSolution(this,s2);
				}
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// {CharacterRange.left=current}
protected class CharacterRange_1_0_Action_CharacterRange_left extends ActionToken  {

	public CharacterRange_1_0_Action_CharacterRange_left(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getCharacterRangeLeftAction_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.getCharacterRangeAccess().getCharacterRangeLeftAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("left", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("left")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// ".."
protected class CharacterRange_1_1_Keyword extends KeywordToken  {
	
	public CharacterRange_1_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getFullStopFullStopKeyword_1_1();
	}	
}

// right=Keyword
protected class CharacterRange_1_2_Assignment_right extends AssignmentToken  {
	
	public CharacterRange_1_2_Assignment_right(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getCharacterRangeAccess().getRightAssignment_1_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("right",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("right");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) {
				Solution s = new Keyword_Assignment_value(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



/************ end Rule CharacterRange ****************/


/************ begin Rule EnumRule ****************
 *
 * EnumRule:
 *   "enum" name=ID ("returns" type=TypeRef)? ":" alternatives=EnumLiterals ";";
 *
 **/

// "enum" name=ID ("returns" type=TypeRef)? ":" alternatives=EnumLiterals ";"
protected class EnumRule_Group extends GroupToken {
	
	public EnumRule_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new EnumRule_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new EnumRule_4_Assignment_alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new EnumRule_3_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new EnumRule_2_Group(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new EnumRule_1_Assignment_name(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new EnumRule_0_Keyword_enum(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							if(s6 != null) {
								last = s6.getPredecessor();
								return s6;
							} else {
								s5 = s5.getPredecessor().nextSolution(this,s5);
							}
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "enum"
protected class EnumRule_0_Keyword_enum extends KeywordToken  {
	
	public EnumRule_0_Keyword_enum(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getEnumKeyword_0();
	}	
}

// name=ID
protected class EnumRule_1_Assignment_name extends AssignmentToken  {
	
	public EnumRule_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getEnumRuleAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// ("returns" type=TypeRef)?
protected class EnumRule_2_Group extends GroupToken {
	
	public EnumRule_2_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getGroup_2();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new EnumRule_2_1_Assignment_type(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new EnumRule_2_0_Keyword_returns(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "returns"
protected class EnumRule_2_0_Keyword_returns extends KeywordToken  {
	
	public EnumRule_2_0_Keyword_returns(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getReturnsKeyword_2_0();
	}	
}

// type=TypeRef
protected class EnumRule_2_1_Assignment_type extends AssignmentToken  {
	
	public EnumRule_2_1_Assignment_type(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getTypeAssignment_2_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("type",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("type");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTypeRefRule().getType().getClassifier())) {
				Solution s = new TypeRef_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// ":"
protected class EnumRule_3_Keyword extends KeywordToken  {
	
	public EnumRule_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getColonKeyword_3();
	}	
}

// alternatives=EnumLiterals
protected class EnumRule_4_Assignment_alternatives extends AssignmentToken  {
	
	public EnumRule_4_Assignment_alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getAlternativesAssignment_4();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("alternatives",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("alternatives");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumLiteralsRule().getType().getClassifier())) {
				Solution s = new EnumLiterals_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ";"
protected class EnumRule_5_Keyword extends KeywordToken  {
	
	public EnumRule_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumRuleAccess().getSemicolonKeyword_5();
	}	
}


/************ end Rule EnumRule ****************/


/************ begin Rule EnumLiterals ****************
 *
 * EnumLiterals returns AbstractElement:
 *   EnumLiteralDeclaration ({Alternatives.groups+=current} ("|" groups+=EnumLiteralDeclaration)+)?;
 *
 **/

// EnumLiteralDeclaration ({Alternatives.groups+=current} ("|" groups+=EnumLiteralDeclaration)+)?
protected class EnumLiterals_Group extends GroupToken {
	
	public EnumLiterals_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new EnumLiterals_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new EnumLiterals_0_RuleCall_EnumLiteralDeclaration(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// EnumLiteralDeclaration
protected class EnumLiterals_0_RuleCall_EnumLiteralDeclaration extends RuleCallToken {
	
	public EnumLiterals_0_RuleCall_EnumLiteralDeclaration(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getEnumLiteralDeclarationParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(EnumLiteralDeclaration_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getEnumLiteralDeclarationRule().getType().getClassifier())) return null;
		return new EnumLiteralDeclaration_Group(current, this).firstSolution();
	}
}

// ({Alternatives.groups+=current} ("|" groups+=EnumLiteralDeclaration)+)?
protected class EnumLiterals_1_Group extends GroupToken {
	
	public EnumLiterals_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new EnumLiterals_1_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new EnumLiterals_1_0_Action_Alternatives_groups(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// {Alternatives.groups+=current}
protected class EnumLiterals_1_0_Action_Alternatives_groups extends ActionToken  {

	public EnumLiterals_1_0_Action_Alternatives_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getAlternativesGroupsAction_1_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(!current.isInstanceOf(grammarAccess.getEnumLiteralsAccess().getAlternativesGroupsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("groups", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("groups")) return null;
		return new Solution(getDescr((EObject)val));
	}
}

// ("|" groups+=EnumLiteralDeclaration)+
protected class EnumLiterals_1_1_Group extends GroupToken {
	
	public EnumLiterals_1_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getGroup_1_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new EnumLiterals_1_1_1_Assignment_groups(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new EnumLiterals_1_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "|"
protected class EnumLiterals_1_1_0_Keyword extends KeywordToken  {
	
	public EnumLiterals_1_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getVerticalLineKeyword_1_1_0();
	}	
}

// groups+=EnumLiteralDeclaration
protected class EnumLiterals_1_1_1_Assignment_groups extends AssignmentToken  {
	
	public EnumLiterals_1_1_1_Assignment_groups(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumLiteralsAccess().getGroupsAssignment_1_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("groups",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("groups");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumLiteralDeclarationRule().getType().getClassifier())) {
				Solution s = new EnumLiteralDeclaration_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}




/************ end Rule EnumLiterals ****************/


/************ begin Rule EnumLiteralDeclaration ****************
 *
 * EnumLiteralDeclaration:
 *   enumLiteral=[ecore::EEnumLiteral] ("=" literal=Keyword)?;
 *
 **/

// enumLiteral=[ecore::EEnumLiteral] ("=" literal=Keyword)?
protected class EnumLiteralDeclaration_Group extends GroupToken {
	
	public EnumLiteralDeclaration_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumLiteralDeclarationAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new EnumLiteralDeclaration_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new EnumLiteralDeclaration_0_Assignment_enumLiteral(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// enumLiteral=[ecore::EEnumLiteral]
protected class EnumLiteralDeclaration_0_Assignment_enumLiteral extends AssignmentToken  {
	
	public EnumLiteralDeclaration_0_Assignment_enumLiteral(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumLiteralDeclarationAccess().getEnumLiteralAssignment_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("enumLiteral",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("enumLiteral");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::CrossReferenceImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getEnumLiteralDeclarationAccess().getEnumLiteralEEnumLiteralCrossReference_0_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getEnumLiteralDeclarationAccess().getEnumLiteralEEnumLiteralCrossReference_0_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// ("=" literal=Keyword)?
protected class EnumLiteralDeclaration_1_Group extends GroupToken {
	
	public EnumLiteralDeclaration_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getEnumLiteralDeclarationAccess().getGroup_1();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new EnumLiteralDeclaration_1_1_Assignment_literal(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new EnumLiteralDeclaration_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// "="
protected class EnumLiteralDeclaration_1_0_Keyword extends KeywordToken  {
	
	public EnumLiteralDeclaration_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getEnumLiteralDeclarationAccess().getEqualsSignKeyword_1_0();
	}	
}

// literal=Keyword
protected class EnumLiteralDeclaration_1_1_Assignment_literal extends AssignmentToken  {
	
	public EnumLiteralDeclaration_1_1_Assignment_literal(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getEnumLiteralDeclarationAccess().getLiteralAssignment_1_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("literal",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("literal");

		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getKeywordRule().getType().getClassifier())) {
				Solution s = new Keyword_Assignment_value(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



/************ end Rule EnumLiteralDeclaration ****************/

}
