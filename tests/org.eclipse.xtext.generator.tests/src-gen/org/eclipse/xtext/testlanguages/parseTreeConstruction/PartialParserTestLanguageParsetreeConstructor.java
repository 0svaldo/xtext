/*
* generated by Xtext
*/
package org.eclipse.xtext.testlanguages.parseTreeConstruction;

//import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.AbstractToken.Solution;
import org.eclipse.xtext.testlanguages.services.PartialParserTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class PartialParserTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private PartialParserTestLanguageGrammarAccess grammarAccess;
	
	@Override
	protected Solution internalSerialize(EObject obj) {
		IInstanceDescription inst = getDescr(obj);
		Solution s;
		if(inst.isInstanceOf(grammarAccess.getSomeContainerRule().getType().getClassifier()) && (s = new SomeContainer_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getNestedRule().getType().getClassifier()) && (s = new Nested_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getContentRule().getType().getClassifier()) && (s = new Content_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getChildrenRule().getType().getClassifier()) && (s = new Children_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getChildRule().getType().getClassifier()) && (s = new Child_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAbstractChildrenRule().getType().getClassifier()) && (s = new AbstractChildren_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getAbstractChildRule().getType().getClassifier()) && (s = new AbstractChild_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getFirstConcreteRule().getType().getClassifier()) && (s = new FirstConcrete_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getSecondConcreteRule().getType().getClassifier()) && (s = new SecondConcrete_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.getNamedRule().getType().getClassifier()) && (s = new Named_Assignment_name(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		return null;
	}
	

/************ begin Rule SomeContainer ****************
 *
 * SomeContainer:
 *   "container" name=ID "{" (nested+=Nested|content+=Content)* "}";
 *
 **/

// "container" name=ID "{" (nested+=Nested|content+=Content)* "}"
protected class SomeContainer_Group extends GroupToken {
	
	public SomeContainer_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSomeContainerAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SomeContainer_4_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SomeContainer_3_Alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new SomeContainer_2_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new SomeContainer_1_Assignment_name(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new SomeContainer_0_Keyword_container(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						if(s5 != null) {
							last = s5.getPredecessor();
							return s5;
						} else {
							s4 = s4.getPredecessor().nextSolution(this,s4);
						}
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "container"
protected class SomeContainer_0_Keyword_container extends KeywordToken  {
	
	public SomeContainer_0_Keyword_container(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSomeContainerAccess().getContainerKeyword_0();
	}	
}

// name=ID
protected class SomeContainer_1_Assignment_name extends AssignmentToken  {
	
	public SomeContainer_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSomeContainerAccess().getNameAssignment_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getSomeContainerAccess().getNameIDTerminalRuleCall_1_0();
			return new Solution(obj);
		}
		return null;
	}
}

// "{"
protected class SomeContainer_2_Keyword extends KeywordToken  {
	
	public SomeContainer_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSomeContainerAccess().getLeftCurlyBracketKeyword_2();
	}	
}

// (nested+=Nested|content+=Content)*
protected class SomeContainer_3_Alternatives extends AlternativesToken {

	public SomeContainer_3_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getSomeContainerAccess().getAlternatives_3();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new SomeContainer_3_0_Assignment_nested(current, this);
			case 1: return new SomeContainer_3_1_Assignment_content(current, this);
			default: return null;
		}
	}
}

// nested+=Nested
protected class SomeContainer_3_0_Assignment_nested extends AssignmentToken  {
	
	public SomeContainer_3_0_Assignment_nested(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSomeContainerAccess().getNestedAssignment_3_0();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("nested",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nested");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNestedRule().getType().getClassifier())) {
				Solution s = new Nested_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// content+=Content
protected class SomeContainer_3_1_Assignment_content extends AssignmentToken  {
	
	public SomeContainer_3_1_Assignment_content(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSomeContainerAccess().getContentAssignment_3_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("content",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("content");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getContentRule().getType().getClassifier())) {
				Solution s = new Content_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// "}"
protected class SomeContainer_4_Keyword extends KeywordToken  {
	
	public SomeContainer_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSomeContainerAccess().getRightCurlyBracketKeyword_4();
	}	
}


/************ end Rule SomeContainer ****************/


/************ begin Rule Nested ****************
 *
 * Nested:
 *   "nested" "{" (nested+=SomeContainer)+ "}";
 *
 **/

// "nested" "{" (nested+=SomeContainer)+ "}"
protected class Nested_Group extends GroupToken {
	
	public Nested_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getNestedAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Nested_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Nested_2_Assignment_nested(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Nested_1_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Nested_0_Keyword_nested(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "nested"
protected class Nested_0_Keyword_nested extends KeywordToken  {
	
	public Nested_0_Keyword_nested(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNestedAccess().getNestedKeyword_0();
	}	
}

// "{"
protected class Nested_1_Keyword extends KeywordToken  {
	
	public Nested_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNestedAccess().getLeftCurlyBracketKeyword_1();
	}	
}

// (nested+=SomeContainer)+
protected class Nested_2_Assignment_nested extends AssignmentToken  {
	
	public Nested_2_Assignment_nested(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNestedAccess().getNestedAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("nested",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nested");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSomeContainerRule().getType().getClassifier())) {
				Solution s = new SomeContainer_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// "}"
protected class Nested_3_Keyword extends KeywordToken  {
	
	public Nested_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getNestedAccess().getRightCurlyBracketKeyword_3();
	}	
}


/************ end Rule Nested ****************/


/************ begin Rule Content ****************
 *
 * Content:
 *   Children|AbstractChildren;
 *
 **/

// Children|AbstractChildren
protected class Content_Alternatives extends AlternativesToken {

	public Content_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getContentAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Content_0_RuleCall_Children(current, this);
			case 1: return new Content_1_RuleCall_AbstractChildren(current, this);
			default: return null;
		}
	}
}

// Children
protected class Content_0_RuleCall_Children extends RuleCallToken {
	
	public Content_0_RuleCall_Children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getContentAccess().getChildrenParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Children_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getChildrenRule().getType().getClassifier())) return null;
		return new Children_Group(current, this).firstSolution();
	}
}

// AbstractChildren
protected class Content_1_RuleCall_AbstractChildren extends RuleCallToken {
	
	public Content_1_RuleCall_AbstractChildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getContentAccess().getAbstractChildrenParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AbstractChildren_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAbstractChildrenRule().getType().getClassifier())) return null;
		return new AbstractChildren_Group(current, this).firstSolution();
	}
}


/************ end Rule Content ****************/


/************ begin Rule Children ****************
 *
 * Children:
 *   "children" "{" children+=Child ("," children+=Child)* "}";
 *
 **/

// "children" "{" children+=Child ("," children+=Child)* "}"
protected class Children_Group extends GroupToken {
	
	public Children_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getChildrenAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Children_4_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Children_3_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Children_2_Assignment_children(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Children_1_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new Children_0_Keyword_children(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						if(s5 != null) {
							last = s5.getPredecessor();
							return s5;
						} else {
							s4 = s4.getPredecessor().nextSolution(this,s4);
						}
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "children"
protected class Children_0_Keyword_children extends KeywordToken  {
	
	public Children_0_Keyword_children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getChildrenAccess().getChildrenKeyword_0();
	}	
}

// "{"
protected class Children_1_Keyword extends KeywordToken  {
	
	public Children_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getChildrenAccess().getLeftCurlyBracketKeyword_1();
	}	
}

// children+=Child
protected class Children_2_Assignment_children extends AssignmentToken  {
	
	public Children_2_Assignment_children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getChildrenAccess().getChildrenAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("children",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("children");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getChildRule().getType().getClassifier())) {
				Solution s = new Child_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ("," children+=Child)*
protected class Children_3_Group extends GroupToken {
	
	public Children_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getChildrenAccess().getGroup_3();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Children_3_1_Assignment_children(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Children_3_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// ","
protected class Children_3_0_Keyword extends KeywordToken  {
	
	public Children_3_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getChildrenAccess().getCommaKeyword_3_0();
	}	
}

// children+=Child
protected class Children_3_1_Assignment_children extends AssignmentToken  {
	
	public Children_3_1_Assignment_children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getChildrenAccess().getChildrenAssignment_3_1();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("children",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("children");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getChildRule().getType().getClassifier())) {
				Solution s = new Child_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// "}"
protected class Children_4_Keyword extends KeywordToken  {
	
	public Children_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getChildrenAccess().getRightCurlyBracketKeyword_4();
	}	
}


/************ end Rule Children ****************/


/************ begin Rule Child ****************
 *
 * Child:
 *   "->" "C" "(" value=Named ")";
 *
 **/

// "->" "C" "(" value=Named ")"
protected class Child_Group extends GroupToken {
	
	public Child_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getChildAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Child_4_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Child_3_Assignment_value(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new Child_2_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new Child_1_Keyword_C(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new Child_0_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						if(s5 != null) {
							last = s5.getPredecessor();
							return s5;
						} else {
							s4 = s4.getPredecessor().nextSolution(this,s4);
						}
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "->"
protected class Child_0_Keyword extends KeywordToken  {
	
	public Child_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getChildAccess().getHyphenMinusGreaterThanSignKeyword_0();
	}	
}

// "C"
protected class Child_1_Keyword_C extends KeywordToken  {
	
	public Child_1_Keyword_C(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getChildAccess().getCKeyword_1();
	}	
}

// "("
protected class Child_2_Keyword extends KeywordToken  {
	
	public Child_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getChildAccess().getLeftParenthesisKeyword_2();
	}	
}

// value=Named
protected class Child_3_Assignment_value extends AssignmentToken  {
	
	public Child_3_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getChildAccess().getValueAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNamedRule().getType().getClassifier())) {
				Solution s = new Named_Assignment_name(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// ")"
protected class Child_4_Keyword extends KeywordToken  {
	
	public Child_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getChildAccess().getRightParenthesisKeyword_4();
	}	
}


/************ end Rule Child ****************/


/************ begin Rule AbstractChildren ****************
 *
 * AbstractChildren:
 *   "abstract children" "{" (abstractChildren+=AbstractChild)+ "}";
 *
 **/

// "abstract children" "{" (abstractChildren+=AbstractChild)+ "}"
protected class AbstractChildren_Group extends GroupToken {
	
	public AbstractChildren_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAbstractChildrenAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AbstractChildren_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AbstractChildren_2_Assignment_abstractChildren(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new AbstractChildren_1_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new AbstractChildren_0_Keyword_abstractchildren(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					if(s4 != null) {
						last = s4.getPredecessor();
						return s4;
					} else {
						s3 = s3.getPredecessor().nextSolution(this,s3);
					}
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "abstract children"
protected class AbstractChildren_0_Keyword_abstractchildren extends KeywordToken  {
	
	public AbstractChildren_0_Keyword_abstractchildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAbstractChildrenAccess().getAbstractChildrenKeyword_0();
	}	
}

// "{"
protected class AbstractChildren_1_Keyword extends KeywordToken  {
	
	public AbstractChildren_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAbstractChildrenAccess().getLeftCurlyBracketKeyword_1();
	}	
}

// (abstractChildren+=AbstractChild)+
protected class AbstractChildren_2_Assignment_abstractChildren extends AssignmentToken  {
	
	public AbstractChildren_2_Assignment_abstractChildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAbstractChildrenAccess().getAbstractChildrenAssignment_2();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("abstractChildren",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("abstractChildren");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAbstractChildRule().getType().getClassifier())) {
				Solution s = new AbstractChild_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// "}"
protected class AbstractChildren_3_Keyword extends KeywordToken  {
	
	public AbstractChildren_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAbstractChildrenAccess().getRightCurlyBracketKeyword_3();
	}	
}


/************ end Rule AbstractChildren ****************/


/************ begin Rule AbstractChild ****************
 *
 * AbstractChild:
 *   FirstConcrete|SecondConcrete;
 *
 **/

// FirstConcrete|SecondConcrete
protected class AbstractChild_Alternatives extends AlternativesToken {

	public AbstractChild_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getAbstractChildAccess().getAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractChild_0_RuleCall_FirstConcrete(current, this);
			case 1: return new AbstractChild_1_RuleCall_SecondConcrete(current, this);
			default: return null;
		}
	}
}

// FirstConcrete
protected class AbstractChild_0_RuleCall_FirstConcrete extends RuleCallToken {
	
	public AbstractChild_0_RuleCall_FirstConcrete(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractChildAccess().getFirstConcreteParserRuleCall_0();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(FirstConcrete_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getFirstConcreteRule().getType().getClassifier())) return null;
		return new FirstConcrete_Group(current, this).firstSolution();
	}
}

// SecondConcrete
protected class AbstractChild_1_RuleCall_SecondConcrete extends RuleCallToken {
	
	public AbstractChild_1_RuleCall_SecondConcrete(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAbstractChildAccess().getSecondConcreteParserRuleCall_1();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(SecondConcrete_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getSecondConcreteRule().getType().getClassifier())) return null;
		return new SecondConcrete_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractChild ****************/


/************ begin Rule FirstConcrete ****************
 *
 * FirstConcrete:
 *   "->" "F" "(" value=Named (referencedContainer=[SomeContainer])? ")";
 *
 **/

// "->" "F" "(" value=Named (referencedContainer=[SomeContainer])? ")"
protected class FirstConcrete_Group extends GroupToken {
	
	public FirstConcrete_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getFirstConcreteAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new FirstConcrete_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new FirstConcrete_4_Assignment_referencedContainer(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new FirstConcrete_3_Assignment_value(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new FirstConcrete_2_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new FirstConcrete_1_Keyword_F(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new FirstConcrete_0_Keyword(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							if(s6 != null) {
								last = s6.getPredecessor();
								return s6;
							} else {
								s5 = s5.getPredecessor().nextSolution(this,s5);
							}
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "->"
protected class FirstConcrete_0_Keyword extends KeywordToken  {
	
	public FirstConcrete_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getFirstConcreteAccess().getHyphenMinusGreaterThanSignKeyword_0();
	}	
}

// "F"
protected class FirstConcrete_1_Keyword_F extends KeywordToken  {
	
	public FirstConcrete_1_Keyword_F(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getFirstConcreteAccess().getFKeyword_1();
	}	
}

// "("
protected class FirstConcrete_2_Keyword extends KeywordToken  {
	
	public FirstConcrete_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getFirstConcreteAccess().getLeftParenthesisKeyword_2();
	}	
}

// value=Named
protected class FirstConcrete_3_Assignment_value extends AssignmentToken  {
	
	public FirstConcrete_3_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFirstConcreteAccess().getValueAssignment_3();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNamedRule().getType().getClassifier())) {
				Solution s = new Named_Assignment_name(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// (referencedContainer=[SomeContainer])?
protected class FirstConcrete_4_Assignment_referencedContainer extends AssignmentToken  {
	
	public FirstConcrete_4_Assignment_referencedContainer(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFirstConcreteAccess().getReferencedContainerAssignment_4();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("referencedContainer",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("referencedContainer");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getFirstConcreteAccess().getReferencedContainerSomeContainerCrossReference_4_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getFirstConcreteAccess().getReferencedContainerSomeContainerCrossReference_4_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// ")"
protected class FirstConcrete_5_Keyword extends KeywordToken  {
	
	public FirstConcrete_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getFirstConcreteAccess().getRightParenthesisKeyword_5();
	}	
}


/************ end Rule FirstConcrete ****************/


/************ begin Rule SecondConcrete ****************
 *
 * SecondConcrete:
 *   "->" "F" "S" "(" value=Named (referencedChildren+=[Child])? ")";
 *
 **/

// "->" "F" "S" "(" value=Named (referencedChildren+=[Child])? ")"
protected class SecondConcrete_Group extends GroupToken {
	
	public SecondConcrete_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSecondConcreteAccess().getGroup();
	}

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SecondConcrete_6_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SecondConcrete_5_Assignment_referencedChildren(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			while(s2 != null) {
				Solution s3 = new SecondConcrete_4_Assignment_value(s2.getCurrent(), s2.getPredecessor()).firstSolution();
				while(s3 != null) {
					Solution s4 = new SecondConcrete_3_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
					while(s4 != null) {
						Solution s5 = new SecondConcrete_2_Keyword_S(s4.getCurrent(), s4.getPredecessor()).firstSolution();
						while(s5 != null) {
							Solution s6 = new SecondConcrete_1_Keyword_F(s5.getCurrent(), s5.getPredecessor()).firstSolution();
							while(s6 != null) {
								Solution s7 = new SecondConcrete_0_Keyword(s6.getCurrent(), s6.getPredecessor()).firstSolution();
								if(s7 != null) {
									last = s7.getPredecessor();
									return s7;
								} else {
									s6 = s6.getPredecessor().nextSolution(this,s6);
								}
							}
							s5 = s5.getPredecessor().nextSolution(this,s5);
						}
						s4 = s4.getPredecessor().nextSolution(this,s4);
					}
					s3 = s3.getPredecessor().nextSolution(this,s3);
				}
				s2 = s2.getPredecessor().nextSolution(this,s2);
			}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// "->"
protected class SecondConcrete_0_Keyword extends KeywordToken  {
	
	public SecondConcrete_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSecondConcreteAccess().getHyphenMinusGreaterThanSignKeyword_0();
	}	
}

// "F"
protected class SecondConcrete_1_Keyword_F extends KeywordToken  {
	
	public SecondConcrete_1_Keyword_F(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSecondConcreteAccess().getFKeyword_1();
	}	
}

// "S"
protected class SecondConcrete_2_Keyword_S extends KeywordToken  {
	
	public SecondConcrete_2_Keyword_S(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSecondConcreteAccess().getSKeyword_2();
	}	
}

// "("
protected class SecondConcrete_3_Keyword extends KeywordToken  {
	
	public SecondConcrete_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSecondConcreteAccess().getLeftParenthesisKeyword_3();
	}	
}

// value=Named
protected class SecondConcrete_4_Assignment_value extends AssignmentToken  {
	
	public SecondConcrete_4_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSecondConcreteAccess().getValueAssignment_4();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getNamedRule().getType().getClassifier())) {
				Solution s = new Named_Assignment_name(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// (referencedChildren+=[Child])?
protected class SecondConcrete_5_Assignment_referencedChildren extends AssignmentToken  {
	
	public SecondConcrete_5_Assignment_referencedChildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSecondConcreteAccess().getReferencedChildrenAssignment_5();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("referencedChildren",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("referencedChildren");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getSecondConcreteAccess().getReferencedChildrenChildCrossReference_5_0().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.getSecondConcreteAccess().getReferencedChildrenChildCrossReference_5_0(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// ")"
protected class SecondConcrete_6_Keyword extends KeywordToken  {
	
	public SecondConcrete_6_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getSecondConcreteAccess().getRightParenthesisKeyword_6();
	}	
}


/************ end Rule SecondConcrete ****************/


/************ begin Rule Named ****************
 *
 * Named:
 *   name=ID;
 *
 **/

// name=ID
protected class Named_Assignment_name extends AssignmentToken  {
	
	public Named_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getNamedAccess().getNameAssignment();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getNamedAccess().getNameIDTerminalRuleCall_0();
			return new Solution(obj);
		}
		return null;
	}
}

/************ end Rule Named ****************/

}
