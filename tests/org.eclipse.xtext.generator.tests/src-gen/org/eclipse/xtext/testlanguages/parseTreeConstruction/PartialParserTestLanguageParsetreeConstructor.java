/*
* generated by Xtext
*/
package org.eclipse.xtext.testlanguages.parseTreeConstruction;

//import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.AbstractToken.Solution;
import org.eclipse.xtext.testlanguages.services.PartialParserTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class PartialParserTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private PartialParserTestLanguageGrammarAccess grammarAccess;
	
	@Override
	protected Solution internalSerialize(EObject obj) {
		IInstanceDescription inst = getDescr(obj);
		Solution s;
		if(inst.isInstanceOf(grammarAccess.prSomeContainer().getRule().getType().getClassifier()) && (s = new SomeContainer_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prNested().getRule().getType().getClassifier()) && (s = new Nested_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prContent().getRule().getType().getClassifier()) && (s = new Content_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prChildren().getRule().getType().getClassifier()) && (s = new Children_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prChild().getRule().getType().getClassifier()) && (s = new Child_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAbstractChildren().getRule().getType().getClassifier()) && (s = new AbstractChildren_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAbstractChild().getRule().getType().getClassifier()) && (s = new AbstractChild_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prFirstConcrete().getRule().getType().getClassifier()) && (s = new FirstConcrete_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prSecondConcrete().getRule().getType().getClassifier()) && (s = new SecondConcrete_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prNamed().getRule().getType().getClassifier()) && (s = new Named_Assignment_name(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		return null;
	}
	

/************ begin Rule SomeContainer ****************
 *
 * not supported
 *
 **/


// not supported
protected class SomeContainer_Group extends GroupToken {
	
	public SomeContainer_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSomeContainer().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SomeContainer_4_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SomeContainer_3_Alternatives(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new SomeContainer_2_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new SomeContainer_1_Assignment_name(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new SomeContainer_0_Keyword_container(s4.getCurrent(), s4.getPredecessor()).firstSolution();
			if(s5 != null) {
				last = s5.getPredecessor();
				return s5;
			} else {
				s4 = s4.getPredecessor().nextSolution(this,s4);
			}
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class SomeContainer_0_Keyword_container extends KeywordToken  {
	
	public SomeContainer_0_Keyword_container(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSomeContainer().ele0KeywordContainer();
	}	
}

// not supported
protected class SomeContainer_1_Assignment_name extends AssignmentToken  {
	
	public SomeContainer_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSomeContainer().ele1AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prSomeContainer().ele10TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

// not supported
protected class SomeContainer_2_Keyword extends KeywordToken  {
	
	public SomeContainer_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSomeContainer().ele2KeywordLeftCurlyBracket();
	}	
}

// not supported
protected class SomeContainer_3_Alternatives extends AlternativesToken {

	public SomeContainer_3_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prSomeContainer().ele3Alternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new SomeContainer_3_0_Assignment_nested(current, this);
			case 1: return new SomeContainer_3_1_Assignment_content(current, this);
			default: return null;
		}
	}
}

// not supported
protected class SomeContainer_3_0_Assignment_nested extends AssignmentToken  {
	
	public SomeContainer_3_0_Assignment_nested(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSomeContainer().ele30AssignmentNested();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("nested",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nested");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prNested().getRule().getType().getClassifier())) {
				Solution s = new Nested_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class SomeContainer_3_1_Assignment_content extends AssignmentToken  {
	
	public SomeContainer_3_1_Assignment_content(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSomeContainer().ele31AssignmentContent();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("content",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("content");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prContent().getRule().getType().getClassifier())) {
				Solution s = new Content_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class SomeContainer_4_Keyword extends KeywordToken  {
	
	public SomeContainer_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSomeContainer().ele4KeywordRightCurlyBracket();
	}	
}


/************ end Rule SomeContainer ****************/


/************ begin Rule Nested ****************
 *
 * not supported
 *
 **/


// not supported
protected class Nested_Group extends GroupToken {
	
	public Nested_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prNested().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Nested_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Nested_2_Assignment_nested(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Nested_1_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new Nested_0_Keyword_nested(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Nested_0_Keyword_nested extends KeywordToken  {
	
	public Nested_0_Keyword_nested(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNested().ele0KeywordNested();
	}	
}

// not supported
protected class Nested_1_Keyword extends KeywordToken  {
	
	public Nested_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNested().ele1KeywordLeftCurlyBracket();
	}	
}

// not supported
protected class Nested_2_Assignment_nested extends AssignmentToken  {
	
	public Nested_2_Assignment_nested(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prNested().ele2AssignmentNested();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("nested",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nested");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prSomeContainer().getRule().getType().getClassifier())) {
				Solution s = new SomeContainer_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class Nested_3_Keyword extends KeywordToken  {
	
	public Nested_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNested().ele3KeywordRightCurlyBracket();
	}	
}


/************ end Rule Nested ****************/


/************ begin Rule Content ****************
 *
 * not supported
 *
 **/


// not supported
protected class Content_Alternatives extends AlternativesToken {

	public Content_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prContent().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new Content_0_RuleCall_Children(current, this);
			case 1: return new Content_1_RuleCall_AbstractChildren(current, this);
			default: return null;
		}
	}
}

// not supported
protected class Content_0_RuleCall_Children extends RuleCallToken {
	
	public Content_0_RuleCall_Children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prContent().ele0ParserRuleCallChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Children_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prChildren().getRule().getType().getClassifier())) return null;
		return new Children_Group(current, this).firstSolution();
	}
}

// not supported
protected class Content_1_RuleCall_AbstractChildren extends RuleCallToken {
	
	public Content_1_RuleCall_AbstractChildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prContent().ele1ParserRuleCallAbstractChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AbstractChildren_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prAbstractChildren().getRule().getType().getClassifier())) return null;
		return new AbstractChildren_Group(current, this).firstSolution();
	}
}


/************ end Rule Content ****************/


/************ begin Rule Children ****************
 *
 * not supported
 *
 **/


// not supported
protected class Children_Group extends GroupToken {
	
	public Children_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChildren().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Children_4_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Children_3_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Children_2_Assignment_children(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new Children_1_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new Children_0_Keyword_children(s4.getCurrent(), s4.getPredecessor()).firstSolution();
			if(s5 != null) {
				last = s5.getPredecessor();
				return s5;
			} else {
				s4 = s4.getPredecessor().nextSolution(this,s4);
			}
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Children_0_Keyword_children extends KeywordToken  {
	
	public Children_0_Keyword_children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChildren().ele0KeywordChildren();
	}	
}

// not supported
protected class Children_1_Keyword extends KeywordToken  {
	
	public Children_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChildren().ele1KeywordLeftCurlyBracket();
	}	
}

// not supported
protected class Children_2_Assignment_children extends AssignmentToken  {
	
	public Children_2_Assignment_children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prChildren().ele2AssignmentChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("children",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("children");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prChild().getRule().getType().getClassifier())) {
				Solution s = new Child_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class Children_3_Group extends GroupToken {
	
	public Children_3_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChildren().ele3Group();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Children_3_1_Assignment_children(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Children_3_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 != null) {
				last = s2.getPredecessor();
				return s2;
			} else {
				s1 = s1.getPredecessor().nextSolution(this,s1);
			}
		}
		return null;
	}
}

// not supported
protected class Children_3_0_Keyword extends KeywordToken  {
	
	public Children_3_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChildren().ele30KeywordComma();
	}	
}

// not supported
protected class Children_3_1_Assignment_children extends AssignmentToken  {
	
	public Children_3_1_Assignment_children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prChildren().ele31AssignmentChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("children",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("children");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prChild().getRule().getType().getClassifier())) {
				Solution s = new Child_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class Children_4_Keyword extends KeywordToken  {
	
	public Children_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChildren().ele4KeywordRightCurlyBracket();
	}	
}


/************ end Rule Children ****************/


/************ begin Rule Child ****************
 *
 * not supported
 *
 **/


// not supported
protected class Child_Group extends GroupToken {
	
	public Child_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChild().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new Child_4_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Child_3_Assignment_value(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new Child_2_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new Child_1_Keyword_C(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new Child_0_Keyword(s4.getCurrent(), s4.getPredecessor()).firstSolution();
			if(s5 != null) {
				last = s5.getPredecessor();
				return s5;
			} else {
				s4 = s4.getPredecessor().nextSolution(this,s4);
			}
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class Child_0_Keyword extends KeywordToken  {
	
	public Child_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChild().ele0KeywordHyphenMinusGreaterThanSign();
	}	
}

// not supported
protected class Child_1_Keyword_C extends KeywordToken  {
	
	public Child_1_Keyword_C(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChild().ele1KeywordC();
	}	
}

// not supported
protected class Child_2_Keyword extends KeywordToken  {
	
	public Child_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChild().ele2KeywordLeftParenthesis();
	}	
}

// not supported
protected class Child_3_Assignment_value extends AssignmentToken  {
	
	public Child_3_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prChild().ele3AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prNamed().getRule().getType().getClassifier())) {
				Solution s = new Named_Assignment_name(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class Child_4_Keyword extends KeywordToken  {
	
	public Child_4_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChild().ele4KeywordRightParenthesis();
	}	
}


/************ end Rule Child ****************/


/************ begin Rule AbstractChildren ****************
 *
 * not supported
 *
 **/


// not supported
protected class AbstractChildren_Group extends GroupToken {
	
	public AbstractChildren_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAbstractChildren().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new AbstractChildren_3_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AbstractChildren_2_Assignment_abstractChildren(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new AbstractChildren_1_Keyword(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new AbstractChildren_0_Keyword_abstractchildren(s3.getCurrent(), s3.getPredecessor()).firstSolution();
			if(s4 != null) {
				last = s4.getPredecessor();
				return s4;
			} else {
				s3 = s3.getPredecessor().nextSolution(this,s3);
			}
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class AbstractChildren_0_Keyword_abstractchildren extends KeywordToken  {
	
	public AbstractChildren_0_Keyword_abstractchildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAbstractChildren().ele0KeywordAbstractChildren();
	}	
}

// not supported
protected class AbstractChildren_1_Keyword extends KeywordToken  {
	
	public AbstractChildren_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAbstractChildren().ele1KeywordLeftCurlyBracket();
	}	
}

// not supported
protected class AbstractChildren_2_Assignment_abstractChildren extends AssignmentToken  {
	
	public AbstractChildren_2_Assignment_abstractChildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAbstractChildren().ele2AssignmentAbstractChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("abstractChildren",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("abstractChildren");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAbstractChild().getRule().getType().getClassifier())) {
				Solution s = new AbstractChild_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class AbstractChildren_3_Keyword extends KeywordToken  {
	
	public AbstractChildren_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAbstractChildren().ele3KeywordRightCurlyBracket();
	}	
}


/************ end Rule AbstractChildren ****************/


/************ begin Rule AbstractChild ****************
 *
 * not supported
 *
 **/


// not supported
protected class AbstractChild_Alternatives extends AlternativesToken {

	public AbstractChild_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prAbstractChild().eleAlternatives();
	}

	protected AbstractToken createChild(int id) {
		switch(id) {
			case 0: return new AbstractChild_0_RuleCall_FirstConcrete(current, this);
			case 1: return new AbstractChild_1_RuleCall_SecondConcrete(current, this);
			default: return null;
		}
	}
}

// not supported
protected class AbstractChild_0_RuleCall_FirstConcrete extends RuleCallToken {
	
	public AbstractChild_0_RuleCall_FirstConcrete(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractChild().ele0ParserRuleCallFirstConcrete();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(FirstConcrete_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prFirstConcrete().getRule().getType().getClassifier())) return null;
		return new FirstConcrete_Group(current, this).firstSolution();
	}
}

// not supported
protected class AbstractChild_1_RuleCall_SecondConcrete extends RuleCallToken {
	
	public AbstractChild_1_RuleCall_SecondConcrete(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractChild().ele1ParserRuleCallSecondConcrete();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(SecondConcrete_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prSecondConcrete().getRule().getType().getClassifier())) return null;
		return new SecondConcrete_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractChild ****************/


/************ begin Rule FirstConcrete ****************
 *
 * not supported
 *
 **/


// not supported
protected class FirstConcrete_Group extends GroupToken {
	
	public FirstConcrete_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prFirstConcrete().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new FirstConcrete_5_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new FirstConcrete_4_Assignment_referencedContainer(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new FirstConcrete_3_Assignment_value(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new FirstConcrete_2_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new FirstConcrete_1_Keyword_F(s4.getCurrent(), s4.getPredecessor()).firstSolution();
		while(s5 != null) {
			Solution s6 = new FirstConcrete_0_Keyword(s5.getCurrent(), s5.getPredecessor()).firstSolution();
			if(s6 != null) {
				last = s6.getPredecessor();
				return s6;
			} else {
				s5 = s5.getPredecessor().nextSolution(this,s5);
			}
		}
			s4 = s4.getPredecessor().nextSolution(this,s4);
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class FirstConcrete_0_Keyword extends KeywordToken  {
	
	public FirstConcrete_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele0KeywordHyphenMinusGreaterThanSign();
	}	
}

// not supported
protected class FirstConcrete_1_Keyword_F extends KeywordToken  {
	
	public FirstConcrete_1_Keyword_F(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele1KeywordF();
	}	
}

// not supported
protected class FirstConcrete_2_Keyword extends KeywordToken  {
	
	public FirstConcrete_2_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele2KeywordLeftParenthesis();
	}	
}

// not supported
protected class FirstConcrete_3_Assignment_value extends AssignmentToken  {
	
	public FirstConcrete_3_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele3AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prNamed().getRule().getType().getClassifier())) {
				Solution s = new Named_Assignment_name(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class FirstConcrete_4_Assignment_referencedContainer extends AssignmentToken  {
	
	public FirstConcrete_4_Assignment_referencedContainer(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele4AssignmentReferencedContainer();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("referencedContainer",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("referencedContainer");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prFirstConcrete().ele40CrossReferenceIDSomeContainer().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.prFirstConcrete().ele40CrossReferenceIDSomeContainer(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class FirstConcrete_5_Keyword extends KeywordToken  {
	
	public FirstConcrete_5_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele5KeywordRightParenthesis();
	}	
}


/************ end Rule FirstConcrete ****************/


/************ begin Rule SecondConcrete ****************
 *
 * not supported
 *
 **/


// not supported
protected class SecondConcrete_Group extends GroupToken {
	
	public SecondConcrete_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSecondConcrete().eleGroup();
	}

	

	@Override
	protected Solution createSolution() {	
		Solution s1 = new SecondConcrete_6_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SecondConcrete_5_Assignment_referencedChildren(s1.getCurrent(), s1.getPredecessor()).firstSolution();
		while(s2 != null) {
			Solution s3 = new SecondConcrete_4_Assignment_value(s2.getCurrent(), s2.getPredecessor()).firstSolution();
		while(s3 != null) {
			Solution s4 = new SecondConcrete_3_Keyword(s3.getCurrent(), s3.getPredecessor()).firstSolution();
		while(s4 != null) {
			Solution s5 = new SecondConcrete_2_Keyword_S(s4.getCurrent(), s4.getPredecessor()).firstSolution();
		while(s5 != null) {
			Solution s6 = new SecondConcrete_1_Keyword_F(s5.getCurrent(), s5.getPredecessor()).firstSolution();
		while(s6 != null) {
			Solution s7 = new SecondConcrete_0_Keyword(s6.getCurrent(), s6.getPredecessor()).firstSolution();
			if(s7 != null) {
				last = s7.getPredecessor();
				return s7;
			} else {
				s6 = s6.getPredecessor().nextSolution(this,s6);
			}
		}
			s5 = s5.getPredecessor().nextSolution(this,s5);
		}
			s4 = s4.getPredecessor().nextSolution(this,s4);
		}
			s3 = s3.getPredecessor().nextSolution(this,s3);
		}
			s2 = s2.getPredecessor().nextSolution(this,s2);
		}
			s1 = s1.getPredecessor().nextSolution(this,s1);
		}
		return null;
	}
}

// not supported
protected class SecondConcrete_0_Keyword extends KeywordToken  {
	
	public SecondConcrete_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele0KeywordHyphenMinusGreaterThanSign();
	}	
}

// not supported
protected class SecondConcrete_1_Keyword_F extends KeywordToken  {
	
	public SecondConcrete_1_Keyword_F(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele1KeywordF();
	}	
}

// not supported
protected class SecondConcrete_2_Keyword_S extends KeywordToken  {
	
	public SecondConcrete_2_Keyword_S(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele2KeywordS();
	}	
}

// not supported
protected class SecondConcrete_3_Keyword extends KeywordToken  {
	
	public SecondConcrete_3_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele3KeywordLeftParenthesis();
	}	
}

// not supported
protected class SecondConcrete_4_Assignment_value extends AssignmentToken  {
	
	public SecondConcrete_4_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele4AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prNamed().getRule().getType().getClassifier())) {
				Solution s = new Named_Assignment_name(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class SecondConcrete_5_Assignment_referencedChildren extends AssignmentToken  {
	
	public SecondConcrete_5_Assignment_referencedChildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele5AssignmentReferencedChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("referencedChildren",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("referencedChildren");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prSecondConcrete().ele50CrossReferenceIDChild().getType().getClassifier())) {
				type = AssignmentType.CR;
				element = grammarAccess.prSecondConcrete().ele50CrossReferenceIDChild(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}

// not supported
protected class SecondConcrete_6_Keyword extends KeywordToken  {
	
	public SecondConcrete_6_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele6KeywordRightParenthesis();
	}	
}


/************ end Rule SecondConcrete ****************/


/************ begin Rule Named ****************
 *
 * not supported
 *
 **/


// not supported
protected class Named_Assignment_name extends AssignmentToken  {
	
	public Named_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prNamed().eleAssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prNamed().ele0TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

/************ end Rule Named ****************/

}
