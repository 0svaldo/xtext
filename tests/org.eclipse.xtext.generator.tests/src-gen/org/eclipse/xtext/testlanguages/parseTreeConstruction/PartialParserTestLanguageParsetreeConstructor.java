/*
* generated by Xtext
*/
package org.eclipse.xtext.testlanguages.parseTreeConstruction;

//import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor.AbstractToken.Solution;
import org.eclipse.xtext.testlanguages.services.PartialParserTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class PartialParserTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private PartialParserTestLanguageGrammarAccess grammarAccess;
	
	@Override
	protected Solution internalSerialize(EObject obj) {
		IInstanceDescription inst = getDescr(obj);
		Solution s;
		if(inst.isInstanceOf(grammarAccess.prSomeContainer().getRule().getType().getType()) && (s = new SomeContainer_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prNested().getRule().getType().getType()) && (s = new Nested_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prContent().getRule().getType().getType()) && (s = new Content_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prChildren().getRule().getType().getType()) && (s = new Children_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prChild().getRule().getType().getType()) && (s = new Child_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAbstractChildren().getRule().getType().getType()) && (s = new AbstractChildren_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prAbstractChild().getRule().getType().getType()) && (s = new AbstractChild_Alternatives(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prFirstConcrete().getRule().getType().getType()) && (s = new FirstConcrete_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prSecondConcrete().getRule().getType().getType()) && (s = new SecondConcrete_Group(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		if(inst.isInstanceOf(grammarAccess.prNamed().getRule().getType().getType()) && (s = new Named_Assignment_name(inst, null).firstSolution()) != null && isConsumed(s,null)) return s;
		return null;
	}
	

/************ begin Rule SomeContainer ****************
 *
 * not supported
 *
 **/


// not supported
protected class SomeContainer_Group extends GroupToken {
	
	public SomeContainer_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSomeContainer().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new SomeContainer_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SomeContainer_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class SomeContainer_0_Group extends GroupToken {
	
	public SomeContainer_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSomeContainer().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new SomeContainer_0_1_Alternatives(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SomeContainer_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class SomeContainer_0_0_Group extends GroupToken {
	
	public SomeContainer_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSomeContainer().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new SomeContainer_0_0_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SomeContainer_0_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class SomeContainer_0_0_0_Group extends GroupToken {
	
	public SomeContainer_0_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSomeContainer().ele000Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new SomeContainer_0_0_0_1_Assignment_name(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SomeContainer_0_0_0_0_Keyword_container(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class SomeContainer_0_0_0_0_Keyword_container extends KeywordToken  {
	
	public SomeContainer_0_0_0_0_Keyword_container(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSomeContainer().ele0000KeywordContainer();
	}	
}

// not supported
protected class SomeContainer_0_0_0_1_Assignment_name extends AssignmentToken  {
	
	public SomeContainer_0_0_0_1_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSomeContainer().ele0001AssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prSomeContainer().ele00010TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}


// not supported
protected class SomeContainer_0_0_1_Keyword extends KeywordToken  {
	
	public SomeContainer_0_0_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSomeContainer().ele001KeywordLeftCurlyBracket();
	}	
}


// not supported
protected class SomeContainer_0_1_Alternatives extends AlternativesToken {

	public SomeContainer_0_1_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prSomeContainer().ele01Alternatives();
	}

	@Override	
	protected Solution createSolution() {
		AbstractToken t = (first) ? new SomeContainer_0_1_1_Assignment_content(current, this) : new SomeContainer_0_1_0_Assignment_nested(current, this);
		Solution s = t.firstSolution();
		if(s == null && activateNextSolution()) s = createSolution();
		if(s == null) return null;
		last = s.getPredecessor();
		return s; 
	}
}

// not supported
protected class SomeContainer_0_1_0_Assignment_nested extends AssignmentToken  {
	
	public SomeContainer_0_1_0_Assignment_nested(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSomeContainer().ele010AssignmentNested();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("nested",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nested");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prNested().getRule().getType().getType())) {
				Solution s = new Nested_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}

// not supported
protected class SomeContainer_0_1_1_Assignment_content extends AssignmentToken  {
	
	public SomeContainer_0_1_1_Assignment_content(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSomeContainer().ele011AssignmentContent();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("content",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("content");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prContent().getRule().getType().getType())) {
				Solution s = new Content_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// not supported
protected class SomeContainer_1_Keyword extends KeywordToken  {
	
	public SomeContainer_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSomeContainer().ele1KeywordRightCurlyBracket();
	}	
}


/************ end Rule SomeContainer ****************/


/************ begin Rule Nested ****************
 *
 * not supported
 *
 **/


// not supported
protected class Nested_Group extends GroupToken {
	
	public Nested_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prNested().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Nested_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Nested_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Nested_0_Group extends GroupToken {
	
	public Nested_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prNested().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Nested_0_1_Assignment_nested(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Nested_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Nested_0_0_Group extends GroupToken {
	
	public Nested_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prNested().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Nested_0_0_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Nested_0_0_0_Keyword_nested(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Nested_0_0_0_Keyword_nested extends KeywordToken  {
	
	public Nested_0_0_0_Keyword_nested(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNested().ele000KeywordNested();
	}	
}

// not supported
protected class Nested_0_0_1_Keyword extends KeywordToken  {
	
	public Nested_0_0_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNested().ele001KeywordLeftCurlyBracket();
	}	
}


// not supported
protected class Nested_0_1_Assignment_nested extends AssignmentToken  {
	
	public Nested_0_1_Assignment_nested(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prNested().ele01AssignmentNested();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("nested",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("nested");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prSomeContainer().getRule().getType().getType())) {
				Solution s = new SomeContainer_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class Nested_1_Keyword extends KeywordToken  {
	
	public Nested_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prNested().ele1KeywordRightCurlyBracket();
	}	
}


/************ end Rule Nested ****************/


/************ begin Rule Content ****************
 *
 * not supported
 *
 **/


// not supported
protected class Content_Alternatives extends AlternativesToken {

	public Content_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prContent().eleAlternatives();
	}

	@Override	
	protected Solution createSolution() {
		AbstractToken t = (first) ? new Content_1_RuleCall_AbstractChildren(current, this) : new Content_0_RuleCall_Children(current, this);
		Solution s = t.firstSolution();
		if(s == null && activateNextSolution()) s = createSolution();
		if(s == null) return null;
		last = s.getPredecessor();
		return s; 
	}
}

// not supported
protected class Content_0_RuleCall_Children extends RuleCallToken {
	
	public Content_0_RuleCall_Children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prContent().ele0ParserRuleCallChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(Children_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prChildren().getRule().getType().getType())) return null;
		return new Children_Group(current, this).firstSolution();
	}
}

// not supported
protected class Content_1_RuleCall_AbstractChildren extends RuleCallToken {
	
	public Content_1_RuleCall_AbstractChildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prContent().ele1ParserRuleCallAbstractChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(AbstractChildren_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prAbstractChildren().getRule().getType().getType())) return null;
		return new AbstractChildren_Group(current, this).firstSolution();
	}
}


/************ end Rule Content ****************/


/************ begin Rule Children ****************
 *
 * not supported
 *
 **/


// not supported
protected class Children_Group extends GroupToken {
	
	public Children_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChildren().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Children_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Children_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Children_0_Group extends GroupToken {
	
	public Children_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChildren().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Children_0_1_Group(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Children_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Children_0_0_Group extends GroupToken {
	
	public Children_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChildren().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Children_0_0_1_Assignment_children(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Children_0_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Children_0_0_0_Group extends GroupToken {
	
	public Children_0_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChildren().ele000Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Children_0_0_0_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Children_0_0_0_0_Keyword_children(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Children_0_0_0_0_Keyword_children extends KeywordToken  {
	
	public Children_0_0_0_0_Keyword_children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChildren().ele0000KeywordChildren();
	}	
}

// not supported
protected class Children_0_0_0_1_Keyword extends KeywordToken  {
	
	public Children_0_0_0_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChildren().ele0001KeywordLeftCurlyBracket();
	}	
}


// not supported
protected class Children_0_0_1_Assignment_children extends AssignmentToken  {
	
	public Children_0_0_1_Assignment_children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prChildren().ele001AssignmentChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("children",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("children");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prChild().getRule().getType().getType())) {
				Solution s = new Child_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class Children_0_1_Group extends GroupToken {
	
	public Children_0_1_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChildren().ele01Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Children_0_1_1_Assignment_children(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Children_0_1_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Children_0_1_0_Keyword extends KeywordToken  {
	
	public Children_0_1_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChildren().ele010KeywordComma();
	}	
}

// not supported
protected class Children_0_1_1_Assignment_children extends AssignmentToken  {
	
	public Children_0_1_1_Assignment_children(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prChildren().ele011AssignmentChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("children",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("children");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prChild().getRule().getType().getType())) {
				Solution s = new Child_Group(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}



// not supported
protected class Children_1_Keyword extends KeywordToken  {
	
	public Children_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChildren().ele1KeywordRightCurlyBracket();
	}	
}


/************ end Rule Children ****************/


/************ begin Rule Child ****************
 *
 * not supported
 *
 **/


// not supported
protected class Child_Group extends GroupToken {
	
	public Child_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChild().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Child_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Child_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Child_0_Group extends GroupToken {
	
	public Child_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChild().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Child_0_1_Assignment_value(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Child_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Child_0_0_Group extends GroupToken {
	
	public Child_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChild().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Child_0_0_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Child_0_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Child_0_0_0_Group extends GroupToken {
	
	public Child_0_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prChild().ele000Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new Child_0_0_0_1_Keyword_C(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new Child_0_0_0_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class Child_0_0_0_0_Keyword extends KeywordToken  {
	
	public Child_0_0_0_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChild().ele0000KeywordHyphenMinusGreaterThanSign();
	}	
}

// not supported
protected class Child_0_0_0_1_Keyword_C extends KeywordToken  {
	
	public Child_0_0_0_1_Keyword_C(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChild().ele0001KeywordC();
	}	
}


// not supported
protected class Child_0_0_1_Keyword extends KeywordToken  {
	
	public Child_0_0_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChild().ele001KeywordLeftParenthesis();
	}	
}


// not supported
protected class Child_0_1_Assignment_value extends AssignmentToken  {
	
	public Child_0_1_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prChild().ele01AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prNamed().getRule().getType().getType())) {
				Solution s = new Named_Assignment_name(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class Child_1_Keyword extends KeywordToken  {
	
	public Child_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prChild().ele1KeywordRightParenthesis();
	}	
}


/************ end Rule Child ****************/


/************ begin Rule AbstractChildren ****************
 *
 * not supported
 *
 **/


// not supported
protected class AbstractChildren_Group extends GroupToken {
	
	public AbstractChildren_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAbstractChildren().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new AbstractChildren_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AbstractChildren_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class AbstractChildren_0_Group extends GroupToken {
	
	public AbstractChildren_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAbstractChildren().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new AbstractChildren_0_1_Assignment_abstractChildren(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AbstractChildren_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class AbstractChildren_0_0_Group extends GroupToken {
	
	public AbstractChildren_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prAbstractChildren().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new AbstractChildren_0_0_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new AbstractChildren_0_0_0_Keyword_abstractchildren(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class AbstractChildren_0_0_0_Keyword_abstractchildren extends KeywordToken  {
	
	public AbstractChildren_0_0_0_Keyword_abstractchildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAbstractChildren().ele000KeywordAbstractChildren();
	}	
}

// not supported
protected class AbstractChildren_0_0_1_Keyword extends KeywordToken  {
	
	public AbstractChildren_0_0_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAbstractChildren().ele001KeywordLeftCurlyBracket();
	}	
}


// not supported
protected class AbstractChildren_0_1_Assignment_abstractChildren extends AssignmentToken  {
	
	public AbstractChildren_0_1_Assignment_abstractChildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prAbstractChildren().ele01AssignmentAbstractChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("abstractChildren",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("abstractChildren");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prAbstractChild().getRule().getType().getType())) {
				Solution s = new AbstractChild_Alternatives(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class AbstractChildren_1_Keyword extends KeywordToken  {
	
	public AbstractChildren_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prAbstractChildren().ele1KeywordRightCurlyBracket();
	}	
}


/************ end Rule AbstractChildren ****************/


/************ begin Rule AbstractChild ****************
 *
 * not supported
 *
 **/


// not supported
protected class AbstractChild_Alternatives extends AlternativesToken {

	public AbstractChild_Alternatives(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.prAbstractChild().eleAlternatives();
	}

	@Override	
	protected Solution createSolution() {
		AbstractToken t = (first) ? new AbstractChild_1_RuleCall_SecondConcrete(current, this) : new AbstractChild_0_RuleCall_FirstConcrete(current, this);
		Solution s = t.firstSolution();
		if(s == null && activateNextSolution()) s = createSolution();
		if(s == null) return null;
		last = s.getPredecessor();
		return s; 
	}
}

// not supported
protected class AbstractChild_0_RuleCall_FirstConcrete extends RuleCallToken {
	
	public AbstractChild_0_RuleCall_FirstConcrete(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractChild().ele0ParserRuleCallFirstConcrete();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(FirstConcrete_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prFirstConcrete().getRule().getType().getType())) return null;
		return new FirstConcrete_Group(current, this).firstSolution();
	}
}

// not supported
protected class AbstractChild_1_RuleCall_SecondConcrete extends RuleCallToken {
	
	public AbstractChild_1_RuleCall_SecondConcrete(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.prAbstractChild().ele1ParserRuleCallSecondConcrete();
	}
	
	@Override
	protected Solution createSolution() {
		if(checkForRecursion(SecondConcrete_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.prSecondConcrete().getRule().getType().getType())) return null;
		return new SecondConcrete_Group(current, this).firstSolution();
	}
}


/************ end Rule AbstractChild ****************/


/************ begin Rule FirstConcrete ****************
 *
 * not supported
 *
 **/


// not supported
protected class FirstConcrete_Group extends GroupToken {
	
	public FirstConcrete_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prFirstConcrete().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new FirstConcrete_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new FirstConcrete_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class FirstConcrete_0_Group extends GroupToken {
	
	public FirstConcrete_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new FirstConcrete_0_1_Assignment_referencedContainer(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new FirstConcrete_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class FirstConcrete_0_0_Group extends GroupToken {
	
	public FirstConcrete_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new FirstConcrete_0_0_1_Assignment_value(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new FirstConcrete_0_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class FirstConcrete_0_0_0_Group extends GroupToken {
	
	public FirstConcrete_0_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele000Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new FirstConcrete_0_0_0_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new FirstConcrete_0_0_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class FirstConcrete_0_0_0_0_Group extends GroupToken {
	
	public FirstConcrete_0_0_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele0000Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new FirstConcrete_0_0_0_0_1_Keyword_F(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new FirstConcrete_0_0_0_0_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class FirstConcrete_0_0_0_0_0_Keyword extends KeywordToken  {
	
	public FirstConcrete_0_0_0_0_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele00000KeywordHyphenMinusGreaterThanSign();
	}	
}

// not supported
protected class FirstConcrete_0_0_0_0_1_Keyword_F extends KeywordToken  {
	
	public FirstConcrete_0_0_0_0_1_Keyword_F(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele00001KeywordF();
	}	
}


// not supported
protected class FirstConcrete_0_0_0_1_Keyword extends KeywordToken  {
	
	public FirstConcrete_0_0_0_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele0001KeywordLeftParenthesis();
	}	
}


// not supported
protected class FirstConcrete_0_0_1_Assignment_value extends AssignmentToken  {
	
	public FirstConcrete_0_0_1_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele001AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prNamed().getRule().getType().getType())) {
				Solution s = new Named_Assignment_name(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class FirstConcrete_0_1_Assignment_referencedContainer extends AssignmentToken  {
	
	public FirstConcrete_0_1_Assignment_referencedContainer(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele01AssignmentReferencedContainer();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("referencedContainer",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("referencedContainer");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prFirstConcrete().ele010CrossReferenceEStringSomeContainer().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prFirstConcrete().ele010CrossReferenceEStringSomeContainer(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}


// not supported
protected class FirstConcrete_1_Keyword extends KeywordToken  {
	
	public FirstConcrete_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prFirstConcrete().ele1KeywordRightParenthesis();
	}	
}


/************ end Rule FirstConcrete ****************/


/************ begin Rule SecondConcrete ****************
 *
 * not supported
 *
 **/


// not supported
protected class SecondConcrete_Group extends GroupToken {
	
	public SecondConcrete_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSecondConcrete().eleGroup();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new SecondConcrete_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SecondConcrete_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class SecondConcrete_0_Group extends GroupToken {
	
	public SecondConcrete_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele0Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new SecondConcrete_0_1_Assignment_referencedChildren(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SecondConcrete_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class SecondConcrete_0_0_Group extends GroupToken {
	
	public SecondConcrete_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele00Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new SecondConcrete_0_0_1_Assignment_value(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SecondConcrete_0_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class SecondConcrete_0_0_0_Group extends GroupToken {
	
	public SecondConcrete_0_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele000Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new SecondConcrete_0_0_0_1_Keyword(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SecondConcrete_0_0_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class SecondConcrete_0_0_0_0_Group extends GroupToken {
	
	public SecondConcrete_0_0_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele0000Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new SecondConcrete_0_0_0_0_1_Keyword_S(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SecondConcrete_0_0_0_0_0_Group(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class SecondConcrete_0_0_0_0_0_Group extends GroupToken {
	
	public SecondConcrete_0_0_0_0_0_Group(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele00000Group();
	}
		
	@Override
	protected Solution createSolution() {	
		Solution s1 = new SecondConcrete_0_0_0_0_0_1_Keyword_F(current, this).firstSolution();
		while(s1 != null) {
			Solution s2 = new SecondConcrete_0_0_0_0_0_0_Keyword(s1.getCurrent(), s1.getPredecessor()).firstSolution();
			if(s2 == null) {
				s1 = s1.getPredecessor().nextSolution(this,s1);
				if(s1 == null) return null;
			} else {
				last = s2.getPredecessor();
				return s2;
			}
		}
		return null;
		
	}
}

// not supported
protected class SecondConcrete_0_0_0_0_0_0_Keyword extends KeywordToken  {
	
	public SecondConcrete_0_0_0_0_0_0_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele000000KeywordHyphenMinusGreaterThanSign();
	}	
}

// not supported
protected class SecondConcrete_0_0_0_0_0_1_Keyword_F extends KeywordToken  {
	
	public SecondConcrete_0_0_0_0_0_1_Keyword_F(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele000001KeywordF();
	}	
}


// not supported
protected class SecondConcrete_0_0_0_0_1_Keyword_S extends KeywordToken  {
	
	public SecondConcrete_0_0_0_0_1_Keyword_S(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele00001KeywordS();
	}	
}


// not supported
protected class SecondConcrete_0_0_0_1_Keyword extends KeywordToken  {
	
	public SecondConcrete_0_0_0_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele0001KeywordLeftParenthesis();
	}	
}


// not supported
protected class SecondConcrete_0_0_1_Assignment_value extends AssignmentToken  {
	
	public SecondConcrete_0_0_1_Assignment_value(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele001AssignmentValue();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("value",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");

		if(value instanceof EObject) { // xtext::RuleCall
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prNamed().getRule().getType().getType())) {
				Solution s = new Named_Assignment_name(param, this).firstSolution();
				while(s != null && !isConsumed(s,this)) s = s.getPredecessor().nextSolution(this,s);
				if(s != null) {
					type = AssignmentType.PRC; 
					return new Solution(obj,s.getPredecessor());
				} 
			}
		}

		return null;
	}
}


// not supported
protected class SecondConcrete_0_1_Assignment_referencedChildren extends AssignmentToken  {
	
	public SecondConcrete_0_1_Assignment_referencedChildren(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, !IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele01AssignmentReferencedChildren();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("referencedChildren",!IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("referencedChildren");
		if(value instanceof EObject) { // xtext::CrossReference
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.prSecondConcrete().ele010CrossReferenceEStringChild().getType().getType())) {
				type = AssignmentType.CR;
				element = grammarAccess.prSecondConcrete().ele010CrossReferenceEStringChild(); 
				return new Solution(obj);
			}
		}
		return null;
	}
}


// not supported
protected class SecondConcrete_1_Keyword extends KeywordToken  {
	
	public SecondConcrete_1_Keyword(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.prSecondConcrete().ele1KeywordRightParenthesis();
	}	
}


/************ end Rule SecondConcrete ****************/


/************ begin Rule Named ****************
 *
 * not supported
 *
 **/


// not supported
protected class Named_Assignment_name extends AssignmentToken  {
	
	public Named_Assignment_name(IInstanceDescription curr, AbstractToken pred) {
		super(curr, pred, !IS_MANY, IS_REQUIRED);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.prNamed().eleAssignmentName();
	}
	
	@Override
	protected Solution createSolution() {
		if((value = current.getConsumable("name",IS_REQUIRED)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // xtext::RuleCall FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.prNamed().ele0TerminalRuleCallID();
			return new Solution(obj);
		}
		return null;
	}
}

/************ end Rule Named ****************/

}
