/*
* generated by Xtext
*/
package org.eclipse.xtext.testlanguages.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor2;

import org.eclipse.xtext.testlanguages.services.SimpleExpressionsTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class SimpleExpressionsTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor2 {
		
	@Inject
	private SimpleExpressionsTestLanguageGrammarAccess grammarAccess;
		
	public SimpleExpressionsTestLanguageGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken2 getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Sequence_Group(this, this, 0, inst);
			case 1: return new Addition_Group(this, this, 1, inst);
			case 2: return new Multiplication_Group(this, this, 2, inst);
			case 3: return new Term_Alternatives(this, this, 3, inst);
			case 4: return new Atom_NameAssignment(this, this, 4, inst);
			case 5: return new Parens_Group(this, this, 5, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule Sequence ****************
 *
 * Sequence:
 *   Addition ({Sequence.expressions+=current} expressions+=Addition)*;
 *
 **/

// Addition ({Sequence.expressions+=current} expressions+=Addition)*
protected class Sequence_Group extends GroupToken {
	
	public Sequence_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSequenceAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Sequence_Group_1(parent, this, 0, inst);
			case 1: return new Sequence_AdditionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getSequenceRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Addition
protected class Sequence_AdditionParserRuleCall_0 extends RuleCallToken {
	
	public Sequence_AdditionParserRuleCall_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getSequenceAccess().getAdditionParserRuleCall_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Addition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Addition_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAdditionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Sequence.expressions+=current} expressions+=Addition)*
protected class Sequence_Group_1 extends GroupToken {
	
	public Sequence_Group_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getSequenceAccess().getGroup_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Sequence_ExpressionsAssignment_1_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Sequence.expressions+=current}
protected class Sequence_SequenceExpressionsAction_1_0 extends ActionToken  {

	public Sequence_SequenceExpressionsAction_1_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getSequenceAccess().getSequenceExpressionsAction_1_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Sequence_Group_1(parent, this, 0, inst);
			case 1: return new Sequence_AdditionParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getSequenceAccess().getSequenceExpressionsAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("expressions", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("expressions")) return null;
		return getDescr((EObject) val);
	}
}

// expressions+=Addition
protected class Sequence_ExpressionsAssignment_1_1 extends AssignmentToken  {
	
	public Sequence_ExpressionsAssignment_1_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getSequenceAccess().getExpressionsAssignment_1_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Addition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expressions",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expressions");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAdditionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSequenceAccess().getExpressionsAdditionParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Sequence_SequenceExpressionsAction_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Sequence ****************/


/************ begin Rule Addition ****************
 *
 * Addition returns Expression:
 *   Multiplication ({Op.values+=current} operator=( "+" | "-" ) values+=Multiplication)*;
 *
 **/

// Multiplication ({Op.values+=current} operator=( "+" | "-" ) values+=Multiplication)*
protected class Addition_Group extends GroupToken {
	
	public Addition_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAdditionAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Addition_Group_1(parent, this, 0, inst);
			case 1: return new Addition_MultiplicationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAdditionRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Multiplication
protected class Addition_MultiplicationParserRuleCall_0 extends RuleCallToken {
	
	public Addition_MultiplicationParserRuleCall_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getAdditionAccess().getMultiplicationParserRuleCall_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Multiplication_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Multiplication_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getMultiplicationRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Op.values+=current} operator=( "+" | "-" ) values+=Multiplication)*
protected class Addition_Group_1 extends GroupToken {
	
	public Addition_Group_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAdditionAccess().getGroup_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Addition_ValuesAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Op.values+=current}
protected class Addition_OpValuesAction_1_0 extends ActionToken  {

	public Addition_OpValuesAction_1_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getAdditionAccess().getOpValuesAction_1_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Addition_Group_1(parent, this, 0, inst);
			case 1: return new Addition_MultiplicationParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getAdditionAccess().getOpValuesAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("values", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("values")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "+" | "-" )
protected class Addition_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public Addition_OperatorAssignment_1_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditionAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Addition_OpValuesAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("+".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAdditionAccess().getOperatorPlusSignKeyword_1_1_0_0();
			return obj;
		}
		if("-".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getAdditionAccess().getOperatorHyphenMinusKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// values+=Multiplication
protected class Addition_ValuesAssignment_1_2 extends AssignmentToken  {
	
	public Addition_ValuesAssignment_1_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAdditionAccess().getValuesAssignment_1_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Multiplication_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("values",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("values");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getMultiplicationRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getAdditionAccess().getValuesMultiplicationParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Addition_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Addition ****************/


/************ begin Rule Multiplication ****************
 *
 * Multiplication returns Expression:
 *   Term ({Op.values+=current} operator=( "*" | "/" ) values+=Term)*;
 *
 **/

// Term ({Op.values+=current} operator=( "*" | "/" ) values+=Term)*
protected class Multiplication_Group extends GroupToken {
	
	public Multiplication_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Multiplication_Group_1(parent, this, 0, inst);
			case 1: return new Multiplication_TermParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getMultiplicationRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Term
protected class Multiplication_TermParserRuleCall_0 extends RuleCallToken {
	
	public Multiplication_TermParserRuleCall_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getTermParserRuleCall_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Term_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Term_Alternatives.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// ({Op.values+=current} operator=( "*" | "/" ) values+=Term)*
protected class Multiplication_Group_1 extends GroupToken {
	
	public Multiplication_Group_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getGroup_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Multiplication_ValuesAssignment_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// {Op.values+=current}
protected class Multiplication_OpValuesAction_1_0 extends ActionToken  {

	public Multiplication_OpValuesAction_1_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Action getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getOpValuesAction_1_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Multiplication_Group_1(parent, this, 0, inst);
			case 1: return new Multiplication_TermParserRuleCall_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isInstanceOf(grammarAccess.getMultiplicationAccess().getOpValuesAction_1_0().getType().getClassifier())) return null;
		Object val = current.getConsumable("values", false);
		if(val == null) return null;
		if(!current.isConsumedWithLastConsumtion("values")) return null;
		return getDescr((EObject) val);
	}
}

// operator=( "*" | "/" )
protected class Multiplication_OperatorAssignment_1_1 extends AssignmentToken  {
	
	public Multiplication_OperatorAssignment_1_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getOperatorAssignment_1_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Multiplication_OpValuesAction_1_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("operator",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("operator");
		if("*".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicationAccess().getOperatorAsteriskKeyword_1_1_0_0();
			return obj;
		}
		if("/".equals(value)) { // org::eclipse::xtext::impl::KeywordImpl
			type = AssignmentType.KW;
			element = grammarAccess.getMultiplicationAccess().getOperatorSolidusKeyword_1_1_0_1();
			return obj;
		}
		return null;
	}

}

// values+=Term
protected class Multiplication_ValuesAssignment_1_2 extends AssignmentToken  {
	
	public Multiplication_ValuesAssignment_1_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getMultiplicationAccess().getValuesAssignment_1_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Term_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("values",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("values");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getMultiplicationAccess().getValuesTermParserRuleCall_1_2_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new Multiplication_OperatorAssignment_1_1(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}



/************ end Rule Multiplication ****************/


/************ begin Rule Term ****************
 *
 * Term returns Expression:
 *   Atom|Parens;
 *
 **/

// Atom|Parens
protected class Term_Alternatives extends AlternativesToken {

	public Term_Alternatives(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Alternatives getGrammarElement() {
		return grammarAccess.getTermAccess().getAlternatives();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Term_AtomParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Term_ParensParserRuleCall_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getTermRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// Atom
protected class Term_AtomParserRuleCall_0 extends RuleCallToken {
	
	public Term_AtomParserRuleCall_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getAtomParserRuleCall_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_NameAssignment(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Atom_NameAssignment.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Parens
protected class Term_ParensParserRuleCall_1 extends RuleCallToken {
	
	public Term_ParensParserRuleCall_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getTermAccess().getParensParserRuleCall_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parens_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Parens_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getParensRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}


/************ end Rule Term ****************/


/************ begin Rule Atom ****************
 *
 * Atom:
 *   name=ID;
 *
 **/

// name=ID
protected class Atom_NameAssignment extends AssignmentToken  {
	
	public Atom_NameAssignment(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAtomAccess().getNameAssignment();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAtomRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAtomAccess().getNameIDTerminalRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Atom ****************/


/************ begin Rule Parens ****************
 *
 * Parens returns Expression:
 *   "(" Addition ")";
 *
 **/

// "(" Addition ")"
protected class Parens_Group extends GroupToken {
	
	public Parens_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getParensAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parens_RightParenthesisKeyword_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getParensRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// "("
protected class Parens_LeftParenthesisKeyword_0 extends KeywordToken  {
	
	public Parens_LeftParenthesisKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParensAccess().getLeftParenthesisKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
}

// Addition
protected class Parens_AdditionParserRuleCall_1 extends RuleCallToken {
	
	public Parens_AdditionParserRuleCall_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public RuleCall getGrammarElement() {
		return grammarAccess.getParensAccess().getAdditionParserRuleCall_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Addition_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Addition_Group.class, current)) return null;
		if(!current.isInstanceOf(grammarAccess.getAdditionRule().getType().getClassifier())) return null;
		return current;
	}
	
	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parens_LeftParenthesisKeyword_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// ")"
protected class Parens_RightParenthesisKeyword_2 extends KeywordToken  {
	
	public Parens_RightParenthesisKeyword_2(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getParensAccess().getRightParenthesisKeyword_2();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Parens_AdditionParserRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}


/************ end Rule Parens ****************/

}
