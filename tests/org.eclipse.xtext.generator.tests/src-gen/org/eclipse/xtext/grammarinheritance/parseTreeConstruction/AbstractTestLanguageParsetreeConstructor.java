/*
* generated by Xtext
*/
package org.eclipse.xtext.grammarinheritance.parseTreeConstruction;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor2;

import org.eclipse.xtext.grammarinheritance.services.AbstractTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class AbstractTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor2 {
		
	@Inject
	private AbstractTestLanguageGrammarAccess grammarAccess;
		
	public AbstractTestLanguageGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	protected AbstractToken2 getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InheritedParserRule_Group(this, this, 0, inst);
			case 1: return new AbstractCallOverridenParserRule_Group(this, this, 1, inst);
			case 2: return new OverridableParserRule_Group(this, this, 2, inst);
			case 3: return new OverridableParserRule2_Group(this, this, 3, inst);
			case 4: return new AbstractCallExtendedParserRule_Group(this, this, 4, inst);
			case 5: return new ExtendableParserRule_Group(this, this, 5, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule InheritedParserRule ****************
 *
 * InheritedParserRule returns mm::AType:
 *   "element" name=ID;
 *
 **/

// "element" name=ID
protected class InheritedParserRule_Group extends GroupToken {
	
	public InheritedParserRule_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getInheritedParserRuleAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InheritedParserRule_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getInheritedParserRuleRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "element"
protected class InheritedParserRule_ElementKeyword_0 extends KeywordToken  {
	
	public InheritedParserRule_ElementKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getInheritedParserRuleAccess().getElementKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// name=ID
protected class InheritedParserRule_NameAssignment_1 extends AssignmentToken  {
	
	public InheritedParserRule_NameAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getInheritedParserRuleAccess().getNameAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new InheritedParserRule_ElementKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getInheritedParserRuleAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule InheritedParserRule ****************/


/************ begin Rule AbstractCallOverridenParserRule ****************
 *
 * AbstractCallOverridenParserRule returns mm::AModel:
 *   "overridemodel" elements+=OverridableParserRule*;
 *
 **/

// "overridemodel" elements+=OverridableParserRule*
protected class AbstractCallOverridenParserRule_Group extends GroupToken {
	
	public AbstractCallOverridenParserRule_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAbstractCallOverridenParserRuleAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractCallOverridenParserRule_ElementsAssignment_1(parent, this, 0, inst);
			case 1: return new AbstractCallOverridenParserRule_OverridemodelKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAbstractCallOverridenParserRuleRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "overridemodel"
protected class AbstractCallOverridenParserRule_OverridemodelKeyword_0 extends KeywordToken  {
	
	public AbstractCallOverridenParserRule_OverridemodelKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAbstractCallOverridenParserRuleAccess().getOverridemodelKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// elements+=OverridableParserRule*
protected class AbstractCallOverridenParserRule_ElementsAssignment_1 extends AssignmentToken  {
	
	public AbstractCallOverridenParserRule_ElementsAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAbstractCallOverridenParserRuleAccess().getElementsAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OverridableParserRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("elements",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("elements");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getOverridableParserRuleRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new AbstractCallOverridenParserRule_ElementsAssignment_1(parent, next, actIndex, consumed);
			case 1: return new AbstractCallOverridenParserRule_OverridemodelKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule AbstractCallOverridenParserRule ****************/


/************ begin Rule OverridableParserRule ****************
 *
 * OverridableParserRule returns mm::AType:
 *   "element" name=ID;
 *
 **/

// "element" name=ID
protected class OverridableParserRule_Group extends GroupToken {
	
	public OverridableParserRule_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOverridableParserRuleAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OverridableParserRule_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOverridableParserRuleRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "element"
protected class OverridableParserRule_ElementKeyword_0 extends KeywordToken  {
	
	public OverridableParserRule_ElementKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOverridableParserRuleAccess().getElementKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// name=ID
protected class OverridableParserRule_NameAssignment_1 extends AssignmentToken  {
	
	public OverridableParserRule_NameAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOverridableParserRuleAccess().getNameAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OverridableParserRule_ElementKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getOverridableParserRuleAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule OverridableParserRule ****************/


/************ begin Rule OverridableParserRule2 ****************
 *
 * OverridableParserRule2 returns mm::AType:
 *   "other element" name=STRING;
 *
 **/

// "other element" name=STRING
protected class OverridableParserRule2_Group extends GroupToken {
	
	public OverridableParserRule2_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getOverridableParserRule2Access().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OverridableParserRule2_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getOverridableParserRule2Rule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "other element"
protected class OverridableParserRule2_OtherElementKeyword_0 extends KeywordToken  {
	
	public OverridableParserRule2_OtherElementKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getOverridableParserRule2Access().getOtherElementKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// name=STRING
protected class OverridableParserRule2_NameAssignment_1 extends AssignmentToken  {
	
	public OverridableParserRule2_NameAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getOverridableParserRule2Access().getNameAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new OverridableParserRule2_OtherElementKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getOverridableParserRule2Access().getNameSTRINGTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule OverridableParserRule2 ****************/


/************ begin Rule AbstractCallExtendedParserRule ****************
 *
 * AbstractCallExtendedParserRule returns mm::AModel:
 *   "extendedmodel" elements+=ExtendableParserRule*;
 *
 **/

// "extendedmodel" elements+=ExtendableParserRule*
protected class AbstractCallExtendedParserRule_Group extends GroupToken {
	
	public AbstractCallExtendedParserRule_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getAbstractCallExtendedParserRuleAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new AbstractCallExtendedParserRule_ElementsAssignment_1(parent, this, 0, inst);
			case 1: return new AbstractCallExtendedParserRule_ExtendedmodelKeyword_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAbstractCallExtendedParserRuleRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "extendedmodel"
protected class AbstractCallExtendedParserRule_ExtendedmodelKeyword_0 extends KeywordToken  {
	
	public AbstractCallExtendedParserRule_ExtendedmodelKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getAbstractCallExtendedParserRuleAccess().getExtendedmodelKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// elements+=ExtendableParserRule*
protected class AbstractCallExtendedParserRule_ElementsAssignment_1 extends AssignmentToken  {
	
	public AbstractCallExtendedParserRule_ElementsAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getAbstractCallExtendedParserRuleAccess().getElementsAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExtendableParserRule_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("elements",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("elements");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExtendableParserRuleRule().getType().getClassifier())) {
				type = AssignmentType.PRC; 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

	public AbstractToken2 createParentFollower(AbstractToken2 next,	int actIndex, int index, IInstanceDescription inst) {	
		switch(index) {
			case 0: return new AbstractCallExtendedParserRule_ElementsAssignment_1(parent, next, actIndex, consumed);
			case 1: return new AbstractCallExtendedParserRule_ExtendedmodelKeyword_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}


/************ end Rule AbstractCallExtendedParserRule ****************/


/************ begin Rule ExtendableParserRule ****************
 *
 * ExtendableParserRule returns mm::AType:
 *   "element" name=ID;
 *
 **/

// "element" name=ID
protected class ExtendableParserRule_Group extends GroupToken {
	
	public ExtendableParserRule_Group(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Group getGrammarElement() {
		return grammarAccess.getExtendableParserRuleAccess().getGroup();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExtendableParserRule_NameAssignment_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getExtendableParserRuleRule().getType().getClassifier())) return null;
  
		return tryConsumeVal();
	}
}

// "element"
protected class ExtendableParserRule_ElementKeyword_0 extends KeywordToken  {
	
	public ExtendableParserRule_ElementKeyword_0(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Keyword getGrammarElement() {
		return grammarAccess.getExtendableParserRuleAccess().getElementKeyword_0();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			//default: return (inst.isConsumed()) ? parent.createParentFollower(this,index , index - 0, inst) : null;
			default: return parent.createParentFollower(this,index , index - 0, inst);
		}	
	}	
		
	public IInstanceDescription tryConsume() {
  
		return tryConsumeVal();
	}
}

// name=ID
protected class ExtendableParserRule_NameAssignment_1 extends AssignmentToken  {
	
	public ExtendableParserRule_NameAssignment_1(AbstractToken2 parent, AbstractToken2 next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	public Assignment getGrammarElement() {
		return grammarAccess.getExtendableParserRuleAccess().getNameAssignment_1();
	}

	public AbstractToken2 createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new ExtendableParserRule_ElementKeyword_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getExtendableParserRuleAccess().getNameIDTerminalRuleCall_1_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule ExtendableParserRule ****************/

}
