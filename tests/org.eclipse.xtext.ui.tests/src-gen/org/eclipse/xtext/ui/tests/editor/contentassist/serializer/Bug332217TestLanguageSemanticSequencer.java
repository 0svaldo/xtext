/*
 * generated by Xtext
 */
package org.eclipse.xtext.ui.tests.editor.contentassist.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.Bug332217TestLanguagePackage;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.Cell;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.CollectionIterator;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.CollectionLiteral;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.ExternalOpen;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.Model;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.ObjectReference;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.Parameter;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.Section;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.Selector;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.StringConcat;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.StringLiteral;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.StringReplace;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.StringSplit;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.StringUrlConform;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.TableView;
import org.eclipse.xtext.ui.tests.editor.contentassist.bug332217TestLanguage.TypeDescription;
import org.eclipse.xtext.ui.tests.editor.contentassist.services.Bug332217TestLanguageGrammarAccess;

@SuppressWarnings("all")
public class Bug332217TestLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private Bug332217TestLanguageGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == Bug332217TestLanguagePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case Bug332217TestLanguagePackage.CELL:
				sequence_Cell(context, (Cell) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.COLLECTION_ITERATOR:
				sequence_CollectionIterator(context, (CollectionIterator) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.COLLECTION_LITERAL:
				sequence_CollectionLiteral(context, (CollectionLiteral) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.EXTERNAL_OPEN:
				sequence_ExternalOpen(context, (ExternalOpen) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.OBJECT_REFERENCE:
				if(context == grammarAccess.getNestedObjectReferenceRule()) {
					sequence_NestedObjectReference(context, (ObjectReference) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getCollectionExpressionRule() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getImageExpressionRule() ||
				   context == grammarAccess.getObjectReferenceRule() ||
				   context == grammarAccess.getScalarExpressionRule()) {
					sequence_ObjectReference(context, (ObjectReference) semanticObject); 
					return; 
				}
				else break;
			case Bug332217TestLanguagePackage.PARAMETER:
				sequence_Parameter(context, (Parameter) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.SECTION:
				sequence_Section(context, (Section) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.SELECTOR:
				sequence_Selector(context, (Selector) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.STRING_CONCAT:
				sequence_StringFunction(context, (StringConcat) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.STRING_REPLACE:
				sequence_StringFunction(context, (StringReplace) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.STRING_SPLIT:
				sequence_CollectionFunction(context, (StringSplit) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.STRING_URL_CONFORM:
				sequence_StringFunction(context, (StringUrlConform) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.TABLE_VIEW:
				sequence_TableView(context, (TableView) semanticObject); 
				return; 
			case Bug332217TestLanguagePackage.TYPE_DESCRIPTION:
				sequence_TypeDescription(context, (TypeDescription) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         type=CellType 
	 *         iterator=CollectionIterator? 
	 *         text=ScalarExpression? 
	 *         details=ScalarExpression? 
	 *         image=ScalarExpression? 
	 *         action=ViewAction? 
	 *         accessory=CellAccessory?
	 *     )
	 */
	protected void sequence_Cell(EObject context, Cell semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=ScalarExpression delimiter=ScalarExpression)
	 */
	protected void sequence_CollectionFunction(EObject context, StringSplit semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_SPLIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_SPLIT__VALUE));
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_SPLIT__DELIMITER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_SPLIT__DELIMITER));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCollectionFunctionAccess().getValueScalarExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getCollectionFunctionAccess().getDelimiterScalarExpressionParserRuleCall_4_0(), semanticObject.getDelimiter());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID collection=CollectionExpression)
	 */
	protected void sequence_CollectionIterator(EObject context, CollectionIterator semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.PROPERTY_PATH_PART__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.PROPERTY_PATH_PART__NAME));
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.COLLECTION_ITERATOR__COLLECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.COLLECTION_ITERATOR__COLLECTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCollectionIteratorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCollectionIteratorAccess().getCollectionCollectionExpressionParserRuleCall_3_0(), semanticObject.getCollection());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (items+=ScalarExpression items+=ScalarExpression*)
	 */
	protected void sequence_CollectionLiteral(EObject context, CollectionLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     url=ScalarExpression
	 */
	protected void sequence_ExternalOpen(EObject context, ExternalOpen semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.EXTERNAL_OPEN__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.EXTERNAL_OPEN__URL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getExternalOpenAccess().getUrlScalarExpressionParserRuleCall_0(), semanticObject.getUrl());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     elements+=TableView*
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (object=[PropertyPathPart|ID] tail=NestedObjectReference?)
	 */
	protected void sequence_NestedObjectReference(EObject context, ObjectReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (object=[PropertyPathPart|ID] tail=NestedObjectReference?)
	 */
	protected void sequence_ObjectReference(EObject context, ObjectReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (description=TypeDescription name=ID)
	 */
	protected void sequence_Parameter(EObject context, Parameter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.PROPERTY_PATH_PART__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.PROPERTY_PATH_PART__NAME));
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.PARAMETER__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.PARAMETER__DESCRIPTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParameterAccess().getDescriptionTypeDescriptionParserRuleCall_0_0(), semanticObject.getDescription());
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (iterator=CollectionIterator? title=ScalarExpression? cells+=Cell+)
	 */
	protected void sequence_Section(EObject context, Section semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=SelectorName
	 */
	protected void sequence_Selector(EObject context, Selector semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.SELECTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.SELECTOR__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSelectorAccess().getNameSelectorNameParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     values+=ScalarExpression+
	 */
	protected void sequence_StringFunction(EObject context, StringConcat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=ScalarExpression match=ScalarExpression replacement=ScalarExpression)
	 */
	protected void sequence_StringFunction(EObject context, StringReplace semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_REPLACE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_REPLACE__VALUE));
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_REPLACE__MATCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_REPLACE__MATCH));
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_REPLACE__REPLACEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_REPLACE__REPLACEMENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringFunctionAccess().getValueScalarExpressionParserRuleCall_1_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getStringFunctionAccess().getMatchScalarExpressionParserRuleCall_1_4_0(), semanticObject.getMatch());
		feeder.accept(grammarAccess.getStringFunctionAccess().getReplacementScalarExpressionParserRuleCall_1_6_0(), semanticObject.getReplacement());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=ScalarExpression
	 */
	protected void sequence_StringFunction(EObject context, StringUrlConform semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_URL_CONFORM__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_URL_CONFORM__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringFunctionAccess().getValueScalarExpressionParserRuleCall_2_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(EObject context, StringLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Bug332217TestLanguagePackage.Literals.STRING_LITERAL__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         content=Parameter? 
	 *         title=ScalarExpression? 
	 *         titleImage=ImageExpression? 
	 *         style=TableViewStyle? 
	 *         sections+=Section*
	 *     )
	 */
	protected void sequence_TableView(EObject context, TableView semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=ID many?='[]'?)
	 */
	protected void sequence_TypeDescription(EObject context, TypeDescription semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
