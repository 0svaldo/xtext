/*
* generated by Xtext
*/
package org.eclipse.xtext.ui.tests.editor.bracketmatching.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.xtext.ui.tests.editor.bracketmatching.services.BmTestLanguageGrammarAccess;

import com.google.inject.Inject;

public class BmTestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private BmTestLanguageGrammarAccess grammarAccess;
	
	@Override	
	public BmTestLanguageGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new File_ExpressionAssignment(this, this, 0, inst);
			case 1: return new Expression_Alternatives(this, this, 1, inst);
			case 2: return new SExpression_Group(this, this, 2, inst);
			case 3: return new Atom_ValueAssignment(this, this, 3, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule File ****************
 *
 * File:
 *   expression+=Expression*;
 *
 **/

// expression+=Expression*
protected class File_ExpressionAssignment extends AssignmentToken  {
	
	public File_ExpressionAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getFileAccess().getExpressionAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("expression",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("expression");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getFileAccess().getExpressionExpressionParserRuleCall_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new File_ExpressionAssignment(parent, next, actIndex, consumed);
			default: return parent.createParentFollower(next, actIndex , index - 1, consumed);
		}	
	}	
}

/************ end Rule File ****************/


/************ begin Rule Expression ****************
 *
 * Expression:
 *   SExpression|Atom|"[" Expression "]";
 *
 **/

// SExpression|Atom|"[" Expression "]"
protected class Expression_Alternatives extends AlternativesToken {

	public Expression_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getExpressionAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_SExpressionParserRuleCall_0(parent, this, 0, inst);
			case 1: return new Expression_AtomParserRuleCall_1(parent, this, 1, inst);
			case 2: return new Expression_Group_2(parent, this, 2, inst);
			default: return null;
		}	
	}

    @Override
	public IInstanceDescription tryConsume() {
		if(current.getDelegate().eClass() == grammarAccess.getAtomRule().getType().getClassifier() || 
		   current.getDelegate().eClass() == grammarAccess.getSExpressionAccess().getSExpressionAction_0().getType().getClassifier())
			return tryConsumeVal();
		return null;
	}

}

// SExpression
protected class Expression_SExpressionParserRuleCall_0 extends RuleCallToken {
	
	public Expression_SExpressionParserRuleCall_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getSExpressionParserRuleCall_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SExpression_Group(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IInstanceDescription tryConsume() {
		if(current.getDelegate().eClass() == grammarAccess.getSExpressionAccess().getSExpressionAction_0().getType().getClassifier())
			return tryConsumeVal();
		return null;
	}

    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(SExpression_Group.class, current)) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// Atom
protected class Expression_AtomParserRuleCall_1 extends RuleCallToken {
	
	public Expression_AtomParserRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getAtomParserRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Atom_ValueAssignment(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IInstanceDescription tryConsume() {
		if(current.getDelegate().eClass() == grammarAccess.getAtomRule().getType().getClassifier())
			return tryConsumeVal();
		return null;
	}

    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Atom_ValueAssignment.class, current)) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(next, actIndex , index, inst);
		}	
	}	
}

// "[" Expression "]"
protected class Expression_Group_2 extends GroupToken {
	
	public Expression_Group_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getExpressionAccess().getGroup_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_RightSquareBracketKeyword_2_2(parent, this, 0, inst);
			default: return null;
		}	
	}

}

// "["
protected class Expression_LeftSquareBracketKeyword_2_0 extends KeywordToken  {
	
	public Expression_LeftSquareBracketKeyword_2_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getExpressionAccess().getLeftSquareBracketKeyword_2_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}

}

// Expression
protected class Expression_ExpressionParserRuleCall_2_1 extends RuleCallToken {
	
	public Expression_ExpressionParserRuleCall_2_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getExpressionAccess().getExpressionParserRuleCall_2_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(checkForRecursion(Expression_Alternatives.class, current)) return null;
		return current;
	}
	
    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_LeftSquareBracketKeyword_2_0(parent, next, actIndex, inst);
			default: return null;
		}	
	}	
}

// "]"
protected class Expression_RightSquareBracketKeyword_2_2 extends KeywordToken  {
	
	public Expression_RightSquareBracketKeyword_2_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getExpressionAccess().getRightSquareBracketKeyword_2_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_ExpressionParserRuleCall_2_1(parent, this, 0, inst);
			default: return null;
		}	
	}

}



/************ end Rule Expression ****************/


/************ begin Rule SExpression ****************
 *
 * SExpression:
 *   {SExpression} ("(" element+=Expression* ")"|"begin" element+=Expression* "end");
 *
 **/

// {SExpression} ("(" element+=Expression* ")"|"begin" element+=Expression* "end")
protected class SExpression_Group extends GroupToken {
	
	public SExpression_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSExpressionAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SExpression_Alternatives_1(parent, this, 0, inst);
			default: return null;
		}	
	}

    @Override
	public IInstanceDescription tryConsume() {
		if(current.getDelegate().eClass() == grammarAccess.getSExpressionAccess().getSExpressionAction_0().getType().getClassifier())
			return tryConsumeVal();
		return null;
	}

}

// {SExpression}
protected class SExpression_SExpressionAction_0 extends ActionToken  {

	public SExpression_SExpressionAction_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Action getGrammarElement() {
		return grammarAccess.getSExpressionAccess().getSExpressionAction_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}

    @Override
	protected IInstanceDescription tryConsumeVal() {
		if(!current.isConsumed()) return null;
		return current;
	}
}

// "(" element+=Expression* ")"|"begin" element+=Expression* "end"
protected class SExpression_Alternatives_1 extends AlternativesToken {

	public SExpression_Alternatives_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getSExpressionAccess().getAlternatives_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SExpression_Group_1_0(parent, this, 0, inst);
			case 1: return new SExpression_Group_1_1(parent, this, 1, inst);
			default: return null;
		}	
	}

}

// "(" element+=Expression* ")"
protected class SExpression_Group_1_0 extends GroupToken {
	
	public SExpression_Group_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSExpressionAccess().getGroup_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SExpression_RightParenthesisKeyword_1_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}

}

// "("
protected class SExpression_LeftParenthesisKeyword_1_0_0 extends KeywordToken  {
	
	public SExpression_LeftParenthesisKeyword_1_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSExpressionAccess().getLeftParenthesisKeyword_1_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SExpression_SExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}

}

// element+=Expression*
protected class SExpression_ElementAssignment_1_0_1 extends AssignmentToken  {
	
	public SExpression_ElementAssignment_1_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSExpressionAccess().getElementAssignment_1_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("element",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("element");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSExpressionAccess().getElementExpressionParserRuleCall_1_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SExpression_ElementAssignment_1_0_1(parent, next, actIndex, consumed);
			case 1: return new SExpression_LeftParenthesisKeyword_1_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// ")"
protected class SExpression_RightParenthesisKeyword_1_0_2 extends KeywordToken  {
	
	public SExpression_RightParenthesisKeyword_1_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSExpressionAccess().getRightParenthesisKeyword_1_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SExpression_ElementAssignment_1_0_1(parent, this, 0, inst);
			case 1: return new SExpression_LeftParenthesisKeyword_1_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}

}


// "begin" element+=Expression* "end"
protected class SExpression_Group_1_1 extends GroupToken {
	
	public SExpression_Group_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getSExpressionAccess().getGroup_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SExpression_EndKeyword_1_1_2(parent, this, 0, inst);
			default: return null;
		}	
	}

}

// "begin"
protected class SExpression_BeginKeyword_1_1_0 extends KeywordToken  {
	
	public SExpression_BeginKeyword_1_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSExpressionAccess().getBeginKeyword_1_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SExpression_SExpressionAction_0(parent, this, 0, inst);
			default: return null;
		}	
	}

}

// element+=Expression*
protected class SExpression_ElementAssignment_1_1_1 extends AssignmentToken  {
	
	public SExpression_ElementAssignment_1_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getSExpressionAccess().getElementAssignment_1_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Expression_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}

    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("element",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("element");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getExpressionRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getSExpressionAccess().getElementExpressionParserRuleCall_1_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new SExpression_ElementAssignment_1_1_1(parent, next, actIndex, consumed);
			case 1: return new SExpression_BeginKeyword_1_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// "end"
protected class SExpression_EndKeyword_1_1_2 extends KeywordToken  {
	
	public SExpression_EndKeyword_1_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Keyword getGrammarElement() {
		return grammarAccess.getSExpressionAccess().getEndKeyword_1_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new SExpression_ElementAssignment_1_1_1(parent, this, 0, inst);
			case 1: return new SExpression_BeginKeyword_1_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}

}




/************ end Rule SExpression ****************/


/************ begin Rule Atom ****************
 *
 * Atom:
 *   value=VALUE;
 *
 **/

// value=VALUE
protected class Atom_ValueAssignment extends AssignmentToken  {
	
	public Atom_ValueAssignment(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAtomAccess().getValueAssignment();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}

    @Override
	public IInstanceDescription tryConsume() {
		if(current.getDelegate().eClass() == grammarAccess.getAtomRule().getType().getClassifier())
			return tryConsumeVal();
		return null;
	}

    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { 
			type = AssignmentType.DRC;
			element = grammarAccess.getAtomAccess().getValueVALUEParserRuleCall_0();
			return obj;
		}
		return null;
	}

}

/************ end Rule Atom ****************/


}
