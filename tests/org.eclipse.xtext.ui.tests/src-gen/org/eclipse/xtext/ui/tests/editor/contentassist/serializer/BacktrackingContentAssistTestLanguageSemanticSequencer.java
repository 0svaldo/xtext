/*
 * generated by Xtext
 */
package org.eclipse.xtext.ui.tests.editor.contentassist.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.BacktrackingContentAssistTestPackage;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.Body;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.BooleanLiteralExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.ClassifierContextDecl;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.CollectionLiteralExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.CollectionLiteralPart;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.CollectionType;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.Definition;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.Der;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.Document;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.IfExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.InfixExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.Init;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.InvalidLiteralExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.Invariant;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.LetExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.LetVariable;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.NestedExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.NullLiteralExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.NumberLiteralExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.OclMessage;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.OclMessageArg;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.OperationContextDecl;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.PackageDeclaration;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.Parameter;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.PathNameExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.Post;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.Pre;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.PreExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.PrefixExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.PrimitiveType;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.PropertyContextDecl;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.QualifiedClassifierRef;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.QualifiedOperationRef;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.QualifiedPackageRef;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.QualifiedPropertyRef;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.RoundBracketExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.SelfExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.SimpleClassifierRef;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.SimpleNameExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.SimpleOperationRef;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.SimplePackageRef;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.SimplePropertyRef;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.SquareBracketExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.StringLiteralExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.TupleLiteralExp;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.TupleLiteralPart;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.TupleType;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.iteratorAccumulator;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.iteratorVariable;
import org.eclipse.xtext.ui.tests.editor.contentassist.backtrackingContentAssistTest.tuplePart;
import org.eclipse.xtext.ui.tests.editor.contentassist.services.BacktrackingContentAssistTestLanguageGrammarAccess;

@SuppressWarnings("all")
public class BacktrackingContentAssistTestLanguageSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BacktrackingContentAssistTestLanguageGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == BacktrackingContentAssistTestPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case BacktrackingContentAssistTestPackage.BODY:
				sequence_Body(context, (Body) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.BOOLEAN_LITERAL_EXP:
				sequence_BooleanLiteralExp(context, (BooleanLiteralExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.CLASSIFIER_CONTEXT_DECL:
				sequence_ClassifierContextDecl(context, (ClassifierContextDecl) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.COLLECTION_LITERAL_EXP:
				sequence_CollectionLiteralExp(context, (CollectionLiteralExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.COLLECTION_LITERAL_PART:
				sequence_CollectionLiteralPart(context, (CollectionLiteralPart) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.COLLECTION_TYPE:
				sequence_CollectionType(context, (CollectionType) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.DER:
				sequence_Der(context, (Der) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.DOCUMENT:
				sequence_Document(context, (Document) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.IF_EXP:
				sequence_IfExp(context, (IfExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.INFIX_EXP:
				if(context == grammarAccess.getNavigatingExpRule()) {
					sequence_NavigatingExp(context, (InfixExp) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNavigationExpRule() ||
				   context == grammarAccess.getUnaryRule()) {
					sequence_NavigationExp(context, (InfixExp) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getOclMessageArgRule() ||
				   context == grammarAccess.getImpliesRule() ||
				   context == grammarAccess.getImpliesAccess().getInfixExpSourceAction_1_0()) {
					sequence_NavigationExp_additive_and_equality_implies_multiplicative_or_relational_xor(context, (InfixExp) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getOrRule() ||
				   context == grammarAccess.getOrAccess().getInfixExpSourceAction_1_0()) {
					sequence_NavigationExp_additive_and_equality_multiplicative_or_relational(context, (InfixExp) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getXorRule() ||
				   context == grammarAccess.getXorAccess().getInfixExpSourceAction_1_0()) {
					sequence_NavigationExp_additive_and_equality_multiplicative_or_relational_xor(context, (InfixExp) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAndRule() ||
				   context == grammarAccess.getAndAccess().getInfixExpSourceAction_1_0()) {
					sequence_NavigationExp_additive_and_equality_multiplicative_relational(context, (InfixExp) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getEqualityRule() ||
				   context == grammarAccess.getEqualityAccess().getInfixExpSourceAction_1_0()) {
					sequence_NavigationExp_additive_equality_multiplicative_relational(context, (InfixExp) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAdditiveRule() ||
				   context == grammarAccess.getAdditiveAccess().getInfixExpSourceAction_1_0()) {
					sequence_NavigationExp_additive_multiplicative(context, (InfixExp) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getRelationalRule() ||
				   context == grammarAccess.getRelationalAccess().getInfixExpSourceAction_1_0()) {
					sequence_NavigationExp_additive_multiplicative_relational(context, (InfixExp) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getMultiplicativeRule() ||
				   context == grammarAccess.getMultiplicativeAccess().getInfixExpSourceAction_1_0()) {
					sequence_NavigationExp_multiplicative(context, (InfixExp) semanticObject); 
					return; 
				}
				else break;
			case BacktrackingContentAssistTestPackage.INIT:
				sequence_Init(context, (Init) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.INVALID_LITERAL_EXP:
				sequence_InvalidLiteralExp(context, (InvalidLiteralExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.INVARIANT:
				sequence_Invariant(context, (Invariant) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.LET_EXP:
				sequence_LetExp(context, (LetExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.LET_VARIABLE:
				sequence_LetVariable(context, (LetVariable) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.NESTED_EXP:
				sequence_SubNavigationExp(context, (NestedExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.NULL_LITERAL_EXP:
				sequence_NullLiteralExp(context, (NullLiteralExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.NUMBER_LITERAL_EXP:
				sequence_NumberLiteralExp(context, (NumberLiteralExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.OCL_MESSAGE:
				if(context == grammarAccess.getNavigatingExpRule()) {
					sequence_NavigatingExp(context, (OclMessage) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getNavigationExpRule() ||
				   context == grammarAccess.getOclMessageArgRule() ||
				   context == grammarAccess.getAdditiveRule() ||
				   context == grammarAccess.getAdditiveAccess().getInfixExpSourceAction_1_0() ||
				   context == grammarAccess.getAndRule() ||
				   context == grammarAccess.getAndAccess().getInfixExpSourceAction_1_0() ||
				   context == grammarAccess.getEqualityRule() ||
				   context == grammarAccess.getEqualityAccess().getInfixExpSourceAction_1_0() ||
				   context == grammarAccess.getImpliesRule() ||
				   context == grammarAccess.getImpliesAccess().getInfixExpSourceAction_1_0() ||
				   context == grammarAccess.getMultiplicativeRule() ||
				   context == grammarAccess.getMultiplicativeAccess().getInfixExpSourceAction_1_0() ||
				   context == grammarAccess.getOrRule() ||
				   context == grammarAccess.getOrAccess().getInfixExpSourceAction_1_0() ||
				   context == grammarAccess.getRelationalRule() ||
				   context == grammarAccess.getRelationalAccess().getInfixExpSourceAction_1_0() ||
				   context == grammarAccess.getUnaryRule() ||
				   context == grammarAccess.getXorRule() ||
				   context == grammarAccess.getXorAccess().getInfixExpSourceAction_1_0()) {
					sequence_NavigationExp(context, (OclMessage) semanticObject); 
					return; 
				}
				else break;
			case BacktrackingContentAssistTestPackage.OCL_MESSAGE_ARG:
				sequence_OclMessageArg(context, (OclMessageArg) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.OPERATION_CONTEXT_DECL:
				sequence_OperationContextDecl(context, (OperationContextDecl) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.PARAMETER:
				sequence_Parameter(context, (Parameter) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.PATH_NAME_EXP:
				sequence_PathNameExp(context, (PathNameExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.POST:
				sequence_Post(context, (Post) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.PRE:
				sequence_Pre(context, (Pre) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.PRE_EXP:
				sequence_PreExp(context, (PreExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.PREFIX_EXP:
				sequence_unary(context, (PrefixExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.PRIMITIVE_TYPE:
				sequence_PrimitiveType(context, (PrimitiveType) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.PROPERTY_CONTEXT_DECL:
				sequence_PropertyContextDecl(context, (PropertyContextDecl) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.QUALIFIED_CLASSIFIER_REF:
				sequence_QualifiedClassifierRef(context, (QualifiedClassifierRef) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.QUALIFIED_OPERATION_REF:
				sequence_QualifiedOperationRef(context, (QualifiedOperationRef) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.QUALIFIED_PACKAGE_REF:
				sequence_QualifiedPackageRef(context, (QualifiedPackageRef) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.QUALIFIED_PROPERTY_REF:
				sequence_QualifiedPropertyRef(context, (QualifiedPropertyRef) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.ROUND_BRACKET_EXP:
				sequence_RoundBracketExp(context, (RoundBracketExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.SELF_EXP:
				sequence_SelfExp(context, (SelfExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.SIMPLE_CLASSIFIER_REF:
				sequence_SimpleClassifierRef(context, (SimpleClassifierRef) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.SIMPLE_NAME_EXP:
				sequence_SimpleNameExp(context, (SimpleNameExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.SIMPLE_OPERATION_REF:
				sequence_SimpleOperationRef(context, (SimpleOperationRef) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.SIMPLE_PACKAGE_REF:
				sequence_SimplePackageRef(context, (SimplePackageRef) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.SIMPLE_PROPERTY_REF:
				sequence_SimplePropertyRef(context, (SimplePropertyRef) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.SQUARE_BRACKET_EXP:
				sequence_SquareBracketExp(context, (SquareBracketExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.STRING_LITERAL_EXP:
				sequence_StringLiteralExp(context, (StringLiteralExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.TUPLE_LITERAL_EXP:
				sequence_TupleLiteralExp(context, (TupleLiteralExp) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.TUPLE_LITERAL_PART:
				sequence_TupleLiteralPart(context, (TupleLiteralPart) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.TUPLE_TYPE:
				sequence_TupleType(context, (TupleType) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.ITERATOR_ACCUMULATOR:
				sequence_iteratorAccumulator(context, (iteratorAccumulator) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.ITERATOR_VARIABLE:
				sequence_iteratorVariable(context, (iteratorVariable) semanticObject); 
				return; 
			case BacktrackingContentAssistTestPackage.TUPLE_PART:
				sequence_tuplePart(context, (tuplePart) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (constraintName=Identifier? expression=Expression)
	 */
	protected void sequence_Body(EObject context, Body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (isTrue?='true'?)
	 */
	protected void sequence_BooleanLiteralExp(EObject context, BooleanLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (selfName=Identifier? classifier=ClassifierRef (invariants+=Invariant | definitions+=Definition)*)
	 */
	protected void sequence_ClassifierContextDecl(EObject context, ClassifierContextDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             type=CollectionLiteralExp_CollectionLiteralExp_1_0 
	 *             (collectionLiteralParts+=CollectionLiteralPart collectionLiteralParts+=CollectionLiteralPart*)?
	 *         ) | 
	 *         type=CollectionLiteralExp_CollectionLiteralExp_1_0
	 *     )
	 */
	protected void sequence_CollectionLiteralExp(EObject context, CollectionLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=Expression lastExpression=Expression?)
	 */
	protected void sequence_CollectionLiteralPart(EObject context, CollectionLiteralPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (typeIdentifier=CollectionTypeIdentifier type=TypeExp?)
	 */
	protected void sequence_CollectionType(EObject context, CollectionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         static?='static'? 
	 *         constraintName=Identifier? 
	 *         constrainedName=Identifier 
	 *         (parameters+=Parameter parameters+=Parameter*)? 
	 *         type=TypeExp? 
	 *         expression=Expression
	 *     )
	 */
	protected void sequence_Definition(EObject context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Der(EObject context, Der semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.DER__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.DER__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDerAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (packages+=PackageDeclaration | contexts+=ContextDecl)*
	 */
	protected void sequence_Document(EObject context, Document semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=Expression thenExpression=Expression elseExpression=Expression)
	 */
	protected void sequence_IfExp(EObject context, IfExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Init(EObject context, Init semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.INIT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.INIT__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getInitAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {InvalidLiteralExp}
	 */
	protected void sequence_InvalidLiteralExp(EObject context, InvalidLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (constraintName=Identifier? expression=Expression)
	 */
	protected void sequence_Invariant(EObject context, Invariant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (variable+=LetVariable variable+=LetVariable* in=Expression)
	 */
	protected void sequence_LetExp(EObject context, LetExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=Identifier type=TypeExp initExpression=Expression)
	 */
	protected void sequence_LetVariable(EObject context, LetVariable semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.LET_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.LET_VARIABLE__NAME));
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.LET_VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.LET_VARIABLE__TYPE));
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.LET_VARIABLE__INIT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.LET_VARIABLE__INIT_EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLetVariableAccess().getNameIdentifierParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLetVariableAccess().getTypeTypeExpParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getLetVariableAccess().getInitExpressionExpressionParserRuleCall_4_0(), semanticObject.getInitExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (source=NavigatingExp_InfixExp_1_0_0 (op='.' | op='->') argument=NavigatingExp)
	 */
	protected void sequence_NavigatingExp(EObject context, InfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (source=NavigatingExp_OclMessage_1_1_0 (op='^^' | op='^') messageName=Identifier (arguments+=OclMessageArg arguments+=OclMessageArg*)?)
	 */
	protected void sequence_NavigatingExp(EObject context, OclMessage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (source=NavigationExp_InfixExp_1_0_0 (op='.' | op='->') argument=NavigatingExp)
	 */
	protected void sequence_NavigationExp(EObject context, InfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (source=NavigationExp_OclMessage_1_1_0 (op='^^' | op='^') messageName=Identifier (arguments+=OclMessageArg arguments+=OclMessageArg*)?)
	 */
	protected void sequence_NavigationExp(EObject context, OclMessage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (source=multiplicative_InfixExp_1_0 (op='*' | op='/') (argument=unary | argument=LetExp)) | 
	 *         (source=NavigationExp_InfixExp_1_0_0 (op='.' | op='->') argument=NavigatingExp) | 
	 *         (source=additive_InfixExp_1_0 (op='+' | op='-') (argument=multiplicative | argument=LetExp)) | 
	 *         (source=relational_InfixExp_1_0 (op='>' | op='<' | op='>=' | op='<=') (argument=additive | argument=LetExp)) | 
	 *         (source=equality_InfixExp_1_0 (op='=' | op='<>') (argument=relational | argument=LetExp)) | 
	 *         (source=and_InfixExp_1_0 op='and' (argument=equality | argument=LetExp)) | 
	 *         (source=or_InfixExp_1_0 op='or' (argument=and | argument=LetExp)) | 
	 *         (source=xor_InfixExp_1_0 op='xor' (argument=or | argument=LetExp)) | 
	 *         (source=implies_InfixExp_1_0 op='implies' (argument=xor | argument=LetExp))
	 *     )
	 */
	protected void sequence_NavigationExp_additive_and_equality_implies_multiplicative_or_relational_xor(EObject context, InfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (source=multiplicative_InfixExp_1_0 (op='*' | op='/') (argument=unary | argument=LetExp)) | 
	 *         (source=NavigationExp_InfixExp_1_0_0 (op='.' | op='->') argument=NavigatingExp) | 
	 *         (source=additive_InfixExp_1_0 (op='+' | op='-') (argument=multiplicative | argument=LetExp)) | 
	 *         (source=relational_InfixExp_1_0 (op='>' | op='<' | op='>=' | op='<=') (argument=additive | argument=LetExp)) | 
	 *         (source=equality_InfixExp_1_0 (op='=' | op='<>') (argument=relational | argument=LetExp)) | 
	 *         (source=and_InfixExp_1_0 op='and' (argument=equality | argument=LetExp)) | 
	 *         (source=or_InfixExp_1_0 op='or' (argument=and | argument=LetExp))
	 *     )
	 */
	protected void sequence_NavigationExp_additive_and_equality_multiplicative_or_relational(EObject context, InfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (source=multiplicative_InfixExp_1_0 (op='*' | op='/') (argument=unary | argument=LetExp)) | 
	 *         (source=NavigationExp_InfixExp_1_0_0 (op='.' | op='->') argument=NavigatingExp) | 
	 *         (source=additive_InfixExp_1_0 (op='+' | op='-') (argument=multiplicative | argument=LetExp)) | 
	 *         (source=relational_InfixExp_1_0 (op='>' | op='<' | op='>=' | op='<=') (argument=additive | argument=LetExp)) | 
	 *         (source=equality_InfixExp_1_0 (op='=' | op='<>') (argument=relational | argument=LetExp)) | 
	 *         (source=and_InfixExp_1_0 op='and' (argument=equality | argument=LetExp)) | 
	 *         (source=or_InfixExp_1_0 op='or' (argument=and | argument=LetExp)) | 
	 *         (source=xor_InfixExp_1_0 op='xor' (argument=or | argument=LetExp))
	 *     )
	 */
	protected void sequence_NavigationExp_additive_and_equality_multiplicative_or_relational_xor(EObject context, InfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (source=multiplicative_InfixExp_1_0 (op='*' | op='/') (argument=unary | argument=LetExp)) | 
	 *         (source=NavigationExp_InfixExp_1_0_0 (op='.' | op='->') argument=NavigatingExp) | 
	 *         (source=additive_InfixExp_1_0 (op='+' | op='-') (argument=multiplicative | argument=LetExp)) | 
	 *         (source=relational_InfixExp_1_0 (op='>' | op='<' | op='>=' | op='<=') (argument=additive | argument=LetExp)) | 
	 *         (source=equality_InfixExp_1_0 (op='=' | op='<>') (argument=relational | argument=LetExp)) | 
	 *         (source=and_InfixExp_1_0 op='and' (argument=equality | argument=LetExp))
	 *     )
	 */
	protected void sequence_NavigationExp_additive_and_equality_multiplicative_relational(EObject context, InfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (source=multiplicative_InfixExp_1_0 (op='*' | op='/') (argument=unary | argument=LetExp)) | 
	 *         (source=NavigationExp_InfixExp_1_0_0 (op='.' | op='->') argument=NavigatingExp) | 
	 *         (source=additive_InfixExp_1_0 (op='+' | op='-') (argument=multiplicative | argument=LetExp)) | 
	 *         (source=relational_InfixExp_1_0 (op='>' | op='<' | op='>=' | op='<=') (argument=additive | argument=LetExp)) | 
	 *         (source=equality_InfixExp_1_0 (op='=' | op='<>') (argument=relational | argument=LetExp))
	 *     )
	 */
	protected void sequence_NavigationExp_additive_equality_multiplicative_relational(EObject context, InfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (source=multiplicative_InfixExp_1_0 (op='*' | op='/') (argument=unary | argument=LetExp)) | 
	 *         (source=NavigationExp_InfixExp_1_0_0 (op='.' | op='->') argument=NavigatingExp) | 
	 *         (source=additive_InfixExp_1_0 (op='+' | op='-') (argument=multiplicative | argument=LetExp))
	 *     )
	 */
	protected void sequence_NavigationExp_additive_multiplicative(EObject context, InfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (source=multiplicative_InfixExp_1_0 (op='*' | op='/') (argument=unary | argument=LetExp)) | 
	 *         (source=NavigationExp_InfixExp_1_0_0 (op='.' | op='->') argument=NavigatingExp) | 
	 *         (source=additive_InfixExp_1_0 (op='+' | op='-') (argument=multiplicative | argument=LetExp)) | 
	 *         (source=relational_InfixExp_1_0 (op='>' | op='<' | op='>=' | op='<=') (argument=additive | argument=LetExp))
	 *     )
	 */
	protected void sequence_NavigationExp_additive_multiplicative_relational(EObject context, InfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (source=multiplicative_InfixExp_1_0 (op='*' | op='/') (argument=unary | argument=LetExp)) | 
	 *         (source=NavigationExp_InfixExp_1_0_0 (op='.' | op='->') argument=NavigatingExp)
	 *     )
	 */
	protected void sequence_NavigationExp_multiplicative(EObject context, InfixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {NullLiteralExp}
	 */
	protected void sequence_NullLiteralExp(EObject context, NullLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=NUMBER_LITERAL
	 */
	protected void sequence_NumberLiteralExp(EObject context, NumberLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=TypeExp?)
	 */
	protected void sequence_OclMessageArg(EObject context, OclMessageArg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (operation=OperationRef (parameters+=Parameter parameters+=Parameter*)? type=TypeExp? (pres+=Pre | posts+=Post | bodies+=Body)*)
	 */
	protected void sequence_OperationContextDecl(EObject context, OperationContextDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (package=PackageRef contexts+=ContextDecl*)
	 */
	protected void sequence_PackageDeclaration(EObject context, PackageDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=Identifier? type=TypeExp)
	 */
	protected void sequence_Parameter(EObject context, Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (namespace=Identifier element=NameExp)
	 */
	protected void sequence_PathNameExp(EObject context, PathNameExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (constraintName=Identifier? expression=Expression)
	 */
	protected void sequence_Post(EObject context, Post semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=NameExp
	 */
	protected void sequence_PreExp(EObject context, PreExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (constraintName=Identifier? expression=Expression)
	 */
	protected void sequence_Pre(EObject context, Pre semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=PrimitiveTypeIdentifier
	 */
	protected void sequence_PrimitiveType(EObject context, PrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (property=PropertyRef type=TypeExp ((init=Init der=Der?)? | (der=Der init=Init?)))
	 */
	protected void sequence_PropertyContextDecl(EObject context, PropertyContextDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (namespace=Identifier element=ClassifierRef)
	 */
	protected void sequence_QualifiedClassifierRef(EObject context, QualifiedClassifierRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_CLASSIFIER_REF__NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_CLASSIFIER_REF__NAMESPACE));
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_CLASSIFIER_REF__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_CLASSIFIER_REF__ELEMENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getQualifiedClassifierRefAccess().getNamespaceIdentifierParserRuleCall_0_0(), semanticObject.getNamespace());
		feeder.accept(grammarAccess.getQualifiedClassifierRefAccess().getElementClassifierRefParserRuleCall_2_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (namespace=Identifier element=OperationRef)
	 */
	protected void sequence_QualifiedOperationRef(EObject context, QualifiedOperationRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_OPERATION_REF__NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_OPERATION_REF__NAMESPACE));
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_OPERATION_REF__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_OPERATION_REF__ELEMENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getQualifiedOperationRefAccess().getNamespaceIdentifierParserRuleCall_0_0(), semanticObject.getNamespace());
		feeder.accept(grammarAccess.getQualifiedOperationRefAccess().getElementOperationRefParserRuleCall_2_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (namespace=Identifier element=PackageRef)
	 */
	protected void sequence_QualifiedPackageRef(EObject context, QualifiedPackageRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_PACKAGE_REF__NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_PACKAGE_REF__NAMESPACE));
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_PACKAGE_REF__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_PACKAGE_REF__ELEMENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getQualifiedPackageRefAccess().getNamespaceIdentifierParserRuleCall_0_0(), semanticObject.getNamespace());
		feeder.accept(grammarAccess.getQualifiedPackageRefAccess().getElementPackageRefParserRuleCall_2_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (namespace=Identifier element=PropertyRef)
	 */
	protected void sequence_QualifiedPropertyRef(EObject context, QualifiedPropertyRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_PROPERTY_REF__NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_PROPERTY_REF__NAMESPACE));
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_PROPERTY_REF__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.QUALIFIED_PROPERTY_REF__ELEMENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getQualifiedPropertyRefAccess().getNamespaceIdentifierParserRuleCall_0_0(), semanticObject.getNamespace());
		feeder.accept(grammarAccess.getQualifiedPropertyRefAccess().getElementPropertyRefParserRuleCall_2_0(), semanticObject.getElement());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=NameExp 
	 *         pre?='pre'? 
	 *         (variable1=iteratorVariable (variable2=iteratorVariable | variable2=iteratorAccumulator)?)? 
	 *         (arguments+=Expression arguments+=Expression*)?
	 *     )
	 */
	protected void sequence_RoundBracketExp(EObject context, RoundBracketExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {SelfExp}
	 */
	protected void sequence_SelfExp(EObject context, SelfExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     classifier=Identifier
	 */
	protected void sequence_SimpleClassifierRef(EObject context, SimpleClassifierRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.SIMPLE_CLASSIFIER_REF__CLASSIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.SIMPLE_CLASSIFIER_REF__CLASSIFIER));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSimpleClassifierRefAccess().getClassifierIdentifierParserRuleCall_0(), semanticObject.getClassifier());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     element=Identifier
	 */
	protected void sequence_SimpleNameExp(EObject context, SimpleNameExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     operation=Identifier
	 */
	protected void sequence_SimpleOperationRef(EObject context, SimpleOperationRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.SIMPLE_OPERATION_REF__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.SIMPLE_OPERATION_REF__OPERATION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSimpleOperationRefAccess().getOperationIdentifierParserRuleCall_0(), semanticObject.getOperation());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     package=Identifier
	 */
	protected void sequence_SimplePackageRef(EObject context, SimplePackageRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.SIMPLE_PACKAGE_REF__PACKAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.SIMPLE_PACKAGE_REF__PACKAGE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSimplePackageRefAccess().getPackageIdentifierParserRuleCall_0(), semanticObject.getPackage());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     feature=Identifier
	 */
	protected void sequence_SimplePropertyRef(EObject context, SimplePropertyRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.SIMPLE_PROPERTY_REF__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.SIMPLE_PROPERTY_REF__FEATURE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSimplePropertyRefAccess().getFeatureIdentifierParserRuleCall_0(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=NameExp arguments+=Expression arguments+=Expression* pre?='pre'?)
	 */
	protected void sequence_SquareBracketExp(EObject context, SquareBracketExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     values+=StringLiteral+
	 */
	protected void sequence_StringLiteralExp(EObject context, StringLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     source=Expression
	 */
	protected void sequence_SubNavigationExp(EObject context, NestedExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((part+=TupleLiteralPart part+=TupleLiteralPart*)?)
	 */
	protected void sequence_TupleLiteralExp(EObject context, TupleLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=Identifier type=TypeExp? initExpression=Expression)
	 */
	protected void sequence_TupleLiteralPart(EObject context, TupleLiteralPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='Tuple' (part+=tuplePart part+=tuplePart*)?)
	 */
	protected void sequence_TupleType(EObject context, TupleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=Identifier type=TypeExp initExpression=Expression)
	 */
	protected void sequence_iteratorAccumulator(EObject context, iteratorAccumulator semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.ITERATOR_ACCUMULATOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.ITERATOR_ACCUMULATOR__NAME));
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.ITERATOR_ACCUMULATOR__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.ITERATOR_ACCUMULATOR__TYPE));
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.ITERATOR_ACCUMULATOR__INIT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.ITERATOR_ACCUMULATOR__INIT_EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIteratorAccumulatorAccess().getNameIdentifierParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getIteratorAccumulatorAccess().getTypeTypeExpParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getIteratorAccumulatorAccess().getInitExpressionExpressionParserRuleCall_4_0(), semanticObject.getInitExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=Identifier type=TypeExp?)
	 */
	protected void sequence_iteratorVariable(EObject context, iteratorVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=Identifier type=TypeExp)
	 */
	protected void sequence_tuplePart(EObject context, tuplePart semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.TUPLE_PART__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.TUPLE_PART__NAME));
			if(transientValues.isValueTransient(semanticObject, BacktrackingContentAssistTestPackage.Literals.TUPLE_PART__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BacktrackingContentAssistTestPackage.Literals.TUPLE_PART__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTuplePartAccess().getNameIdentifierParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTuplePartAccess().getTypeTypeExpParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((op='-' | op='not') source=unary)
	 */
	protected void sequence_unary(EObject context, PrefixExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
