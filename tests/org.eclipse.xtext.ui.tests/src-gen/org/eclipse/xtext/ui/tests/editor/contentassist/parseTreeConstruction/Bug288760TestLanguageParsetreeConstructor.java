/*
* generated by Xtext
*/
package org.eclipse.xtext.ui.tests.editor.contentassist.parseTreeConstruction;

import org.eclipse.emf.ecore.*;
import org.eclipse.xtext.*;
import org.eclipse.xtext.parsetree.reconstr.IInstanceDescription;
import org.eclipse.xtext.parsetree.reconstr.impl.AbstractParseTreeConstructor;

import org.eclipse.xtext.ui.tests.editor.contentassist.services.Bug288760TestLanguageGrammarAccess;

import com.google.inject.Inject;

public class Bug288760TestLanguageParsetreeConstructor extends AbstractParseTreeConstructor {
		
	@Inject
	private Bug288760TestLanguageGrammarAccess grammarAccess;
	
	@Override	
	public Bug288760TestLanguageGrammarAccess getGrammarAccess() {
		return grammarAccess;
	}

	@Override
	protected AbstractToken getRootToken(IInstanceDescription inst) {
		return new ThisRootNode(inst);	
	}
	
protected class ThisRootNode extends RootToken {
	public ThisRootNode(IInstanceDescription inst) {
		super(inst);
	}
	
	@Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WorkflowElement_Alternatives(this, this, 0, inst);
			case 1: return new Attribute_Group(this, this, 1, inst);
			default: return null;
		}	
	}	
}
	

/************ begin Rule WorkflowElement ****************
 *
 * WorkflowElement:
 *   name=START_TAG attributes+=Attribute* END_TAG_SHORT|name=START_TAG attributes+=
 *   Attribute* GT children+=WorkflowElement* end=END_TAG;
 *
 **/

// name=START_TAG attributes+=Attribute* END_TAG_SHORT|name=START_TAG attributes+=
// Attribute* GT children+=WorkflowElement* end=END_TAG
protected class WorkflowElement_Alternatives extends AlternativesToken {

	public WorkflowElement_Alternatives(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Alternatives getGrammarElement() {
		return grammarAccess.getWorkflowElementAccess().getAlternatives();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WorkflowElement_Group_0(parent, this, 0, inst);
			case 1: return new WorkflowElement_Group_1(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getWorkflowElementRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=START_TAG attributes+=Attribute* END_TAG_SHORT
protected class WorkflowElement_Group_0 extends GroupToken {
	
	public WorkflowElement_Group_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWorkflowElementAccess().getGroup_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WorkflowElement_END_TAG_SHORTTerminalRuleCall_0_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=START_TAG
protected class WorkflowElement_NameAssignment_0_0 extends AssignmentToken  {
	
	public WorkflowElement_NameAssignment_0_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWorkflowElementAccess().getNameAssignment_0_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getWorkflowElementAccess().getNameSTART_TAGTerminalRuleCall_0_0_0();
			return obj;
		}
		return null;
	}

}

// attributes+=Attribute*
protected class WorkflowElement_AttributesAssignment_0_1 extends AssignmentToken  {
	
	public WorkflowElement_AttributesAssignment_0_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWorkflowElementAccess().getAttributesAssignment_0_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("attributes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("attributes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWorkflowElementAccess().getAttributesAttributeParserRuleCall_0_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WorkflowElement_AttributesAssignment_0_1(parent, next, actIndex, consumed);
			case 1: return new WorkflowElement_NameAssignment_0_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// END_TAG_SHORT
protected class WorkflowElement_END_TAG_SHORTTerminalRuleCall_0_2 extends UnassignedTextToken {

	public WorkflowElement_END_TAG_SHORTTerminalRuleCall_0_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getWorkflowElementAccess().getEND_TAG_SHORTTerminalRuleCall_0_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WorkflowElement_AttributesAssignment_0_1(parent, this, 0, inst);
			case 1: return new WorkflowElement_NameAssignment_0_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}


// name=START_TAG attributes+=Attribute* GT children+=WorkflowElement* end=END_TAG
protected class WorkflowElement_Group_1 extends GroupToken {
	
	public WorkflowElement_Group_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getWorkflowElementAccess().getGroup_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WorkflowElement_EndAssignment_1_4(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// name=START_TAG
protected class WorkflowElement_NameAssignment_1_0 extends AssignmentToken  {
	
	public WorkflowElement_NameAssignment_1_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWorkflowElementAccess().getNameAssignment_1_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getWorkflowElementAccess().getNameSTART_TAGTerminalRuleCall_1_0_0();
			return obj;
		}
		return null;
	}

}

// attributes+=Attribute*
protected class WorkflowElement_AttributesAssignment_1_1 extends AssignmentToken  {
	
	public WorkflowElement_AttributesAssignment_1_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWorkflowElementAccess().getAttributesAssignment_1_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_Group(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("attributes",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("attributes");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWorkflowElementAccess().getAttributesAttributeParserRuleCall_1_1_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WorkflowElement_AttributesAssignment_1_1(parent, next, actIndex, consumed);
			case 1: return new WorkflowElement_NameAssignment_1_0(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// GT
protected class WorkflowElement_GTTerminalRuleCall_1_2 extends UnassignedTextToken {

	public WorkflowElement_GTTerminalRuleCall_1_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getWorkflowElementAccess().getGTTerminalRuleCall_1_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WorkflowElement_AttributesAssignment_1_1(parent, this, 0, inst);
			case 1: return new WorkflowElement_NameAssignment_1_0(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
}

// children+=WorkflowElement*
protected class WorkflowElement_ChildrenAssignment_1_3 extends AssignmentToken  {
	
	public WorkflowElement_ChildrenAssignment_1_3(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWorkflowElementAccess().getChildrenAssignment_1_3();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WorkflowElement_Alternatives(this, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("children",false)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("children");
		if(value instanceof EObject) { // org::eclipse::xtext::impl::RuleCallImpl
			IInstanceDescription param = getDescr((EObject)value);
			if(param.isInstanceOf(grammarAccess.getWorkflowElementRule().getType().getClassifier())) {
				type = AssignmentType.PRC;
				element = grammarAccess.getWorkflowElementAccess().getChildrenWorkflowElementParserRuleCall_1_3_0(); 
				consumed = obj;
				return param;
			}
		}
		return null;
	}

    @Override
	public AbstractToken createParentFollower(AbstractToken next,	int actIndex, int index, IInstanceDescription inst) {
		if(value == inst.getDelegate() && !inst.isConsumed()) return null;
		switch(index) {
			case 0: return new WorkflowElement_ChildrenAssignment_1_3(parent, next, actIndex, consumed);
			case 1: return new WorkflowElement_GTTerminalRuleCall_1_2(parent, next, actIndex, consumed);
			default: return null;
		}	
	}	
}

// end=END_TAG
protected class WorkflowElement_EndAssignment_1_4 extends AssignmentToken  {
	
	public WorkflowElement_EndAssignment_1_4(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getWorkflowElementAccess().getEndAssignment_1_4();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new WorkflowElement_ChildrenAssignment_1_3(parent, this, 0, inst);
			case 1: return new WorkflowElement_GTTerminalRuleCall_1_2(parent, this, 1, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("end",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("end");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getWorkflowElementAccess().getEndEND_TAGTerminalRuleCall_1_4_0();
			return obj;
		}
		return null;
	}

}



/************ end Rule WorkflowElement ****************/


/************ begin Rule Attribute ****************
 *
 * Attribute:
 *   name=ID EQ value=STRING;
 *
 **/

// name=ID EQ value=STRING
protected class Attribute_Group extends GroupToken {
	
	public Attribute_Group(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Group getGrammarElement() {
		return grammarAccess.getAttributeAccess().getGroup();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_ValueAssignment_2(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override
	public IInstanceDescription tryConsume() {
		if(!current.isInstanceOf(grammarAccess.getAttributeRule().getType().getClassifier())) return null;
		return tryConsumeVal();
	}
}

// name=ID
protected class Attribute_NameAssignment_0 extends AssignmentToken  {
	
	public Attribute_NameAssignment_0(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getNameAssignment_0();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			default: return parent.createParentFollower(this, index, index, inst);
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("name",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("name");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_0_0();
			return obj;
		}
		return null;
	}

}

// EQ
protected class Attribute_EQTerminalRuleCall_1 extends UnassignedTextToken {

	public Attribute_EQTerminalRuleCall_1(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public RuleCall getGrammarElement() {
		return grammarAccess.getAttributeAccess().getEQTerminalRuleCall_1();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_NameAssignment_0(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
}

// value=STRING
protected class Attribute_ValueAssignment_2 extends AssignmentToken  {
	
	public Attribute_ValueAssignment_2(AbstractToken parent, AbstractToken next, int no, IInstanceDescription current) {
		super(parent, next, no, current);
	}
	
	@Override
	public Assignment getGrammarElement() {
		return grammarAccess.getAttributeAccess().getValueAssignment_2();
	}

    @Override
	public AbstractToken createFollower(int index, IInstanceDescription inst) {
		switch(index) {
			case 0: return new Attribute_EQTerminalRuleCall_1(parent, this, 0, inst);
			default: return null;
		}	
	}	
		
    @Override	
	protected IInstanceDescription tryConsumeVal() {
		if((value = current.getConsumable("value",true)) == null) return null;
		IInstanceDescription obj = current.cloneAndConsume("value");
		if(Boolean.TRUE.booleanValue()) { // org::eclipse::xtext::impl::RuleCallImpl FIXME: check if value is valid for lexer rule
			type = AssignmentType.LRC;
			element = grammarAccess.getAttributeAccess().getValueSTRINGTerminalRuleCall_2_0();
			return obj;
		}
		return null;
	}

}


/************ end Rule Attribute ****************/

}
